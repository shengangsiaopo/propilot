---  C:\MCC18\src\pmc_common\USART\_usartpc.asm  -------------------------------------------------
                                                  1:     #include <P18CXXX.INC>
                                                  2:     
                                                  3:     
                                                  4:     #ifdef __18F1220
                                                  5:     #define __USE_PORTB 1
                                                  6:     #endif
                                                  7:     #ifdef __18F1230
                                                  8:     #define __USE_PORTB 1
                                                  9:     #endif
                                                  10:    #ifdef __18F1231
                                                  11:    #define __USE_PORTB 1
                                                  12:    #endif
                                                  13:    #ifdef __18F1320
                                                  14:    #define __USE_PORTB 1
                                                  15:    #endif
                                                  16:    #ifdef __18F1330
                                                  17:    #define __USE_PORTB 1
                                                  18:    #endif
                                                  19:    #ifdef __18F1331
                                                  20:    #define __USE_PORTB 1
                                                  21:    #endif
                                                  22:    
                                                  23:      GLOBAL _usart_putc
                                                  24:    
                                                  25:    STDIO CODE
                                                  26:      
                                                  27:    _usart_putc  
  6738    0EFF     MOVLW 0xff                     28:                  MOVLW     0xff
  673A    50E3     MOVF 0xfe3, W, ACCESS          29:                  MOVF      PLUSW1, w
  673C    BAAD     BTFSC 0xfad, 0x5, ACCESS       30:                  BTFSC     TXSTA, 0x5
  673E    D004     BRA 0x6748                     31:                  BRA       loop
  6740    6AB0     CLRF 0xfb0, ACCESS             32:                  CLRF      SPBRG
  6742    8EAC     BSF 0xfac, 0x7, ACCESS         33:                  BSF       RCSTA, 0x7
  6744    8AAD     BSF 0xfad, 0x5, ACCESS         34:                  BSF       TXSTA, 0x5
                                                  35:    #ifdef __USE_PORTB
                                                  36:                  BCF       TRISB, 0x1
                                                  37:    #else
  6746    9C94     BCF 0xf94, 0x6, ACCESS         38:                  BCF       TRISC, 0x6
                                                  39:    #endif
  6748    A2AD     BTFSS 0xfad, 0x1, ACCESS       40:    loop:         BTFSS     TXSTA, 0x1
  674A    D7FE     BRA 0x6748                     41:                  BRA       loop
  674C    6EAE     MOVWF 0xfae, ACCESS            42:                  MOVWF     TXREG
  674E    6EF3     MOVWF 0xff3, ACCESS            43:                  MOVWF     PRODL
  6750    6AF4     CLRF 0xff4, ACCESS             44:                  CLRF      PRODL + 1
                                                  45:                 
  6752    0012     RETURN 0                       46:                  RETURN
---  C:\MCC18\src\traditional\math\fxd3232u.c  ---------------------------------------------------
1:                 /*** Unsigned Integer Division: 32-bit by 32-bit
2:                  *** 
3:                  *** Optimized: Dec. 21, 2000
4:                  ***        by: Daniel R. Madill, Quanser Consulting Inc.
5:                  ***       for: Saved (for the worst case) at least 8*32 = 256 instruction cycles
6:                  ***            over the code supplied with MCC18 v1.00.12
7:                  ***/
8:                 
9:                 void  FXD3232U(void/* ulong aarg, ulong barg */)
10:                {
11:                  // use INDF1 for the counter...
12:                
13:                    _asm
14:                
15:                    // REM = 0
16:                    clrf __REMB0, 0
  6630    6A05     CLRF 0x5, ACCESS
17:                    clrf __REMB1, 0
  6632    6A04     CLRF 0x4, ACCESS
18:                    clrf __REMB2, 0
  6634    6A03     CLRF 0x3, ACCESS
19:                    clrf __REMB3, 0
  6636    6A02     CLRF 0x2, ACCESS
20:                
21:                    // INDF1 = 32
22:                    movlw 32
  6638    0E20     MOVLW 0x20
23:                    movwf INDF1, 0
  663A    6EE7     MOVWF 0xfe7, ACCESS
24:                
25:                    // Clear the carry
26:                    bcf STATUS, 0, 0
  663C    90D8     BCF 0xfd8, 0, ACCESS
27:                
28:                loop:
29:                
30:                	//AARG32 <<= 1; The carry is always clear at the top of the loop.
31:                	rlcf __AARGB3, 1, 0
  663E    3606     RLCF 0x6, F, ACCESS
32:                	rlcf __AARGB2, 1, 0
  6640    3607     RLCF 0x7, F, ACCESS
33:                	rlcf __AARGB1, 1, 0
  6642    3608     RLCF 0x8, F, ACCESS
34:                	rlcf __AARGB0, 1, 0
  6644    3609     RLCF 0x9, F, ACCESS
35:                
36:                	//REM32 = (REM32 << 1) | (AARG32 >> 32)
37:                	rlcf __REMB3, 1, 0
  6646    3602     RLCF 0x2, F, ACCESS
38:                	rlcf __REMB2, 1, 0
  6648    3603     RLCF 0x3, F, ACCESS
39:                	rlcf __REMB1, 1, 0
  664A    3604     RLCF 0x4, F, ACCESS
40:                	rlcf __REMB0, 1, 0
  664C    3605     RLCF 0x5, F, ACCESS
41:                	
42:                	//if (PROD >= BARG32)
43:                	movf __BARGB3, 0, 0
  664E    500B     MOVF 0xb, W, ACCESS
44:                	subwf __REMB3, 0, 0
  6650    5C02     SUBWF 0x2, W, ACCESS
45:                	movf __BARGB2, 0, 0
  6652    500C     MOVF 0xc, W, ACCESS
46:                	subwfb __REMB2, 0, 0
  6654    5803     SUBWFB 0x3, W, ACCESS
47:                	movf __BARGB1, 0, 0
  6656    500D     MOVF 0xd, W, ACCESS
48:                	subwfb __REMB1, 0, 0
  6658    5804     SUBWFB 0x4, W, ACCESS
49:                	movf __BARGB0, 0, 0
  665A    500E     MOVF 0xe, W, ACCESS
50:                	subwfb __REMB0, 0, 0
  665C    5805     SUBWFB 0x5, W, ACCESS
51:                	bnc _false
  665E    E309     BNC 0x6672
52:                    //{
53:                	    //REM32-= BARG32;
54:                	    movf __BARGB3, 0, 0
  6660    500B     MOVF 0xb, W, ACCESS
55:                	    subwf __REMB3, 1, 0
  6662    5E02     SUBWF 0x2, F, ACCESS
56:                	    movf __BARGB2, 0, 0
  6664    500C     MOVF 0xc, W, ACCESS
57:                	    subwfb __REMB2, 1, 0
  6666    5A03     SUBWFB 0x3, F, ACCESS
58:                	    movf __BARGB1, 0, 0
  6668    500D     MOVF 0xd, W, ACCESS
59:                	    subwfb __REMB1, 1, 0
  666A    5A04     SUBWFB 0x4, F, ACCESS
60:                	    movf __BARGB0, 0, 0
  666C    500E     MOVF 0xe, W, ACCESS
61:                	    subwfb __REMB0, 1, 0
  666E    5A05     SUBWFB 0x5, F, ACCESS
62:                
63:                	    //++AARG32; Since AARG32 was shift to the left above, we only need to set
64:                        //          the lowest bit. Use incf so that the carry flag will also be cleared.
65:                        //          Thus, the carry will always be clear at the top of the loop.
66:                	    incf __AARGB3, 1, 0
  6670    2A06     INCF 0x6, F, ACCESS
67:                    //}
68:                _false:
69:                
70:                    decfsz INDF1, 1, 0    // does not affect the carry bit
  6672    2EE7     DECFSZ 0xfe7, F, ACCESS
71:                    bra loop
  6674    D7E4     BRA 0x663e
72:                
73:                  /* result in AARG already... */
74:                  _endasm
75:                }
  6676    0012     RETURN 0
---  C:\MCC18\src\traditional\math\fxm1616s.asm  -------------------------------------------------
                                                  1:     ;	RCS Header $Id: fxm1616s.asm,v 1.3 2006/01/12 23:16:38 rhinec Exp $
                                                  2:     
                                                  3:     ;	$Revision: 1.3 $
                                                  4:     
                                                  5:     	include <P18CXXX.INC>		; general Golden Gate definitions
                                                  6:     
                                                  7:     	include <CMATH18.INC>		; Math library definitions
                                                  8:     
                                                  9:     	include <AARG.INC>		; AARG declarations
                                                  10:    	
                                                  11:    	include <BARG.INC>		; BARG declarations
                                                  12:    
                                                  13:    	include <TEMPARG.INC>		; TEMPARG declarations
                                                  14:    
                                                  15:    ;**********************************************************************************************
                                                  16:    ;**********************************************************************************************
                                                  17:    
                                                  18:    ;       16x16 Bit Signed Fixed Point Multiply 16 x 16 -> 32
                                                  19:    
                                                  20:    ;       Input:  16 bit signed fixed point multiplicand in AARGB0, AARGB1
                                                  21:    ;               16 bit signed fixed point multiplier in BARGB0, BARGB1
                                                  22:    
                                                  23:    ;       Use:    CALL    FXM1616S
                                                  24:    
                                                  25:    ;       Output: 32 bit signed fixed point product in AARGB0, AARGB1,
                                                  26:    ;               AARGB2, AARGB3
                                                  27:    
                                                  28:    ;       Result: AARG  <--  AARG * BARG
                                                  29:    
                                                  30:    ;       Max Timing:     39 clks
                                                  31:    
                                                  32:    ;       Min Timing:     31 clks
                                                  33:    
                                                  34:    ;       PM: 38              DM: 8
                                                  35:    
                                                  36:    PROG	CODE
                                                  37:    
                                                  38:    FXM1616S
                                                  39:    		GLOBAL	FXM1616S
                                                  40:    
  6186    C009     MOVFF 0x9, 0x13                41:    		MOVFF	__AARGB0,__TEMPB0
  6188    F013     NOP
  618A    C008     MOVFF 0x8, 0x12                42:    		MOVFF	__AARGB1,__TEMPB1	
  618C    F012     NOP
                                                  43:    
  618E    5008     MOVF 0x8, W, ACCESS            44:    		MOVF	__AARGB1,W
  6190    020D     MULWF 0xd, ACCESS              45:    		MULWF	__BARGB1
  6192    CFF4     MOVFF 0xff4, 0x7               46:    		MOVFF	PRODH,__AARGB2
  6194    F007     NOP
  6196    CFF3     MOVFF 0xff3, 0x6               47:    		MOVFF	PRODL,__AARGB3
  6198    F006     NOP
                                                  48:    		
  619A    5009     MOVF 0x9, W, ACCESS            49:    		MOVF	__AARGB0,W
  619C    020E     MULWF 0xe, ACCESS              50:    		MULWF	__BARGB0
  619E    CFF4     MOVFF 0xff4, 0x9               51:    		MOVFF	PRODH,__AARGB0
  61A0    F009     NOP
  61A2    CFF3     MOVFF 0xff3, 0x8               52:    		MOVFF	PRODL,__AARGB1
  61A4    F008     NOP
                                                  53:    
  61A6    020D     MULWF 0xd, ACCESS              54:    		MULWF	__BARGB1
  61A8    50F3     MOVF 0xff3, W, ACCESS          55:    		MOVF	PRODL,W
  61AA    2607     ADDWF 0x7, F, ACCESS           56:    		ADDWF	__AARGB2,F
  61AC    50F4     MOVF 0xff4, W, ACCESS          57:    		MOVF	PRODH,W
  61AE    2208     ADDWFC 0x8, F, ACCESS          58:    		ADDWFC	__AARGB1,F
  61B0    6AE8     CLRF 0xfe8, ACCESS             59:    		CLRF	WREG
  61B2    2209     ADDWFC 0x9, F, ACCESS          60:    		ADDWFC	__AARGB0,F
                                                  61:    
  61B4    5012     MOVF 0x12, W, ACCESS           62:    		MOVF	__TEMPB1,W
  61B6    020E     MULWF 0xe, ACCESS              63:    		MULWF	__BARGB0
  61B8    50F3     MOVF 0xff3, W, ACCESS          64:    		MOVF	PRODL,W
  61BA    2607     ADDWF 0x7, F, ACCESS           65:    		ADDWF	__AARGB2,F
  61BC    50F4     MOVF 0xff4, W, ACCESS          66:    		MOVF	PRODH,W
  61BE    2208     ADDWFC 0x8, F, ACCESS          67:    		ADDWFC	__AARGB1,F
  61C0    6AE8     CLRF 0xfe8, ACCESS             68:    		CLRF	WREG
  61C2    2209     ADDWFC 0x9, F, ACCESS          69:    		ADDWFC	__AARGB0,F
                                                  70:    
  61C4    AE0E     BTFSS 0xe, 0x7, ACCESS         71:    		BTFSS	__BARGB0,MSB
  61C6    EFE9     GOTO 0x61d2                    72:    		GOTO	TSIGN1616A
  61C8    F030     NOP
  61CA    5012     MOVF 0x12, W, ACCESS           73:    		MOVF	__TEMPB1,W
  61CC    5E08     SUBWF 0x8, F, ACCESS           74:    		SUBWF	__AARGB1,F
  61CE    5013     MOVF 0x13, W, ACCESS           75:    		MOVF	__TEMPB0,W
  61D0    5A09     SUBWFB 0x9, F, ACCESS          76:    		SUBWFB	__AARGB0,F
                                                  77:    
                                                  78:    TSIGN1616A
  61D2    AE13     BTFSS 0x13, 0x7, ACCESS        79:    		BTFSS	__TEMPB0,MSB
  61D4    0C00     RETLW 0                        80:    		RETLW	0x00
  61D6    500D     MOVF 0xd, W, ACCESS            81:    		MOVF	__BARGB1,W
  61D8    5E08     SUBWF 0x8, F, ACCESS           82:    		SUBWF	__AARGB1,F
  61DA    500E     MOVF 0xe, W, ACCESS            83:    		MOVF	__BARGB0,W
  61DC    5A09     SUBWFB 0x9, F, ACCESS          84:    		SUBWFB	__AARGB0,F
                                                  85:    		
  61DE    0C00     RETLW 0                        86:    		RETLW	0x00
---  C:\MCC18\src\traditional\math\fxm2424u.asm  -------------------------------------------------
                                                  1:     ;	RCS Header $Id: fxm2424u.asm,v 1.3 2006/01/12 23:16:38 rhinec Exp $
                                                  2:     
                                                  3:     ;	$Revision: 1.3 $
                                                  4:     
                                                  5:     	include <P18CXXX.INC>		; general Golden Gate definitions
                                                  6:     
                                                  7:     	include <CMATH18.INC>		; Math library definitions
                                                  8:     
                                                  9:     	include <AARG.INC>		; AARG declarations
                                                  10:    	
                                                  11:    	include <BARG.INC>		; BARG declarations
                                                  12:    
                                                  13:    	include <TEMPARG.INC>		; TEMPARG declarations
                                                  14:    
                                                  15:    ;**********************************************************************************************
                                                  16:    ;**********************************************************************************************
                                                  17:    
                                                  18:    ;       24x24 Bit Unsigned Fixed Point Multiply 24 x 24 -> 48
                                                  19:    
                                                  20:    ;       Input:  24 bit unsigned fixed point multiplicand in AARGB0, AARGB1,
                                                  21:    ;               AARGB2
                                                  22:    ;               24 bit unsigned fixed point multiplier in BARGB0, BARGB1,
                                                  23:    ;               BARGB2
                                                  24:    
                                                  25:    ;       Use:    CALL    FXM2424U
                                                  26:    
                                                  27:    ;       Output: 48 bit unsigned fixed point product in AARGB0, AARGB1, 
                                                  28:    ;               AARGB2, AARGB3, AARGB4, AARGB5
                                                  29:    
                                                  30:    ;       Result: AARG  <--  AARG * BARG
                                                  31:    
                                                  32:    ;       Max Timing:     65 clks
                                                  33:    
                                                  34:    ;       Min Timing:     65 clks
                                                  35:    
                                                  36:    ;       PM: 64              DM: 12
                                                  37:    
                                                  38:    PROG	CODE
                                                  39:    
                                                  40:    FXM2424U
                                                  41:    		GLOBAL	FXM2424U
                                                  42:    
  60F4    C009     MOVFF 0x9, 0x13                43:    		MOVFF	__AARGB0,__TEMPB0	
  60F6    F013     NOP
  60F8    C008     MOVFF 0x8, 0x12                44:    		MOVFF	__AARGB1,__TEMPB1	
  60FA    F012     NOP
  60FC    C007     MOVFF 0x7, 0x11                45:    		MOVFF	__AARGB2,__TEMPB2	
  60FE    F011     NOP
                                                  46:    
  6100    5007     MOVF 0x7, W, ACCESS            47:    		MOVF	__AARGB2,W
  6102    020C     MULWF 0xc, ACCESS              48:    		MULWF	__BARGB2
  6104    CFF4     MOVFF 0xff4, 0x5               49:    		MOVFF	PRODH,__AARGB4
  6106    F005     NOP
  6108    CFF3     MOVFF 0xff3, 0x4               50:    		MOVFF	PRODL,__AARGB5
  610A    F004     NOP
                                                  51:    		
  610C    5008     MOVF 0x8, W, ACCESS            52:    		MOVF	__AARGB1,W
  610E    020D     MULWF 0xd, ACCESS              53:    		MULWF	__BARGB1
  6110    CFF4     MOVFF 0xff4, 0x7               54:    		MOVFF	PRODH,__AARGB2
  6112    F007     NOP
  6114    CFF3     MOVFF 0xff3, 0x6               55:    		MOVFF	PRODL,__AARGB3
  6116    F006     NOP
                                                  56:    
  6118    020C     MULWF 0xc, ACCESS              57:    		MULWF	__BARGB2
  611A    50F3     MOVF 0xff3, W, ACCESS          58:    		MOVF	PRODL,W
  611C    2605     ADDWF 0x5, F, ACCESS           59:    		ADDWF	__AARGB4,F
  611E    50F4     MOVF 0xff4, W, ACCESS          60:    		MOVF	PRODH,W
  6120    2206     ADDWFC 0x6, F, ACCESS          61:    		ADDWFC	__AARGB3,F
  6122    6AE8     CLRF 0xfe8, ACCESS             62:    		CLRF	WREG
  6124    2207     ADDWFC 0x7, F, ACCESS          63:    		ADDWFC	__AARGB2,F
                                                  64:    
  6126    5011     MOVF 0x11, W, ACCESS           65:    		MOVF	__TEMPB2,W
  6128    020D     MULWF 0xd, ACCESS              66:    		MULWF	__BARGB1
  612A    50F3     MOVF 0xff3, W, ACCESS          67:    		MOVF	PRODL,W
  612C    2605     ADDWF 0x5, F, ACCESS           68:    		ADDWF	__AARGB4,F
  612E    50F4     MOVF 0xff4, W, ACCESS          69:    		MOVF	PRODH,W
  6130    2206     ADDWFC 0x6, F, ACCESS          70:    		ADDWFC	__AARGB3,F
  6132    6AE8     CLRF 0xfe8, ACCESS             71:    		CLRF	WREG
  6134    2207     ADDWFC 0x7, F, ACCESS          72:    		ADDWFC	__AARGB2,F
                                                  73:    	
  6136    5009     MOVF 0x9, W, ACCESS            74:    		MOVF	__AARGB0,W
  6138    020C     MULWF 0xc, ACCESS              75:    		MULWF	__BARGB2
  613A    50F3     MOVF 0xff3, W, ACCESS          76:    		MOVF	PRODL,W
  613C    2606     ADDWF 0x6, F, ACCESS           77:    		ADDWF	__AARGB3,F
  613E    50F4     MOVF 0xff4, W, ACCESS          78:    		MOVF	PRODH,W
  6140    2207     ADDWFC 0x7, F, ACCESS          79:    		ADDWFC	__AARGB2,F
  6142    5009     MOVF 0x9, W, ACCESS            80:    		MOVF	__AARGB0,W
  6144    020D     MULWF 0xd, ACCESS              81:    		MULWF	__BARGB1
  6146    6A08     CLRF 0x8, ACCESS               82:    		CLRF	__AARGB1
  6148    6AE8     CLRF 0xfe8, ACCESS             83:    		CLRF	WREG
  614A    2208     ADDWFC 0x8, F, ACCESS          84:    		ADDWFC	__AARGB1,F
  614C    50F3     MOVF 0xff3, W, ACCESS          85:    		MOVF	PRODL,W
  614E    2607     ADDWF 0x7, F, ACCESS           86:    		ADDWF	__AARGB2,F
  6150    50F4     MOVF 0xff4, W, ACCESS          87:    		MOVF	PRODH,W
  6152    2208     ADDWFC 0x8, F, ACCESS          88:    		ADDWFC	__AARGB1,F
                                                  89:    
  6154    5011     MOVF 0x11, W, ACCESS           90:    		MOVF	__TEMPB2,W
  6156    020E     MULWF 0xe, ACCESS              91:    		MULWF	__BARGB0
  6158    50F3     MOVF 0xff3, W, ACCESS          92:    		MOVF	PRODL,W
  615A    2606     ADDWF 0x6, F, ACCESS           93:    		ADDWF	__AARGB3,F
  615C    50F4     MOVF 0xff4, W, ACCESS          94:    		MOVF	PRODH,W
  615E    2207     ADDWFC 0x7, F, ACCESS          95:    		ADDWFC	__AARGB2,F
  6160    6A09     CLRF 0x9, ACCESS               96:    		CLRF	__AARGB0
  6162    6AE8     CLRF 0xfe8, ACCESS             97:    		CLRF	WREG
  6164    2208     ADDWFC 0x8, F, ACCESS          98:    		ADDWFC	__AARGB1,F
  6166    2209     ADDWFC 0x9, F, ACCESS          99:    		ADDWFC	__AARGB0,F
                                                  100:   
  6168    5012     MOVF 0x12, W, ACCESS           101:   		MOVF	__TEMPB1,W
  616A    020E     MULWF 0xe, ACCESS              102:   		MULWF	__BARGB0
  616C    50F3     MOVF 0xff3, W, ACCESS          103:   		MOVF	PRODL,W
  616E    2607     ADDWF 0x7, F, ACCESS           104:   		ADDWF	__AARGB2,F
  6170    50F4     MOVF 0xff4, W, ACCESS          105:   		MOVF	PRODH,W
  6172    2208     ADDWFC 0x8, F, ACCESS          106:   		ADDWFC	__AARGB1,F
  6174    6AE8     CLRF 0xfe8, ACCESS             107:   		CLRF	WREG
  6176    2209     ADDWFC 0x9, F, ACCESS          108:   		ADDWFC	__AARGB0,F
                                                  109:   
  6178    5013     MOVF 0x13, W, ACCESS           110:   		MOVF	__TEMPB0,W
  617A    020E     MULWF 0xe, ACCESS              111:   		MULWF	__BARGB0
  617C    50F3     MOVF 0xff3, W, ACCESS          112:   		MOVF	PRODL,W
  617E    2608     ADDWF 0x8, F, ACCESS           113:   		ADDWF	__AARGB1,F
  6180    50F4     MOVF 0xff4, W, ACCESS          114:   		MOVF	PRODH,W
  6182    2209     ADDWFC 0x9, F, ACCESS          115:   		ADDWFC	__AARGB0,F
                                                  116:   
  6184    0C00     RETLW 0                        117:   		RETLW	0x00
---  C:\MCC18\src\traditional\math\fxm3232.c  ----------------------------------------------------
1:                 /* a signed multiply is only different from an unsigned multiply
2:                  * if the upper bytes of the result matter, which for us they
3:                  * don't.
4:                  */
5:                 
6:                 #define PRODH	(PRODL + 1)
7:                 
8:                 extern near unsigned char __AARGB3, __BARGB3;
9:                 extern near unsigned char __AARGB7;
10:                void FXM3232 (void)
11:                {
12:                  _asm
13:                    movf __AARGB3, 0, 0
  6578    5006     MOVF 0x6, W, ACCESS
14:                    mulwf __BARGB3, 0
  657A    020B     MULWF 0xb, ACCESS
15:                    // low byte of both operands, so result adds into the low order
16:                    // result bytes
17:                    movff PRODL, __AARGB7
  657C    CFF3     MOVFF 0xff3, 0x2
  657E    F002     NOP
18:                    movff PRODH, __AARGB7 + 1
  6580    CFF4     MOVFF 0xff4, 0x3
  6582    F003     NOP
19:                    // W still contains AARGB3
20:                    mulwf __BARGB3 + 1, 0
  6584    020C     MULWF 0xc, ACCESS
21:                    // BARGB3[1], so result adds into AARGB7[1,2]
22:                    movf PRODL, 0, 0
  6586    50F3     MOVF 0xff3, W, ACCESS
23:                    addwf __AARGB7 + 1, 1, 0
  6588    2603     ADDWF 0x3, F, ACCESS
24:                    movlw 0
  658A    0E00     MOVLW 0
25:                    addwfc PRODH, 0, 0
  658C    20F4     ADDWFC 0xff4, W, ACCESS
26:                    movwf __AARGB7 + 2, 0
  658E    6E04     MOVWF 0x4, ACCESS
27:                    // reload AARGB3 to continue
28:                    movf __AARGB3, 0, 0
  6590    5006     MOVF 0x6, W, ACCESS
29:                    mulwf __BARGB3 + 2, 0
  6592    020D     MULWF 0xd, ACCESS
30:                    // BARGB3[2], so result adds into AARGB7[2,3]
31:                    movf PRODL, 0, 0
  6594    50F3     MOVF 0xff3, W, ACCESS
32:                    addwf __AARGB7 + 2, 1, 0
  6596    2604     ADDWF 0x4, F, ACCESS
33:                    movlw 0
  6598    0E00     MOVLW 0
34:                    addwfc PRODH, 0, 0
  659A    20F4     ADDWFC 0xff4, W, ACCESS
35:                    movwf __AARGB7 + 3, 0
  659C    6E05     MOVWF 0x5, ACCESS
36:                    // reload AARGB3 to continue
37:                    movf __AARGB3, 0, 0
  659E    5006     MOVF 0x6, W, ACCESS
38:                    mulwf __BARGB3 + 3, 0
  65A0    020E     MULWF 0xe, ACCESS
39:                    // BARGB3[3], so result adds into AARGB7[3]. 
40:                    // we don't care about result bytes above AARGB7[3], ignore prodh here.
41:                    movf PRODL, 0, 0
  65A2    50F3     MOVF 0xff3, W, ACCESS
42:                    addwf __AARGB7 + 3, 1, 0
  65A4    2605     ADDWF 0x5, F, ACCESS
43:                    // that's the end of all terms involving AARGB3[0].
44:                    // load AARGB3[1] to continue
45:                    movf __AARGB3 + 1, 0, 0
  65A6    5007     MOVF 0x7, W, ACCESS
46:                    mulwf __BARGB3, 0
  65A8    020B     MULWF 0xb, ACCESS
47:                    // AARGB3[1], so result adds into AARGB7[1,2]
48:                    movf PRODL, 0, 0
  65AA    50F3     MOVF 0xff3, W, ACCESS
49:                    addwf __AARGB7 + 1, 1, 0
  65AC    2603     ADDWF 0x3, F, ACCESS
50:                    movf PRODH, 0, 0
  65AE    50F4     MOVF 0xff4, W, ACCESS
51:                    addwfc __AARGB7 + 2, 1, 0
  65B0    2204     ADDWFC 0x4, F, ACCESS
52:                    movlw 0
  65B2    0E00     MOVLW 0
53:                    addwfc __AARGB7 + 3, 1, 0
  65B4    2205     ADDWFC 0x5, F, ACCESS
54:                    // reload AARGB3[1] to continue
55:                    movf __AARGB3 + 1, 0, 0
  65B6    5007     MOVF 0x7, W, ACCESS
56:                    mulwf __BARGB3 + 1, 0
  65B8    020C     MULWF 0xc, ACCESS
57:                    // AARGB3[1] and BARGB3[1], so result adds into AARGB7[2,3]
58:                    movf PRODL, 0, 0
  65BA    50F3     MOVF 0xff3, W, ACCESS
59:                    addwf __AARGB7 + 2, 1, 0
  65BC    2604     ADDWF 0x4, F, ACCESS
60:                    movf PRODH, 0, 0
  65BE    50F4     MOVF 0xff4, W, ACCESS
61:                    addwfc __AARGB7 + 3, 1, 0
  65C0    2205     ADDWFC 0x5, F, ACCESS
62:                    // reload AARGB3[1] to continue
63:                    movf __AARGB3 + 1, 0, 0
  65C2    5007     MOVF 0x7, W, ACCESS
64:                    mulwf __BARGB3 + 2, 0
  65C4    020D     MULWF 0xd, ACCESS
65:                    // AARGB3[1] and BARGB3[2], so result adds into AARGB7[3]
66:                    // we don't care about result bytes above AARGB7[3], ignore prodh here.
67:                    movf PRODL, 0, 0
  65C6    50F3     MOVF 0xff3, W, ACCESS
68:                    addwf __AARGB7 + 3, 1, 0
  65C8    2605     ADDWF 0x5, F, ACCESS
69:                    // all bytes of the term from the product of AARGB3[1] and BARGB3[3] are
70:                    // above our 32-bit result, don't even need to bother calculating
71:                    // that term.
72:                    // load AARGB3[2] to continue
73:                    movf __AARGB3 + 2, 0, 0
  65CA    5008     MOVF 0x8, W, ACCESS
74:                    mulwf __BARGB3, 0
  65CC    020B     MULWF 0xb, ACCESS
75:                    // AARGB3[2] and BARGB3[0], so result adds into AARGB7[2,3]
76:                    movf PRODL, 0, 0
  65CE    50F3     MOVF 0xff3, W, ACCESS
77:                    addwf __AARGB7 + 2, 1, 0
  65D0    2604     ADDWF 0x4, F, ACCESS
78:                    movf PRODH, 0, 0
  65D2    50F4     MOVF 0xff4, W, ACCESS
79:                    addwfc __AARGB7 + 3, 1, 0
  65D4    2205     ADDWFC 0x5, F, ACCESS
80:                    // reload AARGB3[2] to continue
81:                    movf __AARGB3 + 2, 0, 0
  65D6    5008     MOVF 0x8, W, ACCESS
82:                    mulwf __BARGB3 + 1, 0
  65D8    020C     MULWF 0xc, ACCESS
83:                    // AARGB3[2] and BARGB3[1], so result adds into AARGB7[3]
84:                    // we don't care about result bytes above AARGB7[3], ignore prodh here.
85:                    movf PRODL, 0, 0
  65DA    50F3     MOVF 0xff3, W, ACCESS
86:                    addwf __AARGB7 + 3, 1, 0
  65DC    2605     ADDWF 0x5, F, ACCESS
87:                    // all bytes of the termsfrom the products of AARGB3[2] and BARGB3[2,3] are
88:                    // above our 32-bit result, don't even need to bother calculating
89:                    // those terms.
90:                    // load AARGB3[3] to continue
91:                    movf __AARGB3 + 3, 0, 0
  65DE    5009     MOVF 0x9, W, ACCESS
92:                    mulwf __BARGB3, 0
  65E0    020B     MULWF 0xb, ACCESS
93:                    // AARGB3[3] and BARGB3[0], so result adds into AARGB7[3]
94:                    movf PRODL, 0, 0
  65E2    50F3     MOVF 0xff3, W, ACCESS
95:                    addwf __AARGB7 + 3, 1, 0
  65E4    2605     ADDWF 0x5, F, ACCESS
96:                
97:                    _endasm;
98:                }
  65E6    0012     RETURN 0
---  C:\MCC18\src\traditional\math\pow2x16.c  ----------------------------------------------------
1:                 void pow2x16 (void)
2:                 {
3:                   /* exponent in wreg, leave result in PROD */
4:                   _asm
5:                     clrf PRODL, 0
  6754    6AF3     CLRF 0xff3, ACCESS
6:                     clrf PRODL+1, 0
  6756    6AF4     CLRF 0xff4, ACCESS
7:                     incf PRODL, 1, 0
  6758    2AF3     INCF 0xff3, F, ACCESS
8:                     andlw 0x0f
  675A    0B0F     ANDLW 0xf
9:                     bz 5
  675C    E005     BZ 0x6768
10:                    bcf STATUS, 0, 0
  675E    90D8     BCF 0xfd8, 0, ACCESS
11:                    rlcf PRODL, 1, 0
  6760    36F3     RLCF 0xff3, F, ACCESS
12:                    rlcf PRODL+1, 1, 0
  6762    36F4     RLCF 0xff4, F, ACCESS
13:                    decf WREG, 0, 0
  6764    04E8     DECF 0xfe8, W, ACCESS
14:                    bnz -5
  6766    E1FB     BNZ 0x675e
15:                  _endasm
16:                }
  6768    0012     RETURN 0
---  C:\MCC18\src\traditional\proc\p18F26J50.asm  ------------------------------------------------
                                                  1:             LIST P=18F26J50
                                                  2:             NOLIST
                                                  3:     ;-------------------------------------------------------------------------
                                                  4:     ; MPLAB-Cxx  PIC18F26J50 processor definition module
                                                  5:     ; 
                                                  6:     ; (c) Copyright 1999-2009 Microchip Technology, All rights reserved
                                                  7:     ;-------------------------------------------------------------------------
                                                  8:     
                                                  9:     SFR_UNBANKED0       UDATA_ACS H'F60'
                                                  10:    
                                                  11:    UFRM                
                                                  12:    UFRML               
                                                  13:    UFRMLbits           RES 1     ; 0xF60
                                                  14:    UFRMH               
                                                  15:    UFRMHbits           RES 1     ; 0xF61
                                                  16:    UIR                 
                                                  17:    UIRbits             RES 1     ; 0xF62
                                                  18:    UEIR                
                                                  19:    UEIRbits            RES 1     ; 0xF63
                                                  20:    USTAT               
                                                  21:    USTATbits           RES 1     ; 0xF64
                                                  22:    UCON                
                                                  23:    UCONbits            RES 1     ; 0xF65
                                                  24:    DMABCH              
                                                  25:    DMABCHbits          RES 1     ; 0xF66
                                                  26:    DMABCL              RES 1     ; 0xF67
                                                  27:    RXADDRH             
                                                  28:    RXADDRHbits         RES 1     ; 0xF68
                                                  29:    RXADDRL             RES 1     ; 0xF69
                                                  30:    TXADDRH             
                                                  31:    TXADDRHbits         RES 1     ; 0xF6A
                                                  32:    TXADDRL             RES 1     ; 0xF6B
                                                  33:                        RES 4
                                                  34:    CMSTAT              
                                                  35:    CMSTATbits          
                                                  36:    CMSTATUS            
                                                  37:    CMSTATUSbits        RES 1     ; 0xF70
                                                  38:    SSP2CON2            
                                                  39:    SSP2CON2bits        RES 1     ; 0xF71
                                                  40:    SSP2CON1            
                                                  41:    SSP2CON1bits        RES 1     ; 0xF72
                                                  42:    SSP2STAT            
                                                  43:    SSP2STATbits        RES 1     ; 0xF73
                                                  44:    SSP2ADD             
                                                  45:    SSP2ADDbits         RES 1     ; 0xF74
                                                  46:    SSP2BUF             RES 1     ; 0xF75
                                                  47:    T4CON               
                                                  48:    T4CONbits           RES 1     ; 0xF76
                                                  49:    PR4                 RES 1     ; 0xF77
                                                  50:    TMR4                RES 1     ; 0xF78
                                                  51:    T3CON               
                                                  52:    T3CONbits           RES 1     ; 0xF79
                                                  53:    TMR3L               RES 1     ; 0xF7A
                                                  54:    TMR3H               RES 1     ; 0xF7B
                                                  55:    BAUDCON2            
                                                  56:    BAUDCON2bits        RES 1     ; 0xF7C
                                                  57:    SPBRGH2             RES 1     ; 0xF7D
                                                  58:    BAUDCON             
                                                  59:    BAUDCONbits         
                                                  60:    BAUDCON1            
                                                  61:    BAUDCON1bits        
                                                  62:    BAUDCTL             
                                                  63:    BAUDCTLbits         RES 1     ; 0xF7E
                                                  64:    SPBRGH              
                                                  65:    SPBRGH1             RES 1     ; 0xF7F
                                                  66:    PORTA               
                                                  67:    PORTAbits           RES 1     ; 0xF80
                                                  68:    PORTB               
                                                  69:    PORTBbits           RES 1     ; 0xF81
                                                  70:    PORTC               
                                                  71:    PORTCbits           RES 1     ; 0xF82
                                                  72:                        RES 2
                                                  73:    HLVDCON             
                                                  74:    HLVDCONbits         RES 1     ; 0xF85
                                                  75:    DMACON2             
                                                  76:    DMACON2bits         RES 1     ; 0xF86
                                                  77:                        RES 1
                                                  78:    DMACON1             
                                                  79:    DMACON1bits         RES 1     ; 0xF88
                                                  80:    LATA                
                                                  81:    LATAbits            RES 1     ; 0xF89
                                                  82:    LATB                
                                                  83:    LATBbits            RES 1     ; 0xF8A
                                                  84:    LATC                
                                                  85:    LATCbits            RES 1     ; 0xF8B
                                                  86:                        RES 2
                                                  87:    ALRMVALL            RES 1     ; 0xF8E
                                                  88:    ALRMVALH            RES 1     ; 0xF8F
                                                  89:    ALRMRPT             
                                                  90:    ALRMRPTbits         RES 1     ; 0xF90
                                                  91:    ALRMCFG             
                                                  92:    ALRMCFGbits         RES 1     ; 0xF91
                                                  93:    TRISA               
                                                  94:    TRISAbits           RES 1     ; 0xF92
                                                  95:    TRISB               
                                                  96:    TRISBbits           RES 1     ; 0xF93
                                                  97:    TRISC               
                                                  98:    TRISCbits           RES 1     ; 0xF94
                                                  99:                        RES 2
                                                  100:   T3GCON              
                                                  101:   T3GCONbits          RES 1     ; 0xF97
                                                  102:   RTCVALL             RES 1     ; 0xF98
                                                  103:   RTCVALH             RES 1     ; 0xF99
                                                  104:   T1GCON              
                                                  105:   T1GCONbits          RES 1     ; 0xF9A
                                                  106:   OSCTUNE             
                                                  107:   OSCTUNEbits         RES 1     ; 0xF9B
                                                  108:   RCSTA2              
                                                  109:   RCSTA2bits          RES 1     ; 0xF9C
                                                  110:   PIE1                
                                                  111:   PIE1bits            RES 1     ; 0xF9D
                                                  112:   PIR1                
                                                  113:   PIR1bits            RES 1     ; 0xF9E
                                                  114:   IPR1                
                                                  115:   IPR1bits            RES 1     ; 0xF9F
                                                  116:   PIE2                
                                                  117:   PIE2bits            RES 1     ; 0xFA0
                                                  118:   PIR2                
                                                  119:   PIR2bits            RES 1     ; 0xFA1
                                                  120:   IPR2                
                                                  121:   IPR2bits            RES 1     ; 0xFA2
                                                  122:   PIE3                
                                                  123:   PIE3bits            RES 1     ; 0xFA3
                                                  124:   PIR3                
                                                  125:   PIR3bits            RES 1     ; 0xFA4
                                                  126:   IPR3                
                                                  127:   IPR3bits            RES 1     ; 0xFA5
                                                  128:   EECON1              
                                                  129:   EECON1bits          RES 1     ; 0xFA6
                                                  130:   EECON2              RES 1     ; 0xFA7
                                                  131:   TXSTA2              
                                                  132:   TXSTA2bits          RES 1     ; 0xFA8
                                                  133:   TXREG2              RES 1     ; 0xFA9
                                                  134:   RCREG2              RES 1     ; 0xFAA
                                                  135:   SPBRG2              RES 1     ; 0xFAB
                                                  136:   RCSTA               
                                                  137:   RCSTAbits           
                                                  138:   RCSTA1              
                                                  139:   RCSTA1bits          RES 1     ; 0xFAC
                                                  140:   TXSTA               
                                                  141:   TXSTAbits           
                                                  142:   TXSTA1              
                                                  143:   TXSTA1bits          RES 1     ; 0xFAD
                                                  144:   TXREG               
                                                  145:   TXREG1              RES 1     ; 0xFAE
                                                  146:   RCREG               
                                                  147:   RCREG1              RES 1     ; 0xFAF
                                                  148:   SPBRG               
                                                  149:   SPBRG1              RES 1     ; 0xFB0
                                                  150:   CTMUICON            
                                                  151:   CTMUICONbits        RES 1     ; 0xFB1
                                                  152:   CTMUCONL            
                                                  153:   CTMUCONLbits        RES 1     ; 0xFB2
                                                  154:   CTMUCONH            
                                                  155:   CTMUCONHbits        RES 1     ; 0xFB3
                                                  156:   CCP2CON             
                                                  157:   CCP2CONbits         
                                                  158:   ECCP2CON            
                                                  159:   ECCP2CONbits        RES 1     ; 0xFB4
                                                  160:   CCPR2               
                                                  161:   CCPR2L              RES 1     ; 0xFB5
                                                  162:   CCPR2H              RES 1     ; 0xFB6
                                                  163:   ECCP2DEL            
                                                  164:   ECCP2DELbits        
                                                  165:   PWM2CON             
                                                  166:   PWM2CONbits         RES 1     ; 0xFB7
                                                  167:   ECCP2AS             
                                                  168:   ECCP2ASbits         RES 1     ; 0xFB8
                                                  169:   PSTR2CON            
                                                  170:   PSTR2CONbits        RES 1     ; 0xFB9
                                                  171:   CCP1CON             
                                                  172:   CCP1CONbits         
                                                  173:   ECCP1CON            
                                                  174:   ECCP1CONbits        RES 1     ; 0xFBA
                                                  175:   CCPR1               
                                                  176:   CCPR1L              RES 1     ; 0xFBB
                                                  177:   CCPR1H              RES 1     ; 0xFBC
                                                  178:   ECCP1DEL            
                                                  179:   ECCP1DELbits        
                                                  180:   PWM1CON             
                                                  181:   PWM1CONbits         RES 1     ; 0xFBD
                                                  182:   ECCP1AS             
                                                  183:   ECCP1ASbits         RES 1     ; 0xFBE
                                                  184:   PSTR1CON            
                                                  185:   PSTR1CONbits        RES 1     ; 0xFBF
                                                  186:   WDTCON              
                                                  187:   WDTCONbits          RES 1     ; 0xFC0
                                                  188:   ADCON1              
                                                  189:   ADCON1bits          RES 1     ; 0xFC1
                                                  190:   ADCON0              
                                                  191:   ADCON0bits          RES 1     ; 0xFC2
                                                  192:   ADRES               
                                                  193:   ADRESL              RES 1     ; 0xFC3
                                                  194:   ADRESH              RES 1     ; 0xFC4
                                                  195:   SSP1CON2            
                                                  196:   SSP1CON2bits        
                                                  197:   SSPCON2             
                                                  198:   SSPCON2bits         RES 1     ; 0xFC5
                                                  199:   SSP1CON1            
                                                  200:   SSP1CON1bits        
                                                  201:   SSPCON1             
                                                  202:   SSPCON1bits         RES 1     ; 0xFC6
                                                  203:   SSP1STAT            
                                                  204:   SSP1STATbits        
                                                  205:   SSPSTAT             
                                                  206:   SSPSTATbits         RES 1     ; 0xFC7
                                                  207:   SSP1ADD             
                                                  208:   SSP1ADDbits         
                                                  209:   SSPADD              
                                                  210:   SSPADDbits          RES 1     ; 0xFC8
                                                  211:   SSP1BUF             
                                                  212:   SSPBUF              RES 1     ; 0xFC9
                                                  213:   T2CON               
                                                  214:   T2CONbits           RES 1     ; 0xFCA
                                                  215:   PR2                 RES 1     ; 0xFCB
                                                  216:   TMR2                RES 1     ; 0xFCC
                                                  217:   T1CON               
                                                  218:   T1CONbits           RES 1     ; 0xFCD
                                                  219:   TMR1L               RES 1     ; 0xFCE
                                                  220:   TMR1H               RES 1     ; 0xFCF
                                                  221:   RCON                
                                                  222:   RCONbits            RES 1     ; 0xFD0
                                                  223:   CM2CON              
                                                  224:   CM2CONbits          
                                                  225:   CM2CON1             
                                                  226:   CM2CON1bits         RES 1     ; 0xFD1
                                                  227:   CM1CON              
                                                  228:   CM1CONbits          
                                                  229:   CM1CON1             
                                                  230:   CM1CON1bits         RES 1     ; 0xFD2
                                                  231:   OSCCON              
                                                  232:   OSCCONbits          RES 1     ; 0xFD3
                                                  233:                       RES 1
                                                  234:   T0CON               
                                                  235:   T0CONbits           RES 1     ; 0xFD5
                                                  236:   TMR0L               RES 1     ; 0xFD6
                                                  237:   TMR0H               RES 1     ; 0xFD7
                                                  238:   STATUS              
                                                  239:   STATUSbits          RES 1     ; 0xFD8
                                                  240:   FSR2                
                                                  241:   FSR2L               RES 1     ; 0xFD9
                                                  242:   FSR2H               RES 1     ; 0xFDA
                                                  243:   PLUSW2              RES 1     ; 0xFDB
                                                  244:   PREINC2             RES 1     ; 0xFDC
                                                  245:   POSTDEC2            RES 1     ; 0xFDD
                                                  246:   POSTINC2            RES 1     ; 0xFDE
                                                  247:   INDF2               RES 1     ; 0xFDF
                                                  248:   BSR                 RES 1     ; 0xFE0
                                                  249:   FSR1                
                                                  250:   FSR1L               RES 1     ; 0xFE1
                                                  251:   FSR1H               RES 1     ; 0xFE2
                                                  252:   PLUSW1              RES 1     ; 0xFE3
                                                  253:   PREINC1             RES 1     ; 0xFE4
                                                  254:   POSTDEC1            RES 1     ; 0xFE5
                                                  255:   POSTINC1            RES 1     ; 0xFE6
                                                  256:   INDF1               RES 1     ; 0xFE7
                                                  257:   WREG                RES 1     ; 0xFE8
                                                  258:   FSR0                
                                                  259:   FSR0L               RES 1     ; 0xFE9
                                                  260:   FSR0H               RES 1     ; 0xFEA
                                                  261:   PLUSW0              RES 1     ; 0xFEB
                                                  262:   PREINC0             RES 1     ; 0xFEC
                                                  263:   POSTDEC0            RES 1     ; 0xFED
                                                  264:   POSTINC0            RES 1     ; 0xFEE
                                                  265:   INDF0               RES 1     ; 0xFEF
                                                  266:   INTCON3             
                                                  267:   INTCON3bits         RES 1     ; 0xFF0
                                                  268:   INTCON2             
                                                  269:   INTCON2bits         RES 1     ; 0xFF1
                                                  270:   INTCON              
                                                  271:   INTCONbits          RES 1     ; 0xFF2
                                                  272:   PROD                
                                                  273:   PRODL               RES 1     ; 0xFF3
                                                  274:   PRODH               RES 1     ; 0xFF4
                                                  275:   TABLAT              RES 1     ; 0xFF5
                                                  276:   TBLPTR              
                                                  277:   TBLPTRL             RES 1     ; 0xFF6
                                                  278:   TBLPTRH             RES 1     ; 0xFF7
                                                  279:   TBLPTRU             RES 1     ; 0xFF8
                                                  280:   PC                  
                                                  281:   PCL                 RES 1     ; 0xFF9
                                                  282:   PCLATH              RES 1     ; 0xFFA
                                                  283:   PCLATU              RES 1     ; 0xFFB
                                                  284:   STKPTR              
                                                  285:   STKPTRbits          RES 1     ; 0xFFC
                                                  286:   TOS                 
                                                  287:   TOSL                RES 1     ; 0xFFD
                                                  288:   TOSH                RES 1     ; 0xFFE
                                                  289:   TOSU                RES 1     ; 0xFFF
                                                  290:   
                                                  291:   SFR_BANKED0         UDATA H'EC6'
                                                  292:   
                                                  293:   RPOR0               RES 1     ; 0xEC6
                                                  294:   RPOR1               RES 1     ; 0xEC7
                                                  295:   RPOR2               RES 1     ; 0xEC8
                                                  296:   RPOR3               RES 1     ; 0xEC9
                                                  297:   RPOR4               RES 1     ; 0xECA
                                                  298:   RPOR5               RES 1     ; 0xECB
                                                  299:   RPOR6               RES 1     ; 0xECC
                                                  300:   RPOR7               RES 1     ; 0xECD
                                                  301:   RPOR8               RES 1     ; 0xECE
                                                  302:   RPOR9               RES 1     ; 0xECF
                                                  303:   RPOR10              RES 1     ; 0xED0
                                                  304:   RPOR11              RES 1     ; 0xED1
                                                  305:   RPOR12              RES 1     ; 0xED2
                                                  306:   RPOR13              RES 1     ; 0xED3
                                                  307:   
                                                  308:   SFR_BANKED1         UDATA H'ED7'
                                                  309:   RPOR17              RES 1     ; 0xED7
                                                  310:   RPOR18              RES 1     ; 0xED8
                                                  311:   
                                                  312:   SFR_BANKED2         UDATA H'EE7'
                                                  313:   RPINR1              RES 1     ; 0xEE7
                                                  314:   RPINR2              RES 1     ; 0xEE8
                                                  315:   RPINR3              RES 1     ; 0xEE9
                                                  316:   RPINR4              RES 1     ; 0xEEA
                                                  317:   
                                                  318:   SFR_BANKED3         UDATA H'EEC'
                                                  319:   RPINR6              RES 1     ; 0xEEC
                                                  320:   RPINR7              RES 1     ; 0xEED
                                                  321:   RPINR8              RES 1     ; 0xEEE
                                                  322:   
                                                  323:   SFR_BANKED4         UDATA H'EF2'
                                                  324:   RPINR12             RES 1     ; 0xEF2
                                                  325:   RPINR13             RES 1     ; 0xEF3
                                                  326:   
                                                  327:   SFR_BANKED5         UDATA H'EF6'
                                                  328:   RPINR16             RES 1     ; 0xEF6
                                                  329:   RPINR17             RES 1     ; 0xEF7
                                                  330:   
                                                  331:   SFR_BANKED6         UDATA H'EFB'
                                                  332:   RPINR21             RES 1     ; 0xEFB
                                                  333:   RPINR22             RES 1     ; 0xEFC
                                                  334:   RPINR23             RES 1     ; 0xEFD
                                                  335:   RPINR24             RES 1     ; 0xEFE
                                                  336:   PPSCON              
                                                  337:   PPSCONbits          RES 1     ; 0xEFF
                                                  338:   
                                                  339:   SFR_BANKED7         UDATA H'F26'
                                                  340:   UEP0                
                                                  341:   UEP0bits            RES 1     ; 0xF26
                                                  342:   UEP1                
                                                  343:   UEP1bits            RES 1     ; 0xF27
                                                  344:   UEP2                
                                                  345:   UEP2bits            RES 1     ; 0xF28
                                                  346:   UEP3                
                                                  347:   UEP3bits            RES 1     ; 0xF29
                                                  348:   UEP4                
                                                  349:   UEP4bits            RES 1     ; 0xF2A
                                                  350:   UEP5                
                                                  351:   UEP5bits            RES 1     ; 0xF2B
                                                  352:   UEP6                
                                                  353:   UEP6bits            RES 1     ; 0xF2C
                                                  354:   UEP7                
                                                  355:   UEP7bits            RES 1     ; 0xF2D
                                                  356:   UEP8                
                                                  357:   UEP8bits            RES 1     ; 0xF2E
                                                  358:   UEP9                
                                                  359:   UEP9bits            RES 1     ; 0xF2F
                                                  360:   UEP10               
                                                  361:   UEP10bits           RES 1     ; 0xF30
                                                  362:   UEP11               
                                                  363:   UEP11bits           RES 1     ; 0xF31
                                                  364:   UEP12               
                                                  365:   UEP12bits           RES 1     ; 0xF32
                                                  366:   UEP13               
                                                  367:   UEP13bits           RES 1     ; 0xF33
                                                  368:   UEP14               
                                                  369:   UEP14bits           RES 1     ; 0xF34
                                                  370:   UEP15               
                                                  371:   UEP15bits           RES 1     ; 0xF35
                                                  372:   UIE                 
                                                  373:   UIEbits             RES 1     ; 0xF36
                                                  374:   UEIE                
                                                  375:   UEIEbits            RES 1     ; 0xF37
                                                  376:   UADDR               
                                                  377:   UADDRbits           RES 1     ; 0xF38
                                                  378:   UCFG                
                                                  379:   UCFGbits            RES 1     ; 0xF39
                                                  380:   
                                                  381:   SFR_BANKED8         UDATA H'F3C'
                                                  382:   PADCFG1             
                                                  383:   PADCFG1bits         RES 1     ; 0xF3C
                                                  384:   REFOCON             
                                                  385:   REFOCONbits         RES 1     ; 0xF3D
                                                  386:   RTCCAL              
                                                  387:   RTCCALbits          RES 1     ; 0xF3E
                                                  388:   RTCCFG              
                                                  389:   RTCCFGbits          RES 1     ; 0xF3F
                                                  390:   ODCON3              
                                                  391:   ODCON3bits          RES 1     ; 0xF40
                                                  392:   ODCON2              
                                                  393:   ODCON2bits          RES 1     ; 0xF41
                                                  394:   ODCON1              
                                                  395:   ODCON1bits          RES 1     ; 0xF42
                                                  396:   
                                                  397:   SFR_BANKED9         UDATA H'F48'
                                                  398:   ANCON0              
                                                  399:   ANCON0bits          RES 1     ; 0xF48
                                                  400:   ANCON1              
                                                  401:   ANCON1bits          RES 1     ; 0xF49
                                                  402:   DSWAKEL             
                                                  403:   DSWAKELbits         RES 1     ; 0xF4A
                                                  404:   DSWAKEH             
                                                  405:   DSWAKEHbits         RES 1     ; 0xF4B
                                                  406:   DSCONL              
                                                  407:   DSCONLbits          RES 1     ; 0xF4C
                                                  408:   DSCONH              
                                                  409:   DSCONHbits          RES 1     ; 0xF4D
                                                  410:   DSGPR0              RES 1     ; 0xF4E
                                                  411:   DSGPR1              RES 1     ; 0xF4F
                                                  412:   
                                                  413:   SFR_BANKED10        UDATA H'F52'
                                                  414:   TCLKCON             
                                                  415:   TCLKCONbits         RES 1     ; 0xF52
                                                  416:   CVRCON              
                                                  417:   CVRCONbits          RES 1     ; 0xF53
                                                  418:   
                                                  419:   ;*** Set all of memory to zeroes ***/
                                                  420:   ; Use FSR0 to increment through memory from address 0x0
                                                  421:   ; to the end of the last bank skipping sfrs and
                                                  422:   ; unimplemented addresses.
                                                  423:   
                                                  424:       CODE
                                                  425:   __zero_memory
  66FC    0EC0     MOVLW 0xc0                     426:       movlw  0xC0      ;low byte of (end address + 1)
  66FE    6EF3     MOVWF 0xff3, ACCESS            427:       movwf  PRODL, 0
  6700    EE00     LFSR 0, 0                      428:       lfsr   0, 0x0    ;start address
  6702    F000     NOP
  6704    0E0E     MOVLW 0xe                      429:       movlw  0xE       ;high byte of (end address + 1)
  6706    D801     RCALL 0x670a                   430:       rcall zero_block
  6708    0012     RETURN 0                       431:       return 0
                                                  432:   zero_block
                                                  433:   loop_h
  670A    60EA     CPFSLT 0xfea, ACCESS           434:       cpfslt FSR0H, 0
  670C    D002     BRA 0x6712                     435:       bra    compare_l
  670E    6AEE     CLRF 0xfee, ACCESS             436:       clrf   POSTINC0, 0
  6710    D7FC     BRA 0x670a                     437:       bra    loop_h
                                                  438:   compare_l
  6712    50F3     MOVF 0xff3, W, ACCESS          439:       movf   PRODL, 0, 0
                                                  440:   loop_l
  6714    60E9     CPFSLT 0xfe9, ACCESS           441:       cpfslt FSR0L, 0
  6716    0012     RETURN 0                       442:       return 0
  6718    6AEE     CLRF 0xfee, ACCESS             443:       clrf   POSTINC0, 0
  671A    D7FC     BRA 0x6714                     444:       bra    loop_l
---  C:\MCC18\src\traditional\startup\c018i.c  ---------------------------------------------------
1:                 /* $Id: c018i.c,v 1.7 2006/11/15 22:53:12 moshtaa Exp $ */
2:                 
3:                 /* Copyright (c)1999 Microchip Technology */
4:                 
5:                 /* MPLAB-C18 startup code, including initialized data */
6:                 
7:                 /* external reference to __init() function */
8:                 extern void __init (void);
9:                 /* external reference to the user's main routine */
10:                extern void main (void);
11:                /* prototype for the startup function */
12:                void _entry (void);
13:                void _startup (void);
14:                /* prototype for the initialized data setup */
15:                void _do_cinit (void);
16:                
17:                extern volatile near unsigned long short TBLPTR;
18:                extern near unsigned FSR0;
19:                extern near char __FPFLAGS;
20:                #define RND 6
21:                
22:                #pragma code _entry_scn=0x000000
23:                void
24:                _entry (void)
25:                {
26:                _asm goto _startup _endasm
  0000    EF8E     GOTO 0x671c
  0002    F033     NOP
27:                
28:                }
  0004    0012     RETURN 0
29:                #pragma code _startup_scn
30:                void
31:                _startup (void)
32:                {
33:                  _asm
34:                    // Initialize the stack pointer
35:                    lfsr 1, _stack
  671C    EE1D     LFSR 0x1, 0xd00
  671E    F000     NOP
36:                    lfsr 2, _stack
  6720    EE2D     LFSR 0x2, 0xd00
  6722    F000     NOP
37:                
38:                    clrf TBLPTRU, 0 // 1st silicon doesn't do this on POR
  6724    6AF8     CLRF 0xff8, ACCESS
39:                
40:                    bcf __FPFLAGS,RND,0 // Initialize rounding flag for floating point libs
  6726    9C01     BCF 0x1, 0x6, ACCESS
41:                    
42:                    _endasm 
43:                    _do_cinit ();
  6728    EC2B     CALL 0x6456, 0
  672A    F032     NOP
44:                
45:                loop:
46:                
47:                  // If user defined __init is not found, the one in clib.lib will be used
48:                  __init ();
  672C    EC07     CALL 0x100e, 0
  672E    F008     NOP
49:                
50:                  // Call the user's main routine
51:                  main ();
  6730    ECDF     CALL 0x53be, 0
  6732    F029     NOP
52:                
53:                  goto loop;
  6734    D7FB     BRA 0x672c
54:                }                               /* end _startup() */
  6736    0012     RETURN 0
55:                
56:                /* MPLAB-C18 initialized data memory support */
57:                /* The linker will populate the _cinit table */
58:                extern far rom struct
59:                {
60:                  unsigned short num_init;
61:                  struct _init_entry
62:                  {
63:                    unsigned long from;
64:                    unsigned long to;
65:                    unsigned long size;
66:                  }
67:                  entries[];
68:                }
69:                _cinit;
70:                
71:                #pragma code _cinit_scn
72:                void
73:                _do_cinit (void)
74:                {
75:                  /* we'll make the assumption in the following code that these statics
76:                   * will be allocated into the same bank.
77:                   */
78:                  static short long prom;
79:                  static unsigned short curr_byte;
80:                  static unsigned short curr_entry;
81:                  static short long data_ptr;
82:                
83:                  // Initialized data...
84:                  TBLPTR = (short long)&_cinit;
  6456    0E1E     MOVLW 0x1e
  6458    6EF6     MOVWF 0xff6, ACCESS
  645A    0E10     MOVLW 0x10
  645C    6EF7     MOVWF 0xff7, ACCESS
  645E    0E00     MOVLW 0
  6460    6EF8     MOVWF 0xff8, ACCESS
85:                  _asm
86:                    movlb data_ptr
  6462    0101     MOVLB 0x1
87:                    tblrdpostinc
  6464    0009     TBLRD*+
88:                    movf TABLAT, 0, 0
  6466    50F5     MOVF 0xff5, W, ACCESS
89:                    movwf curr_entry, 1
  6468    6FE0     MOVWF 0xe0, BANKED
90:                    tblrdpostinc
  646A    0009     TBLRD*+
91:                    movf TABLAT, 0, 0
  646C    50F5     MOVF 0xff5, W, ACCESS
92:                    movwf curr_entry+1, 1
  646E    6FE1     MOVWF 0xe1, BANKED
93:                  _endasm
94:                    //while (curr_entry)
95:                    //{
96:                    test:
97:                    _asm
98:                     bnz 3
  6470    E103     BNZ 0x6478
99:                    tstfsz curr_entry, 1
  6472    67E0     TSTFSZ 0xe0, BANKED
100:                   bra 1
  6474    D001     BRA 0x6478
101:                   _endasm
102:                   goto done;
  6476    D03D     BRA 0x64f2
103:                     /* Count down so we only have to look up the data in _cinit
104:                      * once.
105:                      *
106:                      * At this point we know that TBLPTR points to the top of the current
107:                      * entry in _cinit, so we can just start reading the from, to, and
108:                      * size values.
109:                      */
110:                     _asm
111:               	/* read the source address */
112:               	tblrdpostinc
  6478    0009     TBLRD*+
113:               	movf TABLAT, 0, 0
  647A    50F5     MOVF 0xff5, W, ACCESS
114:               	movwf prom, 1
  647C    6FDB     MOVWF 0xdb, BANKED
115:               	tblrdpostinc
  647E    0009     TBLRD*+
116:               	movf TABLAT, 0, 0
  6480    50F5     MOVF 0xff5, W, ACCESS
117:               	movwf prom+1, 1
  6482    6FDC     MOVWF 0xdc, BANKED
118:               	tblrdpostinc
  6484    0009     TBLRD*+
119:               	movf TABLAT, 0, 0
  6486    50F5     MOVF 0xff5, W, ACCESS
120:               	movwf prom+2, 1
  6488    6FDD     MOVWF 0xdd, BANKED
121:               	/* skip a byte since it's stored as a 32bit int */
122:               	tblrdpostinc
  648A    0009     TBLRD*+
123:               	/* read the destination address directly into FSR0 */
124:               	tblrdpostinc
  648C    0009     TBLRD*+
125:               	movf TABLAT, 0, 0
  648E    50F5     MOVF 0xff5, W, ACCESS
126:               	movwf FSR0L, 0
  6490    6EE9     MOVWF 0xfe9, ACCESS
127:               	tblrdpostinc
  6492    0009     TBLRD*+
128:               	movf TABLAT, 0, 0
  6494    50F5     MOVF 0xff5, W, ACCESS
129:               	movwf FSR0H, 0
  6496    6EEA     MOVWF 0xfea, ACCESS
130:               	/* skip two bytes since it's stored as a 32bit int */
131:               	tblrdpostinc
  6498    0009     TBLRD*+
132:               	tblrdpostinc
  649A    0009     TBLRD*+
133:               	/* read the destination address directly into FSR0 */
134:               	tblrdpostinc
  649C    0009     TBLRD*+
135:               	movf TABLAT, 0, 0
  649E    50F5     MOVF 0xff5, W, ACCESS
136:               	movwf curr_byte, 1
  64A0    6FDE     MOVWF 0xde, BANKED
137:               	tblrdpostinc
  64A2    0009     TBLRD*+
138:               	movf TABLAT, 0, 0
  64A4    50F5     MOVF 0xff5, W, ACCESS
139:               	movwf curr_byte+1, 1
  64A6    6FDF     MOVWF 0xdf, BANKED
140:               	/* skip two bytes since it's stored as a 32bit int */
141:               	tblrdpostinc
  64A8    0009     TBLRD*+
142:               	tblrdpostinc
  64AA    0009     TBLRD*+
143:                     _endasm  
144:                     //prom = data_ptr->from;
145:                     //FSR0 = data_ptr->to;
146:                     //curr_byte = (unsigned short) data_ptr->size;
147:                     /* the table pointer now points to the next entry. Save it
148:                      * off since we'll be using the table pointer to do the copying
149:                      * for the entry.
150:                      */
151:                     data_ptr = TBLPTR;
  64AC    CFF6     MOVFF 0xff6, 0x1e2
  64AE    F1E2     NOP
  64B0    CFF7     MOVFF 0xff7, 0x1e3
  64B2    F1E3     NOP
  64B4    CFF8     MOVFF 0xff8, 0x1e4
  64B6    F1E4     NOP
152:                     
153:                     /* now assign the source address to the table pointer */
154:                     TBLPTR = prom;
  64B8    C1DB     MOVFF 0x1db, 0xff6
  64BA    FFF6     NOP
  64BC    C1DC     MOVFF 0x1dc, 0xff7
  64BE    FFF7     NOP
  64C0    C1DD     MOVFF 0x1dd, 0xff8
  64C2    FFF8     NOP
155:               
156:                     /* do the copy loop */
157:                     _asm
158:                       // determine if we have any more bytes to copy
159:               	movlb curr_byte
  64C4    0101     MOVLB 0x1
160:               	movf curr_byte, 1, 1
  64C6    53DE     MOVF 0xde, F, BANKED
161:               copy_loop:
162:               	bnz 2 // copy_one_byte
  64C8    E102     BNZ 0x64ce
163:               	movf curr_byte + 1, 1, 1
  64CA    53DF     MOVF 0xdf, F, BANKED
164:               	bz 7 // done_copying
  64CC    E007     BZ 0x64dc
165:               
166:               copy_one_byte:
167:               	tblrdpostinc
  64CE    0009     TBLRD*+
168:               	movf TABLAT, 0, 0
  64D0    50F5     MOVF 0xff5, W, ACCESS
169:               	movwf POSTINC0, 0
  64D2    6EEE     MOVWF 0xfee, ACCESS
170:               
171:               	// decrement byte counter
172:               	decf curr_byte, 1, 1
  64D4    07DE     DECF 0xde, F, BANKED
173:               	bc -8 // copy_loop
  64D6    E2F8     BC 0x64c8
174:                       decf curr_byte + 1, 1, 1
  64D8    07DF     DECF 0xdf, F, BANKED
175:               	bra -7 // copy_one_byte
  64DA    D7F9     BRA 0x64ce
176:               
177:               done_copying:
178:               
179:                     _endasm
180:                     /* restore the table pointer for the next entry */
181:                     TBLPTR = data_ptr;
  64DC    C1E2     MOVFF 0x1e2, 0xff6
  64DE    FFF6     NOP
  64E0    C1E3     MOVFF 0x1e3, 0xff7
  64E2    FFF7     NOP
  64E4    C1E4     MOVFF 0x1e4, 0xff8
  64E6    FFF8     NOP
182:                     /* next entry... */
183:                     curr_entry--;
  64E8    0101     MOVLB 0x1
  64EA    07E0     DECF 0xe0, F, BANKED
  64EC    0E00     MOVLW 0
  64EE    5BE1     SUBWFB 0xe1, F, BANKED
184:                     goto test;
  64F0    D7BF     BRA 0x6470
185:               done:
186:               ;
187:               }
  64F2    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\__init.c  --------------------------------------------------
1:                 
2:                 /** @name __init
3:                  * The {\bf __init} is called if the linker can not find a
4:                  * user defined version for it
5:                  */
6:                 
7:                 void __init (void)
8:                 {
9:                 }
  100E    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\_user_putc.c  ----------------------------------------------
1:                 /* this default version should not do anything. it is entirely a
2:                    placeholder symbol. To keep code size at a minimum, it is declared
3:                    without a return value or parameters. The caller will still clean up 
4:                    the stack frame correctly. 
5:                 
6:                    When using the _H_USER stream, the function will be implemented in
7:                    application code with the prototype:   
8:                     int _user_putc (char c);
9:                   */
10:                void
11:                _user_putc (void)
12:                {
13:                }
  1006    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\isdigit.asm  -----------------------------------------------
                                                  1:     #include "P18CXXX.INC"
                                                  2:     #include "P18MACRO.INC"
                                                  3:     
                                                  4:     ; @name isdigit
                                                  5:     ;The {\bf isdigit} function tests the value of {\bf c} to determine if it
                                                  6:     ;is a digit character. A digit character is defined as any decimal digit
                                                  7:     ;character (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).
                                                  8:     ;
                                                  9:     ; int isdigit (int c);
                                                  10:    
                                                  11:    CTYPE CODE
                                                  12:    isdigit
                                                  13:      global isdigit
                                                  14:    
                                                  15:    ; Proceedure: Use FSR0 as pointer to 'c'
                                                  16:    ;         Return with result in PROD
                                                  17:    
                                                  18:      ; Clear out result
  66B4    6AF3     CLRF 0xff3, ACCESS             19:              clrf      PRODL, ACCESS
  66B6    6AF4     CLRF 0xff4, ACCESS             20:    	  clrf      PRODH, ACCESS
                                                  21:    	  
                                                  22:      ; Set FSR0 = FSR1 - 2 ( location of 'c')
  66B8    0EFF     MOVLW 0xff                     23:              StkSetPtrToOffset FSR0L,-1
  66BA    24E1     ADDWF 0xfe1, W, ACCESS
  66BC    6EE9     MOVWF 0xfe9, ACCESS
  66BE    0EFF     MOVLW 0xff
  66C0    20E2     ADDWFC 0xfe2, W, ACCESS
  66C2    6EEA     MOVWF 0xfea, ACCESS
                                                  24:    
  66C4    66ED     TSTFSZ 0xfed, ACCESS           25:              tstfsz    POSTDEC0,ACCESS
  66C6    D007     BRA 0x66d6                     26:              bra       jNoMatch            ; upper byte must be 0 to match
                                                  27:    
                                                  28:      ; Test for condition
                                                  29:    
  66C8    0E2F     MOVLW 0x2f                     30:              jmpFleL   INDF0,ACCESS,'0'-1,jNoMatch
  66CA    64EF     CPFSGT 0xfef, ACCESS
  66CC    D004     BRA 0x66d6
  66CE    0E3A     MOVLW 0x3a                     31:              jmpFgeL   INDF0,ACCESS,'9'+1,jNoMatch
  66D0    60EF     CPFSLT 0xfef, ACCESS
  66D2    D001     BRA 0x66d6
                                                  32:    
                                                  33:    jMatch:
  66D4    2AF3     INCF 0xff3, F, ACCESS          34:              incf      PRODL,F,ACCESS
                                                  35:    jNoMatch:
  66D6    0012     RETURN 0                       36:              return
---  C:\MCC18\src\traditional\stdclib\mcpyp2r.asm  -----------------------------------------------
                                                  1:     ; $Id: mcpyp2r.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name memcpypgm2ram
                                                  7:     ;The {\bf memcpypgm2ram} function performs a {\bf memcpy} where
                                                  8:     ;{\bf s1} points to data memory and {\bf s2} points to program
                                                  9:     ;memory.
                                                  10:    ;@param s1 pointer to destination in data memory
                                                  11:    ;@param s2 pointer to source in program memory
                                                  12:    ;@param n number of characters to copy
                                                  13:    ;
                                                  14:    
                                                  15:    
                                                  16:    STRING CODE
                                                  17:    memcpypgm2ram
                                                  18:      global memcpypgm2ram
                                                  19:    
                                                  20:    
                                                  21:    #ifdef __SMALL__
                                                  22:     messg "memcpypgm2ram - SMALL"
                                                  23:    
                                                  24:    
                                                  25:    ; Proceedure: Two byte pointers and two byte n.
                                                  26:    ;         Use offset from top of stack to test 'n' for zero and decrement
                                                  27:    ;         it. Use FSR0 for 'dest' and TBLPTR for 'src' 
                                                  28:    ;         Assumes TBLPTRU = 0.
                                                  29:    
                                                  30:      ; Load TBLPTR with the 'src' pointer
                                                  31:    
                                                  32:              Stk2CpyToReg -4,TBLPTRL
                                                  33:    
                                                  34:      ; Load FSR0 with the 'dest' pointer
                                                  35:    
                                                  36:              Stk2CpyToReg -2,FSR0L
                                                  37:    
                                                  38:      ; make a copy for the return value
                                                  39:    	movff FSR0L, PRODL
                                                  40:    	movff FSR0H, PRODH
                                                  41:    
                                                  42:    jLoop:
                                                  43:    
                                                  44:      ; Test 2 byte n for zero
                                                  45:    
                                                  46:              Stk2TestForZero -6,jEnd
                                                  47:    
                                                  48:      ; Decrement n 
                                                  49:    
                                                  50:              Stk2Dec   -6
                                                  51:    
                                                  52:              tblrd     *+                  ; read & increment
                                                  53:    
                                                  54:              movff     TABLAT, POSTINC0
                                                  55:              bra       jLoop
                                                  56:    
                                                  57:    jEnd
                                                  58:    
                                                  59:              return
                                                  60:    
                                                  61:    #else
                                                  62:    #ifdef __LARGE__
                                                  63:     messg "memcpypgm2ram - LARGE"
                                                  64:    
                                                  65:    
                                                  66:    ; Proceedure: Three byte rom pointer.
                                                  67:    ;         Use offset from top of stack to test 'n' for zero and decrement
                                                  68:    ;         it. Use FSR0 for 'dest' and TBLPTR for 'src' 
                                                  69:    
                                                  70:      ; Load TBLPTR with the 'src' pointer
                                                  71:    
  62CA    0EFB     MOVLW 0xfb                     72:              Stk3CpyToReg -5,TBLPTRL
  62CC    CFE3     MOVFF 0xfe3, 0xff6
  62CE    FFF6     NOP
  62D0    0EFC     MOVLW 0xfc
  62D2    CFE3     MOVFF 0xfe3, 0xff7
  62D4    FFF7     NOP
  62D6    0EFD     MOVLW 0xfd
  62D8    CFE3     MOVFF 0xfe3, 0xff8
  62DA    FFF8     NOP
                                                  73:    
                                                  74:      ; Load FSR0 with the 'dest' pointer
                                                  75:    
  62DC    0EFE     MOVLW 0xfe                     76:              Stk2CpyToReg -2,FSR0L
  62DE    CFE3     MOVFF 0xfe3, 0xfe9
  62E0    FFE9     NOP
  62E2    0EFF     MOVLW 0xff
  62E4    CFE3     MOVFF 0xfe3, 0xfea
  62E6    FFEA     NOP
                                                  77:    
                                                  78:      ; make a copy for the return value
  62E8    CFE9     MOVFF 0xfe9, 0xff3             79:    	movff FSR0L, PRODL
  62EA    FFF3     NOP
  62EC    CFEA     MOVFF 0xfea, 0xff4             80:    	movff FSR0H, PRODH
  62EE    FFF4     NOP
                                                  81:    
                                                  82:    jLoop:
                                                  83:    
                                                  84:      ; Test 2 byte n for zero
                                                  85:    
  62F0    0EF9     MOVLW 0xf9                     86:              Stk2TestForZero -7,jEnd
  62F2    50E3     MOVF 0xfe3, W, ACCESS
  62F4    E103     BNZ 0x62fc
  62F6    0EFA     MOVLW 0xfa
  62F8    50E3     MOVF 0xfe3, W, ACCESS
  62FA    E009     BZ 0x630e
                                                  87:    
                                                  88:      ; Decrement n 
                                                  89:    
  62FC    0EF9     MOVLW 0xf9                     90:              Stk2Dec   -7
  62FE    06E3     DECF 0xfe3, F, ACCESS
  6300    E202     BC 0x6306
  6302    0EFA     MOVLW 0xfa
  6304    06E3     DECF 0xfe3, F, ACCESS
                                                  91:    
  6306    0009     TBLRD*+                        92:              tblrd     *+                  ; read & increment
                                                  93:    
  6308    CFF5     MOVFF 0xff5, 0xfee             94:              movff     TABLAT, POSTINC0
  630A    FFEE     NOP
  630C    D7F1     BRA 0x62f0                     95:              bra       jLoop
                                                  96:    
                                                  97:    jEnd
                                                  98:    
  630E    0012     RETURN 0                       99:              return
---  C:\MCC18\src\traditional\stdclib\memset.asm  ------------------------------------------------
                                                  1:     ; $Id: memset.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name memset
                                                  7:     ;``The {\bf memset} function copies the value of {\bf c} [...] into
                                                  8:     ;each of the first {\bf n} characters of the object pointed to by
                                                  9:     ;{\bf s}.''
                                                  10:    ; * The MPLAB-C18 version of the {\bf memset} function differs from the ANSI
                                                  11:    ;specified function in that {\bf c} is defined as an {\bf unsigned char}
                                                  12:    ;parameter rather than an {\bf int} parameter.
                                                  13:    ;Stack usage: 5 bytes. Re-entrant.
                                                  14:    ;@param s pointer to object
                                                  15:    ;@param c character to copy into object
                                                  16:    ;@param n number of bytes of object to copy {\bf c} into
                                                  17:    ;@return ``The {\bf memset} function returns the value of {\bf s}.''
                                                  18:    ;
                                                  19:    ; void *memset (void *s, unsigned char c, size_t n);
                                                  20:    
                                                  21:    
                                                  22:    STRING CODE
                                                  23:    memset
                                                  24:      global memset
                                                  25:    
                                                  26:    ; Proceedure: Use offset from top of stack to test 'n' for zero and decrement
                                                  27:    ;         it. Use FSR0 for 's'.
                                                  28:    
                                                  29:    
                                                  30:      ; Load FSR0 with the 's' pointer
                                                  31:    
  6310    0EFE     MOVLW 0xfe                     32:              Stk2CpyToReg -2,FSR0L
  6312    CFE3     MOVFF 0xfe3, 0xfe9
  6314    FFE9     NOP
  6316    0EFF     MOVLW 0xff
  6318    CFE3     MOVFF 0xfe3, 0xfea
  631A    FFEA     NOP
                                                  33:    
                                                  34:      ; Make a copy for the return value
  631C    CFE9     MOVFF 0xfe9, 0xff3             35:    	  movff FSR0L, PRODL
  631E    FFF3     NOP
  6320    CFEA     MOVFF 0xfea, 0xff4             36:        	  movff FSR0H, PRODH
  6322    FFF4     NOP
                                                  37:    
                                                  38:    jLoop:
                                                  39:    
                                                  40:      ; Test n for zero
                                                  41:    
  6324    0EFB     MOVLW 0xfb                     42:              Stk2TestForZero -5,jEnd
  6326    50E3     MOVF 0xfe3, W, ACCESS
  6328    E103     BNZ 0x6330
  632A    0EFC     MOVLW 0xfc
  632C    50E3     MOVF 0xfe3, W, ACCESS
  632E    E009     BZ 0x6342
                                                  43:    
                                                  44:      ; Decrement n 
                                                  45:    
  6330    0EFB     MOVLW 0xfb                     46:              Stk2Dec   -5
  6332    06E3     DECF 0xfe3, F, ACCESS
  6334    E202     BC 0x633a
  6336    0EFC     MOVLW 0xfc
  6338    06E3     DECF 0xfe3, F, ACCESS
                                                  47:    
                                                  48:      ; get 'c'
  633A    0EFD     MOVLW 0xfd                     49:              movlw     -3
  633C    50E3     MOVF 0xfe3, W, ACCESS          50:              movf      PLUSW1, W, ACCESS
                                                  51:    
                                                  52:      ; Store it in 's'
  633E    6EEE     MOVWF 0xfee, ACCESS            53:              movwf     POSTINC0, ACCESS
  6340    D7F1     BRA 0x6324                     54:              bra       jLoop
                                                  55:    
                                                  56:    jEnd
                                                  57:    
  6342    0012     RETURN 0                       58:              return
---  C:\MCC18\src\traditional\stdclib\putc.c  ----------------------------------------------------
1:                 #include <stdio.h>
2:                 
3:                 int _user_putc (char c);
4:                 int _usart_putc (char c);
5:                 
6:                 int
7:                 putc (char c, FILE * f)
  64F4    CFD9     MOVFF 0xfd9, 0xfe6
  64F6    FFE6     NOP
  64F8    CFDA     MOVFF 0xfda, 0xfe6
  64FA    FFE6     NOP
  64FC    CFE1     MOVFF 0xfe1, 0xfd9
  64FE    FFD9     NOP
  6500    CFE2     MOVFF 0xfe2, 0xfda
  6502    FFDA     NOP
8:                 {
9:                   /* if the handle > 0 then it's a pointer to a string buffer address.
10:                     specifically, a pointer to a pointer referencing the next available
11:                     byte in the buffer, to which the character will be stored. */
12:                  if ((int) f >= 0)
  6504    0EFB     MOVLW 0xfb
  6506    CFDB     MOVFF 0xfdb, 0x14
  6508    F014     NOP
  650A    0EFC     MOVLW 0xfc
  650C    CFDB     MOVFF 0xfdb, 0x15
  650E    F015     NOP
  6510    0100     MOVLB 0
  6512    0E80     MOVLW 0x80
  6514    1415     ANDWF 0x15, W, ACCESS
  6516    E11A     BNZ 0x654c
13:                    return (unsigned char) (*(*(char **) f)++ = c);
  6518    0EFB     MOVLW 0xfb
  651A    CFDB     MOVFF 0xfdb, 0xfe9
  651C    FFE9     NOP
  651E    0EFC     MOVLW 0xfc
  6520    CFDB     MOVFF 0xfdb, 0xfea
  6522    FFEA     NOP
  6524    CFEE     MOVFF 0xfee, 0xff3
  6526    FFF3     NOP
  6528    CFED     MOVFF 0xfed, 0xff4
  652A    FFF4     NOP
  652C    2AEE     INCF 0xfee, F, ACCESS
  652E    0E00     MOVLW 0
  6530    22EF     ADDWFC 0xfef, F, ACCESS
  6532    CFF3     MOVFF 0xff3, 0xfe9
  6534    FFE9     NOP
  6536    CFF4     MOVFF 0xff4, 0xfea
  6538    FFEA     NOP
  653A    0EFD     MOVLW 0xfd
  653C    CFDB     MOVFF 0xfdb, 0xfef
  653E    FFEF     NOP
  6540    50EF     MOVF 0xfef, W, ACCESS
  6542    6A15     CLRF 0x15, ACCESS
  6544    6EF3     MOVWF 0xff3, ACCESS
  6546    C015     MOVFF 0x15, 0xff4
  6548    FFF4     NOP
  654A    D010     BRA 0x656c
14:                
15:                  if ((signed char) f == (signed char) _H_USART)
  654C    0EFB     MOVLW 0xfb
  654E    50DB     MOVF 0xfdb, W, ACCESS
  6550    08FE     SUBLW 0xfe
  6552    E106     BNZ 0x6560
16:                    {
17:                      /* the invocation of the USART function is direct, as it's our
18:                         default value and we want it to work without needing any
19:                         direct initialization from the user */
20:                      return _usart_putc (c);
  6554    0EFD     MOVLW 0xfd
  6556    CFDB     MOVFF 0xfdb, 0xfe6
  6558    FFE6     NOP
  655A    EC9C     CALL 0x6738, 0
  655C    F033     NOP
  655E    D005     BRA 0x656a
21:                    }
22:                  else
23:                    {
24:                      /* the invocation of the user function is direct, not via a
25:                         function pointer. We just put an empty definition of the
26:                         function in the library and if the user specifies their own
27:                         version it will be found first and the library definition will 
28:                         be ignored. We do it this way because it's generally better to 
29:                         spend 2 bytes of program memory for the RETURN instruction of
30:                         the empty function than three bytes of data memory for the
31:                         function pointer. */
32:                      return _user_putc (c);
  6560    0EFD     MOVLW 0xfd
  6562    CFDB     MOVFF 0xfdb, 0xfe6
  6564    FFE6     NOP
  6566    EC03     CALL 0x1006, 0
  6568    F008     NOP
  656A    52E5     MOVF 0xfe5, F, ACCESS
33:                    }
34:                }
  656C    52E5     MOVF 0xfe5, F, ACCESS
  656E    CFE5     MOVFF 0xfe5, 0xfda
  6570    FFDA     NOP
  6572    CFE7     MOVFF 0xfe7, 0xfd9
  6574    FFD9     NOP
  6576    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\slenpgm.asm  -----------------------------------------------
                                                  1:     ; $Id: slenpgm.asm,v 1.6 2009/05/14 08:27:21 guptan Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name strlenpgm
                                                  7:     ;``The {\bf strlenpgm} function computes the length of the string pointed
                                                  8:     ;to by {\bf s}.''
                                                  9:     ;@param s pointer to the string
                                                  10:    ;@return ``The {\bf strlenpgm} function returns the number of characters
                                                  11:    ;that precede the terminating null character.''
                                                  12:    ;
                                                  13:    ; sizerom_t strlenpgm (const rom char *s);
                                                  14:    
                                                  15:    
                                                  16:      extern __AARGB2
                                                  17:    
                                                  18:    STRING CODE
                                                  19:    strlenpgm
                                                  20:      global strlenpgm
                                                  21:    
                                                  22:    #ifdef __SMALL__
                                                  23:     messg "strlenpgm - SMALL"
                                                  24:    
                                                  25:    ; Procedure: Use TBLPTR for 's' and create 'n' on stack.  Return 'n' in
                                                  26:    ; __AARGB0:__AARGB1:__AARGB2.
                                                  27:    
                                                  28:      ; Load TBLPTR by POPing 's' off stack.
                                                  29:    
                                                  30:              Stk2PopToReg TBLPTRL
                                                  31:              clrf      POSTINC1,ACCESS    ; provide extra byte below stack
                                                  32:    
                                                  33:      ; Push 3 bytes of 0 onto stack. This is initial value of 'n'.
                                                  34:              clrf      POSTINC1,ACCESS
                                                  35:              clrf      POSTINC1,ACCESS
                                                  36:              clrf      POSTINC1,ACCESS
                                                  37:    
                                                  38:      ; Scan for '\0' while counting.
                                                  39:    jLoop:
                                                  40:    
                                                  41:      ; Test for '\0'
                                                  42:              tblrd     *+                  ; read & increment
                                                  43:              movf      TABLAT, F, ACCESS
                                                  44:              bz        jEnd
                                                  45:    
                                                  46:      ; Count it
                                                  47:    
                                                  48:              Stk3Inc   -3
                                                  49:              bra       jLoop
                                                  50:    
                                                  51:    jEnd
                                                  52:    
                                                  53:              Stk3CpyToReg -3, __AARGB2
                                                  54:    
                                                  55:      ; adjust the stack pointer (FSR1) back to the position where it was when it entered the function
                                                  56:              clrf      POSTDEC1,ACCESS
                                                  57:              clrf      POSTDEC1,ACCESS
                                                  58:    
                                                  59:              return
                                                  60:    #else
                                                  61:    #ifdef __LARGE__
                                                  62:     messg "strlenpgm - LARGE"
                                                  63:    
                                                  64:    ; Procedure: Use TBLPTR for 's' and create 'n' on stack.  Return 'n' in
                                                  65:    ; __AARGB0:__AARGB1:__AARGB2.
                                                  66:    
                                                  67:      ; Load TBLPTR by POPing 's' off stack.
                                                  68:    
  6360    0EFF     MOVLW 0xff                     69:              Stk3PopToReg TBLPTRL
  6362    CFE3     MOVFF 0xfe3, 0xff8
  6364    FFF8     NOP
  6366    52E5     MOVF 0xfe5, F, ACCESS
  6368    0EFF     MOVLW 0xff
  636A    CFE3     MOVFF 0xfe3, 0xff7
  636C    FFF7     NOP
  636E    52E5     MOVF 0xfe5, F, ACCESS
  6370    0EFF     MOVLW 0xff
  6372    CFE3     MOVFF 0xfe3, 0xff6
  6374    FFF6     NOP
  6376    52E5     MOVF 0xfe5, F, ACCESS
                                                  70:    
                                                  71:      ; Push 3 bytes of 0 onto stack. This is initial value of 'n'.
  6378    6AE6     CLRF 0xfe6, ACCESS             72:              clrf      POSTINC1,ACCESS
  637A    6AE6     CLRF 0xfe6, ACCESS             73:              clrf      POSTINC1,ACCESS
  637C    6AE6     CLRF 0xfe6, ACCESS             74:              clrf      POSTINC1,ACCESS
                                                  75:    
                                                  76:      ; Scan for '\0' while counting.
                                                  77:    jLoop:
                                                  78:    
                                                  79:      ; Test for '\0'
  637E    0009     TBLRD*+                        80:              tblrd     *+                  ; read & increment
  6380    52F5     MOVF 0xff5, F, ACCESS          81:              movf      TABLAT, F, ACCESS
  6382    E009     BZ 0x6396                      82:              bz        jEnd
                                                  83:    
                                                  84:      ; Count it
                                                  85:    
  6384    0EFD     MOVLW 0xfd                     86:              Stk3Inc   -3
  6386    2AE3     INCF 0xfe3, F, ACCESS
  6388    E105     BNZ 0x6394
  638A    0EFE     MOVLW 0xfe
  638C    2AE3     INCF 0xfe3, F, ACCESS
  638E    E102     BNZ 0x6394
  6390    0EFF     MOVLW 0xff
  6392    2AE3     INCF 0xfe3, F, ACCESS
  6394    D7F4     BRA 0x637e                     87:              bra       jLoop
                                                  88:    
                                                  89:    jEnd
                                                  90:    
  6396    0EFD     MOVLW 0xfd                     91:              Stk3CpyToReg -3, __AARGB2
  6398    CFE3     MOVFF 0xfe3, 0x7
  639A    F007     NOP
  639C    0EFE     MOVLW 0xfe
  639E    CFE3     MOVFF 0xfe3, 0x8
  63A0    F008     NOP
  63A2    0EFF     MOVLW 0xff
  63A4    CFE3     MOVFF 0xfe3, 0x9
  63A6    F009     NOP
  63A8    0012     RETURN 0                       92:              return
---  C:\MCC18\src\traditional\stdclib\sprintf.c  -------------------------------------------------
1:                 #include <stdio.h>
2:                 
3:                 /* sprintf() is a wrapper function which calls vfprintf() with the address
4:                    of the destination buffer as the output stream. EOF is returned on
5:                    error, else the number of characters output. */
6:                 int
7:                 sprintf (char *buf, const rom char *f, ...)
  63AA    CFD9     MOVFF 0xfd9, 0xfe6
  63AC    FFE6     NOP
  63AE    CFDA     MOVFF 0xfda, 0xfe6
  63B0    FFE6     NOP
  63B2    CFE1     MOVFF 0xfe1, 0xfd9
  63B4    FFD9     NOP
  63B6    CFE2     MOVFF 0xfe2, 0xfda
  63B8    FFDA     NOP
  63BA    52E6     MOVF 0xfe6, F, ACCESS
  63BC    52E6     MOVF 0xfe6, F, ACCESS
  63BE    52E6     MOVF 0xfe6, F, ACCESS
  63C0    52E6     MOVF 0xfe6, F, ACCESS
8:                 {
9:                   int n;
10:                  va_list ap;
11:                  va_start (ap, f);
  63C2    50D9     MOVF 0xfd9, W, ACCESS
  63C4    0FF9     ADDLW 0xf9
  63C6    6E14     MOVWF 0x14, ACCESS
  63C8    0EFF     MOVLW 0xff
  63CA    20DA     ADDWFC 0xfda, W, ACCESS
  63CC    6E15     MOVWF 0x15, ACCESS
  63CE    0E02     MOVLW 0x2
  63D0    C014     MOVFF 0x14, 0xfdb
  63D2    FFDB     NOP
  63D4    0E03     MOVLW 0x3
  63D6    C015     MOVFF 0x15, 0xfdb
  63D8    FFDB     NOP
12:                  n = vfprintf ((FILE *) & buf, f, ap);
  63DA    0E02     MOVLW 0x2
  63DC    CFDB     MOVFF 0xfdb, 0xfe6
  63DE    FFE6     NOP
  63E0    0E03     MOVLW 0x3
  63E2    CFDB     MOVFF 0xfdb, 0xfe6
  63E4    FFE6     NOP
  63E6    0EF9     MOVLW 0xf9
  63E8    CFDB     MOVFF 0xfdb, 0xfe6
  63EA    FFE6     NOP
  63EC    0EFA     MOVLW 0xfa
  63EE    CFDB     MOVFF 0xfdb, 0xfe6
  63F0    FFE6     NOP
  63F2    0EFB     MOVLW 0xfb
  63F4    CFDB     MOVFF 0xfdb, 0xfe6
  63F6    FFE6     NOP
  63F8    50D9     MOVF 0xfd9, W, ACCESS
  63FA    0FFC     ADDLW 0xfc
  63FC    6EE6     MOVWF 0xfe6, ACCESS
  63FE    0EFF     MOVLW 0xff
  6400    20DA     ADDWFC 0xfda, W, ACCESS
  6402    6EE6     MOVWF 0xfe6, ACCESS
  6404    EC03     CALL 0x3c06, 0
  6406    F01E     NOP
  6408    6E14     MOVWF 0x14, ACCESS
  640A    0E07     MOVLW 0x7
  640C    5CE1     SUBWF 0xfe1, W, ACCESS
  640E    E202     BC 0x6414
  6410    6AE1     CLRF 0xfe1, ACCESS
  6412    52E5     MOVF 0xfe5, F, ACCESS
  6414    6EE1     MOVWF 0xfe1, ACCESS
  6416    5014     MOVF 0x14, W, ACCESS
  6418    CFF3     MOVFF 0xff3, 0xfde
  641A    FFDE     NOP
  641C    CFF4     MOVFF 0xff4, 0xfdd
  641E    FFDD     NOP
13:                  va_end (ap);
14:                  *buf = '\0';
  6420    0EFC     MOVLW 0xfc
  6422    CFDB     MOVFF 0xfdb, 0xfe9
  6424    FFE9     NOP
  6426    0EFD     MOVLW 0xfd
  6428    CFDB     MOVFF 0xfdb, 0xfea
  642A    FFEA     NOP
  642C    6AEF     CLRF 0xfef, ACCESS
15:                  return n;
  642E    CFDE     MOVFF 0xfde, 0x14
  6430    F014     NOP
  6432    CFDD     MOVFF 0xfdd, 0x15
  6434    F015     NOP
  6436    C014     MOVFF 0x14, 0xff3
  6438    FFF3     NOP
  643A    C015     MOVFF 0x15, 0xff4
  643C    FFF4     NOP
16:                }
  643E    0E04     MOVLW 0x4
  6440    5CE1     SUBWF 0xfe1, W, ACCESS
  6442    E202     BC 0x6448
  6444    6AE1     CLRF 0xfe1, ACCESS
  6446    52E5     MOVF 0xfe5, F, ACCESS
  6448    6EE1     MOVWF 0xfe1, ACCESS
  644A    52E5     MOVF 0xfe5, F, ACCESS
  644C    CFE5     MOVFF 0xfe5, 0xfda
  644E    FFDA     NOP
  6450    CFE7     MOVFF 0xfe7, 0xfd9
  6452    FFD9     NOP
  6454    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\strlen.asm  ------------------------------------------------
                                                  1:     ; $Id: strlen.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name strlen
                                                  7:     ;``The {\bf strlen} function computes the length of the string pointed
                                                  8:     ;to by {\bf s}.''
                                                  9:     ;Stack usage: 2 bytes. Re-entrant.
                                                  10:    ;@param s pointer to the string
                                                  11:    ;@return ``The {\bf strlen} function returns the number of characters
                                                  12:    ;that precede the terminating null character.''
                                                  13:    ;
                                                  14:    ; size_t strlen (const char *s);
                                                  15:    
                                                  16:    
                                                  17:    STRING CODE
                                                  18:    strlen
                                                  19:      global strlen
                                                  20:    
                                                  21:    ; Proceedure: Use FSR0 for 's' and use PROD for 'n'.
                                                  22:    
                                                  23:      ; Load FSR0 by copying 's' off stack into FSR0.
                                                  24:    
  6344    0EFE     MOVLW 0xfe                     25:              Stk2CpyToReg -2,FSR0L
  6346    CFE3     MOVFF 0xfe3, 0xfe9
  6348    FFE9     NOP
  634A    0EFF     MOVLW 0xff
  634C    CFE3     MOVFF 0xfe3, 0xfea
  634E    FFEA     NOP
                                                  26:    
                                                  27:      ; Clear PROD
  6350    6AF3     CLRF 0xff3, ACCESS             28:              clrf      PRODL,ACCESS
  6352    6AF4     CLRF 0xff4, ACCESS             29:              clrf      PRODH,ACCESS
                                                  30:    
                                                  31:      ; Scan for '\0' while counting.
                                                  32:    jLoop:
                                                  33:    
                                                  34:      ; Test for '\0'
  6354    52EE     MOVF 0xfee, F, ACCESS          35:              movf      POSTINC0,F,ACCESS   ; set Z flag
  6356    E003     BZ 0x635e                      36:              bz        jEnd
                                                  37:    
                                                  38:      ; Count it 
  6358    4AF3     INFSNZ 0xff3, F, ACCESS        39:    	  infsnz    PRODL, F, ACCESS
  635A    2AF4     INCF 0xff4, F, ACCESS          40:    	  incf      PRODH, F, ACCESS
                                                  41:    
  635C    D7FB     BRA 0x6354                     42:              bra       jLoop
                                                  43:    
                                                  44:    jEnd
                                                  45:    
  635E    0012     RETURN 0                       46:              return
---  C:\MCC18\src\traditional\stdclib\vfprintf.c  ------------------------------------------------
1:                 #include <stdio.h>
2:                 #include <ctype.h>
3:                 #include <string.h>
4:                 
5:                 #define _FLAG_MINUS 0x1
6:                 #define _FLAG_PLUS  0x2
7:                 #define _FLAG_SPACE 0x4
8:                 #define _FLAG_OCTO  0x8
9:                 #define _FLAG_ZERO  0x10
10:                #define _FLAG_SIGNED 0x80
11:                
12:                static const rom char s_digits[] = "0123456789abcdef";
13:                
14:                static unsigned char
15:                s_put_n_chars (FILE * handle, unsigned char n, char c)
  3BDA    EC29     CALL 0x4652, 0
  3BDC    F023     NOP
  4652    CFD9     MOVFF 0xfd9, 0xfe6
  4654    FFE6     NOP
  4656    CFDA     MOVFF 0xfda, 0xfe6
  4658    FFE6     NOP
  465A    CFE1     MOVFF 0xfe1, 0xfd9
  465C    FFD9     NOP
  465E    CFE2     MOVFF 0xfe2, 0xfda
  4660    FFDA     NOP
  4662    0012     RETURN 0
16:                {
17:                  while (n--)
  3BDE    0EFB     MOVLW 0xfb
  3BE0    CFDB     MOVFF 0xfdb, 0xff3
  3BE2    FFF3     NOP
  3BE4    06DB     DECF 0xfdb, F, ACCESS
  3BE6    50F3     MOVF 0xff3, W, ACCESS
  3BE8    0900     IORLW 0
  3BEA    E00A     BZ 0x3c00
18:                    if (putc (c, handle) == EOF)
  3BEC    EC77     CALL 0x46ee, 0
  3BEE    F023     NOP
  3BF0    0EFA     MOVLW 0xfa
  3BF2    ECE2     CALL 0x47c4, 0
  3BF4    F023     NOP
  3BF6    E1F3     BNZ 0x3bde
  3BF8    1C15     COMF 0x15, W, ACCESS
  3BFA    E1F1     BNZ 0x3bde
19:                      return 1;
  3BFC    0E01     MOVLW 0x1
  3BFE    D001     BRA 0x3c02
20:                  return 0;
  3C00    0E00     MOVLW 0
21:                }
  3C02    EF58     GOTO 0x46b0
  3C04    F023     NOP
  46B0    52E5     MOVF 0xfe5, F, ACCESS
  46B2    CFE5     MOVFF 0xfe5, 0xfda
  46B4    FFDA     NOP
  46B6    CFE7     MOVFF 0xfe7, 0xfd9
  46B8    FFD9     NOP
  46BA    0012     RETURN 0
22:                
23:                #define _FMT_UNSPECIFIED 0
24:                #define _FMT_LONG 1
25:                #define _FMT_SHLONG 2
26:                #define _FMT_BYTE   3
27:                int
28:                vfprintf (auto FILE *handle, auto const rom char *f, auto va_list ap)
  3C06    EC29     CALL 0x4652, 0
  3C08    F023     NOP
  3C0A    0E3B     MOVLW 0x3b
  3C0C    24E1     ADDWF 0xfe1, W, ACCESS
  3C0E    E302     BNC 0x3c14
  3C10    68E1     SETF 0xfe1, ACCESS
  3C12    52E6     MOVF 0xfe6, F, ACCESS
  3C14    6EE1     MOVWF 0xfe1, ACCESS
29:                {
30:                  unsigned char c;
31:                  int count = 0;
  3C16    0E01     MOVLW 0x1
  3C18    6ADB     CLRF 0xfdb, ACCESS
  3C1A    0E02     MOVLW 0x2
  3C1C    6ADB     CLRF 0xfdb, ACCESS
32:                
33:                  for (c = *f; c; c = *++f)
  3C1E    0EF9     MOVLW 0xf9
  3C20    CFDB     MOVFF 0xfdb, 0xff6
  3C22    FFF6     NOP
  3C24    0EFA     MOVLW 0xfa
  3C26    CFDB     MOVFF 0xfdb, 0xff7
  3C28    FFF7     NOP
  3C2A    0EFB     MOVLW 0xfb
  3C2C    CFDB     MOVFF 0xfdb, 0xff8
  3C2E    FFF8     NOP
  3C30    0008     TBLRD*
  3C32    50F5     MOVF 0xff5, W, ACCESS
  3C34    6EDF     MOVWF 0xfdf, ACCESS
  3C36    50DF     MOVF 0xfdf, W, ACCESS
  3C38    E102     BNZ 0x3c3e
  3C3A    EF7C     GOTO 0x44f8
  3C3C    F022     NOP
  44F2    D979     RCALL 0x47e6
  44F4    EF18     GOTO 0x3c30
  44F6    F01E     NOP
  47E6    50D9     MOVF 0xfd9, W, ACCESS
  47E8    0FF9     ADDLW 0xf9
  47EA    6EE9     MOVWF 0xfe9, ACCESS
  47EC    0EFF     MOVLW 0xff
  47EE    EF8C     GOTO 0x4718
  47F0    F023     NOP
34:                    {
35:                      if (c == '%')
  3C3E    0E25     MOVLW 0x25
  3C40    5CDF     SUBWF 0xfdf, W, ACCESS
  3C42    E002     BZ 0x3c48
  3C44    EF6F     GOTO 0x44de
  3C46    F022     NOP
36:                        {
37:                          unsigned char flags = 0;
  3C48    0E03     MOVLW 0x3
  3C4A    6ADB     CLRF 0xfdb, ACCESS
38:                          unsigned char width = 0;
  3C4C    0E04     MOVLW 0x4
  3C4E    6ADB     CLRF 0xfdb, ACCESS
39:                          unsigned char precision = 0;
  3C50    0E05     MOVLW 0x5
  3C52    6ADB     CLRF 0xfdb, ACCESS
40:                          unsigned char have_precision = 0;
  3C54    0E06     MOVLW 0x6
  3C56    6ADB     CLRF 0xfdb, ACCESS
41:                          unsigned char size = 0;
  3C58    0E07     MOVLW 0x7
  3C5A    6ADB     CLRF 0xfdb, ACCESS
42:                          unsigned char space_cnt;
43:                          unsigned char cval;
44:                          unsigned long larg;
45:                          far rom char *romstring;
46:                          char *ramstring;
47:                          int n;
48:                          /* get the first character of the conversion specifier */
49:                          c = *++f;
  3C5C    EC91     CALL 0x4522, 0
  3C5E    F022     NOP
50:                
51:                          /**  The conversion specification has, after the '%' character:
52:                              7.9.6.1
53:                             * Zero or more flags (in any order) that modify the meaning of the
54:                               conversion specification.
55:                             * An optional minimum field width. If the converted value has 
56:                               fewer characters than the field width, it will be padded with
57:                               spaces (by default) on the left (or right, if the left
58:                               adjustment flag, described later, has been given) to the field
59:                               width. The field width takes the form of an asterisk * 
60:                               (described later) or a decimal integer.
61:                             * An optional precision that gives the minimum number of digits
62:                               to appear for the d, i, o, u, x, and X conversions, the
63:                               maximum number of digits to appear after the decimal point
64:                               character for e, E, and f conversions, the maximum number
65:                               of significant digits for the g and G conversions, or the 
66:                               maximum number of characters to be written from a string in
67:                               s conversion. The precision takes the form of a period (.)
68:                               followed by an asterisk * (described later) or by an optional
69:                               decimal integer; if only the period is specified, the precision
70:                               is taken as zero. If a precision appears with any other 
71:                               conversion specifier, the behaviour is undefined.
72:                             * An optional h specifying that a following d, i, o, u, x, or X
73:                               conversion specifier applies to a short int or unsigned short
74:                               int argument (the argument will have been promoted according
75:                               to the integer promotions, and its value shall be converted
76:                               to short int or unsigned short int before printing); an
77:                               optional h specifying that a following n conversion specifier
78:                               applies to a pointer to a short int argument; an optional l 
79:                               (ell) specifying that a following d, i, o, u, x, or X 
80:                               conversion specifier applies to a long int or unsigned long int 
81:                               argument; or an optional L specifying that a following e, E, 
82:                               f, g, or G conversion specifier applies to a long double 
83:                               argument. If an h, l, or L appears with any other conversion 
84:                               specifier, the behaviour is undefined.
85:                             * A character that specifies the type of conversion to be applied.
86:                            */
87:                
88:                          /** check for a flag.
89:                             7.9.6.1
90:                             The flag characters and their meanings are:
91:                
92:                             - The result of the conversion will be left-justified within
93:                               the field. (It will be right justified if this flag is not
94:                               specified.)
95:                             + The result of a signed conversion will always begin with a 
96:                               plus or a minus sign. (It will begin with a sign only when
97:                               a negative value is converted if this flag is not specified.)
98:                             space  If the first character of a signed conversion is not a
99:                               sign, or if a signed conversion results in no characters, a
100:                              space will be prefixed to the result. If the space and + flags
101:                              both appear, the space flag will be ignored.
102:                            # The result is to be converted to an "alternate form." For o
103:                              conversion, it increases the precision to force the first digit
104:                              of the result to be a zero. For x (or X) conversion, a nonzero
105:                              result will have 0x (or 0X) prefixed to it. For e, E, f, g, 
106:                              and G conversions, the result will always contain a decimal-
107:                              point character, even if no digits follow it. (Normally, a
108:                              decimal point character appears in the result of these
109:                              conversions only if a digit follows it.) For g and G
110:                              conversions, trailing zeros will not be removed from the 
111:                              result. For other conversions the behaviour is undefined.
112:                            0 For d, i, o, u, x, X, e, E, f, g, and G conversions, leading
113:                              zeros (following any indication of sign or base) are used to
114:                              pad to the field width; no space padding is performed. If
115:                              the 0 and - flags both appear, the 0 flag will be ignored.
116:                              For other conversions, the behaviour is undefined.
117:                           */
118:                         while (c == '-' || c == '+' || c == ' ' || c == '#'
  3C60    0E2D     MOVLW 0x2d
  3C62    5CDF     SUBWF 0xfdf, W, ACCESS
  3C64    E00C     BZ 0x3c7e
  3C66    0E2B     MOVLW 0x2b
  3C68    5CDF     SUBWF 0xfdf, W, ACCESS
  3C6A    E009     BZ 0x3c7e
  3C6C    0E20     MOVLW 0x20
  3C6E    5CDF     SUBWF 0xfdf, W, ACCESS
  3C70    E006     BZ 0x3c7e
  3C72    0E23     MOVLW 0x23
  3CB0    D7D5     BRA 0x3c5c
119:                                || c == '0')
  3C74    5CDF     SUBWF 0xfdf, W, ACCESS
  3C76    E003     BZ 0x3c7e
  3C78    0E30     MOVLW 0x30
  3C7A    5CDF     SUBWF 0xfdf, W, ACCESS
  3C7C    E11A     BNZ 0x3cb2
120:                           {
121:                             switch (c)
  3C7E    50DF     MOVF 0xfdf, W, ACCESS
  3C80    0A30     XORLW 0x30
  3C82    E014     BZ 0x3cac
  3C84    0A13     XORLW 0x13
  3C86    E00F     BZ 0x3ca6
  3C88    0A03     XORLW 0x3
  3C8A    E00A     BZ 0x3ca0
  3C8C    0A0B     XORLW 0xb
  3C8E    E005     BZ 0x3c9a
  3C90    0A06     XORLW 0x6
  3C92    E1E4     BNZ 0x3c5c
122:                               {
123:                               case '-':
124:                                 flags |= _FLAG_MINUS;
  3C94    0E03     MOVLW 0x3
  3C96    80DB     BSF 0xfdb, 0, ACCESS
125:                                 break;
  3C98    D7E1     BRA 0x3c5c
126:                               case '+':
127:                                 flags |= _FLAG_PLUS;
  3C9A    0E03     MOVLW 0x3
  3C9C    82DB     BSF 0xfdb, 0x1, ACCESS
128:                                 break;
  3C9E    D7DE     BRA 0x3c5c
129:                               case ' ':
130:                                 flags |= _FLAG_SPACE;
  3CA0    0E03     MOVLW 0x3
  3CA2    84DB     BSF 0xfdb, 0x2, ACCESS
131:                                 break;
  3CA4    D7DB     BRA 0x3c5c
132:                               case '#':
133:                                 flags |= _FLAG_OCTO;
  3CA6    0E03     MOVLW 0x3
  3CA8    86DB     BSF 0xfdb, 0x3, ACCESS
134:                                 break;
  3CAA    D7D8     BRA 0x3c5c
135:                               case '0':
136:                                 flags |= _FLAG_ZERO;
  3CAC    0E03     MOVLW 0x3
  3CAE    88DB     BSF 0xfdb, 0x4, ACCESS
137:                                 break;
138:                               }
139:                             c = *++f;
140:                           }
141:                         /* the optional width field is next */
142:                         if (c == '*')
  3CB2    0E2A     MOVLW 0x2a
  3CB4    5CDF     SUBWF 0xfdf, W, ACCESS
  3CB6    E11B     BNZ 0x3cee
143:                           {
144:                             n = va_arg (ap, int);
  3CB8    EC8D     CALL 0x451a, 0
  3CBA    F022     NOP
  3CBC    ECDB     CALL 0x45b6, 0
  3CBE    F022     NOP
  45B6    0E13     MOVLW 0x13
  45B8    CFEE     MOVFF 0xfee, 0xfdb
  45BA    FFDB     NOP
  45BC    0E14     MOVLW 0x14
  45BE    CFED     MOVFF 0xfed, 0xfdb
  45C0    FFDB     NOP
145:                             if (n < 0)
  3CC0    E010     BZ 0x3ce2
  45C2    0E13     MOVLW 0x13
  45C4    CFDB     MOVFF 0xfdb, 0x14
  45C6    F014     NOP
  45C8    0E14     MOVLW 0x14
  45CA    CFDB     MOVFF 0xfdb, 0x15
  45CC    F015     NOP
  45CE    0100     MOVLB 0
  45D0    0E80     MOVLW 0x80
  45D2    1415     ANDWF 0x15, W, ACCESS
  45D4    0012     RETURN 0
146:                               {
147:                                 flags |= _FLAG_MINUS;
  3CC2    0E03     MOVLW 0x3
  3CC4    80DB     BSF 0xfdb, 0, ACCESS
148:                                 width = -n;
  3CC6    6808     SETF 0x8, ACCESS
  3CC8    6809     SETF 0x9, ACCESS
  3CCA    0E13     MOVLW 0x13
  3CCC    CFDB     MOVFF 0xfdb, 0xd
  3CCE    F00D     NOP
  3CD0    0E14     MOVLW 0x14
  3CD2    CFDB     MOVFF 0xfdb, 0xe
  3CD4    F00E     NOP
  3CD6    ECC3     CALL 0x6186, 0
  3CD8    F030     NOP
  3CDA    0E04     MOVLW 0x4
  3CDC    C006     MOVFF 0x6, 0xfdb
  3CDE    FFDB     NOP
149:                               }
150:                             else
  3CE0    D003     BRA 0x3ce8
151:                               width = n;
  3CE2    0E13     MOVLW 0x13
  3CE4    ECC4     CALL 0x4588, 0
  3CE6    F022     NOP
152:                             c = *++f;
  3CE8    EC91     CALL 0x4522, 0
  3CEA    F022     NOP
153:                           }
154:                         else
  3CEC    D00B     BRA 0x3d04
155:                           {
156:                             cval = 0;
  3CEE    0E09     MOVLW 0x9
  3CF0    6ADB     CLRF 0xfdb, ACCESS
157:                             while ((unsigned char) isdigit (c))
  3CF2    EC32     CALL 0x4664, 0
  3CF4    F023     NOP
  3CF6    E003     BZ 0x3cfe
  3CFC    D7FA     BRA 0x3cf2
  4664    CFDF     MOVFF 0xfdf, 0xfe6
  4666    FFE6     NOP
  4668    6AE6     CLRF 0xfe6, ACCESS
  466A    EC5A     CALL 0x66b4, 0
  466C    F033     NOP
  466E    52E5     MOVF 0xfe5, F, ACCESS
  4670    52E5     MOVF 0xfe5, F, ACCESS
  4672    50F3     MOVF 0xff3, W, ACCESS
  4674    0012     RETURN 0
158:                               {
159:                                 cval = cval * 10 + c - '0';
  3CF8    ECA6     CALL 0x474c, 0
  3CFA    F023     NOP
  474C    0E09     MOVLW 0x9
  474E    50DB     MOVF 0xfdb, W, ACCESS
  4750    0D0A     MULLW 0xa
  4752    50F3     MOVF 0xff3, W, ACCESS
  4754    24DF     ADDWF 0xfdf, W, ACCESS
  4756    0FD0     ADDLW 0xd0
  4758    6EE7     MOVWF 0xfe7, ACCESS
  475A    0E09     MOVLW 0x9
  475C    CFE7     MOVFF 0xfe7, 0xfdb
  475E    FFDB     NOP
160:                                 c = *++f;
  4760    EF91     GOTO 0x4522
  4762    F022     NOP
161:                               }
162:                             width = cval;
  3CFE    0E09     MOVLW 0x9
  3D00    ECC4     CALL 0x4588, 0
  3D02    F022     NOP
163:                           }
164:               
165:                         /* if '-' is specified, '0' is ignored */
166:                         if (flags & _FLAG_MINUS)
  3D04    0E03     MOVLW 0x3
  3D06    B0DB     BTFSC 0xfdb, 0, ACCESS
167:                           flags &= ~_FLAG_ZERO;
  3D08    98DB     BCF 0xfdb, 0x4, ACCESS
168:               
169:                         /* the optional precision field is next */
170:                         if (c == '.')
  3D0A    0E2E     MOVLW 0x2e
  3D0C    5CDF     SUBWF 0xfdf, W, ACCESS
  3D0E    E11B     BNZ 0x3d46
171:                           {
172:                             c = *++f;
  3D10    EC91     CALL 0x4522, 0
  3D12    F022     NOP
173:                             if (c == '*')
  3D14    0E2A     MOVLW 0x2a
  3D16    5CDF     SUBWF 0xfdf, W, ACCESS
  3D18    E10B     BNZ 0x3d30
174:                               {
175:                                 n = va_arg (ap, int);
  3D1A    EC8D     CALL 0x451a, 0
  3D1C    F022     NOP
  3D1E    ECDB     CALL 0x45b6, 0
  3D20    F022     NOP
  451A    D929     RCALL 0x476e
  451C    0E02     MOVLW 0x2
  451E    EF7E     GOTO 0x46fc
  4520    F023     NOP
  46FC    5E14     SUBWF 0x14, F, ACCESS
  46FE    0E00     MOVLW 0
  4700    5A15     SUBWFB 0x15, F, ACCESS
  4702    0EF7     MOVLW 0xf7
  4704    C014     MOVFF 0x14, 0xfdb
  4706    FFDB     NOP
  4708    0EF8     MOVLW 0xf8
  470A    C015     MOVFF 0x15, 0xfdb
  470C    FFDB     NOP
  470E    C014     MOVFF 0x14, 0xfe9
  4710    FFE9     NOP
  4712    C015     MOVFF 0x15, 0xfea
  4714    FFEA     NOP
  4716    0012     RETURN 0
  476E    0EF7     MOVLW 0xf7
  4770    CFDB     MOVFF 0xfdb, 0x14
  4772    F014     NOP
  4774    0EF8     MOVLW 0xf8
  4776    CFDB     MOVFF 0xfdb, 0x15
  4778    F015     NOP
  477A    0012     RETURN 0
176:                                 if (n >= 0)
  3D22    E103     BNZ 0x3d2a
177:                                   {
178:                                     precision = n;
  3D24    0E13     MOVLW 0x13
  3D26    EC16     CALL 0x462c, 0
  3D28    F023     NOP
  462C    50DB     MOVF 0xfdb, W, ACCESS
  462E    D8CE     RCALL 0x47cc
  47CC    6EE7     MOVWF 0xfe7, ACCESS
  47CE    0E05     MOVLW 0x5
  47D0    CFE7     MOVFF 0xfe7, 0xfdb
  47D2    FFDB     NOP
  47D4    0012     RETURN 0
179:                                     have_precision = 1;
  4630    0E01     MOVLW 0x1
  4632    6EF3     MOVWF 0xff3, ACCESS
  4634    0E06     MOVLW 0x6
  4636    CFF3     MOVFF 0xff3, 0xfdb
  4638    FFDB     NOP
  463A    0012     RETURN 0
180:                                   }
181:                                 c = *++f;
  3D2A    EC91     CALL 0x4522, 0
  3D2C    F022     NOP
182:                               }
183:                             else
  3D2E    D00B     BRA 0x3d46
184:                               {
185:                                 cval = 0;
  3D30    0E09     MOVLW 0x9
  3D32    6ADB     CLRF 0xfdb, ACCESS
186:                                 while ((unsigned char) isdigit (c))
  3D34    EC32     CALL 0x4664, 0
  3D36    F023     NOP
  3D38    E003     BZ 0x3d40
  3D3E    D7FA     BRA 0x3d34
187:                                   {
188:                                     cval = cval * 10 + c - '0';
  3D3A    ECA6     CALL 0x474c, 0
  3D3C    F023     NOP
189:                                     c = *++f;
190:                                   }
191:                                 precision = cval;
  3D40    0E09     MOVLW 0x9
  3D42    EC16     CALL 0x462c, 0
  3D44    F023     NOP
192:                                 have_precision = 1;
193:                               }
194:                           }
195:               
196:                         /* the optional 'h' specifier. since int and short int are
197:                            the same size for MPLAB C18, this is a NOP for us. */
198:                         if (c == 'h')
  3D46    0E68     MOVLW 0x68
  3D48    5CDF     SUBWF 0xfdf, W, ACCESS
  3D4A    E107     BNZ 0x3d5a
199:                           {
200:                             c = *++f;
  3D4C    EC91     CALL 0x4522, 0
  3D4E    F022     NOP
201:                             /* if 'c' is another 'h' character, this is an 'hh'
202:                                specifier and the size is 8 bits */
203:                             if (c == 'h')
  3D50    0E68     MOVLW 0x68
  3D52    5CDF     SUBWF 0xfdf, W, ACCESS
  3D54    E11D     BNZ 0x3d90
204:                               {
205:                                 size = _FMT_BYTE;
  3D56    0E03     MOVLW 0x3
206:                                 c = *++f;
207:                               }
208:                           }
209:                         /* 'z' and 't' are both 16-bit and so are NOPs */
210:                         else if (c == 't' || c == 'z')
  3D58    D018     BRA 0x3d8a
  3D5A    0E74     MOVLW 0x74
  3D5C    5CDF     SUBWF 0xfdf, W, ACCESS
  3D5E    E017     BZ 0x3d8e
  3D60    0E7A     MOVLW 0x7a
  3D62    5CDF     SUBWF 0xfdf, W, ACCESS
  3D64    E014     BZ 0x3d8e
211:                           c = *++f;
212:                         /* the 'H' specifier tells us to deal with 24-bit integers.
213:                            the 'T' and 'Z' specifiers are also 24 bit */
214:                         else if (c == 'H' || c == 'T' || c == 'Z')
  3D66    0E48     MOVLW 0x48
  3D68    5CDF     SUBWF 0xfdf, W, ACCESS
  3D6A    E006     BZ 0x3d78
  3D6C    0E54     MOVLW 0x54
  3D6E    5CDF     SUBWF 0xfdf, W, ACCESS
  3D70    E003     BZ 0x3d78
  3D72    0E5A     MOVLW 0x5a
  3D74    5CDF     SUBWF 0xfdf, W, ACCESS
  3D76    E102     BNZ 0x3d7c
215:                           {
216:                             size = _FMT_SHLONG;
  3D78    0E02     MOVLW 0x2
217:                             c = *++f;
218:                           }
219:                         /* the 'l' specifier tells us to deal with 32-bit integers
220:                            'j' specifies intmax_t (long in our case). */
221:                         else if (c == 'l' || c == 'j')
  3D7A    D007     BRA 0x3d8a
  3D7C    0E6C     MOVLW 0x6c
  3D7E    5CDF     SUBWF 0xfdf, W, ACCESS
  3D80    E003     BZ 0x3d88
  3D82    0E6A     MOVLW 0x6a
  3D84    5CDF     SUBWF 0xfdf, W, ACCESS
  3D86    E104     BNZ 0x3d90
222:                           {
223:                             size = _FMT_LONG;
  3D88    0E01     MOVLW 0x1
  3D8A    EC69     CALL 0x46d2, 0
  3D8C    F023     NOP
224:                             c = *++f;
  3D8E    DBC9     RCALL 0x4522
  4522    D961     RCALL 0x47e6
  4524    0008     TBLRD*
  4526    50F5     MOVF 0xff5, W, ACCESS
  4528    6EDF     MOVWF 0xfdf, ACCESS
  452A    0012     RETURN 0
  4718    20DA     ADDWFC 0xfda, W, ACCESS
  471A    6EEA     MOVWF 0xfea, ACCESS
  471C    2AEF     INCF 0xfef, F, ACCESS
  471E    CFEE     MOVFF 0xfee, 0xff6
  4720    FFF6     NOP
  4722    0E00     MOVLW 0
  4724    22EF     ADDWFC 0xfef, F, ACCESS
  4726    CFEE     MOVFF 0xfee, 0xff7
  4728    FFF7     NOP
  472A    22EF     ADDWFC 0xfef, F, ACCESS
  472C    CFEE     MOVFF 0xfee, 0xff8
  472E    FFF8     NOP
  4730    0012     RETURN 0
225:                           }
226:               
227:                         switch (c)
  3D90    50DF     MOVF 0xfdf, W, ACCESS
  3D92    0A6E     XORLW 0x6e
  3D94    E101     BNZ 0x3d98
  3D96    D37F     BRA 0x4496
  3D98    0A1E     XORLW 0x1e
  3D9A    E101     BNZ 0x3d9e
  3D9C    D192     BRA 0x40c2
  3D9E    0A20     XORLW 0x20
  3DA0    E101     BNZ 0x3da4
  3DA2    D18F     BRA 0x40c2
  3DA4    0A3F     XORLW 0x3f
  3DA6    E101     BNZ 0x3daa
  3DA8    D149     BRA 0x403c
  3DAA    0A1A     XORLW 0x1a
  3DAC    E101     BNZ 0x3db0
  3DAE    D146     BRA 0x403c
  3DB0    0A0D     XORLW 0xd
  3DB2    E101     BNZ 0x3db6
  3DB4    D143     BRA 0x403c
  3DB6    0A20     XORLW 0x20
  3DB8    E101     BNZ 0x3dbc
  3DBA    D140     BRA 0x403c
  3DBC    0A3A     XORLW 0x3a
  3DBE    E101     BNZ 0x3dc2
  3DC0    D13D     BRA 0x403c
  3DC2    0A20     XORLW 0x20
  3DC4    E101     BNZ 0x3dc8
  3DC6    D13A     BRA 0x403c
  3DC8    0A26     XORLW 0x26
  3DCA    E101     BNZ 0x3dce
  3DCC    D135     BRA 0x4038
  3DCE    0A0D     XORLW 0xd
  3DD0    E101     BNZ 0x3dd4
  3DD2    D132     BRA 0x4038
  3DD4    0A1A     XORLW 0x1a
  3DD6    E101     BNZ 0x3dda
  3DD8    D0D9     BRA 0x3f8c
  3DDA    0A20     XORLW 0x20
  3DDC    E04A     BZ 0x3e72
  3DDE    0A30     XORLW 0x30
  3DE0    E01F     BZ 0x3e20
  3DE2    0A46     XORLW 0x46
  3DE4    E00E     BZ 0x3e02
  3DE6    0A25     XORLW 0x25
  3DE8    E001     BZ 0x3dec
  3DEA    D383     BRA 0x44f2
228:                           {
229:                           case '\0':
230:                             /* this is undefined behaviour. we have a trailing '%' character
231:                                in the string, perhaps with some flags, width, precision
232:                                stuff as well, but no format specifier. We'll, arbitrarily,
233:                                back up a character so that the loop will terminate 
234:                                properly when it loops back and we'll output a '%'
235:                                character. */
236:                             --f;
  3DEC    50D9     MOVF 0xfd9, W, ACCESS
  3DEE    0FF9     ADDLW 0xf9
  3DF0    6EE9     MOVWF 0xfe9, ACCESS
  3DF2    0EFF     MOVLW 0xff
  3DF4    20DA     ADDWFC 0xfda, W, ACCESS
  3DF6    6EEA     MOVWF 0xfea, ACCESS
  3DF8    0E01     MOVLW 0x1
  3DFA    5EEE     SUBWF 0xfee, F, ACCESS
  3DFC    0E00     MOVLW 0
  3DFE    5AEE     SUBWFB 0xfee, F, ACCESS
  3E00    5AEE     SUBWFB 0xfee, F, ACCESS
237:                             /* fallthrough */
238:                           case '%':
239:                             if (putc ('%', handle) == EOF)
  3E02    EC77     CALL 0x46ee, 0
  3E04    F023     NOP
  3E06    0E25     MOVLW 0x25
  3E08    6EE6     MOVWF 0xfe6, ACCESS
  3E0A    DB95     RCALL 0x4536
  3E0C    E103     BNZ 0x3e14
  3E0E    1C15     COMF 0x15, W, ACCESS
  3E10    E101     BNZ 0x3e14
  3E12    D369     BRA 0x44e6
240:                               return EOF;
241:                             ++count;
  3E14    EC73     CALL 0x46e6, 0
  3E16    F023     NOP
  3E18    E201     BC 0x3e1c
  3E1A    D36B     BRA 0x44f2
  3E1C    2ADB     INCF 0xfdb, F, ACCESS
242:                             break;
  3E1E    D369     BRA 0x44f2
243:                           case 'c':
244:                             space_cnt = 0;
  3E20    0E08     MOVLW 0x8
  3E22    6ADB     CLRF 0xfdb, ACCESS
245:                             if (width > 1)
  3E24    0E04     MOVLW 0x4
  3E26    50DB     MOVF 0xfdb, W, ACCESS
  3E28    0801     SUBLW 0x1
  3E2A    E206     BC 0x3e38
246:                               {
247:                                 space_cnt = width - 1;
  3E2C    0E04     MOVLW 0x4
  3E2E    04DB     DECF 0xfdb, W, ACCESS
  3E30    EC3B     CALL 0x4676, 0
  3E32    F023     NOP
248:                                 count += space_cnt;
  3E34    50DB     MOVF 0xfdb, W, ACCESS
  3E36    DB8B     RCALL 0x454e
249:                               }
250:                             if (space_cnt && !(flags & _FLAG_MINUS))
  3E38    0E08     MOVLW 0x8
  3E3A    50DB     MOVF 0xfdb, W, ACCESS
  3E3C    E009     BZ 0x3e50
  3E3E    0E03     MOVLW 0x3
  3E40    50DB     MOVF 0xfdb, W, ACCESS
  3E42    0B01     ANDLW 0x1
  3E44    E105     BNZ 0x3e50
251:                               {
252:                                 if (s_put_n_chars (handle, space_cnt, ' '))
  3E46    DB72     RCALL 0x452c
  3E48    E001     BZ 0x3e4c
  3E4A    D34D     BRA 0x44e6
253:                                   return EOF;
254:                                 space_cnt = 0;
  3E4C    0E08     MOVLW 0x8
  3E4E    6ADB     CLRF 0xfdb, ACCESS
255:                               }
256:                             c = va_arg (ap, int);
  3E50    DB64     RCALL 0x451a
  3E52    CFEF     MOVFF 0xfef, 0xfdf
  3E54    FFDF     NOP
257:                             if (putc (c, handle) == EOF)
  3E56    ECEB     CALL 0x47d6, 0
  3E58    F023     NOP
  3E5A    E103     BNZ 0x3e62
  3E5C    1C15     COMF 0x15, W, ACCESS
  3E5E    E101     BNZ 0x3e62
  3E60    D342     BRA 0x44e6
258:                               return EOF;
259:                             ++count;
  3E62    EC73     CALL 0x46e6, 0
  3E64    F023     NOP
  3E66    E301     BNC 0x3e6a
  3E68    2ADB     INCF 0xfdb, F, ACCESS
260:                             if (s_put_n_chars (handle, space_cnt, ' '))
  3E6A    DB60     RCALL 0x452c
  3E6C    E101     BNZ 0x3e70
  3E6E    D341     BRA 0x44f2
261:                               return EOF;
  3E70    D33A     BRA 0x44e6
262:                             break;
263:                           case 'S':
264:                             if (size == _FMT_SHLONG)
  3E72    0E07     MOVLW 0x7
  3E74    50DB     MOVF 0xfdb, W, ACCESS
  3E76    0802     SUBLW 0x2
  3E78    E10F     BNZ 0x3e98
265:                               romstring = va_arg (ap, rom far char *);
  3E7A    ECB7     CALL 0x476e, 0
  3E7C    F023     NOP
  3E7E    0E03     MOVLW 0x3
  3E80    EC7E     CALL 0x46fc, 0
  3E82    F023     NOP
  3E84    0E0E     MOVLW 0xe
  3E86    CFEE     MOVFF 0xfee, 0xfdb
  3E88    FFDB     NOP
  3E8A    0E0F     MOVLW 0xf
  3E8C    CFEE     MOVFF 0xfee, 0xfdb
  3E8E    FFDB     NOP
  3E90    0E10     MOVLW 0x10
  3E92    CFEE     MOVFF 0xfee, 0xfdb
  3E94    FFDB     NOP
266:                             else
  3E96    D020     BRA 0x3ed8
267:                               romstring = (far rom char*)va_arg (ap, rom near char *);
  3E98    0EF7     MOVLW 0xf7
  3E9A    CFDB     MOVFF 0xfdb, 0x17
  3E9C    F017     NOP
  3E9E    0EF8     MOVLW 0xf8
  3EA0    CFDB     MOVFF 0xfdb, 0x18
  3EA2    F018     NOP
  3EA4    0E02     MOVLW 0x2
  3EA6    5E17     SUBWF 0x17, F, ACCESS
  3EA8    0E00     MOVLW 0
  3EAA    5A18     SUBWFB 0x18, F, ACCESS
  3EAC    0EF7     MOVLW 0xf7
  3EAE    C017     MOVFF 0x17, 0xfdb
  3EB0    FFDB     NOP
  3EB2    0EF8     MOVLW 0xf8
  3EB4    C018     MOVFF 0x18, 0xfdb
  3EB6    FFDB     NOP
  3EB8    C017     MOVFF 0x17, 0xfe9
  3EBA    FFE9     NOP
  3EBC    C018     MOVFF 0x18, 0xfea
  3EBE    FFEA     NOP
  3EC0    EC6E     CALL 0x46dc, 0
  3EC2    F023     NOP
  3EC4    6A16     CLRF 0x16, ACCESS
  3EC6    0E0E     MOVLW 0xe
  3EC8    C014     MOVFF 0x14, 0xfdb
  3ECA    FFDB     NOP
  3ECC    0E0F     MOVLW 0xf
  3ECE    C015     MOVFF 0x15, 0xfdb
  3ED0    FFDB     NOP
  3ED2    0E10     MOVLW 0x10
  3ED4    C016     MOVFF 0x16, 0xfdb
  3ED6    FFDB     NOP
268:                             n = strlenpgm (romstring);
  3ED8    0E0E     MOVLW 0xe
  3EDA    CFDB     MOVFF 0xfdb, 0xfe6
  3EDC    FFE6     NOP
  3EDE    0E0F     MOVLW 0xf
  3EE0    CFDB     MOVFF 0xfdb, 0xfe6
  3EE2    FFE6     NOP
  3EE4    0E10     MOVLW 0x10
  3EE6    CFDB     MOVFF 0xfdb, 0xfe6
  3EE8    FFE6     NOP
  3EEA    ECB0     CALL 0x6360, 0
  3EEC    F031     NOP
  3EEE    52E5     MOVF 0xfe5, F, ACCESS
  3EF0    52E5     MOVF 0xfe5, F, ACCESS
  3EF2    52E5     MOVF 0xfe5, F, ACCESS
  3EF4    0E13     MOVLW 0x13
  3EF6    C007     MOVFF 0x7, 0xfdb
  3EF8    FFDB     NOP
  3EFA    0E14     MOVLW 0x14
  3EFC    C008     MOVFF 0x8, 0xfdb
  3EFE    FFDB     NOP
269:                             /* Normalize the width based on the length of the actual 
270:                                string and the precision. */
271:                             if (have_precision && precision < (unsigned char) n)
  3F00    0E06     MOVLW 0x6
  3F02    50DB     MOVF 0xfdb, W, ACCESS
  3F04    E005     BZ 0x3f10
  3F06    0E13     MOVLW 0x13
  3F08    ECB2     CALL 0x4764, 0
  3F0A    F023     NOP
  3F0C    E201     BC 0x3f10
272:                               n = precision;
  3F0E    DB6A     RCALL 0x45e4
  45E4    0E05     MOVLW 0x5
  45E6    50DB     MOVF 0xfdb, W, ACCESS
  45E8    6EE6     MOVWF 0xfe6, ACCESS
  45EA    50D9     MOVF 0xfd9, W, ACCESS
  45EC    0F13     ADDLW 0x13
  45EE    D901     RCALL 0x47f2
  45F0    52E5     MOVF 0xfe5, F, ACCESS
  45F2    50E7     MOVF 0xfe7, W, ACCESS
  45F4    6EEE     MOVWF 0xfee, ACCESS
  45F6    6AED     CLRF 0xfed, ACCESS
  45F8    0012     RETURN 0
273:                             if (width < (unsigned char) n)
  3F10    ECD6     CALL 0x47ac, 0
  3F12    F023     NOP
  3F14    E202     BC 0x3f1a
  47AC    0E13     MOVLW 0x13
  47AE    50DB     MOVF 0xfdb, W, ACCESS
  47B0    6EF3     MOVWF 0xff3, ACCESS
  47B2    0E04     MOVLW 0x4
  47B4    EFBF     GOTO 0x457e
  47B6    F022     NOP
274:                               width = n;
  3F16    0E13     MOVLW 0x13
  3F18    DB37     RCALL 0x4588
275:                             space_cnt = width - (unsigned char) n;
  3F1A    EC99     CALL 0x4732, 0
  3F1C    F023     NOP
  4732    0E04     MOVLW 0x4
  4734    CFDB     MOVFF 0xfdb, 0xfe6
  4736    FFE6     NOP
  4738    0E13     MOVLW 0x13
  473A    50DB     MOVF 0xfdb, W, ACCESS
  473C    52E5     MOVF 0xfe5, F, ACCESS
  473E    5CE7     SUBWF 0xfe7, W, ACCESS
  4740    DF9A     RCALL 0x4676
276:                             count += space_cnt;
  4742    50DB     MOVF 0xfdb, W, ACCESS
  4744    DF04     RCALL 0x454e
277:                             /* we've already calculated the space count that the width
278:                                will require. now we want the width field to have the
279:                                number of character to display from the string itself,
280:                                limited by the length of the actual string and the
281:                                specified precision. */
282:                             if (have_precision && precision < width)
  3F1E    E006     BZ 0x3f2c
  3F20    0E04     MOVLW 0x4
  3F22    ECB2     CALL 0x4764, 0
  3F24    F023     NOP
  3F26    E202     BC 0x3f2c
  4746    0E06     MOVLW 0x6
  4748    50DB     MOVF 0xfdb, W, ACCESS
  474A    0012     RETURN 0
283:                               width = precision;
  3F28    0E05     MOVLW 0x5
  3F2A    DB2E     RCALL 0x4588
284:                             /* if right justified, we print the spaces before the
285:                                string */
286:                             if (!(flags & _FLAG_MINUS))
  3F2C    0E03     MOVLW 0x3
  3F2E    B0DB     BTFSC 0xfdb, 0, ACCESS
  3F30    D005     BRA 0x3f3c
287:                               {
288:                                 if (s_put_n_chars (handle, space_cnt, ' '))
  3F32    DAFC     RCALL 0x452c
  3F34    E001     BZ 0x3f38
  3F36    D2D7     BRA 0x44e6
289:                                   return EOF;
290:                                 space_cnt = 0;
  3F38    0E08     MOVLW 0x8
  3F3A    6ADB     CLRF 0xfdb, ACCESS
291:                               }
292:                             cval = 0;
  3F3C    0E09     MOVLW 0x9
  3F3E    6ADB     CLRF 0xfdb, ACCESS
293:                             for (c = *romstring; c && cval < width; c = *++romstring)
  3F40    0E0E     MOVLW 0xe
  3F42    CFDB     MOVFF 0xfdb, 0xff6
  3F44    FFF6     NOP
  3F46    0E0F     MOVLW 0xf
  3F48    CFDB     MOVFF 0xfdb, 0xff7
  3F4A    FFF7     NOP
  3F4C    0E10     MOVLW 0x10
  3F4E    CFDB     MOVFF 0xfdb, 0xff8
  3F50    FFF8     NOP
  3F52    0008     TBLRD*
  3F54    50F5     MOVF 0xff5, W, ACCESS
  3F56    6EDF     MOVWF 0xfdf, ACCESS
  3F58    50DF     MOVF 0xfdf, W, ACCESS
  3F5A    E014     BZ 0x3f84
  3F5C    ECDC     CALL 0x47b8, 0
  3F5E    F023     NOP
  3F60    E211     BC 0x3f84
  3F78    50D9     MOVF 0xfd9, W, ACCESS
  3F7A    0F0E     ADDLW 0xe
  3F7C    6EE9     MOVWF 0xfe9, ACCESS
  3F7E    0E00     MOVLW 0
  3F80    DBCB     RCALL 0x4718
  3F82    D7E7     BRA 0x3f52
  47B8    0E04     MOVLW 0x4
  47BA    50DB     MOVF 0xfdb, W, ACCESS
  47BC    6EF3     MOVWF 0xff3, ACCESS
  47BE    0E09     MOVLW 0x9
  47C0    EFBF     GOTO 0x457e
  47C2    F022     NOP
294:                               {
295:                                 if (putc (c, handle) == EOF)
  3F62    ECEB     CALL 0x47d6, 0
  3F64    F023     NOP
  3F66    E103     BNZ 0x3f6e
  3F68    1C15     COMF 0x15, W, ACCESS
  3F6A    E101     BNZ 0x3f6e
  3F6C    D2BC     BRA 0x44e6
296:                                   return EOF;
297:                                 ++count;
  3F6E    DBBB     RCALL 0x46e6
  3F70    E301     BNC 0x3f74
  3F72    2ADB     INCF 0xfdb, F, ACCESS
298:                                 ++cval;
  3F74    0E09     MOVLW 0x9
  3F76    2ADB     INCF 0xfdb, F, ACCESS
299:                               }
300:                             /* If there are spaces left, it's left justified. 
301:                                Either way, calling the function unconditionally 
302:                                is smaller code. */
303:                             if (s_put_n_chars (handle, space_cnt, ' '))
  3F84    DAD3     RCALL 0x452c
  3F86    E101     BNZ 0x3f8a
  3F88    D2B4     BRA 0x44f2
304:                               return EOF;
  3F8A    D2AD     BRA 0x44e6
305:                             break;
306:                           case 's':
307:                             ramstring = va_arg (ap, char *);
  3F8C    DAC6     RCALL 0x451a
  3F8E    0E11     MOVLW 0x11
  3F90    CFEE     MOVFF 0xfee, 0xfdb
  3F92    FFDB     NOP
  3F94    0E12     MOVLW 0x12
  3F96    CFED     MOVFF 0xfed, 0xfdb
  3F98    FFDB     NOP
308:                             n = strlen (ramstring);
  3F9A    0E11     MOVLW 0x11
  3F9C    CFDB     MOVFF 0xfdb, 0xfe6
  3F9E    FFE6     NOP
  3FA0    0E12     MOVLW 0x12
  3FA2    CFDB     MOVFF 0xfdb, 0xfe6
  3FA4    FFE6     NOP
  3FA6    ECA2     CALL 0x6344, 0
  3FA8    F031     NOP
  3FAA    52E5     MOVF 0xfe5, F, ACCESS
  3FAC    52E5     MOVF 0xfe5, F, ACCESS
  3FAE    0E13     MOVLW 0x13
  3FB0    CFF3     MOVFF 0xff3, 0xfdb
  3FB2    FFDB     NOP
  3FB4    0E14     MOVLW 0x14
  3FB6    CFF4     MOVFF 0xff4, 0xfdb
  3FB8    FFDB     NOP
309:                             /* Normalize the width based on the length of the actual 
310:                                string and the precision. */
311:                             if (have_precision && precision < (unsigned char) n)
  3FBA    0E06     MOVLW 0x6
  3FBC    50DB     MOVF 0xfdb, W, ACCESS
  3FBE    E004     BZ 0x3fc8
  3FC0    0E13     MOVLW 0x13
  3FC2    DBD0     RCALL 0x4764
  3FC4    E201     BC 0x3fc8
312:                               n = precision;
  3FC6    DB0E     RCALL 0x45e4
313:                             if (width < (unsigned char) n)
  3FC8    ECD6     CALL 0x47ac, 0
  3FCA    F023     NOP
  3FCC    E202     BC 0x3fd2
314:                               width = n;
  3FCE    0E13     MOVLW 0x13
  3FD0    DADB     RCALL 0x4588
315:                             space_cnt = width - (unsigned char) n;
  3FD2    DBAF     RCALL 0x4732
  4676    6EE7     MOVWF 0xfe7, ACCESS
  4678    0E08     MOVLW 0x8
  467A    CFE7     MOVFF 0xfe7, 0xfdb
  467C    FFDB     NOP
  467E    0012     RETURN 0
316:                             count += space_cnt;
317:                             /* we've already calculated the space count that the width
318:                                will require. now we want the width field to have the
319:                                number of character to display from the string itself,
320:                                limited by the length of the actual string and the
321:                                specified precision. */
322:                             if (have_precision && precision < width)
  3FD4    E005     BZ 0x3fe0
  3FD6    0E04     MOVLW 0x4
  3FD8    DBC5     RCALL 0x4764
  3FDA    E202     BC 0x3fe0
  4764    50DB     MOVF 0xfdb, W, ACCESS
  4766    6EF3     MOVWF 0xff3, ACCESS
  4768    0E05     MOVLW 0x5
  476A    EFBF     GOTO 0x457e
  476C    F022     NOP
323:                               width = precision;
  3FDC    0E05     MOVLW 0x5
  3FDE    DAD4     RCALL 0x4588
  4588    50DB     MOVF 0xfdb, W, ACCESS
  458A    6EE7     MOVWF 0xfe7, ACCESS
  458C    0E04     MOVLW 0x4
  458E    CFE7     MOVFF 0xfe7, 0xfdb
  4590    FFDB     NOP
  4592    0012     RETURN 0
324:                             /* if right justified, we print the spaces before the
325:                                string */
326:                             if (!(flags & _FLAG_MINUS))
  3FE0    0E03     MOVLW 0x3
  3FE2    B0DB     BTFSC 0xfdb, 0, ACCESS
  3FE4    D005     BRA 0x3ff0
327:                               {
328:                                 if (s_put_n_chars (handle, space_cnt, ' '))
  3FE6    DAA2     RCALL 0x452c
  3FE8    E001     BZ 0x3fec
  3FEA    D27D     BRA 0x44e6
329:                                   return EOF;
330:                                 space_cnt = 0;
  3FEC    0E08     MOVLW 0x8
  3FEE    6ADB     CLRF 0xfdb, ACCESS
331:                               }
332:                             cval = 0;
  3FF0    0E09     MOVLW 0x9
  3FF2    6ADB     CLRF 0xfdb, ACCESS
333:                             for (c = *ramstring; c && cval < width; c = *++ramstring)
  3FF4    0E11     MOVLW 0x11
  3FF6    CFDB     MOVFF 0xfdb, 0xfe9
  3FF8    FFE9     NOP
  3FFA    0E12     MOVLW 0x12
  3FFC    CFDB     MOVFF 0xfdb, 0xfea
  3FFE    FFEA     NOP
  4000    CFEF     MOVFF 0xfef, 0xfdf
  4002    FFDF     NOP
  4004    50DF     MOVF 0xfdf, W, ACCESS
  4006    E014     BZ 0x4030
  4008    DBD7     RCALL 0x47b8
  400A    E212     BC 0x4030
  4020    0E11     MOVLW 0x11
  4022    2ADB     INCF 0xfdb, F, ACCESS
  4024    CFDB     MOVFF 0xfdb, 0xfe9
  4026    FFE9     NOP
  4028    0E12     MOVLW 0x12
  402A    E3E8     BNC 0x3ffc
  402C    2ADB     INCF 0xfdb, F, ACCESS
  402E    D7E6     BRA 0x3ffc
334:                               {
335:                                 if (putc (c, handle) == EOF)
  400C    DBE4     RCALL 0x47d6
  400E    E103     BNZ 0x4016
  4010    1C15     COMF 0x15, W, ACCESS
  4012    E101     BNZ 0x4016
  4014    D268     BRA 0x44e6
336:                                   return EOF;
337:                                 ++count;
  4016    DB67     RCALL 0x46e6
  4018    E301     BNC 0x401c
  401A    2ADB     INCF 0xfdb, F, ACCESS
338:                                 ++cval;
  401C    0E09     MOVLW 0x9
  401E    2ADB     INCF 0xfdb, F, ACCESS
339:                               }
340:                             /* If there are spaces left, it's left justified. 
341:                                Either way, calling the function unconditionally 
342:                                is smaller code. */
343:                             if (s_put_n_chars (handle, space_cnt, ' '))
  4030    DA7D     RCALL 0x452c
  4032    E101     BNZ 0x4036
  4034    D25E     BRA 0x44f2
344:                               return EOF;
  4036    D257     BRA 0x44e6
345:                             break;
346:                           case 'd':
347:                           case 'i':
348:                             flags |= _FLAG_SIGNED;
  4038    0E03     MOVLW 0x3
  403A    8EDB     BSF 0xfdb, 0x7, ACCESS
349:                             /* fall through */
350:                           case 'o':
351:                           case 'u':
352:                           case 'x':
353:                           case 'X':
354:                           case 'b':
355:                           case 'B':
356:                             /* This is a bit of a sneaky trick. The 'l' and 'hh' size
357:                                specifiers are valid only for the integer conversions,
358:                                not the 'p' or 'P' conversions, and are ignored for the
359:                                latter. By jumping over the additional size specifier
360:                                checks here we get the best code size since we can
361:                                limit the size checks in the remaining code. */
362:                             if (size == _FMT_LONG)
  403C    0E07     MOVLW 0x7
  403E    04DB     DECF 0xfdb, W, ACCESS
  4040    E110     BNZ 0x4062
363:                               {
364:                                 larg = va_arg (ap, long int);
  4042    DB95     RCALL 0x476e
  4044    0E04     MOVLW 0x4
  4046    DB5A     RCALL 0x46fc
  4048    0E0A     MOVLW 0xa
  404A    CFEE     MOVFF 0xfee, 0xfdb
  404C    FFDB     NOP
  404E    0E0B     MOVLW 0xb
  4050    CFEE     MOVFF 0xfee, 0xfdb
  4052    FFDB     NOP
  4054    0E0C     MOVLW 0xc
  4056    CFEE     MOVFF 0xfee, 0xfdb
  4058    FFDB     NOP
  405A    0E0D     MOVLW 0xd
  405C    CFEE     MOVFF 0xfee, 0xfdb
  405E    FFDB     NOP
365:                                 goto _do_integer_conversion;
  4060    D06C     BRA 0x413a
366:                               }
367:                             else if (size == _FMT_BYTE)
  4062    0E07     MOVLW 0x7
  4064    50DB     MOVF 0xfdb, W, ACCESS
  4066    0803     SUBLW 0x3
  4068    E12C     BNZ 0x40c2
368:                               {
369:                                 if (flags & _FLAG_SIGNED)
  406A    0E03     MOVLW 0x3
  406C    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  406E    D00D     BRA 0x408a
370:                                   larg = (signed char) va_arg (ap, int);
  4070    DAB2     RCALL 0x45d6
  4072    0E02     MOVLW 0x2
  4074    DA76     RCALL 0x4562
  4076    CFEF     MOVFF 0xfef, 0x14
  4078    F014     NOP
  407A    6A15     CLRF 0x15, ACCESS
  407C    6A16     CLRF 0x16, ACCESS
  407E    6A17     CLRF 0x17, ACCESS
  4080    AE14     BTFSS 0x14, 0x7, ACCESS
  4082    D039     BRA 0x40f6
  4084    6815     SETF 0x15, ACCESS
  4086    6816     SETF 0x16, ACCESS
371:                                 else
  4088    D035     BRA 0x40f4
372:                                   larg = (unsigned char) va_arg (ap, unsigned int);
  408A    0EF7     MOVLW 0xf7
  408C    CFDB     MOVFF 0xfdb, 0x15
  408E    F015     NOP
  4090    0EF8     MOVLW 0xf8
  4092    CFDB     MOVFF 0xfdb, 0x16
  4094    F016     NOP
  4096    0E02     MOVLW 0x2
  4098    5E15     SUBWF 0x15, F, ACCESS
  409A    0E00     MOVLW 0
  409C    5A16     SUBWFB 0x16, F, ACCESS
  409E    0EF7     MOVLW 0xf7
  40A0    C015     MOVFF 0x15, 0xfdb
  40A2    FFDB     NOP
  40A4    0EF8     MOVLW 0xf8
  40A6    C016     MOVFF 0x16, 0xfdb
  40A8    FFDB     NOP
  40AA    C015     MOVFF 0x15, 0xfe9
  40AC    FFE9     NOP
  40AE    C016     MOVFF 0x16, 0xfea
  40B0    FFEA     NOP
  40B2    CFEF     MOVFF 0xfef, 0x14
  40B4    F014     NOP
  40B6    0E0A     MOVLW 0xa
  40B8    C014     MOVFF 0x14, 0xfdb
  40BA    FFDB     NOP
  40BC    0E0B     MOVLW 0xb
  40BE    6ADB     CLRF 0xfdb, ACCESS
373:                                 goto _do_integer_conversion;
  40C0    D038     BRA 0x4132
374:                               }
375:                             /* fall through */
376:                           case 'p':
377:                           case 'P':
378:                             if (size == _FMT_SHLONG)
  40C2    0E07     MOVLW 0x7
  40C4    50DB     MOVF 0xfdb, W, ACCESS
  40C6    0802     SUBLW 0x2
  40C8    E109     BNZ 0x40dc
379:                               {
380:                                 if (flags & _FLAG_SIGNED)
  40CA    0E03     MOVLW 0x3
  40CC    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  40CE    D004     BRA 0x40d8
381:                                   larg = va_arg (ap, short long int);
  40D0    DB59     RCALL 0x4784
  40D2    AE16     BTFSS 0x16, 0x7, ACCESS
  40D4    D010     BRA 0x40f6
  4680    CFEE     MOVFF 0xfee, 0x14
  4682    F014     NOP
  4684    CFEE     MOVFF 0xfee, 0x15
  4686    F015     NOP
  4688    CFEF     MOVFF 0xfef, 0x16
  468A    F016     NOP
  468C    6A17     CLRF 0x17, ACCESS
  468E    0012     RETURN 0
  4784    DF28     RCALL 0x45d6
  4786    0E03     MOVLW 0x3
  4788    DEEC     RCALL 0x4562
  478A    EF40     GOTO 0x4680
  478C    F023     NOP
382:                                 else
  40D6    D00E     BRA 0x40f4
383:                                   larg = va_arg (ap, unsigned short long int);
  40D8    DB55     RCALL 0x4784
384:                               }
385:                             else if (flags & _FLAG_SIGNED)
  40DA    D00D     BRA 0x40f6
  40DC    0E03     MOVLW 0x3
  40DE    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  40E0    D012     BRA 0x4106
386:                               larg = va_arg (ap, int);
  40E2    DA79     RCALL 0x45d6
  40E4    0E02     MOVLW 0x2
  40E6    DA3D     RCALL 0x4562
  40E8    DAF9     RCALL 0x46dc
  40EA    6A16     CLRF 0x16, ACCESS
  40EC    6A17     CLRF 0x17, ACCESS
  40EE    AE15     BTFSS 0x15, 0x7, ACCESS
  40F0    D002     BRA 0x40f6
  40F2    6816     SETF 0x16, ACCESS
  40F4    6817     SETF 0x17, ACCESS
  40F6    DAE2     RCALL 0x46bc
  40F8    0E0C     MOVLW 0xc
  40FA    C016     MOVFF 0x16, 0xfdb
  40FC    FFDB     NOP
  40FE    0E0D     MOVLW 0xd
  4100    C017     MOVFF 0x17, 0xfdb
  4102    FFDB     NOP
  4562    5E18     SUBWF 0x18, F, ACCESS
  4564    0E00     MOVLW 0
  4566    5A19     SUBWFB 0x19, F, ACCESS
  4568    0EF7     MOVLW 0xf7
  456A    C018     MOVFF 0x18, 0xfdb
  456C    FFDB     NOP
  456E    0EF8     MOVLW 0xf8
  4570    C019     MOVFF 0x19, 0xfdb
  4572    FFDB     NOP
  4574    C018     MOVFF 0x18, 0xfe9
  4576    FFE9     NOP
  4578    C019     MOVFF 0x19, 0xfea
  457A    FFEA     NOP
  457C    0012     RETURN 0
  45D6    0EF7     MOVLW 0xf7
  45D8    CFDB     MOVFF 0xfdb, 0x18
  45DA    F018     NOP
  45DC    0EF8     MOVLW 0xf8
  45DE    CFDB     MOVFF 0xfdb, 0x19
  45E0    F019     NOP
  45E2    0012     RETURN 0
  46BC    0E0A     MOVLW 0xa
  46BE    C014     MOVFF 0x14, 0xfdb
  46C0    FFDB     NOP
  46C2    0E0B     MOVLW 0xb
  46C4    C015     MOVFF 0x15, 0xfdb
  46C6    FFDB     NOP
  46C8    0012     RETURN 0
  46DC    CFEE     MOVFF 0xfee, 0x14
  46DE    F014     NOP
  46E0    CFEF     MOVFF 0xfef, 0x15
  46E2    F015     NOP
  46E4    0012     RETURN 0
387:                             else
  4104    D01A     BRA 0x413a
388:                               larg = va_arg (ap, unsigned int);
  4106    0EF7     MOVLW 0xf7
  4108    CFDB     MOVFF 0xfdb, 0x16
  410A    F016     NOP
  410C    0EF8     MOVLW 0xf8
  410E    CFDB     MOVFF 0xfdb, 0x17
  4110    F017     NOP
  4112    0E02     MOVLW 0x2
  4114    5E16     SUBWF 0x16, F, ACCESS
  4116    0E00     MOVLW 0
  4118    5A17     SUBWFB 0x17, F, ACCESS
  411A    0EF7     MOVLW 0xf7
  411C    C016     MOVFF 0x16, 0xfdb
  411E    FFDB     NOP
  4120    0EF8     MOVLW 0xf8
  4122    C017     MOVFF 0x17, 0xfdb
  4124    FFDB     NOP
  4126    C016     MOVFF 0x16, 0xfe9
  4128    FFE9     NOP
  412A    C017     MOVFF 0x17, 0xfea
  412C    FFEA     NOP
  412E    DAD6     RCALL 0x46dc
  4130    DAC5     RCALL 0x46bc
  4132    0E0C     MOVLW 0xc
  4134    6ADB     CLRF 0xfdb, ACCESS
  4136    0E0D     MOVLW 0xd
  4138    6ADB     CLRF 0xfdb, ACCESS
389:                           _do_integer_conversion:
390:                             /* default precision is 1 */
391:                             if (!have_precision)
  413A    0E06     MOVLW 0x6
  413C    50DB     MOVF 0xfdb, W, ACCESS
  413E    E105     BNZ 0x414a
392:                               precision = 1;
  4140    0E01     MOVLW 0x1
  4142    6EF3     MOVWF 0xff3, ACCESS
  4144    0E05     MOVLW 0x5
  4146    CFF3     MOVFF 0xff3, 0xfdb
  4148    FFDB     NOP
393:               
394:                             {
395:                               unsigned char digit_cnt = 0;
  414A    0E15     MOVLW 0x15
  414C    6ADB     CLRF 0xfdb, ACCESS
396:                               unsigned char prefix_cnt = 0;
  414E    0E16     MOVLW 0x16
  4150    6ADB     CLRF 0xfdb, ACCESS
397:                               unsigned char sign_char;
398:                               /* A 32 bit number will require at most 32 digits in the
399:                                  string representation (binary format). */
400:                               char buf[33];
401:                               /* Start storing digits least-significant first */
402:                               char *q = &buf[31];
  4152    50D9     MOVF 0xfd9, W, ACCESS
  4154    0F37     ADDLW 0x37
  4156    6E14     MOVWF 0x14, ACCESS
  4158    0E00     MOVLW 0
  415A    20DA     ADDWFC 0xfda, W, ACCESS
  415C    6E15     MOVWF 0x15, ACCESS
  415E    0E39     MOVLW 0x39
  4160    C014     MOVFF 0x14, 0xfdb
  4162    FFDB     NOP
  4164    0E3A     MOVLW 0x3a
  4166    C015     MOVFF 0x15, 0xfdb
  4168    FFDB     NOP
403:                               /* null terminate the string */
404:                               buf[32] = '\0';
  416A    0E38     MOVLW 0x38
  416C    6ADB     CLRF 0xfdb, ACCESS
405:               
406:                               space_cnt = 0;
  416E    0E08     MOVLW 0x8
  4170    6ADB     CLRF 0xfdb, ACCESS
407:                               size = 10;
  4172    0E0A     MOVLW 0xa
  4174    DAAE     RCALL 0x46d2
408:               
409:                               switch (c)
  4176    50DF     MOVF 0xfdf, W, ACCESS
  4178    0A78     XORLW 0x78
  417A    E012     BZ 0x41a0
  417C    0A20     XORLW 0x20
  417E    E010     BZ 0x41a0
  4180    0A28     XORLW 0x28
  4182    E00C     BZ 0x419c
  4184    0A20     XORLW 0x20
  4186    E00A     BZ 0x419c
  4188    0A3F     XORLW 0x3f
  418A    E006     BZ 0x4198
  418C    0A0D     XORLW 0xd
  418E    E002     BZ 0x4194
  4190    0A20     XORLW 0x20
  4192    E108     BNZ 0x41a4
410:                                 {
411:                                 case 'b':
412:                                 case 'B':
413:                                   size = 2;
  4194    0E02     MOVLW 0x2
414:                                   break;
  4196    D005     BRA 0x41a2
415:                                 case 'o':
416:                                   size = 8;
  4198    0E08     MOVLW 0x8
417:                                   break;
  419A    D003     BRA 0x41a2
418:                                 case 'p':
419:                                 case 'P':
420:                                   /* from here on out, treat 'p' conversions just
421:                                      like 'x' conversions. */
422:                                   c += 'x' - 'p';
  419C    0E08     MOVLW 0x8
  419E    26DF     ADDWF 0xfdf, F, ACCESS
423:                                   /* fall through */
424:                                 case 'x':
425:                                 case 'X':
426:                                   size = 16;
  41A0    0E10     MOVLW 0x10
  41A2    DA97     RCALL 0x46d2
  46D2    6EF3     MOVWF 0xff3, ACCESS
  46D4    0E07     MOVLW 0x7
  46D6    CFF3     MOVFF 0xff3, 0xfdb
  46D8    FFDB     NOP
  46DA    0012     RETURN 0
427:                                   break;
428:                                 }
429:               
430:                               /* if it's an unsigned conversion, we should ignore the
431:                                  ' ' and '+' flags */
432:                               if (!(flags & _FLAG_SIGNED))
  41A4    0E03     MOVLW 0x3
  41A6    BEDB     BTFSC 0xfdb, 0x7, ACCESS
  41A8    D002     BRA 0x41ae
433:                                 flags &= ~(_FLAG_PLUS | _FLAG_SPACE);
  41AA    92DB     BCF 0xfdb, 0x1, ACCESS
  41AC    94DB     BCF 0xfdb, 0x2, ACCESS
434:               
435:                               /* if it's a negative value, we need to negate the
436:                                  unsigned version before we convert to text. Using
437:                                  unsigned for this allows us to (ab)use the 2's
438:                                  complement system to avoid overflow and be able to
439:                                  adequately handle LONG_MIN.
440:               
441:                                  We'll figure out what sign character to print, if
442:                                  any, here as well. */
443:                               if (flags & _FLAG_SIGNED && ((long) larg < 0))
  41AE    50DB     MOVF 0xfdb, W, ACCESS
  41B0    0B80     ANDLW 0x80
  41B2    E024     BZ 0x41fc
  41B4    DA8A     RCALL 0x46ca
  41B6    90D8     BCF 0xfd8, 0, ACCESS
  41B8    0E03     MOVLW 0x3
  41BA    50EB     MOVF 0xfeb, W, ACCESS
  41BC    0A00     XORLW 0
  41BE    E608     BN 0x41d0
  41C0    0E00     MOVLW 0
  41C2    5CEE     SUBWF 0xfee, W, ACCESS
  41C4    0E00     MOVLW 0
  41C6    58EE     SUBWFB 0xfee, W, ACCESS
  41C8    0E00     MOVLW 0
  41CA    58EE     SUBWFB 0xfee, W, ACCESS
  41CC    0E00     MOVLW 0
  41CE    58EE     SUBWFB 0xfee, W, ACCESS
  41D0    E215     BC 0x41fc
  46CA    50D9     MOVF 0xfd9, W, ACCESS
  46CC    0F0A     ADDLW 0xa
  46CE    EFF9     GOTO 0x47f2
  46D0    F023     NOP
  47F2    6EE9     MOVWF 0xfe9, ACCESS
  47F4    0E00     MOVLW 0
  47F6    20DA     ADDWFC 0xfda, W, ACCESS
  47F8    6EEA     MOVWF 0xfea, ACCESS
  47FA    0012     RETURN 0
444:                                 {
445:                                   larg = -(long) larg;
  41D2    DA13     RCALL 0x45fa
  41D4    680B     SETF 0xb, ACCESS
  41D6    680C     SETF 0xc, ACCESS
  41D8    680D     SETF 0xd, ACCESS
  41DA    680E     SETF 0xe, ACCESS
  41DC    ECBC     CALL 0x6578, 0
  41DE    F032     NOP
  41E0    0E0A     MOVLW 0xa
  41E2    C002     MOVFF 0x2, 0xfdb
  41E4    FFDB     NOP
  41E6    0E0B     MOVLW 0xb
  41E8    C003     MOVFF 0x3, 0xfdb
  41EA    FFDB     NOP
  41EC    0E0C     MOVLW 0xc
  41EE    C004     MOVFF 0x4, 0xfdb
  41F0    FFDB     NOP
  41F2    0E0D     MOVLW 0xd
  41F4    C005     MOVFF 0x5, 0xfdb
  41F6    FFDB     NOP
  45FA    0E0A     MOVLW 0xa
  45FC    CFDB     MOVFF 0xfdb, 0x6
  45FE    F006     NOP
  4600    0E0B     MOVLW 0xb
  4602    CFDB     MOVFF 0xfdb, 0x7
  4604    F007     NOP
  4606    0E0C     MOVLW 0xc
  4608    CFDB     MOVFF 0xfdb, 0x8
  460A    F008     NOP
  460C    0E0D     MOVLW 0xd
  460E    CFDB     MOVFF 0xfdb, 0x9
  4610    F009     NOP
  4612    0012     RETURN 0
446:                                   sign_char = '-';
  41F8    0E2D     MOVLW 0x2d
447:                                   ++digit_cnt;
448:                                 }
449:                               else if (flags & _FLAG_PLUS)
  41FA    D008     BRA 0x420c
  41FC    0E03     MOVLW 0x3
  41FE    A2DB     BTFSS 0xfdb, 0x1, ACCESS
  4200    D002     BRA 0x4206
450:                                 {
451:                                   sign_char = '+';
  4202    0E2B     MOVLW 0x2b
452:                                   ++digit_cnt;
453:                                 }
454:                               else if (flags & _FLAG_SPACE)
  4204    D003     BRA 0x420c
  4206    A4DB     BTFSS 0xfdb, 0x2, ACCESS
  4208    D008     BRA 0x421a
455:                                 {
456:                                   sign_char = ' ';
  420A    0E20     MOVLW 0x20
  420C    6EF3     MOVWF 0xff3, ACCESS
  420E    0E17     MOVLW 0x17
  4210    CFF3     MOVFF 0xff3, 0xfdb
  4212    FFDB     NOP
457:                                   ++digit_cnt;
  4214    0E15     MOVLW 0x15
  4216    2ADB     INCF 0xfdb, F, ACCESS
458:                                 }
459:                               else
  4218    D002     BRA 0x421e
460:                                 sign_char = '\0';
  421A    0E17     MOVLW 0x17
  421C    6ADB     CLRF 0xfdb, ACCESS
461:                               /* get the digits for the actual number. If the
462:                                  precision is zero and the value is zero, the result
463:                                  is no characters. */
464:                               if (precision || larg)
  421E    0E05     MOVLW 0x5
  4220    50DB     MOVF 0xfdb, W, ACCESS
  4222    E103     BNZ 0x422a
  4224    D9B7     RCALL 0x4594
  4226    E101     BNZ 0x422a
  4228    D089     BRA 0x433c
  4594    0E0A     MOVLW 0xa
  4596    CFDB     MOVFF 0xfdb, 0x14
  4598    F014     NOP
  459A    0E0B     MOVLW 0xb
  459C    CFDB     MOVFF 0xfdb, 0x15
  459E    F015     NOP
  45A0    0E0C     MOVLW 0xc
  45A2    CFDB     MOVFF 0xfdb, 0x16
  45A4    F016     NOP
  45A6    0E0D     MOVLW 0xd
  45A8    CFDB     MOVFF 0xfdb, 0x17
  45AA    F017     NOP
  45AC    5014     MOVF 0x14, W, ACCESS
  45AE    1015     IORWF 0x15, W, ACCESS
  45B0    1016     IORWF 0x16, W, ACCESS
  45B2    1017     IORWF 0x17, W, ACCESS
  45B4    0012     RETURN 0
465:                                 {
466:                                   do
467:                                     {
468:                                       cval = s_digits[larg % size];
  422A    0E6A     MOVLW 0x6a
  422C    6E14     MOVWF 0x14, ACCESS
  422E    0E67     MOVLW 0x67
  4230    6E15     MOVWF 0x15, ACCESS
  4232    0E00     MOVLW 0
  4234    6E16     MOVWF 0x16, ACCESS
  4236    0E07     MOVLW 0x7
  4238    CFDB     MOVFF 0xfdb, 0x17
  423A    F017     NOP
  423C    6A18     CLRF 0x18, ACCESS
  423E    6A19     CLRF 0x19, ACCESS
  4240    6A1A     CLRF 0x1a, ACCESS
  4242    C017     MOVFF 0x17, 0xb
  4244    F00B     NOP
  4246    C018     MOVFF 0x18, 0xc
  4248    F00C     NOP
  424A    C019     MOVFF 0x19, 0xd
  424C    F00D     NOP
  424E    C01A     MOVFF 0x1a, 0xe
  4250    F00E     NOP
  4252    D9D3     RCALL 0x45fa
  4254    EC18     CALL 0x6630, 0
  4256    F033     NOP
  4258    5014     MOVF 0x14, W, ACCESS
  425A    2402     ADDWF 0x2, W, ACCESS
  425C    6EF3     MOVWF 0xff3, ACCESS
  425E    5015     MOVF 0x15, W, ACCESS
  4260    2003     ADDWFC 0x3, W, ACCESS
  4262    6EF4     MOVWF 0xff4, ACCESS
  4264    5016     MOVF 0x16, W, ACCESS
  4266    2004     ADDWFC 0x4, W, ACCESS
  4268    6EF8     MOVWF 0xff8, ACCESS
  426A    CFF4     MOVFF 0xff4, 0xff7
  426C    FFF7     NOP
  426E    CFF3     MOVFF 0xff3, 0xff6
  4270    FFF6     NOP
  4272    0008     TBLRD*
  4274    0E09     MOVLW 0x9
  4276    CFF5     MOVFF 0xff5, 0xfdb
  4278    FFDB     NOP
469:                                       if (c == 'X' && cval >= 'a')
  427A    0E58     MOVLW 0x58
  427C    5CDF     SUBWF 0xfdf, W, ACCESS
  427E    E10F     BNZ 0x429e
  4280    0E61     MOVLW 0x61
  4282    6EF3     MOVWF 0xff3, ACCESS
  4284    0E09     MOVLW 0x9
  4286    D97B     RCALL 0x457e
  4288    E30A     BNC 0x429e
  457E    CFDB     MOVFF 0xfdb, 0xff4
  4580    FFF4     NOP
  4582    50F3     MOVF 0xff3, W, ACCESS
  4584    5CF4     SUBWF 0xff4, W, ACCESS
  4586    0012     RETURN 0
470:                                         cval -= 'a' - 'A';
  428A    0E20     MOVLW 0x20
  428C    6E14     MOVWF 0x14, ACCESS
  428E    0E09     MOVLW 0x9
  4290    CFDB     MOVFF 0xfdb, 0xfe7
  4292    FFE7     NOP
  4294    5014     MOVF 0x14, W, ACCESS
  4296    5EE7     SUBWF 0xfe7, F, ACCESS
  4298    0E09     MOVLW 0x9
  429A    CFE7     MOVFF 0xfe7, 0xfdb
  429C    FFDB     NOP
471:                                       larg /= size;
  429E    0E07     MOVLW 0x7
  42A0    CFDB     MOVFF 0xfdb, 0x14
  42A2    F014     NOP
  42A4    6A15     CLRF 0x15, ACCESS
  42A6    6A16     CLRF 0x16, ACCESS
  42A8    6A17     CLRF 0x17, ACCESS
  42AA    DA0F     RCALL 0x46ca
  42AC    C014     MOVFF 0x14, 0xb
  42AE    F00B     NOP
  42B0    C015     MOVFF 0x15, 0xc
  42B2    F00C     NOP
  42B4    C016     MOVFF 0x16, 0xd
  42B6    F00D     NOP
  42B8    C017     MOVFF 0x17, 0xe
  42BA    F00E     NOP
  42BC    CFEE     MOVFF 0xfee, 0x6
  42BE    F006     NOP
  42C0    CFEE     MOVFF 0xfee, 0x7
  42C2    F007     NOP
  42C4    CFEE     MOVFF 0xfee, 0x8
  42C6    F008     NOP
  42C8    CFEF     MOVFF 0xfef, 0x9
  42CA    F009     NOP
  42CC    EC18     CALL 0x6630, 0
  42CE    F033     NOP
  42D0    C009     MOVFF 0x9, 0xfed
  42D2    FFED     NOP
  42D4    C008     MOVFF 0x8, 0xfed
  42D6    FFED     NOP
  42D8    C007     MOVFF 0x7, 0xfed
  42DA    FFED     NOP
  42DC    C006     MOVFF 0x6, 0xfef
  42DE    FFEF     NOP
472:                                       *q-- = cval;
  42E0    0E39     MOVLW 0x39
  42E2    CFDB     MOVFF 0xfdb, 0xfe9
  42E4    FFE9     NOP
  42E6    06DB     DECF 0xfdb, F, ACCESS
  42E8    0E3A     MOVLW 0x3a
  42EA    CFDB     MOVFF 0xfdb, 0xfea
  42EC    FFEA     NOP
  42EE    E201     BC 0x42f2
  42F0    06DB     DECF 0xfdb, F, ACCESS
  42F2    0E09     MOVLW 0x9
  42F4    CFDB     MOVFF 0xfdb, 0xfef
  42F6    FFEF     NOP
473:                                       ++digit_cnt;
  42F8    0E15     MOVLW 0x15
  42FA    2ADB     INCF 0xfdb, F, ACCESS
474:                                     }
475:                                   while (larg);
  42FC    D94B     RCALL 0x4594
  42FE    E195     BNZ 0x422a
476:                                   /* if the '#' flag was specified and we're dealing
477:                                      with an 'o', 'b', 'B', 'x', or 'X' conversion,
478:                                      we need a bit more. */
479:                                   if (flags & _FLAG_OCTO)
  4300    0E03     MOVLW 0x3
  4302    A6DB     BTFSS 0xfdb, 0x3, ACCESS
  4304    D01D     BRA 0x4340
480:                                     {
481:                                       if (c == 'o')
  4306    0E6F     MOVLW 0x6f
  4308    5CDF     SUBWF 0xfdf, W, ACCESS
  430A    E106     BNZ 0x4318
482:                                         {
483:                                           /* per the standard, for octal, the '#' flag
484:                                              makes the precision be at least one more
485:                                              than the number of digits in the number */
486:                                           if (precision <= digit_cnt)
  430C    D9C1     RCALL 0x4690
  430E    E318     BNC 0x4340
  4690    0E05     MOVLW 0x5
  4692    CFDB     MOVFF 0xfdb, 0x14
  4694    F014     NOP
  4696    0E15     MOVLW 0x15
  4698    50DB     MOVF 0xfdb, W, ACCESS
  469A    80D8     BSF 0xfd8, 0, ACCESS
  469C    5414     SUBFWB 0x14, W, ACCESS
  469E    0012     RETURN 0
487:                                             precision = digit_cnt + 1;
  4310    0E15     MOVLW 0x15
  4312    28DB     INCF 0xfdb, W, ACCESS
  4314    DA5B     RCALL 0x47cc
488:                                         }
489:                                       else if (c == 'x'
  4316    D014     BRA 0x4340
  4318    0E78     MOVLW 0x78
490:                                                || c == 'X' || c == 'b' || c == 'B')
  431A    5CDF     SUBWF 0xfdf, W, ACCESS
  431C    E009     BZ 0x4330
  431E    0E58     MOVLW 0x58
  4320    5CDF     SUBWF 0xfdf, W, ACCESS
  4322    E006     BZ 0x4330
  4324    0E62     MOVLW 0x62
  4326    5CDF     SUBWF 0xfdf, W, ACCESS
  4328    E003     BZ 0x4330
  432A    0E42     MOVLW 0x42
  432C    5CDF     SUBWF 0xfdf, W, ACCESS
  432E    E108     BNZ 0x4340
491:                                         prefix_cnt = 2;
  4330    0E02     MOVLW 0x2
  4332    6EF3     MOVWF 0xff3, ACCESS
  4334    0E16     MOVLW 0x16
  4336    CFF3     MOVFF 0xff3, 0xfdb
  4338    FFDB     NOP
492:                                     }
493:                                 }
494:                               else
  433A    D002     BRA 0x4340
495:                                 digit_cnt = 0;
  433C    0E15     MOVLW 0x15
  433E    6ADB     CLRF 0xfdb, ACCESS
496:               
497:                               /* The leading zero count depends on whether the '0'
498:                                  flag was specified or not. If it was not, then the
499:                                  count is the difference between the specified
500:                                  precision and the number of digits (including the
501:                                  sign character, if any) to be printed; otherwise,
502:                                  it's as if the precision were equal to the max of
503:                                  the specified precision and the field width. If a
504:                                  precision was specified, the '0' flag is ignored,
505:                                  however. */
506:                               if ((flags & _FLAG_ZERO) && (width > precision)
  4340    0E03     MOVLW 0x3
  4342    50DB     MOVF 0xfdb, W, ACCESS
  4344    0B10     ANDLW 0x10
  4348    0E04     MOVLW 0x4
  434A    CFDB     MOVFF 0xfdb, 0x14
  434C    F014     NOP
  434E    0E05     MOVLW 0x5
  4350    50DB     MOVF 0xfdb, W, ACCESS
  4352    80D8     BSF 0xfd8, 0, ACCESS
  4354    5414     SUBFWB 0x14, W, ACCESS
507:                                   && !have_precision)
  4346    E00E     BZ 0x4364
  4356    E206     BC 0x4364
  4358    0E06     MOVLW 0x6
  435A    50DB     MOVF 0xfdb, W, ACCESS
  435C    E103     BNZ 0x4364
508:                                 precision = width;
  435E    0E04     MOVLW 0x4
  4360    50DB     MOVF 0xfdb, W, ACCESS
  4362    DA34     RCALL 0x47cc
509:                               /* for the rest of the processing, precision contains
510:                                  the leading zero count for the conversion. */
511:                               if (precision > digit_cnt)
  4364    D995     RCALL 0x4690
  4366    E20A     BC 0x437c
512:                                 precision -= digit_cnt;
  4368    0E05     MOVLW 0x5
  436A    CFDB     MOVFF 0xfdb, 0xfe7
  436C    FFE7     NOP
  436E    0E15     MOVLW 0x15
  4370    50DB     MOVF 0xfdb, W, ACCESS
  4372    5EE7     SUBWF 0xfe7, F, ACCESS
  4374    0E05     MOVLW 0x5
  4376    CFE7     MOVFF 0xfe7, 0xfdb
  4378    FFDB     NOP
513:                               else
  437A    D002     BRA 0x4380
514:                                 precision = 0;
  437C    0E05     MOVLW 0x5
  437E    6ADB     CLRF 0xfdb, ACCESS
515:                               /* the space count is the difference between the field
516:                                  width and the digit count plus the leading zero
517:                                  count. If the width is less than the digit count
518:                                  plus the leading zero count, the space count is
519:                                  zero. */
520:                               if (width > precision + digit_cnt + prefix_cnt)
  4380    0E04     MOVLW 0x4
  4382    CFDB     MOVFF 0xfdb, 0x14
  4384    F014     NOP
  4386    0E16     MOVLW 0x16
  4388    D945     RCALL 0x4614
  438A    80D8     BSF 0xfd8, 0, ACCESS
  438C    5414     SUBFWB 0x14, W, ACCESS
  438E    E214     BC 0x43b8
  4614    CFDB     MOVFF 0xfdb, 0xfe6
  4616    FFE6     NOP
  4618    0E15     MOVLW 0x15
  461A    CFDB     MOVFF 0xfdb, 0xfe6
  461C    FFE6     NOP
  461E    0E05     MOVLW 0x5
  4620    50DB     MOVF 0xfdb, W, ACCESS
  4622    52E5     MOVF 0xfe5, F, ACCESS
  4624    24E7     ADDWF 0xfe7, W, ACCESS
  4626    52E5     MOVF 0xfe5, F, ACCESS
  4628    24E7     ADDWF 0xfe7, W, ACCESS
  462A    0012     RETURN 0
521:                                 space_cnt =
522:                                   width - precision - digit_cnt - prefix_cnt;
  4390    0E16     MOVLW 0x16
  4392    CFDB     MOVFF 0xfdb, 0xfe6
  4394    FFE6     NOP
  4396    0E15     MOVLW 0x15
  4398    CFDB     MOVFF 0xfdb, 0xfe6
  439A    FFE6     NOP
  439C    0E04     MOVLW 0x4
  439E    CFDB     MOVFF 0xfdb, 0xfe6
  43A0    FFE6     NOP
  43A2    0E05     MOVLW 0x5
  43A4    50DB     MOVF 0xfdb, W, ACCESS
  43A6    52E5     MOVF 0xfe5, F, ACCESS
  43A8    5CE7     SUBWF 0xfe7, W, ACCESS
  43AA    52E5     MOVF 0xfe5, F, ACCESS
  43AC    80D8     BSF 0xfd8, 0, ACCESS
  43AE    54E7     SUBFWB 0xfe7, W, ACCESS
  43B0    52E5     MOVF 0xfe5, F, ACCESS
  43B2    80D8     BSF 0xfd8, 0, ACCESS
  43B4    54E7     SUBFWB 0xfe7, W, ACCESS
  43B6    D95F     RCALL 0x4676
523:               
524:                               /* for output, we check the justification, if it's
525:                                  right justified and the space count is positive, we
526:                                  emit the space characters first. */
527:                               if (!(flags & _FLAG_MINUS) && space_cnt)
  43B8    0E03     MOVLW 0x3
  43BA    50DB     MOVF 0xfdb, W, ACCESS
  43BC    0B01     ANDLW 0x1
  43BE    E10B     BNZ 0x43d6
  43C0    0E08     MOVLW 0x8
  43C2    50DB     MOVF 0xfdb, W, ACCESS
  43C4    E008     BZ 0x43d6
528:                                 {
529:                                   if (s_put_n_chars (handle, space_cnt, ' '))
  43C6    D8B2     RCALL 0x452c
  43C8    E001     BZ 0x43cc
  43CA    D08D     BRA 0x44e6
530:                                     return EOF;
531:                                   count += space_cnt;
  43CC    0E08     MOVLW 0x8
  43CE    50DB     MOVF 0xfdb, W, ACCESS
  43D0    D8BE     RCALL 0x454e
532:                                   space_cnt = 0;
  43D2    0E08     MOVLW 0x8
  43D4    6ADB     CLRF 0xfdb, ACCESS
533:                                 }
534:                               /* if we have a sign character to print, that comes
535:                                  next */
536:                               if (sign_char)
  43D6    0E17     MOVLW 0x17
  43D8    50DB     MOVF 0xfdb, W, ACCESS
  43DA    E007     BZ 0x43ea
537:                                 if (putc (sign_char, handle) == EOF)
  43DC    D988     RCALL 0x46ee
  43DE    0E17     MOVLW 0x17
  43E0    D9F1     RCALL 0x47c4
  43E2    E103     BNZ 0x43ea
  43E4    1C15     COMF 0x15, W, ACCESS
  43E6    E101     BNZ 0x43ea
  43E8    D07E     BRA 0x44e6
538:                                   return EOF;
539:                               /* if we have a prefix (0b, 0B, 0x or 0X), that's next */
540:                               if (prefix_cnt)
  43EA    0E16     MOVLW 0x16
  43EC    50DB     MOVF 0xfdb, W, ACCESS
  43EE    E016     BZ 0x441c
541:                                 {
542:                                   if (putc ('0', handle) == EOF)
  43F0    D97E     RCALL 0x46ee
  43F2    0E30     MOVLW 0x30
  43F4    6EE6     MOVWF 0xfe6, ACCESS
  43F6    D89F     RCALL 0x4536
  43F8    E102     BNZ 0x43fe
  43FA    1C15     COMF 0x15, W, ACCESS
  43FC    E074     BZ 0x44e6
543:                                     return EOF;
544:                                   if (putc (c, handle) == EOF)
  43FE    D977     RCALL 0x46ee
  4400    CFDF     MOVFF 0xfdf, 0xfe6
  4402    FFE6     NOP
  4404    EC7A     CALL 0x64f4, 0
  4406    F032     NOP
  4408    52E5     MOVF 0xfe5, F, ACCESS
  440A    52E5     MOVF 0xfe5, F, ACCESS
  440C    52E5     MOVF 0xfe5, F, ACCESS
  440E    CFF4     MOVFF 0xff4, 0x15
  4410    F015     NOP
  4412    0100     MOVLB 0
  4414    1CF3     COMF 0xff3, W, ACCESS
  4416    E102     BNZ 0x441c
  4418    1C15     COMF 0x15, W, ACCESS
  441A    E065     BZ 0x44e6
545:                                     return EOF;
546:                                 }
547:                               /* if we have leading zeros, they follow. the prefix, if any
548:                                  is included in the number of digits when determining how
549:                                  many leading zeroes are needed. */
550:                               if (precision > prefix_cnt)
  441C    0E05     MOVLW 0x5
  441E    CFDB     MOVFF 0xfdb, 0x14
  4420    F014     NOP
  4422    0E16     MOVLW 0x16
  4424    50DB     MOVF 0xfdb, W, ACCESS
  4426    80D8     BSF 0xfd8, 0, ACCESS
  4428    5414     SUBFWB 0x14, W, ACCESS
  442A    E209     BC 0x443e
551:                                 precision -= prefix_cnt;
  442C    0E05     MOVLW 0x5
  442E    CFDB     MOVFF 0xfdb, 0xfe7
  4430    FFE7     NOP
  4432    0E16     MOVLW 0x16
  4434    50DB     MOVF 0xfdb, W, ACCESS
  4436    5EE7     SUBWF 0xfe7, F, ACCESS
  4438    0E05     MOVLW 0x5
  443A    CFE7     MOVFF 0xfe7, 0xfdb
  443C    FFDB     NOP
552:                               if (s_put_n_chars (handle, precision, '0'))
  443E    0E30     MOVLW 0x30
  4440    6EE6     MOVWF 0xfe6, ACCESS
  4442    0E05     MOVLW 0x5
  4444    D9CB     RCALL 0x47dc
  4446    E14F     BNZ 0x44e6
  478E    ECED     CALL 0x3bda, 0
  4790    F01D     NOP
  4792    52E5     MOVF 0xfe5, F, ACCESS
  4794    52E5     MOVF 0xfe5, F, ACCESS
  4796    52E5     MOVF 0xfe5, F, ACCESS
  4798    52E5     MOVF 0xfe5, F, ACCESS
  479A    0900     IORLW 0
  479C    0012     RETURN 0
  47DC    CFDB     MOVFF 0xfdb, 0xfe6
  47DE    FFE6     NOP
  47E0    DF86     RCALL 0x46ee
  47E2    EFC7     GOTO 0x478e
  47E4    F023     NOP
553:                                 return EOF;
554:                               /* print the actual number */
555:                               for (cval = *++q; cval; cval = *++q)
  4448    0E39     MOVLW 0x39
  444A    2ADB     INCF 0xfdb, F, ACCESS
  444C    CFDB     MOVFF 0xfdb, 0xfe9
  444E    FFE9     NOP
  4450    0E3A     MOVLW 0x3a
  4452    E301     BNC 0x4456
  4454    2ADB     INCF 0xfdb, F, ACCESS
  4456    CFDB     MOVFF 0xfdb, 0xfea
  4458    FFEA     NOP
  445A    0E09     MOVLW 0x9
  445C    CFEF     MOVFF 0xfef, 0xfdb
  445E    FFDB     NOP
  4460    50DB     MOVF 0xfdb, W, ACCESS
  4462    E00E     BZ 0x4480
  4470    0E39     MOVLW 0x39
  4472    2ADB     INCF 0xfdb, F, ACCESS
  4474    CFDB     MOVFF 0xfdb, 0xfe9
  4476    FFE9     NOP
  4478    0E3A     MOVLW 0x3a
  447A    E3ED     BNC 0x4456
  447C    2ADB     INCF 0xfdb, F, ACCESS
  447E    D7EB     BRA 0x4456
556:                                 if (putc (cval, handle) == EOF)
  4464    D944     RCALL 0x46ee
  4466    0E09     MOVLW 0x9
  4468    D9AD     RCALL 0x47c4
  446A    E102     BNZ 0x4470
  446C    1C15     COMF 0x15, W, ACCESS
  446E    E03B     BZ 0x44e6
  47C4    CFDB     MOVFF 0xfdb, 0xfe6
  47C6    FFE6     NOP
  47C8    EF9B     GOTO 0x4536
  47CA    F022     NOP
557:                                   return EOF;
558:                               /* if there are any spaces left, they go to right-pad
559:                                  the field */
560:                               if (s_put_n_chars (handle, space_cnt, ' '))
  4480    D855     RCALL 0x452c
  4482    E131     BNZ 0x44e6
  452C    0E20     MOVLW 0x20
  452E    6EE6     MOVWF 0xfe6, ACCESS
  4530    0E08     MOVLW 0x8
  4532    EFEE     GOTO 0x47dc
  4534    F023     NOP
  46EE    0EFC     MOVLW 0xfc
  46F0    CFDB     MOVFF 0xfdb, 0xfe6
  46F2    FFE6     NOP
  46F4    0EFD     MOVLW 0xfd
  46F6    CFDB     MOVFF 0xfdb, 0xfe6
  46F8    FFE6     NOP
  46FA    0012     RETURN 0
561:                                 return EOF;
562:               
563:                               count += precision + digit_cnt + space_cnt + prefix_cnt;
  4484    0E16     MOVLW 0x16
  4486    CFDB     MOVFF 0xfdb, 0xfe6
  4488    FFE6     NOP
  448A    0E08     MOVLW 0x8
  448C    D8C3     RCALL 0x4614
  448E    52E5     MOVF 0xfe5, F, ACCESS
  4490    24E7     ADDWF 0xfe7, W, ACCESS
  4492    D85D     RCALL 0x454e
  454E    6E14     MOVWF 0x14, ACCESS
  4550    6A15     CLRF 0x15, ACCESS
  4552    50D9     MOVF 0xfd9, W, ACCESS
  4554    0F01     ADDLW 0x1
  4556    D94D     RCALL 0x47f2
  4558    5014     MOVF 0x14, W, ACCESS
  455A    26EE     ADDWF 0xfee, F, ACCESS
  455C    5015     MOVF 0x15, W, ACCESS
  455E    22ED     ADDWFC 0xfed, F, ACCESS
  4560    0012     RETURN 0
564:                             }
565:                             break;
  4494    D02E     BRA 0x44f2
566:                           case 'n':
567:                             switch (size)
  4496    0E07     MOVLW 0x7
  4498    50DB     MOVF 0xfdb, W, ACCESS
  449A    0A03     XORLW 0x3
  449C    E01C     BZ 0x44d6
  449E    0A01     XORLW 0x1
  44A0    E014     BZ 0x44ca
  44A2    0A03     XORLW 0x3
  44A4    E007     BZ 0x44b4
568:                               {
569:                               case _FMT_LONG:
570:                                 *(long *) va_arg (ap, long *) = count;
  44B4    D8F5     RCALL 0x46a0
  44B6    6A19     CLRF 0x19, ACCESS
  44B8    AE17     BTFSS 0x17, 0x7, ACCESS
  44BA    D002     BRA 0x44c0
  44BC    6818     SETF 0x18, ACCESS
  44BE    6819     SETF 0x19, ACCESS
  44C0    D82C     RCALL 0x451a
  44C2    D8BC     RCALL 0x463c
  44C4    C019     MOVFF 0x19, 0xfee
  44C6    FFEE     NOP
  463C    50EE     MOVF 0xfee, W, ACCESS
  463E    CFEF     MOVFF 0xfef, 0xfea
  4640    FFEA     NOP
  4642    6EE9     MOVWF 0xfe9, ACCESS
  4644    C016     MOVFF 0x16, 0xfee
  4646    FFEE     NOP
  4648    C017     MOVFF 0x17, 0xfee
  464A    FFEE     NOP
  464C    C018     MOVFF 0x18, 0xfee
  464E    FFEE     NOP
  4650    0012     RETURN 0
  46A0    0E01     MOVLW 0x1
  46A2    CFDB     MOVFF 0xfdb, 0x16
  46A4    F016     NOP
  46A6    0E02     MOVLW 0x2
  46A8    CFDB     MOVFF 0xfdb, 0x17
  46AA    F017     NOP
  46AC    6A18     CLRF 0x18, ACCESS
  46AE    0012     RETURN 0
571:                                 break;
  44C8    D014     BRA 0x44f2
572:                               case _FMT_SHLONG:
573:                                 *(short long *) va_arg (ap, short long *) = count;
  44CA    D8EA     RCALL 0x46a0
  44CC    BE17     BTFSC 0x17, 0x7, ACCESS
  44CE    6818     SETF 0x18, ACCESS
  44D0    D824     RCALL 0x451a
  44D2    D8B4     RCALL 0x463c
574:                                 break;
  44D4    D00E     BRA 0x44f2
575:                               case _FMT_BYTE:
576:                                 *(signed char *) va_arg (ap, signed char *) = count;
  44D6    D963     RCALL 0x479e
  44D8    CFDB     MOVFF 0xfdb, 0xfef
  44DA    FFEF     NOP
577:                                 break;
  44DC    D00A     BRA 0x44f2
578:                               default:
579:                                 *(int *) va_arg (ap, int *) = count;
  44A6    D97B     RCALL 0x479e
  44A8    CFDB     MOVFF 0xfdb, 0xfee
  44AA    FFEE     NOP
  44AC    0E02     MOVLW 0x2
  44AE    CFDB     MOVFF 0xfdb, 0xfed
  44B0    FFED     NOP
  479E    DEBD     RCALL 0x451a
  47A0    50EE     MOVF 0xfee, W, ACCESS
  47A2    CFEF     MOVFF 0xfef, 0xfea
  47A4    FFEA     NOP
  47A6    6EE9     MOVWF 0xfe9, ACCESS
  47A8    0E01     MOVLW 0x1
  47AA    0012     RETURN 0
580:                                 break;
581:                               }
582:                             break;
  44B2    D01F     BRA 0x44f2
583:                           default:
584:                             /* undefined behaviour. we do nothing */
585:                             break;
586:                           }
587:                       }
588:                     else
589:                       {
590:                         if (putc (c, handle) == EOF)
  44DE    D97B     RCALL 0x47d6
  44E0    E105     BNZ 0x44ec
  44E2    1C15     COMF 0x15, W, ACCESS
  44E4    E103     BNZ 0x44ec
  4536    EC7A     CALL 0x64f4, 0
  4538    F032     NOP
  453A    52E5     MOVF 0xfe5, F, ACCESS
  453C    52E5     MOVF 0xfe5, F, ACCESS
  453E    52E5     MOVF 0xfe5, F, ACCESS
  4540    CFF3     MOVFF 0xff3, 0x14
  4542    F014     NOP
  4544    CFF4     MOVFF 0xff4, 0x15
  4546    F015     NOP
  4548    0100     MOVLB 0
  454A    1CF3     COMF 0xff3, W, ACCESS
  454C    0012     RETURN 0
  477C    CFDF     MOVFF 0xfdf, 0xfe6
  477E    FFE6     NOP
  4780    EF9B     GOTO 0x4536
  4782    F022     NOP
  47D6    DF8B     RCALL 0x46ee
  47D8    EFBE     GOTO 0x477c
  47DA    F023     NOP
591:                           return EOF;
  44E6    68F3     SETF 0xff3, ACCESS
  44E8    68F4     SETF 0xff4, ACCESS
  44EA    D010     BRA 0x450c
592:                         ++count;
  44EC    D8FC     RCALL 0x46e6
  44EE    E301     BNC 0x44f2
  44F0    2ADB     INCF 0xfdb, F, ACCESS
  46E6    0E01     MOVLW 0x1
  46E8    2ADB     INCF 0xfdb, F, ACCESS
  46EA    0E02     MOVLW 0x2
  46EC    0012     RETURN 0
593:                       }
594:                   }
595:               
596:                 return count;
  44F8    0E01     MOVLW 0x1
  44FA    CFDB     MOVFF 0xfdb, 0x14
  44FC    F014     NOP
  44FE    0E02     MOVLW 0x2
  4500    CFDB     MOVFF 0xfdb, 0x15
  4502    F015     NOP
  4504    C014     MOVFF 0x14, 0xff3
  4506    FFF3     NOP
  4508    C015     MOVFF 0x15, 0xff4
  450A    FFF4     NOP
597:               }
  450C    0E3B     MOVLW 0x3b
  450E    5CE1     SUBWF 0xfe1, W, ACCESS
  4510    E202     BC 0x4516
  4512    6AE1     CLRF 0xfe1, ACCESS
  4514    52E5     MOVF 0xfe5, F, ACCESS
  4516    6EE1     MOVWF 0xfe1, ACCESS
  4518    D0CB     BRA 0x46b0
---  E:\Projects\DevPFG\Microchip\MDD File System\SD-SPI.c  --------------------------------------
1:                 /******************************************************************************
2:                  *
3:                  *               Microchip Memory Disk Drive File System
4:                  *
5:                  ******************************************************************************
6:                  * FileName:        SD-SPI.c
7:                  * Dependencies:    SD-SPI.h
8:                  *                  string.h
9:                  *                  FSIO.h
10:                 *                  FSDefs.h
11:                 * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32
12:                 * Compiler:        C18/C30/C32
13:                 * Company:         Microchip Technology, Inc.
14:                 *
15:                 * Software License Agreement
16:                 *
17:                 * The software supplied herewith by Microchip Technology Incorporated
18:                 * (the "Company") for its PICmicror Microcontroller is intended and
19:                 * supplied to you, the Company's customer, for use solely and
20:                 * exclusively on Microchip PICmicro Microcontroller products. The
21:                 * software is owned by the Company and/or its supplier, and is
22:                 * protected under applicable copyright laws. All rights are reserved.
23:                 * Any use in violation of the foregoing restrictions may subject the
24:                 * user to criminal sanctions under applicable laws, as well as to
25:                 * civil liability for the breach of the terms and conditions of this
26:                 * license.
27:                 *
28:                 * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                 *
35:                *****************************************************************************
36:                 File Description:
37:                
38:                 Change History:
39:                  Rev     Description
40:                  -----   -----------
41:                  1.2.5   Fixed bug in the calculation of the capacity for v1.0 devices
42:                          
43:                ********************************************************************/
44:                
45:                
46:                #include "Compiler.h"
47:                #include "GenericTypeDefs.h"
48:                #include "HardwareProfile.h"
49:                #include "MDD File System/FSIO.h"
50:                
51:                #if defined(USE_SD_INTERFACE_WITH_SPI)
52:                
53:                #include "MDD File System/FSDefs.h"
54:                #include "string.h"
55:                #include "MDD File System/SD-SPI.h"
56:                
57:                /******************************************************************************
58:                 * Global Variables
59:                 *****************************************************************************/
60:                
61:                // Description:  Used for the mass-storage library to determine capacity
62:                DWORD MDD_SDSPI_finalLBA;
63:                WORD gMediaSectorSize;
64:                BYTE gSDMode;
65:                static MEDIA_INFORMATION mediaInformation;
66:                
67:                #ifdef __18CXX
68:                    // Summary: Table of SD card commands and parameters
69:                    // Description: The sdmmc_cmdtable contains an array of SD card commands, the corresponding CRC code, the
70:                    //              response type that the card will return, and a parameter indicating whether to expect
71:                    //              additional data from the card.
72:                    const rom typMMC_CMD sdmmc_cmdtable[] =
73:                #else
74:                    const typMMC_CMD sdmmc_cmdtable[] =
75:                #endif
76:                {
77:                    // cmd                      crc     response
78:                    {cmdGO_IDLE_STATE,          0x95,   R1,     NODATA},
79:                    {cmdSEND_OP_COND,           0xF9,   R1,     NODATA},
80:                    {cmdSEND_IF_COND,      		0x87,   R7,     NODATA},
81:                    {cmdSEND_CSD,               0xAF,   R1,     MOREDATA},
82:                    {cmdSEND_CID,               0x1B,   R1,     MOREDATA},
83:                    {cmdSTOP_TRANSMISSION,      0xC3,   R1,     NODATA},
84:                    {cmdSEND_STATUS,            0xAF,   R2,     NODATA},
85:                    {cmdSET_BLOCKLEN,           0xFF,   R1,     NODATA},
86:                    {cmdREAD_SINGLE_BLOCK,      0xFF,   R1,     MOREDATA},
87:                    {cmdREAD_MULTI_BLOCK,       0xFF,   R1,     MOREDATA},
88:                    {cmdWRITE_SINGLE_BLOCK,     0xFF,   R1,     MOREDATA},
89:                    {cmdWRITE_MULTI_BLOCK,      0xFF,   R1,     MOREDATA}, 
90:                    {cmdTAG_SECTOR_START,       0xFF,   R1,     NODATA},
91:                    {cmdTAG_SECTOR_END,         0xFF,   R1,     NODATA},
92:                    {cmdERASE,                  0xDF,   R1b,    NODATA},
93:                    {cmdAPP_CMD,                0x73,   R1,     NODATA},
94:                    {cmdREAD_OCR,               0x25,   R7,     NODATA},
95:                    {cmdCRC_ON_OFF,             0x25,   R1,     NODATA}
96:                };
97:                
98:                
99:                
100:               
101:               /******************************************************************************
102:                * Prototypes
103:                *****************************************************************************/
104:               extern void Delayms(BYTE milliseconds);
105:               BYTE MDD_SDSPI_ReadMedia(void);
106:               MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void);
107:               MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address);
108:               
109:               #if defined __C30__ || defined __C32__
110:                   void OpenSPIM ( unsigned int sync_mode);
111:                   void CloseSPIM( void );
112:                   unsigned char WriteSPIM( unsigned char data_out );
113:               #elif defined __18CXX
114:                   void OpenSPIM ( unsigned char sync_mode);
115:                   void CloseSPIM( void );
116:                   unsigned char WriteSPIM( unsigned char data_out );
117:               
118:                   unsigned char WriteSPIManual(unsigned char data_out);
119:                   BYTE ReadMediaManual (void);
120:                   MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address);
121:               #endif
122:               
123:               
124:               #ifdef __PIC32MX__
125:               /*********************************************************
126:                 Function:
127:                   static inline __attribute__((always_inline)) unsigned char SPICacutateBRG (unsigned int pb_clk, unsigned int spi_clk)
128:                 Summary:
129:                   Calculate the PIC32 SPI BRG value
130:                 Conditions:
131:                   None
132:                 Input:
133:                   pb_clk -  The value of the PIC32 peripheral clock
134:                   spi_clk - The desired baud rate
135:                 Return:
136:                   The corresponding BRG register value.
137:                 Side Effects:
138:                   None.
139:                 Description:
140:                   The SPICalutateBRG function is used to determine an appropriate BRG register value for the PIC32 SPI module.
141:                 Remarks:
142:                   None                                                  
143:                 *********************************************************/
144:               
145:               static inline __attribute__((always_inline)) unsigned char SPICalutateBRG(unsigned int pb_clk, unsigned int spi_clk)
146:               {
147:                   unsigned int brg;
148:               
149:                   brg = pb_clk / (2 * spi_clk);
150:               
151:                   if(pb_clk % (2 * spi_clk))
152:                       brg++;
153:               
154:                   if(brg > 0x100)
155:                       brg = 0x100;
156:               
157:                   if(brg)
158:                       brg--;
159:               
160:                   return (unsigned char) brg;
161:               }
162:               #endif
163:               
164:               
165:               /*********************************************************
166:                 Function:
167:                   BYTE MDD_SDSPI_MediaDetect
168:                 Summary:
169:                   Determines whether an SD card is present
170:                 Conditions:
171:                   The MDD_MediaDetect function pointer must be configured
172:                   to point to this function in FSconfig.h
173:                 Input:
174:                   None
175:                 Return Values:
176:                   TRUE -  Card detected
177:                   FALSE - No card detected
178:                 Side Effects:
179:                   None.
180:                 Description:
181:                   The MDD_SDSPI_MediaDetect function determine if an SD card is connected to 
182:                   the microcontroller.
183:                   If the MEDIA_SOFT_DETECT is not defined, the detection is done by polling
184:                   the SD card detect pin.
185:                   The MicroSD connector does not have a card detect pin, and therefore a
186:                   software mechanism must be used. To do this, the SEND_STATUS command is sent 
187:                   to the card. If the card is not answering with 0x00, the card is either not 
188:                   present, not configured, or in an error state. If this is the case, we try
189:                   to reconfigure the card. If the configuration fails, we consider the card not 
190:                   present (it still may be present, but malfunctioning). In order to use the 
191:                   software card detect mechanism, the MEDIA_SOFT_DETECT macro must be defined.
192:                   
193:                 Remarks:
194:                   None                                                  
195:                 *********************************************************/
196:               
197:               BYTE MDD_SDSPI_MediaDetect (void)
  1038    CFD9     MOVFF 0xfd9, 0xfe6
  103A    FFE6     NOP
  103C    CFE1     MOVFF 0xfe1, 0xfd9
  103E    FFD9     NOP
  1040    0E05     MOVLW 0x5
  1042    26E1     ADDWF 0xfe1, F, ACCESS
198:               {
199:               #ifndef MEDIA_SOFT_DETECT
200:                   return(!SD_CD);
201:               #else
202:               	MMC_RESPONSE    response;
203:               
204:               	if (SPIENABLE == 0)
  1044    BA72     BTFSC 0xf72, 0x5, ACCESS
  1046    D008     BRA 0x1058
205:               	{
206:               		/* If the SPI module is not enabled, send manually the SEND_STATUS command */
207:               		#if (GetSystemClock() > 25600000UL)
208:               			/* should only be here when GetSystemClock() >= 25600000 */
209:               	    	response = SendMMCCmdManual(SEND_STATUS,0x0);
  1048    6AE6     CLRF 0xfe6, ACCESS
  104A    6AE6     CLRF 0xfe6, ACCESS
  104C    6AE6     CLRF 0xfe6, ACCESS
  104E    6AE6     CLRF 0xfe6, ACCESS
  1050    0E06     MOVLW 0x6
  1052    6EE6     MOVWF 0xfe6, ACCESS
  1054    DADA     RCALL 0x160a
210:               		#endif
211:               	}
212:               	else
  1056    D007     BRA 0x1066
213:               	{
214:                   	response = SendMMCCmd(SEND_STATUS,0x0);
  1058    6AE6     CLRF 0xfe6, ACCESS
  105A    6AE6     CLRF 0xfe6, ACCESS
  105C    6AE6     CLRF 0xfe6, ACCESS
  105E    6AE6     CLRF 0xfe6, ACCESS
  1060    0E06     MOVLW 0x6
  1062    6EE6     MOVWF 0xfe6, ACCESS
  1064    D84E     RCALL 0x1102
  1066    CFEE     MOVFF 0xfee, 0x14
  1068    F014     NOP
  106A    CFEE     MOVFF 0xfee, 0x15
  106C    F015     NOP
  106E    CFEE     MOVFF 0xfee, 0x16
  1070    F016     NOP
  1072    CFEE     MOVFF 0xfee, 0x17
  1074    F017     NOP
  1076    CFEE     MOVFF 0xfee, 0x18
  1078    F018     NOP
  107A    6E19     MOVWF 0x19, ACCESS
  107C    0E05     MOVLW 0x5
  107E    5EE1     SUBWF 0xfe1, F, ACCESS
  1080    5019     MOVF 0x19, W, ACCESS
  1082    C014     MOVFF 0x14, 0xfdf
  1084    FFDF     NOP
  1086    0E01     MOVLW 0x1
  1088    C015     MOVFF 0x15, 0xfdb
  108A    FFDB     NOP
  108C    0E02     MOVLW 0x2
  108E    C016     MOVFF 0x16, 0xfdb
  1090    FFDB     NOP
  1092    0E03     MOVLW 0x3
  1094    C017     MOVFF 0x17, 0xfdb
  1096    FFDB     NOP
  1098    0E04     MOVLW 0x4
  109A    C018     MOVFF 0x18, 0xfdb
  109C    FFDB     NOP
215:               	}
216:               
217:               	/* Check the response to the SEND_STATUS command*/
218:               	if(response.r2._word != 0x00)
  109E    CFD9     MOVFF 0xfd9, 0xfe9
  10A0    FFE9     NOP
  10A2    CFDA     MOVFF 0xfda, 0xfea
  10A4    FFEA     NOP
  10A6    50EE     MOVF 0xfee, W, ACCESS
  10A8    10ED     IORWF 0xfed, W, ACCESS
  10AA    E009     BZ 0x10be
219:               	{
220:               		/* the card has not responded correctly to the SEND_STATUS command; try to reinitialize it */
221:               		MDD_SDSPI_MediaInitialize();
  10AC    ECEC     CALL 0x21d8, 0
  10AE    F010     NOP
222:               		if (mediaInformation.errorCode == MEDIA_NO_ERROR)
  10B0    0101     MOVLB 0x1
  10B2    51D6     MOVF 0xd6, W, BANKED
  10B4    E102     BNZ 0x10ba
223:               		{
224:               			/* if the card was reinitialized correctly, it means it is present */
225:               			return 1;
  10B6    0E01     MOVLW 0x1
  10B8    D003     BRA 0x10c0
226:               		}
227:               		else 
228:               		{
229:               			return 0;
  10BA    0E00     MOVLW 0
  10BC    D001     BRA 0x10c0
230:               		}
231:               	}
232:               	else
233:               	{
234:                   /* No error was reported, the card is present and not  */
235:               		return 1;
  10BE    0E01     MOVLW 0x1
236:               	}
237:               #endif
238:               
239:               }//end MediaDetect
  10C0    6E14     MOVWF 0x14, ACCESS
  10C2    0E05     MOVLW 0x5
  10C4    5CE1     SUBWF 0xfe1, W, ACCESS
  10C6    E202     BC 0x10cc
  10C8    6AE1     CLRF 0xfe1, ACCESS
  10CA    52E5     MOVF 0xfe5, F, ACCESS
  10CC    6EE1     MOVWF 0xfe1, ACCESS
  10CE    5014     MOVF 0x14, W, ACCESS
  10D0    52E5     MOVF 0xfe5, F, ACCESS
  10D2    CFE7     MOVFF 0xfe7, 0xfd9
  10D4    FFD9     NOP
  10D6    0012     RETURN 0
240:               
241:               
242:               
243:               /*********************************************************
244:                 Function:
245:                   WORD MDD_SDSPI_ReadSectorSize (void)
246:                 Summary:
247:                   Determines the current sector size on the SD card
248:                 Conditions:
249:                   MDD_MediaInitialize() is complete
250:                 Input:
251:                   None
252:                 Return:
253:                   The size of the sectors for the physical media
254:                 Side Effects:
255:                   None.
256:                 Description:
257:                   The MDD_SDSPI_ReadSectorSize function is used by the
258:                   USB mass storage class to return the card's sector
259:                   size to the PC on request.
260:                 Remarks:
261:                   None
262:                 *********************************************************/
263:               
264:               WORD MDD_SDSPI_ReadSectorSize(void)
265:               {
266:                   return gMediaSectorSize;
  10D8    C1D3     MOVFF 0x1d3, 0xff3
  10DA    FFF3     NOP
  10DC    C1D4     MOVFF 0x1d4, 0xff4
  10DE    FFF4     NOP
267:               }
  10E0    0012     RETURN 0
268:               
269:               
270:               /*********************************************************
271:                 Function:
272:                   DWORD MDD_SDSPI_ReadCapacity (void)
273:                 Summary:
274:                   Determines the current capacity of the SD card
275:                 Conditions:
276:                   MDD_MediaInitialize() is complete
277:                 Input:
278:                   None
279:                 Return:
280:                   The capacity of the device
281:                 Side Effects:
282:                   None.
283:                 Description:
284:                   The MDD_SDSPI_ReadCapacity function is used by the
285:                   USB mass storage class to return the total number
286:                   of sectors on the card.
287:                 Remarks:
288:                   None
289:                 *********************************************************/
290:               DWORD MDD_SDSPI_ReadCapacity(void)
291:               {
292:                   return (MDD_SDSPI_finalLBA);
  10E2    C1CF     MOVFF 0x1cf, 0x6
  10E4    F006     NOP
  10E6    C1D0     MOVFF 0x1d0, 0x7
  10E8    F007     NOP
  10EA    C1D1     MOVFF 0x1d1, 0x8
  10EC    F008     NOP
  10EE    C1D2     MOVFF 0x1d2, 0x9
  10F0    F009     NOP
293:               }
  10F2    0012     RETURN 0
294:               
295:               
296:               /*********************************************************
297:                 Function:
298:                   WORD MDD_SDSPI_InitIO (void)
299:                 Summary:
300:                   Initializes the I/O lines connected to the card
301:                 Conditions:
302:                   MDD_MediaInitialize() is complete.  The MDD_InitIO
303:                   function pointer is pointing to this function.
304:                 Input:
305:                   None
306:                 Return:
307:                   None
308:                 Side Effects:
309:                   None.
310:                 Description:
311:                   The MDD_SDSPI_InitIO function initializes the I/O
312:                   pins connected to the SD card.
313:                 Remarks:
314:                   None
315:                 *********************************************************/
316:               
317:               void MDD_SDSPI_InitIO (void)
318:               {
319:                   // Turn off the card
320:                   SD_CS = 1;                     //Initialize Chip Select line
  10F4    8081     BSF 0xf81, 0, ACCESS
321:                   SD_CS_TRIS = OUTPUT;            //Card Select - output
  10F6    9093     BCF 0xf93, 0, ACCESS
322:               #if !defined(MEDIA_SOFT_DETECT)
323:                   SD_CD_TRIS = INPUT;            //Card Detect - input
324:                   SD_WE_TRIS = INPUT;            //Write Protect - input
325:               #endif
326:               //    Delayms(1);
327:               //    WriteSPIManual(0xff);                //Send Command
328:               //    WriteSPIManual(0xff);                //Send Command
329:               //    WriteSPIManual(0xff);                //Send Command
330:               //    WriteSPIManual(0xff);                //Send Command
331:               //    WriteSPIManual(0xff);                //Send Command
332:               //    WriteSPIManual(0xff);                //Send Command
333:               //    WriteSPIManual(0xff);                //Send Command
334:               //    WriteSPIManual(0xff);                //Send Command
335:               //    WriteSPIManual(0xff);                //Send Command
336:               //    WriteSPIManual(0xff);                //Send Command
337:               //
338:               }
  10F8    0012     RETURN 0
339:               
340:               
341:               
342:               /*********************************************************
343:                 Function:
344:                   BYTE MDD_SDSPI_ShutdownMedia (void)
345:                 Summary:
346:                   Disables the SD card
347:                 Conditions:
348:                   The MDD_ShutdownMedia function pointer is pointing 
349:                   towards this function.
350:                 Input:
351:                   None
352:                 Return:
353:                   None
354:                 Side Effects:
355:                   None.
356:                 Description:
357:                   This function will disable the SPI port and deselect
358:                   the SD card.
359:                 Remarks:
360:                   None
361:                 *********************************************************/
362:               
363:               BYTE MDD_SDSPI_ShutdownMedia(void)
364:               {
365:                   // close the spi bus
366:                   CloseSPIM();
  10FA    EC27     CALL 0x204e, 0
  10FC    F010     NOP
367:                   
368:                   // deselect the device
369:                   SD_CS = 1;
  10FE    8081     BSF 0xf81, 0, ACCESS
370:               
371:                   return 0;
372:               }
  1100    0C00     RETLW 0
373:               
374:               
375:               /*****************************************************************************
376:                 Function:
377:                   MMC_RESPONSE SendMMCCmd (BYTE cmd, DWORD address)
378:                 Summary:
379:                   Sends a command packet to the SD card.
380:                 Conditions:
381:                   None.
382:                 Input:
383:                   None.
384:                 Return Values:
385:                   MMC_RESPONSE    - The response from the card
386:                                   - Bit 0 - Idle state
387:                                   - Bit 1 - Erase Reset
388:                                   - Bit 2 - Illegal Command
389:                                   - Bit 3 - Command CRC Error
390:                                   - Bit 4 - Erase Sequence Error
391:                                   - Bit 5 - Address Error
392:                                   - Bit 6 - Parameter Error
393:                                   - Bit 7 - Unused. Always 0.
394:                 Side Effects:
395:                   None.
396:                 Description:
397:                   SendMMCCmd prepares a command packet and sends it out over the SPI interface.
398:                   Response data of type 'R1' (as indicated by the SD/MMC product manual is returned.
399:                 Remarks:
400:                   None.
401:                 ***************************************************************************************/
402:               
403:               MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address)
  1102    CFD9     MOVFF 0xfd9, 0xfe6
  1104    FFE6     NOP
  1106    CFE1     MOVFF 0xfe1, 0xfd9
  1108    FFD9     NOP
  110A    0E0E     MOVLW 0xe
  110C    26E1     ADDWF 0xfe1, F, ACCESS
404:               {
405:                   WORD timeout = 0x8;
  110E    0E08     MOVLW 0x8
  1110    6EDE     MOVWF 0xfde, ACCESS
  1112    6ADD     CLRF 0xfdd, ACCESS
406:                   BYTE index;
407:                   MMC_RESPONSE    response;
408:                   CMD_PACKET  CmdPacket;
409:                   
410:                   SD_CS = 0;                           //Card Select
  1114    9081     BCF 0xf81, 0, ACCESS
411:                   
412:                   // Copy over data
413:                   CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode;
  1116    0EE8     MOVLW 0xe8
  1118    6E14     MOVWF 0x14, ACCESS
  111A    0E65     MOVLW 0x65
  111C    6E15     MOVWF 0x15, ACCESS
  111E    0E00     MOVLW 0
  1120    6E16     MOVWF 0x16, ACCESS
  1122    0EFE     MOVLW 0xfe
  1124    CFDB     MOVFF 0xfdb, 0x17
  1126    F017     NOP
  1128    6A18     CLRF 0x18, ACCESS
  112A    6A19     CLRF 0x19, ACCESS
  112C    0E02     MOVLW 0x2
  112E    90D8     BCF 0xfd8, 0, ACCESS
  1130    3617     RLCF 0x17, F, ACCESS
  1132    3618     RLCF 0x18, F, ACCESS
  1134    3619     RLCF 0x19, F, ACCESS
  1136    06E8     DECF 0xfe8, F, ACCESS
  1138    E1FA     BNZ 0x112e
  113A    5014     MOVF 0x14, W, ACCESS
  113C    2417     ADDWF 0x17, W, ACCESS
  113E    6EF3     MOVWF 0xff3, ACCESS
  1140    5015     MOVF 0x15, W, ACCESS
  1142    2018     ADDWFC 0x18, W, ACCESS
  1144    6EF4     MOVWF 0xff4, ACCESS
  1146    5016     MOVF 0x16, W, ACCESS
  1148    2019     ADDWFC 0x19, W, ACCESS
  114A    6EF8     MOVWF 0xff8, ACCESS
  114C    CFF4     MOVFF 0xff4, 0xff7
  114E    FFF7     NOP
  1150    CFF3     MOVFF 0xff3, 0xff6
  1152    FFF6     NOP
  1154    0008     TBLRD*
  1156    0E0D     MOVLW 0xd
  1158    CFF5     MOVFF 0xff5, 0xfdb
  115A    FFDB     NOP
414:                   CmdPacket.address    = address;
  115C    50D9     MOVF 0xfd9, W, ACCESS
  115E    0FFA     ADDLW 0xfa
  1160    6EE9     MOVWF 0xfe9, ACCESS
  1162    0EFF     MOVLW 0xff
  1164    20DA     ADDWFC 0xfda, W, ACCESS
  1166    6EEA     MOVWF 0xfea, ACCESS
  1168    0E09     MOVLW 0x9
  116A    CFEE     MOVFF 0xfee, 0xfdb
  116C    FFDB     NOP
  116E    0E0A     MOVLW 0xa
  1170    CFEE     MOVFF 0xfee, 0xfdb
  1172    FFDB     NOP
  1174    0E0B     MOVLW 0xb
  1176    CFEE     MOVFF 0xfee, 0xfdb
  1178    FFDB     NOP
  117A    0E0C     MOVLW 0xc
  117C    CFEE     MOVFF 0xfee, 0xfdb
  117E    FFDB     NOP
415:                   CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here
  1180    0EE8     MOVLW 0xe8
  1182    6E14     MOVWF 0x14, ACCESS
  1184    0E65     MOVLW 0x65
  1186    6E15     MOVWF 0x15, ACCESS
  1188    0E00     MOVLW 0
  118A    6E16     MOVWF 0x16, ACCESS
  118C    0EFE     MOVLW 0xfe
  118E    CFDB     MOVFF 0xfdb, 0x17
  1190    F017     NOP
  1192    6A18     CLRF 0x18, ACCESS
  1194    6A19     CLRF 0x19, ACCESS
  1196    0E02     MOVLW 0x2
  1198    90D8     BCF 0xfd8, 0, ACCESS
  119A    3617     RLCF 0x17, F, ACCESS
  119C    3618     RLCF 0x18, F, ACCESS
  119E    3619     RLCF 0x19, F, ACCESS
  11A0    06E8     DECF 0xfe8, F, ACCESS
  11A2    E1FA     BNZ 0x1198
  11A4    5014     MOVF 0x14, W, ACCESS
  11A6    2417     ADDWF 0x17, W, ACCESS
  11A8    6EF3     MOVWF 0xff3, ACCESS
  11AA    5015     MOVF 0x15, W, ACCESS
  11AC    2018     ADDWFC 0x18, W, ACCESS
  11AE    6EF4     MOVWF 0xff4, ACCESS
  11B0    5016     MOVF 0x16, W, ACCESS
  11B2    2019     ADDWFC 0x19, W, ACCESS
  11B4    6EF8     MOVWF 0xff8, ACCESS
  11B6    CFF4     MOVFF 0xff4, 0xff7
  11B8    FFF7     NOP
  11BA    CFF3     MOVFF 0xff3, 0xff6
  11BC    FFF6     NOP
  11BE    2AF6     INCF 0xff6, F, ACCESS
  11C0    0E00     MOVLW 0
  11C2    22F7     ADDWFC 0xff7, F, ACCESS
  11C4    22F8     ADDWFC 0xff8, F, ACCESS
  11C6    0008     TBLRD*
  11C8    0E08     MOVLW 0x8
  11CA    CFF5     MOVFF 0xff5, 0xfdb
  11CC    FFDB     NOP
416:                   
417:                   CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit
  11CE    0E0D     MOVLW 0xd
  11D0    8CDB     BSF 0xfdb, 0x6, ACCESS
418:                   
419:                   WriteSPIM(CmdPacket.cmd);                //Send Command
  11D2    CFDB     MOVFF 0xfdb, 0xfe6
  11D4    FFE6     NOP
  11D6    EC29     CALL 0x2052, 0
  11D8    F010     NOP
  11DA    52E5     MOVF 0xfe5, F, ACCESS
420:                   WriteSPIM(CmdPacket.addr3);              //Most Significant Byte
  11DC    0E0C     MOVLW 0xc
  11DE    CFDB     MOVFF 0xfdb, 0xfe6
  11E0    FFE6     NOP
  11E2    EC29     CALL 0x2052, 0
  11E4    F010     NOP
  11E6    52E5     MOVF 0xfe5, F, ACCESS
421:                   WriteSPIM(CmdPacket.addr2);
  11E8    0E0B     MOVLW 0xb
  11EA    CFDB     MOVFF 0xfdb, 0xfe6
  11EC    FFE6     NOP
  11EE    EC29     CALL 0x2052, 0
  11F0    F010     NOP
  11F2    52E5     MOVF 0xfe5, F, ACCESS
422:                   WriteSPIM(CmdPacket.addr1);
  11F4    0E0A     MOVLW 0xa
  11F6    CFDB     MOVFF 0xfdb, 0xfe6
  11F8    FFE6     NOP
  11FA    EC29     CALL 0x2052, 0
  11FC    F010     NOP
  11FE    52E5     MOVF 0xfe5, F, ACCESS
423:                   WriteSPIM(CmdPacket.addr0);              //Least Significant Byte
  1200    0E09     MOVLW 0x9
  1202    CFDB     MOVFF 0xfdb, 0xfe6
  1204    FFE6     NOP
  1206    EC29     CALL 0x2052, 0
  1208    F010     NOP
  120A    52E5     MOVF 0xfe5, F, ACCESS
424:                   WriteSPIM(CmdPacket.crc);                //Send CRC
  120C    0E08     MOVLW 0x8
  120E    CFDB     MOVFF 0xfdb, 0xfe6
  1210    FFE6     NOP
  1212    EC29     CALL 0x2052, 0
  1214    F010     NOP
  1216    52E5     MOVF 0xfe5, F, ACCESS
425:                   
426:                   // see if we are going to get a response
427:                   if(sdmmc_cmdtable[cmd].responsetype == R1 || sdmmc_cmdtable[cmd].responsetype == R1b || sdmmc_cmdtable[cmd].responsetype == R7)
  1218    0EE8     MOVLW 0xe8
  121A    6E14     MOVWF 0x14, ACCESS
  121C    0E65     MOVLW 0x65
  121E    6E15     MOVWF 0x15, ACCESS
  1220    0E00     MOVLW 0
  1222    6E16     MOVWF 0x16, ACCESS
  1224    0EFE     MOVLW 0xfe
  1226    CFDB     MOVFF 0xfdb, 0x17
  1228    F017     NOP
  122A    6A18     CLRF 0x18, ACCESS
  122C    6A19     CLRF 0x19, ACCESS
  122E    0E02     MOVLW 0x2
  1230    90D8     BCF 0xfd8, 0, ACCESS
  1232    3617     RLCF 0x17, F, ACCESS
  1234    3618     RLCF 0x18, F, ACCESS
  1236    3619     RLCF 0x19, F, ACCESS
  1238    06E8     DECF 0xfe8, F, ACCESS
  123A    E1FA     BNZ 0x1230
  123C    5014     MOVF 0x14, W, ACCESS
  123E    2417     ADDWF 0x17, W, ACCESS
  1240    6EF3     MOVWF 0xff3, ACCESS
  1242    5015     MOVF 0x15, W, ACCESS
  1244    2018     ADDWFC 0x18, W, ACCESS
  1246    6EF4     MOVWF 0xff4, ACCESS
  1248    5016     MOVF 0x16, W, ACCESS
  124A    2019     ADDWFC 0x19, W, ACCESS
  124C    6EF8     MOVWF 0xff8, ACCESS
  124E    CFF4     MOVFF 0xff4, 0xff7
  1250    FFF7     NOP
  1252    CFF3     MOVFF 0xff3, 0xff6
  1254    FFF6     NOP
  1256    0E02     MOVLW 0x2
  1258    26F6     ADDWF 0xff6, F, ACCESS
  125A    0E00     MOVLW 0
  125C    22F7     ADDWFC 0xff7, F, ACCESS
  125E    22F8     ADDWFC 0xff8, F, ACCESS
  1260    0008     TBLRD*
  1262    50F5     MOVF 0xff5, W, ACCESS
  1264    E050     BZ 0x1306
  1266    0EE8     MOVLW 0xe8
  1268    6E1A     MOVWF 0x1a, ACCESS
  126A    0E65     MOVLW 0x65
  126C    6E1B     MOVWF 0x1b, ACCESS
  126E    0E00     MOVLW 0
  1270    6E1C     MOVWF 0x1c, ACCESS
  1272    0EFE     MOVLW 0xfe
  1274    CFDB     MOVFF 0xfdb, 0x1d
  1276    F01D     NOP
  1278    6A1E     CLRF 0x1e, ACCESS
  127A    6A1F     CLRF 0x1f, ACCESS
  127C    0E02     MOVLW 0x2
  127E    90D8     BCF 0xfd8, 0, ACCESS
  1280    361D     RLCF 0x1d, F, ACCESS
  1282    361E     RLCF 0x1e, F, ACCESS
  1284    361F     RLCF 0x1f, F, ACCESS
  1286    06E8     DECF 0xfe8, F, ACCESS
  1288    E1FA     BNZ 0x127e
  128A    501A     MOVF 0x1a, W, ACCESS
  128C    241D     ADDWF 0x1d, W, ACCESS
  128E    6EF3     MOVWF 0xff3, ACCESS
  1290    501B     MOVF 0x1b, W, ACCESS
  1292    201E     ADDWFC 0x1e, W, ACCESS
  1294    6EF4     MOVWF 0xff4, ACCESS
  1296    501C     MOVF 0x1c, W, ACCESS
  1298    201F     ADDWFC 0x1f, W, ACCESS
  129A    6EF8     MOVWF 0xff8, ACCESS
  129C    CFF4     MOVFF 0xff4, 0xff7
  129E    FFF7     NOP
  12A0    CFF3     MOVFF 0xff3, 0xff6
  12A2    FFF6     NOP
  12A4    0E02     MOVLW 0x2
  12A6    26F6     ADDWF 0xff6, F, ACCESS
  12A8    0E00     MOVLW 0
  12AA    22F7     ADDWFC 0xff7, F, ACCESS
  12AC    22F8     ADDWFC 0xff8, F, ACCESS
  12AE    0008     TBLRD*
  12B0    50F5     MOVF 0xff5, W, ACCESS
  12B2    0801     SUBLW 0x1
  12B4    E028     BZ 0x1306
  12B6    0EE8     MOVLW 0xe8
  12B8    6E20     MOVWF 0x20, ACCESS
  12BA    0E65     MOVLW 0x65
  12BC    6E21     MOVWF 0x21, ACCESS
  12BE    0E00     MOVLW 0
  12C0    6E22     MOVWF 0x22, ACCESS
  12C2    0EFE     MOVLW 0xfe
  12C4    CFDB     MOVFF 0xfdb, 0x23
  12C6    F023     NOP
  12C8    6A24     CLRF 0x24, ACCESS
  12CA    6A25     CLRF 0x25, ACCESS
  12CC    0E02     MOVLW 0x2
  12CE    90D8     BCF 0xfd8, 0, ACCESS
  12D0    3623     RLCF 0x23, F, ACCESS
  12D2    3624     RLCF 0x24, F, ACCESS
  12D4    3625     RLCF 0x25, F, ACCESS
  12D6    06E8     DECF 0xfe8, F, ACCESS
  12D8    E1FA     BNZ 0x12ce
  12DA    5020     MOVF 0x20, W, ACCESS
  12DC    2423     ADDWF 0x23, W, ACCESS
  12DE    6EF3     MOVWF 0xff3, ACCESS
  12E0    5021     MOVF 0x21, W, ACCESS
  12E2    2024     ADDWFC 0x24, W, ACCESS
  12E4    6EF4     MOVWF 0xff4, ACCESS
  12E6    5022     MOVF 0x22, W, ACCESS
  12E8    2025     ADDWFC 0x25, W, ACCESS
  12EA    6EF8     MOVWF 0xff8, ACCESS
  12EC    CFF4     MOVFF 0xff4, 0xff7
  12EE    FFF7     NOP
  12F0    CFF3     MOVFF 0xff3, 0xff6
  12F2    FFF6     NOP
  12F4    0E02     MOVLW 0x2
  12F6    26F6     ADDWF 0xff6, F, ACCESS
  12F8    0E00     MOVLW 0
  12FA    22F7     ADDWFC 0xff7, F, ACCESS
  12FC    22F8     ADDWFC 0xff8, F, ACCESS
  12FE    0008     TBLRD*
  1300    50F5     MOVF 0xff5, W, ACCESS
  1302    0804     SUBLW 0x4
  1304    E116     BNZ 0x1332
428:                   {
429:                       do
430:                       {
431:                           response.r1._byte = MDD_SDSPI_ReadMedia();
  1306    EC40     CALL 0x2080, 0
  1308    F010     NOP
  130A    6EE7     MOVWF 0xfe7, ACCESS
  130C    0E03     MOVLW 0x3
  130E    CFE7     MOVFF 0xfe7, 0xfdb
  1310    FFDB     NOP
432:                           timeout--;
  1312    06DF     DECF 0xfdf, F, ACCESS
  1314    0E01     MOVLW 0x1
  1316    E201     BC 0x131a
  1318    06DB     DECF 0xfdb, F, ACCESS
433:                       }while(response.r1._byte == MMC_FLOATING_BUS && timeout != 0);
  131A    0E03     MOVLW 0x3
  131C    50DB     MOVF 0xfdb, W, ACCESS
  131E    08FF     SUBLW 0xff
  1320    E13E     BNZ 0x139e
  1322    CFD9     MOVFF 0xfd9, 0xfe9
  1324    FFE9     NOP
  1326    CFDA     MOVFF 0xfda, 0xfea
  1328    FFEA     NOP
  132A    50EE     MOVF 0xfee, W, ACCESS
  132C    10ED     IORWF 0xfed, W, ACCESS
  132E    E1EB     BNZ 0x1306
434:                   }
435:                   else if(sdmmc_cmdtable[cmd].responsetype == R2)
  1330    D036     BRA 0x139e
  1332    0EE8     MOVLW 0xe8
  1334    6E14     MOVWF 0x14, ACCESS
  1336    0E65     MOVLW 0x65
  1338    6E15     MOVWF 0x15, ACCESS
  133A    0E00     MOVLW 0
  133C    6E16     MOVWF 0x16, ACCESS
  133E    0EFE     MOVLW 0xfe
  1340    CFDB     MOVFF 0xfdb, 0x17
  1342    F017     NOP
  1344    6A18     CLRF 0x18, ACCESS
  1346    6A19     CLRF 0x19, ACCESS
  1348    0E02     MOVLW 0x2
  134A    90D8     BCF 0xfd8, 0, ACCESS
  134C    3617     RLCF 0x17, F, ACCESS
  134E    3618     RLCF 0x18, F, ACCESS
  1350    3619     RLCF 0x19, F, ACCESS
  1352    06E8     DECF 0xfe8, F, ACCESS
  1354    E1FA     BNZ 0x134a
  1356    5014     MOVF 0x14, W, ACCESS
  1358    2417     ADDWF 0x17, W, ACCESS
  135A    6EF3     MOVWF 0xff3, ACCESS
  135C    5015     MOVF 0x15, W, ACCESS
  135E    2018     ADDWFC 0x18, W, ACCESS
  1360    6EF4     MOVWF 0xff4, ACCESS
  1362    5016     MOVF 0x16, W, ACCESS
  1364    2019     ADDWFC 0x19, W, ACCESS
  1366    6EF8     MOVWF 0xff8, ACCESS
  1368    CFF4     MOVFF 0xff4, 0xff7
  136A    FFF7     NOP
  136C    CFF3     MOVFF 0xff3, 0xff6
  136E    FFF6     NOP
  1370    0E02     MOVLW 0x2
  1372    26F6     ADDWF 0xff6, F, ACCESS
  1374    0E00     MOVLW 0
  1376    22F7     ADDWFC 0xff7, F, ACCESS
  1378    22F8     ADDWFC 0xff8, F, ACCESS
  137A    0008     TBLRD*
  137C    50F5     MOVF 0xff5, W, ACCESS
  137E    0802     SUBLW 0x2
  1380    E10E     BNZ 0x139e
436:                   {
437:                       MDD_SDSPI_ReadMedia();
  1382    EC40     CALL 0x2080, 0
  1384    F010     NOP
438:                       
439:                       response.r2._byte1 = MDD_SDSPI_ReadMedia();
  1386    EC40     CALL 0x2080, 0
  1388    F010     NOP
  138A    6EE7     MOVWF 0xfe7, ACCESS
  138C    0E04     MOVLW 0x4
  138E    CFE7     MOVFF 0xfe7, 0xfdb
  1390    FFDB     NOP
440:                       response.r2._byte0 = MDD_SDSPI_ReadMedia();
  1392    EC40     CALL 0x2080, 0
  1394    F010     NOP
  1396    6EE7     MOVWF 0xfe7, ACCESS
  1398    0E03     MOVLW 0x3
  139A    CFE7     MOVFF 0xfe7, 0xfdb
  139C    FFDB     NOP
441:                   }
442:               
443:                   if(sdmmc_cmdtable[cmd].responsetype == R1b)
  139E    0EE8     MOVLW 0xe8
  13A0    6E14     MOVWF 0x14, ACCESS
  13A2    0E65     MOVLW 0x65
  13A4    6E15     MOVWF 0x15, ACCESS
  13A6    0E00     MOVLW 0
  13A8    6E16     MOVWF 0x16, ACCESS
  13AA    0EFE     MOVLW 0xfe
  13AC    CFDB     MOVFF 0xfdb, 0x17
  13AE    F017     NOP
  13B0    6A18     CLRF 0x18, ACCESS
  13B2    6A19     CLRF 0x19, ACCESS
  13B4    0E02     MOVLW 0x2
  13B6    90D8     BCF 0xfd8, 0, ACCESS
  13B8    3617     RLCF 0x17, F, ACCESS
  13BA    3618     RLCF 0x18, F, ACCESS
  13BC    3619     RLCF 0x19, F, ACCESS
  13BE    06E8     DECF 0xfe8, F, ACCESS
  13C0    E1FA     BNZ 0x13b6
  13C2    5014     MOVF 0x14, W, ACCESS
  13C4    2417     ADDWF 0x17, W, ACCESS
  13C6    6EF3     MOVWF 0xff3, ACCESS
  13C8    5015     MOVF 0x15, W, ACCESS
  13CA    2018     ADDWFC 0x18, W, ACCESS
  13CC    6EF4     MOVWF 0xff4, ACCESS
  13CE    5016     MOVF 0x16, W, ACCESS
  13D0    2019     ADDWFC 0x19, W, ACCESS
  13D2    6EF8     MOVWF 0xff8, ACCESS
  13D4    CFF4     MOVFF 0xff4, 0xff7
  13D6    FFF7     NOP
  13D8    CFF3     MOVFF 0xff3, 0xff6
  13DA    FFF6     NOP
  13DC    0E02     MOVLW 0x2
  13DE    26F6     ADDWF 0xff6, F, ACCESS
  13E0    0E00     MOVLW 0
  13E2    22F7     ADDWFC 0xff7, F, ACCESS
  13E4    22F8     ADDWFC 0xff8, F, ACCESS
  13E6    0008     TBLRD*
  13E8    50F5     MOVF 0xff5, W, ACCESS
  13EA    0801     SUBLW 0x1
  13EC    E128     BNZ 0x143e
444:                   {
445:                       response.r1._byte = 0x00;
  13EE    0E03     MOVLW 0x3
  13F0    6ADB     CLRF 0xfdb, ACCESS
446:                       
447:                       for(index =0; index < 0xFF && response.r1._byte == 0x00; index++)
  13F2    0E02     MOVLW 0x2
  13F4    6ADB     CLRF 0xfdb, ACCESS
  13F6    0EFF     MOVLW 0xff
  13F8    6EF3     MOVWF 0xff3, ACCESS
  13FA    0E02     MOVLW 0x2
  13FC    CFDB     MOVFF 0xfdb, 0xff4
  13FE    FFF4     NOP
  1400    50F3     MOVF 0xff3, W, ACCESS
  1402    5CF4     SUBWF 0xff4, W, ACCESS
  1404    E21C     BC 0x143e
  1406    0E03     MOVLW 0x3
  1408    50DB     MOVF 0xfdb, W, ACCESS
  140A    E119     BNZ 0x143e
  1438    0E02     MOVLW 0x2
  143A    2ADB     INCF 0xfdb, F, ACCESS
  143C    D7DC     BRA 0x13f6
448:                       {
449:                           timeout = 0xFFFF;
  140C    68DE     SETF 0xfde, ACCESS
  140E    68DD     SETF 0xfdd, ACCESS
450:                           
451:                           do
452:                           {
453:                               response.r1._byte = MDD_SDSPI_ReadMedia();
  1410    EC40     CALL 0x2080, 0
  1412    F010     NOP
  1414    6EE7     MOVWF 0xfe7, ACCESS
  1416    0E03     MOVLW 0x3
  1418    CFE7     MOVFF 0xfe7, 0xfdb
  141A    FFDB     NOP
454:                               timeout--;
  141C    06DF     DECF 0xfdf, F, ACCESS
  141E    0E01     MOVLW 0x1
  1420    E201     BC 0x1424
  1422    06DB     DECF 0xfdb, F, ACCESS
455:                           }while(response.r1._byte == 0x00 && timeout != 0);
  1424    0E03     MOVLW 0x3
  1426    50DB     MOVF 0xfdb, W, ACCESS
  1428    E107     BNZ 0x1438
  142A    CFD9     MOVFF 0xfd9, 0xfe9
  142C    FFE9     NOP
  142E    CFDA     MOVFF 0xfda, 0xfea
  1430    FFEA     NOP
  1432    50EE     MOVF 0xfee, W, ACCESS
  1434    10ED     IORWF 0xfed, W, ACCESS
  1436    E1EC     BNZ 0x1410
456:                       }
457:                   }
458:               
459:                   if (sdmmc_cmdtable[cmd].responsetype == R7)
  143E    0EE8     MOVLW 0xe8
  1440    6E14     MOVWF 0x14, ACCESS
  1442    0E65     MOVLW 0x65
  1444    6E15     MOVWF 0x15, ACCESS
  1446    0E00     MOVLW 0
  1448    6E16     MOVWF 0x16, ACCESS
  144A    0EFE     MOVLW 0xfe
  144C    CFDB     MOVFF 0xfdb, 0x17
  144E    F017     NOP
  1450    6A18     CLRF 0x18, ACCESS
  1452    6A19     CLRF 0x19, ACCESS
  1454    0E02     MOVLW 0x2
  1456    90D8     BCF 0xfd8, 0, ACCESS
  1458    3617     RLCF 0x17, F, ACCESS
  145A    3618     RLCF 0x18, F, ACCESS
  145C    3619     RLCF 0x19, F, ACCESS
  145E    06E8     DECF 0xfe8, F, ACCESS
  1460    E1FA     BNZ 0x1456
  1462    5014     MOVF 0x14, W, ACCESS
  1464    2417     ADDWF 0x17, W, ACCESS
  1466    6EF3     MOVWF 0xff3, ACCESS
  1468    5015     MOVF 0x15, W, ACCESS
  146A    2018     ADDWFC 0x18, W, ACCESS
  146C    6EF4     MOVWF 0xff4, ACCESS
  146E    5016     MOVF 0x16, W, ACCESS
  1470    2019     ADDWFC 0x19, W, ACCESS
  1472    6EF8     MOVWF 0xff8, ACCESS
  1474    CFF4     MOVFF 0xff4, 0xff7
  1476    FFF7     NOP
  1478    CFF3     MOVFF 0xff3, 0xff6
  147A    FFF6     NOP
  147C    0E02     MOVLW 0x2
  147E    26F6     ADDWF 0xff6, F, ACCESS
  1480    0E00     MOVLW 0
  1482    22F7     ADDWFC 0xff7, F, ACCESS
  1484    22F8     ADDWFC 0xff8, F, ACCESS
  1486    0008     TBLRD*
  1488    50F5     MOVF 0xff5, W, ACCESS
  148A    0804     SUBLW 0x4
  148C    E169     BNZ 0x1560
460:                   {
461:                       response.r7.bytewise._returnVal = (DWORD)MDD_SDSPI_ReadMedia() << 24;
  148E    EC40     CALL 0x2080, 0
  1490    F010     NOP
  1492    6E14     MOVWF 0x14, ACCESS
  1494    6A15     CLRF 0x15, ACCESS
  1496    6A16     CLRF 0x16, ACCESS
  1498    6A17     CLRF 0x17, ACCESS
  149A    0E18     MOVLW 0x18
  149C    0B1F     ANDLW 0x1f
  149E    E007     BZ 0x14ae
  14A0    90D8     BCF 0xfd8, 0, ACCESS
  14A2    3614     RLCF 0x14, F, ACCESS
  14A4    3615     RLCF 0x15, F, ACCESS
  14A6    3616     RLCF 0x16, F, ACCESS
  14A8    3617     RLCF 0x17, F, ACCESS
  14AA    06E8     DECF 0xfe8, F, ACCESS
  14AC    E1F9     BNZ 0x14a0
  14AE    0E04     MOVLW 0x4
  14B0    C014     MOVFF 0x14, 0xfdb
  14B2    FFDB     NOP
  14B4    0E05     MOVLW 0x5
  14B6    C015     MOVFF 0x15, 0xfdb
  14B8    FFDB     NOP
  14BA    0E06     MOVLW 0x6
  14BC    C016     MOVFF 0x16, 0xfdb
  14BE    FFDB     NOP
  14C0    0E07     MOVLW 0x7
  14C2    C017     MOVFF 0x17, 0xfdb
  14C4    FFDB     NOP
462:                       response.r7.bytewise._returnVal += (DWORD)MDD_SDSPI_ReadMedia() << 16;
  14C6    EC40     CALL 0x2080, 0
  14C8    F010     NOP
  14CA    6E14     MOVWF 0x14, ACCESS
  14CC    6A15     CLRF 0x15, ACCESS
  14CE    6A16     CLRF 0x16, ACCESS
  14D0    6A17     CLRF 0x17, ACCESS
  14D2    0E10     MOVLW 0x10
  14D4    0B1F     ANDLW 0x1f
  14D6    E007     BZ 0x14e6
  14D8    90D8     BCF 0xfd8, 0, ACCESS
  14DA    3614     RLCF 0x14, F, ACCESS
  14DC    3615     RLCF 0x15, F, ACCESS
  14DE    3616     RLCF 0x16, F, ACCESS
  14E0    3617     RLCF 0x17, F, ACCESS
  14E2    06E8     DECF 0xfe8, F, ACCESS
  14E4    E1F9     BNZ 0x14d8
  14E6    50D9     MOVF 0xfd9, W, ACCESS
  14E8    0F04     ADDLW 0x4
  14EA    6EE9     MOVWF 0xfe9, ACCESS
  14EC    CFDA     MOVFF 0xfda, 0xfea
  14EE    FFEA     NOP
  14F0    5014     MOVF 0x14, W, ACCESS
  14F2    26EE     ADDWF 0xfee, F, ACCESS
  14F4    5015     MOVF 0x15, W, ACCESS
  14F6    22EE     ADDWFC 0xfee, F, ACCESS
  14F8    5016     MOVF 0x16, W, ACCESS
  14FA    22EE     ADDWFC 0xfee, F, ACCESS
  14FC    5017     MOVF 0x17, W, ACCESS
  14FE    22EE     ADDWFC 0xfee, F, ACCESS
463:                       response.r7.bytewise._returnVal += (DWORD)MDD_SDSPI_ReadMedia() << 8;
  1500    EC40     CALL 0x2080, 0
  1502    F010     NOP
  1504    6E14     MOVWF 0x14, ACCESS
  1506    6A15     CLRF 0x15, ACCESS
  1508    6A16     CLRF 0x16, ACCESS
  150A    6A17     CLRF 0x17, ACCESS
  150C    0E08     MOVLW 0x8
  150E    0B1F     ANDLW 0x1f
  1510    E007     BZ 0x1520
  1512    90D8     BCF 0xfd8, 0, ACCESS
  1514    3614     RLCF 0x14, F, ACCESS
  1516    3615     RLCF 0x15, F, ACCESS
  1518    3616     RLCF 0x16, F, ACCESS
  151A    3617     RLCF 0x17, F, ACCESS
  151C    06E8     DECF 0xfe8, F, ACCESS
  151E    E1F9     BNZ 0x1512
  1520    50D9     MOVF 0xfd9, W, ACCESS
  1522    0F04     ADDLW 0x4
  1524    6EE9     MOVWF 0xfe9, ACCESS
  1526    CFDA     MOVFF 0xfda, 0xfea
  1528    FFEA     NOP
  152A    5014     MOVF 0x14, W, ACCESS
  152C    26EE     ADDWF 0xfee, F, ACCESS
  152E    5015     MOVF 0x15, W, ACCESS
  1530    22EE     ADDWFC 0xfee, F, ACCESS
  1532    5016     MOVF 0x16, W, ACCESS
  1534    22EE     ADDWFC 0xfee, F, ACCESS
  1536    5017     MOVF 0x17, W, ACCESS
  1538    22EE     ADDWFC 0xfee, F, ACCESS
464:                       response.r7.bytewise._returnVal += (DWORD)MDD_SDSPI_ReadMedia();
  153A    EC40     CALL 0x2080, 0
  153C    F010     NOP
  153E    6E14     MOVWF 0x14, ACCESS
  1540    6A15     CLRF 0x15, ACCESS
  1542    6A16     CLRF 0x16, ACCESS
  1544    6A17     CLRF 0x17, ACCESS
  1546    50D9     MOVF 0xfd9, W, ACCESS
  1548    0F04     ADDLW 0x4
  154A    6EE9     MOVWF 0xfe9, ACCESS
  154C    CFDA     MOVFF 0xfda, 0xfea
  154E    FFEA     NOP
  1550    5014     MOVF 0x14, W, ACCESS
  1552    26EE     ADDWF 0xfee, F, ACCESS
  1554    5015     MOVF 0x15, W, ACCESS
  1556    22EE     ADDWFC 0xfee, F, ACCESS
  1558    5016     MOVF 0x16, W, ACCESS
  155A    22EE     ADDWFC 0xfee, F, ACCESS
  155C    5017     MOVF 0x17, W, ACCESS
  155E    22EE     ADDWFC 0xfee, F, ACCESS
465:                   }
466:               
467:                   mSend8ClkCycles();                      //Required clocking (see spec)
  1560    68E6     SETF 0xfe6, ACCESS
  1562    EC29     CALL 0x2052, 0
  1564    F010     NOP
  1566    52E5     MOVF 0xfe5, F, ACCESS
468:               
469:                   // see if we are expecting data or not
470:                   if(!(sdmmc_cmdtable[cmd].moredataexpected))
  1568    0EE8     MOVLW 0xe8
  156A    6E14     MOVWF 0x14, ACCESS
  156C    0E65     MOVLW 0x65
  156E    6E15     MOVWF 0x15, ACCESS
  1570    0E00     MOVLW 0
  1572    6E16     MOVWF 0x16, ACCESS
  1574    0EFE     MOVLW 0xfe
  1576    CFDB     MOVFF 0xfdb, 0x17
  1578    F017     NOP
  157A    6A18     CLRF 0x18, ACCESS
  157C    6A19     CLRF 0x19, ACCESS
  157E    0E02     MOVLW 0x2
  1580    90D8     BCF 0xfd8, 0, ACCESS
  1582    3617     RLCF 0x17, F, ACCESS
  1584    3618     RLCF 0x18, F, ACCESS
  1586    3619     RLCF 0x19, F, ACCESS
  1588    06E8     DECF 0xfe8, F, ACCESS
  158A    E1FA     BNZ 0x1580
  158C    5014     MOVF 0x14, W, ACCESS
  158E    2417     ADDWF 0x17, W, ACCESS
  1590    6EF3     MOVWF 0xff3, ACCESS
  1592    5015     MOVF 0x15, W, ACCESS
  1594    2018     ADDWFC 0x18, W, ACCESS
  1596    6EF4     MOVWF 0xff4, ACCESS
  1598    5016     MOVF 0x16, W, ACCESS
  159A    2019     ADDWFC 0x19, W, ACCESS
  159C    6EF8     MOVWF 0xff8, ACCESS
  159E    CFF4     MOVFF 0xff4, 0xff7
  15A0    FFF7     NOP
  15A2    CFF3     MOVFF 0xff3, 0xff6
  15A4    FFF6     NOP
  15A6    0E03     MOVLW 0x3
  15A8    26F6     ADDWF 0xff6, F, ACCESS
  15AA    0E00     MOVLW 0
  15AC    22F7     ADDWFC 0xff7, F, ACCESS
  15AE    22F8     ADDWFC 0xff8, F, ACCESS
  15B0    0008     TBLRD*
  15B2    50F5     MOVF 0xff5, W, ACCESS
  15B4    E101     BNZ 0x15b8
471:                       SD_CS = 1;
  15B6    8081     BSF 0xf81, 0, ACCESS
472:               
473:                   return(response);
  15B8    0E03     MOVLW 0x3
  15BA    CFDB     MOVFF 0xfdb, 0x14
  15BC    F014     NOP
  15BE    0E04     MOVLW 0x4
  15C0    CFDB     MOVFF 0xfdb, 0x15
  15C2    F015     NOP
  15C4    0E05     MOVLW 0x5
  15C6    CFDB     MOVFF 0xfdb, 0x16
  15C8    F016     NOP
  15CA    0E06     MOVLW 0x6
  15CC    CFDB     MOVFF 0xfdb, 0x17
  15CE    F017     NOP
  15D0    0E07     MOVLW 0x7
  15D2    CFDB     MOVFF 0xfdb, 0x18
  15D4    F018     NOP
  15D6    CFD9     MOVFF 0xfd9, 0xfe9
  15D8    FFE9     NOP
  15DA    CFDA     MOVFF 0xfda, 0xfea
  15DC    FFEA     NOP
  15DE    50ED     MOVF 0xfed, W, ACCESS
  15E0    50ED     MOVF 0xfed, W, ACCESS
  15E2    C018     MOVFF 0x18, 0xfed
  15E4    FFED     NOP
  15E6    C017     MOVFF 0x17, 0xfed
  15E8    FFED     NOP
  15EA    C016     MOVFF 0x16, 0xfed
  15EC    FFED     NOP
  15EE    C015     MOVFF 0x15, 0xfed
  15F0    FFED     NOP
  15F2    C014     MOVFF 0x14, 0xfef
  15F4    FFEF     NOP
474:               }
  15F6    0E0E     MOVLW 0xe
  15F8    5CE1     SUBWF 0xfe1, W, ACCESS
  15FA    E202     BC 0x1600
  15FC    6AE1     CLRF 0xfe1, ACCESS
  15FE    52E5     MOVF 0xfe5, F, ACCESS
  1600    6EE1     MOVWF 0xfe1, ACCESS
  1602    52E5     MOVF 0xfe5, F, ACCESS
  1604    CFE7     MOVFF 0xfe7, 0xfd9
  1606    FFD9     NOP
  1608    0012     RETURN 0
475:               
476:               #ifdef __18CXX
477:               #if (GetSystemClock() >= 25600000)
478:               
479:               /*****************************************************************************
480:                 Function:
481:                   MMC_RESPONSE SendMMCCmdManual (BYTE cmd, DWORD address)
482:                 Summary:
483:                   Sends a command packet to the SD card with bit-bang SPI.
484:                 Conditions:
485:                   None.
486:                 Input:
487:                   None.
488:                 Return Values:
489:                   MMC_RESPONSE    - The response from the card
490:                                   - Bit 0 - Idle state
491:                                   - Bit 1 - Erase Reset
492:                                   - Bit 2 - Illegal Command
493:                                   - Bit 3 - Command CRC Error
494:                                   - Bit 4 - Erase Sequence Error
495:                                   - Bit 5 - Address Error
496:                                   - Bit 6 - Parameter Error
497:                                   - Bit 7 - Unused. Always 0.
498:                 Side Effects:
499:                   None.
500:                 Description:
501:                   SendMMCCmd prepares a command packet and sends it out over the SPI interface.
502:                   Response data of type 'R1' (as indicated by the SD/MMC product manual is returned.
503:                   This function is intended to be used when the clock speed of a PIC18 device is
504:                   so high that the maximum SPI divider can't reduce the clock below the maximum
505:                   SD card initialization sequence speed.
506:                 Remarks:
507:                   None.
508:                 ***************************************************************************************/
509:               
510:               MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address)
  160A    CFD9     MOVFF 0xfd9, 0xfe6
  160C    FFE6     NOP
  160E    CFE1     MOVFF 0xfe1, 0xfd9
  1610    FFD9     NOP
  1612    0E0E     MOVLW 0xe
  1614    26E1     ADDWF 0xfe1, F, ACCESS
511:               {
512:                   WORD timeout = 0x8;
  1616    0E08     MOVLW 0x8
  1618    6EDE     MOVWF 0xfde, ACCESS
  161A    6ADD     CLRF 0xfdd, ACCESS
513:                   BYTE index;
514:                   MMC_RESPONSE    response;
515:                   CMD_PACKET  CmdPacket;
516:                   
517:                   SD_CS = 0;                           //Card Select
  161C    9081     BCF 0xf81, 0, ACCESS
518:                   
519:                   // Copy over data
520:                   CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode;
  161E    0EE8     MOVLW 0xe8
  1620    6E14     MOVWF 0x14, ACCESS
  1622    0E65     MOVLW 0x65
  1624    6E15     MOVWF 0x15, ACCESS
  1626    0E00     MOVLW 0
  1628    6E16     MOVWF 0x16, ACCESS
  162A    0EFE     MOVLW 0xfe
  162C    CFDB     MOVFF 0xfdb, 0x17
  162E    F017     NOP
  1630    6A18     CLRF 0x18, ACCESS
  1632    6A19     CLRF 0x19, ACCESS
  1634    0E02     MOVLW 0x2
  1636    90D8     BCF 0xfd8, 0, ACCESS
  1638    3617     RLCF 0x17, F, ACCESS
  163A    3618     RLCF 0x18, F, ACCESS
  163C    3619     RLCF 0x19, F, ACCESS
  163E    06E8     DECF 0xfe8, F, ACCESS
  1640    E1FA     BNZ 0x1636
  1642    5014     MOVF 0x14, W, ACCESS
  1644    2417     ADDWF 0x17, W, ACCESS
  1646    6EF3     MOVWF 0xff3, ACCESS
  1648    5015     MOVF 0x15, W, ACCESS
  164A    2018     ADDWFC 0x18, W, ACCESS
  164C    6EF4     MOVWF 0xff4, ACCESS
  164E    5016     MOVF 0x16, W, ACCESS
  1650    2019     ADDWFC 0x19, W, ACCESS
  1652    6EF8     MOVWF 0xff8, ACCESS
  1654    CFF4     MOVFF 0xff4, 0xff7
  1656    FFF7     NOP
  1658    CFF3     MOVFF 0xff3, 0xff6
  165A    FFF6     NOP
  165C    0008     TBLRD*
  165E    0E0D     MOVLW 0xd
  1660    CFF5     MOVFF 0xff5, 0xfdb
  1662    FFDB     NOP
521:                   CmdPacket.address    = address;
  1664    50D9     MOVF 0xfd9, W, ACCESS
  1666    0FFA     ADDLW 0xfa
  1668    6EE9     MOVWF 0xfe9, ACCESS
  166A    0EFF     MOVLW 0xff
  166C    20DA     ADDWFC 0xfda, W, ACCESS
  166E    6EEA     MOVWF 0xfea, ACCESS
  1670    0E09     MOVLW 0x9
  1672    CFEE     MOVFF 0xfee, 0xfdb
  1674    FFDB     NOP
  1676    0E0A     MOVLW 0xa
  1678    CFEE     MOVFF 0xfee, 0xfdb
  167A    FFDB     NOP
  167C    0E0B     MOVLW 0xb
  167E    CFEE     MOVFF 0xfee, 0xfdb
  1680    FFDB     NOP
  1682    0E0C     MOVLW 0xc
  1684    CFEE     MOVFF 0xfee, 0xfdb
  1686    FFDB     NOP
522:                   CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here
  1688    0EE8     MOVLW 0xe8
  168A    6E14     MOVWF 0x14, ACCESS
  168C    0E65     MOVLW 0x65
  168E    6E15     MOVWF 0x15, ACCESS
  1690    0E00     MOVLW 0
  1692    6E16     MOVWF 0x16, ACCESS
  1694    0EFE     MOVLW 0xfe
  1696    CFDB     MOVFF 0xfdb, 0x17
  1698    F017     NOP
  169A    6A18     CLRF 0x18, ACCESS
  169C    6A19     CLRF 0x19, ACCESS
  169E    0E02     MOVLW 0x2
  16A0    90D8     BCF 0xfd8, 0, ACCESS
  16A2    3617     RLCF 0x17, F, ACCESS
  16A4    3618     RLCF 0x18, F, ACCESS
  16A6    3619     RLCF 0x19, F, ACCESS
  16A8    06E8     DECF 0xfe8, F, ACCESS
  16AA    E1FA     BNZ 0x16a0
  16AC    5014     MOVF 0x14, W, ACCESS
  16AE    2417     ADDWF 0x17, W, ACCESS
  16B0    6EF3     MOVWF 0xff3, ACCESS
  16B2    5015     MOVF 0x15, W, ACCESS
  16B4    2018     ADDWFC 0x18, W, ACCESS
  16B6    6EF4     MOVWF 0xff4, ACCESS
  16B8    5016     MOVF 0x16, W, ACCESS
  16BA    2019     ADDWFC 0x19, W, ACCESS
  16BC    6EF8     MOVWF 0xff8, ACCESS
  16BE    CFF4     MOVFF 0xff4, 0xff7
  16C0    FFF7     NOP
  16C2    CFF3     MOVFF 0xff3, 0xff6
  16C4    FFF6     NOP
  16C6    2AF6     INCF 0xff6, F, ACCESS
  16C8    0E00     MOVLW 0
  16CA    22F7     ADDWFC 0xff7, F, ACCESS
  16CC    22F8     ADDWFC 0xff8, F, ACCESS
  16CE    0008     TBLRD*
  16D0    0E08     MOVLW 0x8
  16D2    CFF5     MOVFF 0xff5, 0xfdb
  16D4    FFDB     NOP
523:                   
524:                   CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit
  16D6    0E0D     MOVLW 0xd
  16D8    8CDB     BSF 0xfdb, 0x6, ACCESS
525:                   
526:                   WriteSPIManual(CmdPacket.cmd);                //Send Command
  16DA    CFDB     MOVFF 0xfdb, 0xfe6
  16DC    FFE6     NOP
  16DE    EC64     CALL 0x20c8, 0
  16E0    F010     NOP
  16E2    52E5     MOVF 0xfe5, F, ACCESS
527:                   WriteSPIManual(CmdPacket.addr3);              //Most Significant Byte
  16E4    0E0C     MOVLW 0xc
  16E6    CFDB     MOVFF 0xfdb, 0xfe6
  16E8    FFE6     NOP
  16EA    EC64     CALL 0x20c8, 0
  16EC    F010     NOP
  16EE    52E5     MOVF 0xfe5, F, ACCESS
528:                   WriteSPIManual(CmdPacket.addr2);
  16F0    0E0B     MOVLW 0xb
  16F2    CFDB     MOVFF 0xfdb, 0xfe6
  16F4    FFE6     NOP
  16F6    EC64     CALL 0x20c8, 0
  16F8    F010     NOP
  16FA    52E5     MOVF 0xfe5, F, ACCESS
529:                   WriteSPIManual(CmdPacket.addr1);
  16FC    0E0A     MOVLW 0xa
  16FE    CFDB     MOVFF 0xfdb, 0xfe6
  1700    FFE6     NOP
  1702    EC64     CALL 0x20c8, 0
  1704    F010     NOP
  1706    52E5     MOVF 0xfe5, F, ACCESS
530:                   WriteSPIManual(CmdPacket.addr0);              //Least Significant Byte
  1708    0E09     MOVLW 0x9
  170A    CFDB     MOVFF 0xfdb, 0xfe6
  170C    FFE6     NOP
  170E    EC64     CALL 0x20c8, 0
  1710    F010     NOP
  1712    52E5     MOVF 0xfe5, F, ACCESS
531:                   WriteSPIManual(CmdPacket.crc);                //Send CRC
  1714    0E08     MOVLW 0x8
  1716    CFDB     MOVFF 0xfdb, 0xfe6
  1718    FFE6     NOP
  171A    EC64     CALL 0x20c8, 0
  171C    F010     NOP
  171E    52E5     MOVF 0xfe5, F, ACCESS
532:                   
533:                   // see if we are going to get a response
534:                   if(sdmmc_cmdtable[cmd].responsetype == R1 || sdmmc_cmdtable[cmd].responsetype == R1b || sdmmc_cmdtable[cmd].responsetype == R7)
  1720    0EE8     MOVLW 0xe8
  1722    6E14     MOVWF 0x14, ACCESS
  1724    0E65     MOVLW 0x65
  1726    6E15     MOVWF 0x15, ACCESS
  1728    0E00     MOVLW 0
  172A    6E16     MOVWF 0x16, ACCESS
  172C    0EFE     MOVLW 0xfe
  172E    CFDB     MOVFF 0xfdb, 0x17
  1730    F017     NOP
  1732    6A18     CLRF 0x18, ACCESS
  1734    6A19     CLRF 0x19, ACCESS
  1736    0E02     MOVLW 0x2
  1738    90D8     BCF 0xfd8, 0, ACCESS
  173A    3617     RLCF 0x17, F, ACCESS
  173C    3618     RLCF 0x18, F, ACCESS
  173E    3619     RLCF 0x19, F, ACCESS
  1740    06E8     DECF 0xfe8, F, ACCESS
  1742    E1FA     BNZ 0x1738
  1744    5014     MOVF 0x14, W, ACCESS
  1746    2417     ADDWF 0x17, W, ACCESS
  1748    6EF3     MOVWF 0xff3, ACCESS
  174A    5015     MOVF 0x15, W, ACCESS
  174C    2018     ADDWFC 0x18, W, ACCESS
  174E    6EF4     MOVWF 0xff4, ACCESS
  1750    5016     MOVF 0x16, W, ACCESS
  1752    2019     ADDWFC 0x19, W, ACCESS
  1754    6EF8     MOVWF 0xff8, ACCESS
  1756    CFF4     MOVFF 0xff4, 0xff7
  1758    FFF7     NOP
  175A    CFF3     MOVFF 0xff3, 0xff6
  175C    FFF6     NOP
  175E    0E02     MOVLW 0x2
  1760    26F6     ADDWF 0xff6, F, ACCESS
  1762    0E00     MOVLW 0
  1764    22F7     ADDWFC 0xff7, F, ACCESS
  1766    22F8     ADDWFC 0xff8, F, ACCESS
  1768    0008     TBLRD*
  176A    50F5     MOVF 0xff5, W, ACCESS
  176C    E050     BZ 0x180e
  176E    0EE8     MOVLW 0xe8
  1770    6E1A     MOVWF 0x1a, ACCESS
  1772    0E65     MOVLW 0x65
  1774    6E1B     MOVWF 0x1b, ACCESS
  1776    0E00     MOVLW 0
  1778    6E1C     MOVWF 0x1c, ACCESS
  177A    0EFE     MOVLW 0xfe
  177C    CFDB     MOVFF 0xfdb, 0x1d
  177E    F01D     NOP
  1780    6A1E     CLRF 0x1e, ACCESS
  1782    6A1F     CLRF 0x1f, ACCESS
  1784    0E02     MOVLW 0x2
  1786    90D8     BCF 0xfd8, 0, ACCESS
  1788    361D     RLCF 0x1d, F, ACCESS
  178A    361E     RLCF 0x1e, F, ACCESS
  178C    361F     RLCF 0x1f, F, ACCESS
  178E    06E8     DECF 0xfe8, F, ACCESS
  1790    E1FA     BNZ 0x1786
  1792    501A     MOVF 0x1a, W, ACCESS
  1794    241D     ADDWF 0x1d, W, ACCESS
  1796    6EF3     MOVWF 0xff3, ACCESS
  1798    501B     MOVF 0x1b, W, ACCESS
  179A    201E     ADDWFC 0x1e, W, ACCESS
  179C    6EF4     MOVWF 0xff4, ACCESS
  179E    501C     MOVF 0x1c, W, ACCESS
  17A0    201F     ADDWFC 0x1f, W, ACCESS
  17A2    6EF8     MOVWF 0xff8, ACCESS
  17A4    CFF4     MOVFF 0xff4, 0xff7
  17A6    FFF7     NOP
  17A8    CFF3     MOVFF 0xff3, 0xff6
  17AA    FFF6     NOP
  17AC    0E02     MOVLW 0x2
  17AE    26F6     ADDWF 0xff6, F, ACCESS
  17B0    0E00     MOVLW 0
  17B2    22F7     ADDWFC 0xff7, F, ACCESS
  17B4    22F8     ADDWFC 0xff8, F, ACCESS
  17B6    0008     TBLRD*
  17B8    50F5     MOVF 0xff5, W, ACCESS
  17BA    0801     SUBLW 0x1
  17BC    E028     BZ 0x180e
  17BE    0EE8     MOVLW 0xe8
  17C0    6E20     MOVWF 0x20, ACCESS
  17C2    0E65     MOVLW 0x65
  17C4    6E21     MOVWF 0x21, ACCESS
  17C6    0E00     MOVLW 0
  17C8    6E22     MOVWF 0x22, ACCESS
  17CA    0EFE     MOVLW 0xfe
  17CC    CFDB     MOVFF 0xfdb, 0x23
  17CE    F023     NOP
  17D0    6A24     CLRF 0x24, ACCESS
  17D2    6A25     CLRF 0x25, ACCESS
  17D4    0E02     MOVLW 0x2
  17D6    90D8     BCF 0xfd8, 0, ACCESS
  17D8    3623     RLCF 0x23, F, ACCESS
  17DA    3624     RLCF 0x24, F, ACCESS
  17DC    3625     RLCF 0x25, F, ACCESS
  17DE    06E8     DECF 0xfe8, F, ACCESS
  17E0    E1FA     BNZ 0x17d6
  17E2    5020     MOVF 0x20, W, ACCESS
  17E4    2423     ADDWF 0x23, W, ACCESS
  17E6    6EF3     MOVWF 0xff3, ACCESS
  17E8    5021     MOVF 0x21, W, ACCESS
  17EA    2024     ADDWFC 0x24, W, ACCESS
  17EC    6EF4     MOVWF 0xff4, ACCESS
  17EE    5022     MOVF 0x22, W, ACCESS
  17F0    2025     ADDWFC 0x25, W, ACCESS
  17F2    6EF8     MOVWF 0xff8, ACCESS
  17F4    CFF4     MOVFF 0xff4, 0xff7
  17F6    FFF7     NOP
  17F8    CFF3     MOVFF 0xff3, 0xff6
  17FA    FFF6     NOP
  17FC    0E02     MOVLW 0x2
  17FE    26F6     ADDWF 0xff6, F, ACCESS
  1800    0E00     MOVLW 0
  1802    22F7     ADDWFC 0xff7, F, ACCESS
  1804    22F8     ADDWFC 0xff8, F, ACCESS
  1806    0008     TBLRD*
  1808    50F5     MOVF 0xff5, W, ACCESS
  180A    0804     SUBLW 0x4
  180C    E116     BNZ 0x183a
535:                   {
536:                       do
537:                       {
538:                           response.r1._byte = ReadMediaManual();
  180E    ECA3     CALL 0x2146, 0
  1810    F010     NOP
  1812    6EE7     MOVWF 0xfe7, ACCESS
  1814    0E03     MOVLW 0x3
  1816    CFE7     MOVFF 0xfe7, 0xfdb
  1818    FFDB     NOP
539:                           timeout--;
  181A    06DF     DECF 0xfdf, F, ACCESS
  181C    0E01     MOVLW 0x1
  181E    E201     BC 0x1822
  1820    06DB     DECF 0xfdb, F, ACCESS
540:                       }while(response.r1._byte == MMC_FLOATING_BUS && timeout != 0);
  1822    0E03     MOVLW 0x3
  1824    50DB     MOVF 0xfdb, W, ACCESS
  1826    08FF     SUBLW 0xff
  1828    E13E     BNZ 0x18a6
  182A    CFD9     MOVFF 0xfd9, 0xfe9
  182C    FFE9     NOP
  182E    CFDA     MOVFF 0xfda, 0xfea
  1830    FFEA     NOP
  1832    50EE     MOVF 0xfee, W, ACCESS
  1834    10ED     IORWF 0xfed, W, ACCESS
  1836    E1EB     BNZ 0x180e
541:                   }
542:                   else if(sdmmc_cmdtable[cmd].responsetype == R2)
  1838    D036     BRA 0x18a6
  183A    0EE8     MOVLW 0xe8
  183C    6E14     MOVWF 0x14, ACCESS
  183E    0E65     MOVLW 0x65
  1840    6E15     MOVWF 0x15, ACCESS
  1842    0E00     MOVLW 0
  1844    6E16     MOVWF 0x16, ACCESS
  1846    0EFE     MOVLW 0xfe
  1848    CFDB     MOVFF 0xfdb, 0x17
  184A    F017     NOP
  184C    6A18     CLRF 0x18, ACCESS
  184E    6A19     CLRF 0x19, ACCESS
  1850    0E02     MOVLW 0x2
  1852    90D8     BCF 0xfd8, 0, ACCESS
  1854    3617     RLCF 0x17, F, ACCESS
  1856    3618     RLCF 0x18, F, ACCESS
  1858    3619     RLCF 0x19, F, ACCESS
  185A    06E8     DECF 0xfe8, F, ACCESS
  185C    E1FA     BNZ 0x1852
  185E    5014     MOVF 0x14, W, ACCESS
  1860    2417     ADDWF 0x17, W, ACCESS
  1862    6EF3     MOVWF 0xff3, ACCESS
  1864    5015     MOVF 0x15, W, ACCESS
  1866    2018     ADDWFC 0x18, W, ACCESS
  1868    6EF4     MOVWF 0xff4, ACCESS
  186A    5016     MOVF 0x16, W, ACCESS
  186C    2019     ADDWFC 0x19, W, ACCESS
  186E    6EF8     MOVWF 0xff8, ACCESS
  1870    CFF4     MOVFF 0xff4, 0xff7
  1872    FFF7     NOP
  1874    CFF3     MOVFF 0xff3, 0xff6
  1876    FFF6     NOP
  1878    0E02     MOVLW 0x2
  187A    26F6     ADDWF 0xff6, F, ACCESS
  187C    0E00     MOVLW 0
  187E    22F7     ADDWFC 0xff7, F, ACCESS
  1880    22F8     ADDWFC 0xff8, F, ACCESS
  1882    0008     TBLRD*
  1884    50F5     MOVF 0xff5, W, ACCESS
  1886    0802     SUBLW 0x2
  1888    E10E     BNZ 0x18a6
543:                   {
544:                       ReadMediaManual();
  188A    ECA3     CALL 0x2146, 0
  188C    F010     NOP
545:                       
546:                       response.r2._byte1 = ReadMediaManual();
  188E    ECA3     CALL 0x2146, 0
  1890    F010     NOP
  1892    6EE7     MOVWF 0xfe7, ACCESS
  1894    0E04     MOVLW 0x4
  1896    CFE7     MOVFF 0xfe7, 0xfdb
  1898    FFDB     NOP
547:                       response.r2._byte0 = ReadMediaManual();
  189A    ECA3     CALL 0x2146, 0
  189C    F010     NOP
  189E    6EE7     MOVWF 0xfe7, ACCESS
  18A0    0E03     MOVLW 0x3
  18A2    CFE7     MOVFF 0xfe7, 0xfdb
  18A4    FFDB     NOP
548:                   }
549:               
550:                   if(sdmmc_cmdtable[cmd].responsetype == R1b)
  18A6    0EE8     MOVLW 0xe8
  18A8    6E14     MOVWF 0x14, ACCESS
  18AA    0E65     MOVLW 0x65
  18AC    6E15     MOVWF 0x15, ACCESS
  18AE    0E00     MOVLW 0
  18B0    6E16     MOVWF 0x16, ACCESS
  18B2    0EFE     MOVLW 0xfe
  18B4    CFDB     MOVFF 0xfdb, 0x17
  18B6    F017     NOP
  18B8    6A18     CLRF 0x18, ACCESS
  18BA    6A19     CLRF 0x19, ACCESS
  18BC    0E02     MOVLW 0x2
  18BE    90D8     BCF 0xfd8, 0, ACCESS
  18C0    3617     RLCF 0x17, F, ACCESS
  18C2    3618     RLCF 0x18, F, ACCESS
  18C4    3619     RLCF 0x19, F, ACCESS
  18C6    06E8     DECF 0xfe8, F, ACCESS
  18C8    E1FA     BNZ 0x18be
  18CA    5014     MOVF 0x14, W, ACCESS
  18CC    2417     ADDWF 0x17, W, ACCESS
  18CE    6EF3     MOVWF 0xff3, ACCESS
  18D0    5015     MOVF 0x15, W, ACCESS
  18D2    2018     ADDWFC 0x18, W, ACCESS
  18D4    6EF4     MOVWF 0xff4, ACCESS
  18D6    5016     MOVF 0x16, W, ACCESS
  18D8    2019     ADDWFC 0x19, W, ACCESS
  18DA    6EF8     MOVWF 0xff8, ACCESS
  18DC    CFF4     MOVFF 0xff4, 0xff7
  18DE    FFF7     NOP
  18E0    CFF3     MOVFF 0xff3, 0xff6
  18E2    FFF6     NOP
  18E4    0E02     MOVLW 0x2
  18E6    26F6     ADDWF 0xff6, F, ACCESS
  18E8    0E00     MOVLW 0
  18EA    22F7     ADDWFC 0xff7, F, ACCESS
  18EC    22F8     ADDWFC 0xff8, F, ACCESS
  18EE    0008     TBLRD*
  18F0    50F5     MOVF 0xff5, W, ACCESS
  18F2    0801     SUBLW 0x1
  18F4    E128     BNZ 0x1946
551:                   {
552:                       response.r1._byte = 0x00;
  18F6    0E03     MOVLW 0x3
  18F8    6ADB     CLRF 0xfdb, ACCESS
553:                       
554:                       for(index =0; index < 0xFF && response.r1._byte == 0x00; index++)
  18FA    0E02     MOVLW 0x2
  18FC    6ADB     CLRF 0xfdb, ACCESS
  18FE    0EFF     MOVLW 0xff
  1900    6EF3     MOVWF 0xff3, ACCESS
  1902    0E02     MOVLW 0x2
  1904    CFDB     MOVFF 0xfdb, 0xff4
  1906    FFF4     NOP
  1908    50F3     MOVF 0xff3, W, ACCESS
  190A    5CF4     SUBWF 0xff4, W, ACCESS
  190C    E21C     BC 0x1946
  190E    0E03     MOVLW 0x3
  1910    50DB     MOVF 0xfdb, W, ACCESS
  1912    E119     BNZ 0x1946
  1940    0E02     MOVLW 0x2
  1942    2ADB     INCF 0xfdb, F, ACCESS
  1944    D7DC     BRA 0x18fe
555:                       {
556:                           timeout = 0xFFFF;
  1914    68DE     SETF 0xfde, ACCESS
  1916    68DD     SETF 0xfdd, ACCESS
557:                           
558:                           do
559:                           {
560:                               response.r1._byte = ReadMediaManual();
  1918    ECA3     CALL 0x2146, 0
  191A    F010     NOP
  191C    6EE7     MOVWF 0xfe7, ACCESS
  191E    0E03     MOVLW 0x3
  1920    CFE7     MOVFF 0xfe7, 0xfdb
  1922    FFDB     NOP
561:                               timeout--;
  1924    06DF     DECF 0xfdf, F, ACCESS
  1926    0E01     MOVLW 0x1
  1928    E201     BC 0x192c
  192A    06DB     DECF 0xfdb, F, ACCESS
562:                           }while(response.r1._byte == 0x00 && timeout != 0);
  192C    0E03     MOVLW 0x3
  192E    50DB     MOVF 0xfdb, W, ACCESS
  1930    E107     BNZ 0x1940
  1932    CFD9     MOVFF 0xfd9, 0xfe9
  1934    FFE9     NOP
  1936    CFDA     MOVFF 0xfda, 0xfea
  1938    FFEA     NOP
  193A    50EE     MOVF 0xfee, W, ACCESS
  193C    10ED     IORWF 0xfed, W, ACCESS
  193E    E1EC     BNZ 0x1918
563:                       }
564:                   }
565:                   if (sdmmc_cmdtable[cmd].responsetype == R7)
  1946    0EE8     MOVLW 0xe8
  1948    6E14     MOVWF 0x14, ACCESS
  194A    0E65     MOVLW 0x65
  194C    6E15     MOVWF 0x15, ACCESS
  194E    0E00     MOVLW 0
  1950    6E16     MOVWF 0x16, ACCESS
  1952    0EFE     MOVLW 0xfe
  1954    CFDB     MOVFF 0xfdb, 0x17
  1956    F017     NOP
  1958    6A18     CLRF 0x18, ACCESS
  195A    6A19     CLRF 0x19, ACCESS
  195C    0E02     MOVLW 0x2
  195E    90D8     BCF 0xfd8, 0, ACCESS
  1960    3617     RLCF 0x17, F, ACCESS
  1962    3618     RLCF 0x18, F, ACCESS
  1964    3619     RLCF 0x19, F, ACCESS
  1966    06E8     DECF 0xfe8, F, ACCESS
  1968    E1FA     BNZ 0x195e
  196A    5014     MOVF 0x14, W, ACCESS
  196C    2417     ADDWF 0x17, W, ACCESS
  196E    6EF3     MOVWF 0xff3, ACCESS
  1970    5015     MOVF 0x15, W, ACCESS
  1972    2018     ADDWFC 0x18, W, ACCESS
  1974    6EF4     MOVWF 0xff4, ACCESS
  1976    5016     MOVF 0x16, W, ACCESS
  1978    2019     ADDWFC 0x19, W, ACCESS
  197A    6EF8     MOVWF 0xff8, ACCESS
  197C    CFF4     MOVFF 0xff4, 0xff7
  197E    FFF7     NOP
  1980    CFF3     MOVFF 0xff3, 0xff6
  1982    FFF6     NOP
  1984    0E02     MOVLW 0x2
  1986    26F6     ADDWF 0xff6, F, ACCESS
  1988    0E00     MOVLW 0
  198A    22F7     ADDWFC 0xff7, F, ACCESS
  198C    22F8     ADDWFC 0xff8, F, ACCESS
  198E    0008     TBLRD*
  1990    50F5     MOVF 0xff5, W, ACCESS
  1992    0804     SUBLW 0x4
  1994    E165     BNZ 0x1a60
566:                   {
567:                       response.r7.bytewise._returnVal = (DWORD)ReadMediaManual() << 24;
  1996    DBD7     RCALL 0x2146
  1998    6E14     MOVWF 0x14, ACCESS
  199A    6A15     CLRF 0x15, ACCESS
  199C    6A16     CLRF 0x16, ACCESS
  199E    6A17     CLRF 0x17, ACCESS
  19A0    0E18     MOVLW 0x18
  19A2    0B1F     ANDLW 0x1f
  19A4    E007     BZ 0x19b4
  19A6    90D8     BCF 0xfd8, 0, ACCESS
  19A8    3614     RLCF 0x14, F, ACCESS
  19AA    3615     RLCF 0x15, F, ACCESS
  19AC    3616     RLCF 0x16, F, ACCESS
  19AE    3617     RLCF 0x17, F, ACCESS
  19B0    06E8     DECF 0xfe8, F, ACCESS
  19B2    E1F9     BNZ 0x19a6
  19B4    0E04     MOVLW 0x4
  19B6    C014     MOVFF 0x14, 0xfdb
  19B8    FFDB     NOP
  19BA    0E05     MOVLW 0x5
  19BC    C015     MOVFF 0x15, 0xfdb
  19BE    FFDB     NOP
  19C0    0E06     MOVLW 0x6
  19C2    C016     MOVFF 0x16, 0xfdb
  19C4    FFDB     NOP
  19C6    0E07     MOVLW 0x7
  19C8    C017     MOVFF 0x17, 0xfdb
  19CA    FFDB     NOP
568:                       response.r7.bytewise._returnVal += (DWORD)ReadMediaManual() << 16;
  19CC    DBBC     RCALL 0x2146
  19CE    6E14     MOVWF 0x14, ACCESS
  19D0    6A15     CLRF 0x15, ACCESS
  19D2    6A16     CLRF 0x16, ACCESS
  19D4    6A17     CLRF 0x17, ACCESS
  19D6    0E10     MOVLW 0x10
  19D8    0B1F     ANDLW 0x1f
  19DA    E007     BZ 0x19ea
  19DC    90D8     BCF 0xfd8, 0, ACCESS
  19DE    3614     RLCF 0x14, F, ACCESS
  19E0    3615     RLCF 0x15, F, ACCESS
  19E2    3616     RLCF 0x16, F, ACCESS
  19E4    3617     RLCF 0x17, F, ACCESS
  19E6    06E8     DECF 0xfe8, F, ACCESS
  19E8    E1F9     BNZ 0x19dc
  19EA    50D9     MOVF 0xfd9, W, ACCESS
  19EC    0F04     ADDLW 0x4
  19EE    6EE9     MOVWF 0xfe9, ACCESS
  19F0    CFDA     MOVFF 0xfda, 0xfea
  19F2    FFEA     NOP
  19F4    5014     MOVF 0x14, W, ACCESS
  19F6    26EE     ADDWF 0xfee, F, ACCESS
  19F8    5015     MOVF 0x15, W, ACCESS
  19FA    22EE     ADDWFC 0xfee, F, ACCESS
  19FC    5016     MOVF 0x16, W, ACCESS
  19FE    22EE     ADDWFC 0xfee, F, ACCESS
  1A00    5017     MOVF 0x17, W, ACCESS
  1A02    22EE     ADDWFC 0xfee, F, ACCESS
569:                       response.r7.bytewise._returnVal += (DWORD)ReadMediaManual() << 8;
  1A04    DBA0     RCALL 0x2146
  1A06    6E14     MOVWF 0x14, ACCESS
  1A08    6A15     CLRF 0x15, ACCESS
  1A0A    6A16     CLRF 0x16, ACCESS
  1A0C    6A17     CLRF 0x17, ACCESS
  1A0E    0E08     MOVLW 0x8
  1A10    0B1F     ANDLW 0x1f
  1A12    E007     BZ 0x1a22
  1A14    90D8     BCF 0xfd8, 0, ACCESS
  1A16    3614     RLCF 0x14, F, ACCESS
  1A18    3615     RLCF 0x15, F, ACCESS
  1A1A    3616     RLCF 0x16, F, ACCESS
  1A1C    3617     RLCF 0x17, F, ACCESS
  1A1E    06E8     DECF 0xfe8, F, ACCESS
  1A20    E1F9     BNZ 0x1a14
  1A22    50D9     MOVF 0xfd9, W, ACCESS
  1A24    0F04     ADDLW 0x4
  1A26    6EE9     MOVWF 0xfe9, ACCESS
  1A28    CFDA     MOVFF 0xfda, 0xfea
  1A2A    FFEA     NOP
  1A2C    5014     MOVF 0x14, W, ACCESS
  1A2E    26EE     ADDWF 0xfee, F, ACCESS
  1A30    5015     MOVF 0x15, W, ACCESS
  1A32    22EE     ADDWFC 0xfee, F, ACCESS
  1A34    5016     MOVF 0x16, W, ACCESS
  1A36    22EE     ADDWFC 0xfee, F, ACCESS
  1A38    5017     MOVF 0x17, W, ACCESS
  1A3A    22EE     ADDWFC 0xfee, F, ACCESS
570:                       response.r7.bytewise._returnVal += (DWORD)ReadMediaManual();
  1A3C    DB84     RCALL 0x2146
  1A3E    6E14     MOVWF 0x14, ACCESS
  1A40    6A15     CLRF 0x15, ACCESS
  1A42    6A16     CLRF 0x16, ACCESS
  1A44    6A17     CLRF 0x17, ACCESS
  1A46    50D9     MOVF 0xfd9, W, ACCESS
  1A48    0F04     ADDLW 0x4
  1A4A    6EE9     MOVWF 0xfe9, ACCESS
  1A4C    CFDA     MOVFF 0xfda, 0xfea
  1A4E    FFEA     NOP
  1A50    5014     MOVF 0x14, W, ACCESS
  1A52    26EE     ADDWF 0xfee, F, ACCESS
  1A54    5015     MOVF 0x15, W, ACCESS
  1A56    22EE     ADDWFC 0xfee, F, ACCESS
  1A58    5016     MOVF 0x16, W, ACCESS
  1A5A    22EE     ADDWFC 0xfee, F, ACCESS
  1A5C    5017     MOVF 0x17, W, ACCESS
  1A5E    22EE     ADDWFC 0xfee, F, ACCESS
571:                   }
572:               
573:                   WriteSPIManual(0xFF);                      //Required clocking (see spec)
  1A60    68E6     SETF 0xfe6, ACCESS
  1A62    DB32     RCALL 0x20c8
  1A64    52E5     MOVF 0xfe5, F, ACCESS
574:               
575:                   // see if we are expecting data or not
576:                   if(!(sdmmc_cmdtable[cmd].moredataexpected))
  1A66    0EE8     MOVLW 0xe8
  1A68    6E14     MOVWF 0x14, ACCESS
  1A6A    0E65     MOVLW 0x65
  1A6C    6E15     MOVWF 0x15, ACCESS
  1A6E    0E00     MOVLW 0
  1A70    6E16     MOVWF 0x16, ACCESS
  1A72    0EFE     MOVLW 0xfe
  1A74    CFDB     MOVFF 0xfdb, 0x17
  1A76    F017     NOP
  1A78    6A18     CLRF 0x18, ACCESS
  1A7A    6A19     CLRF 0x19, ACCESS
  1A7C    0E02     MOVLW 0x2
  1A7E    90D8     BCF 0xfd8, 0, ACCESS
  1A80    3617     RLCF 0x17, F, ACCESS
  1A82    3618     RLCF 0x18, F, ACCESS
  1A84    3619     RLCF 0x19, F, ACCESS
  1A86    06E8     DECF 0xfe8, F, ACCESS
  1A88    E1FA     BNZ 0x1a7e
  1A8A    5014     MOVF 0x14, W, ACCESS
  1A8C    2417     ADDWF 0x17, W, ACCESS
  1A8E    6EF3     MOVWF 0xff3, ACCESS
  1A90    5015     MOVF 0x15, W, ACCESS
  1A92    2018     ADDWFC 0x18, W, ACCESS
  1A94    6EF4     MOVWF 0xff4, ACCESS
  1A96    5016     MOVF 0x16, W, ACCESS
  1A98    2019     ADDWFC 0x19, W, ACCESS
  1A9A    6EF8     MOVWF 0xff8, ACCESS
  1A9C    CFF4     MOVFF 0xff4, 0xff7
  1A9E    FFF7     NOP
  1AA0    CFF3     MOVFF 0xff3, 0xff6
  1AA2    FFF6     NOP
  1AA4    0E03     MOVLW 0x3
  1AA6    26F6     ADDWF 0xff6, F, ACCESS
  1AA8    0E00     MOVLW 0
  1AAA    22F7     ADDWFC 0xff7, F, ACCESS
  1AAC    22F8     ADDWFC 0xff8, F, ACCESS
  1AAE    0008     TBLRD*
  1AB0    50F5     MOVF 0xff5, W, ACCESS
  1AB2    E101     BNZ 0x1ab6
577:                       SD_CS = 1;
  1AB4    8081     BSF 0xf81, 0, ACCESS
578:               
579:                   return(response);
  1AB6    0E03     MOVLW 0x3
  1AB8    CFDB     MOVFF 0xfdb, 0x14
  1ABA    F014     NOP
  1ABC    0E04     MOVLW 0x4
  1ABE    CFDB     MOVFF 0xfdb, 0x15
  1AC0    F015     NOP
  1AC2    0E05     MOVLW 0x5
  1AC4    CFDB     MOVFF 0xfdb, 0x16
  1AC6    F016     NOP
  1AC8    0E06     MOVLW 0x6
  1ACA    CFDB     MOVFF 0xfdb, 0x17
  1ACC    F017     NOP
  1ACE    0E07     MOVLW 0x7
  1AD0    CFDB     MOVFF 0xfdb, 0x18
  1AD2    F018     NOP
  1AD4    CFD9     MOVFF 0xfd9, 0xfe9
  1AD6    FFE9     NOP
  1AD8    CFDA     MOVFF 0xfda, 0xfea
  1ADA    FFEA     NOP
  1ADC    50ED     MOVF 0xfed, W, ACCESS
  1ADE    50ED     MOVF 0xfed, W, ACCESS
  1AE0    C018     MOVFF 0x18, 0xfed
  1AE2    FFED     NOP
  1AE4    C017     MOVFF 0x17, 0xfed
  1AE6    FFED     NOP
  1AE8    C016     MOVFF 0x16, 0xfed
  1AEA    FFED     NOP
  1AEC    C015     MOVFF 0x15, 0xfed
  1AEE    FFED     NOP
  1AF0    C014     MOVFF 0x14, 0xfef
  1AF2    FFEF     NOP
580:               }
  1AF4    0E0E     MOVLW 0xe
  1AF6    5CE1     SUBWF 0xfe1, W, ACCESS
  1AF8    E202     BC 0x1afe
  1AFA    6AE1     CLRF 0xfe1, ACCESS
  1AFC    52E5     MOVF 0xfe5, F, ACCESS
  1AFE    6EE1     MOVWF 0xfe1, ACCESS
  1B00    52E5     MOVF 0xfe5, F, ACCESS
  1B02    CFE7     MOVFF 0xfe7, 0xfd9
  1B04    FFD9     NOP
  1B06    0012     RETURN 0
581:               #endif
582:               #endif
583:               
584:               
585:               
586:               /*****************************************************************************
587:                 Function:
588:                   BYTE MDD_SDSPI_SectorRead (DWORD sector_addr, BYTE * buffer)
589:                 Summary:
590:                   Reads a sector of data from an SD card.
591:                 Conditions:
592:                   The MDD_SectorRead function pointer must be pointing towards this function.
593:                 Input:
594:                   sector_addr - The address of the sector on the card.
595:                   byffer -      The buffer where the retrieved data will be stored.  If
596:                                 buffer is NULL, do not store the data anywhere.
597:                 Return Values:
598:                   TRUE -  The sector was read successfully
599:                   FALSE - The sector could not be read
600:                 Side Effects:
601:                   None
602:                 Description:
603:                   The MDD_SDSPI_SectorRead function reads a sector of data bytes (512 bytes) 
604:                   of data from the SD card starting at the sector address and stores them in 
605:                   the location pointed to by 'buffer.'
606:                 Remarks:
607:                   The card expects the address field in the command packet to be a byte address.
608:                   The sector_addr value is converted to a byte address by shifting it left nine
609:                   times (multiplying by 512).
610:                 ***************************************************************************************/
611:               
612:               BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer)
  1B08    CFD9     MOVFF 0xfd9, 0xfe6
  1B0A    FFE6     NOP
  1B0C    CFE1     MOVFF 0xfe1, 0xfd9
  1B0E    FFD9     NOP
  1B10    0E0F     MOVLW 0xf
  1B12    26E1     ADDWF 0xfe1, F, ACCESS
613:               {
614:                   WORD index;
615:                   WORD delay;
616:                   MMC_RESPONSE    response;
617:                   BYTE data_token;
618:                   BYTE status = TRUE;
  1B14    0E01     MOVLW 0x1
  1B16    6EF3     MOVWF 0xff3, ACCESS
  1B18    0E0A     MOVLW 0xa
  1B1A    CFF3     MOVFF 0xff3, 0xfdb
  1B1C    FFDB     NOP
619:                   DWORD   new_addr;
620:                  
621:                   // send the cmd
622:                   if (gSDMode == SD_MODE_NORMAL)
  1B1E    0101     MOVLB 0x1
  1B20    51D5     MOVF 0xd5, W, BANKED
  1B22    E123     BNZ 0x1b6a
623:                       new_addr = sector_addr << 9;
  1B24    0EFB     MOVLW 0xfb
  1B26    CFDB     MOVFF 0xfdb, 0x14
  1B28    F014     NOP
  1B2A    0EFC     MOVLW 0xfc
  1B2C    CFDB     MOVFF 0xfdb, 0x15
  1B2E    F015     NOP
  1B30    0EFD     MOVLW 0xfd
  1B32    CFDB     MOVFF 0xfdb, 0x16
  1B34    F016     NOP
  1B36    0EFE     MOVLW 0xfe
  1B38    CFDB     MOVFF 0xfdb, 0x17
  1B3A    F017     NOP
  1B3C    0E09     MOVLW 0x9
  1B3E    0B1F     ANDLW 0x1f
  1B40    E007     BZ 0x1b50
  1B42    90D8     BCF 0xfd8, 0, ACCESS
  1B44    3614     RLCF 0x14, F, ACCESS
  1B46    3615     RLCF 0x15, F, ACCESS
  1B48    3616     RLCF 0x16, F, ACCESS
  1B4A    3617     RLCF 0x17, F, ACCESS
  1B4C    06E8     DECF 0xfe8, F, ACCESS
  1B4E    E1F9     BNZ 0x1b42
  1B50    0E0B     MOVLW 0xb
  1B52    C014     MOVFF 0x14, 0xfdb
  1B54    FFDB     NOP
  1B56    0E0C     MOVLW 0xc
  1B58    C015     MOVFF 0x15, 0xfdb
  1B5A    FFDB     NOP
  1B5C    0E0D     MOVLW 0xd
  1B5E    C016     MOVFF 0x16, 0xfdb
  1B60    FFDB     NOP
  1B62    0E0E     MOVLW 0xe
  1B64    C017     MOVFF 0x17, 0xfdb
  1B66    FFDB     NOP
624:                   else
  1B68    D012     BRA 0x1b8e
625:                       new_addr = sector_addr;
  1B6A    50D9     MOVF 0xfd9, W, ACCESS
  1B6C    0FFB     ADDLW 0xfb
  1B6E    6EE9     MOVWF 0xfe9, ACCESS
  1B70    0EFF     MOVLW 0xff
  1B72    20DA     ADDWFC 0xfda, W, ACCESS
  1B74    6EEA     MOVWF 0xfea, ACCESS
  1B76    0E0B     MOVLW 0xb
  1B78    CFEE     MOVFF 0xfee, 0xfdb
  1B7A    FFDB     NOP
  1B7C    0E0C     MOVLW 0xc
  1B7E    CFEE     MOVFF 0xfee, 0xfdb
  1B80    FFDB     NOP
  1B82    0E0D     MOVLW 0xd
  1B84    CFEE     MOVFF 0xfee, 0xfdb
  1B86    FFDB     NOP
  1B88    0E0E     MOVLW 0xe
  1B8A    CFEE     MOVFF 0xfee, 0xfdb
  1B8C    FFDB     NOP
626:                   response = SendMMCCmd(READ_SINGLE_BLOCK,new_addr);
  1B8E    50D9     MOVF 0xfd9, W, ACCESS
  1B90    0F0B     ADDLW 0xb
  1B92    6EE9     MOVWF 0xfe9, ACCESS
  1B94    CFDA     MOVFF 0xfda, 0xfea
  1B96    FFEA     NOP
  1B98    CFEE     MOVFF 0xfee, 0xfe6
  1B9A    FFE6     NOP
  1B9C    CFEE     MOVFF 0xfee, 0xfe6
  1B9E    FFE6     NOP
  1BA0    CFEE     MOVFF 0xfee, 0xfe6
  1BA2    FFE6     NOP
  1BA4    CFEF     MOVFF 0xfef, 0xfe6
  1BA6    FFE6     NOP
  1BA8    0E08     MOVLW 0x8
  1BAA    6EE6     MOVWF 0xfe6, ACCESS
  1BAC    EC81     CALL 0x1102, 0
  1BAE    F008     NOP
  1BB0    CFEE     MOVFF 0xfee, 0x14
  1BB2    F014     NOP
  1BB4    CFEE     MOVFF 0xfee, 0x15
  1BB6    F015     NOP
  1BB8    CFEE     MOVFF 0xfee, 0x16
  1BBA    F016     NOP
  1BBC    CFEE     MOVFF 0xfee, 0x17
  1BBE    F017     NOP
  1BC0    CFEE     MOVFF 0xfee, 0x18
  1BC2    F018     NOP
  1BC4    6E19     MOVWF 0x19, ACCESS
  1BC6    0E05     MOVLW 0x5
  1BC8    5EE1     SUBWF 0xfe1, F, ACCESS
  1BCA    5019     MOVF 0x19, W, ACCESS
  1BCC    0E04     MOVLW 0x4
  1BCE    C014     MOVFF 0x14, 0xfdb
  1BD0    FFDB     NOP
  1BD2    0E05     MOVLW 0x5
  1BD4    C015     MOVFF 0x15, 0xfdb
  1BD6    FFDB     NOP
  1BD8    0E06     MOVLW 0x6
  1BDA    C016     MOVFF 0x16, 0xfdb
  1BDC    FFDB     NOP
  1BDE    0E07     MOVLW 0x7
  1BE0    C017     MOVFF 0x17, 0xfdb
  1BE2    FFDB     NOP
  1BE4    0E08     MOVLW 0x8
  1BE6    C018     MOVFF 0x18, 0xfdb
  1BE8    FFDB     NOP
627:               
628:                   // Make sure the command was accepted
629:                   if(response.r1._byte != 0x00)
  1BEA    0E04     MOVLW 0x4
  1BEC    50DB     MOVF 0xfdb, W, ACCESS
  1BEE    E033     BZ 0x1c56
630:                   {
631:                       response = SendMMCCmd (READ_SINGLE_BLOCK,new_addr);
  1BF0    50D9     MOVF 0xfd9, W, ACCESS
  1BF2    0F0B     ADDLW 0xb
  1BF4    6EE9     MOVWF 0xfe9, ACCESS
  1BF6    CFDA     MOVFF 0xfda, 0xfea
  1BF8    FFEA     NOP
  1BFA    CFEE     MOVFF 0xfee, 0xfe6
  1BFC    FFE6     NOP
  1BFE    CFEE     MOVFF 0xfee, 0xfe6
  1C00    FFE6     NOP
  1C02    CFEE     MOVFF 0xfee, 0xfe6
  1C04    FFE6     NOP
  1C06    CFEF     MOVFF 0xfef, 0xfe6
  1C08    FFE6     NOP
  1C0A    0E08     MOVLW 0x8
  1C0C    6EE6     MOVWF 0xfe6, ACCESS
  1C0E    EC81     CALL 0x1102, 0
  1C10    F008     NOP
  1C12    CFEE     MOVFF 0xfee, 0x14
  1C14    F014     NOP
  1C16    CFEE     MOVFF 0xfee, 0x15
  1C18    F015     NOP
  1C1A    CFEE     MOVFF 0xfee, 0x16
  1C1C    F016     NOP
  1C1E    CFEE     MOVFF 0xfee, 0x17
  1C20    F017     NOP
  1C22    CFEE     MOVFF 0xfee, 0x18
  1C24    F018     NOP
  1C26    6E19     MOVWF 0x19, ACCESS
  1C28    0E05     MOVLW 0x5
  1C2A    5EE1     SUBWF 0xfe1, F, ACCESS
  1C2C    5019     MOVF 0x19, W, ACCESS
  1C2E    0E04     MOVLW 0x4
  1C30    C014     MOVFF 0x14, 0xfdb
  1C32    FFDB     NOP
  1C34    0E05     MOVLW 0x5
  1C36    C015     MOVFF 0x15, 0xfdb
  1C38    FFDB     NOP
  1C3A    0E06     MOVLW 0x6
  1C3C    C016     MOVFF 0x16, 0xfdb
  1C3E    FFDB     NOP
  1C40    0E07     MOVLW 0x7
  1C42    C017     MOVFF 0x17, 0xfdb
  1C44    FFDB     NOP
  1C46    0E08     MOVLW 0x8
  1C48    C018     MOVFF 0x18, 0xfdb
  1C4A    FFDB     NOP
632:                       if(response.r1._byte != 0x00)
  1C4C    0E04     MOVLW 0x4
  1C4E    50DB     MOVF 0xfdb, W, ACCESS
  1C50    E002     BZ 0x1c56
633:                       {
634:                           return FALSE;
  1C52    0E00     MOVLW 0
  1C54    D08C     BRA 0x1d6e
635:                       }
636:                   }
637:               
638:                   index = 0x2FF;
  1C56    68DE     SETF 0xfde, ACCESS
  1C58    0E02     MOVLW 0x2
  1C5A    6EDD     MOVWF 0xfdd, ACCESS
639:                   
640:                   // Timing delay- at least 8 clock cycles
641:                   delay = 0x40;
  1C5C    0E40     MOVLW 0x40
  1C5E    6EF3     MOVWF 0xff3, ACCESS
  1C60    0E02     MOVLW 0x2
  1C62    CFF3     MOVFF 0xff3, 0xfdb
  1C64    FFDB     NOP
  1C66    0E03     MOVLW 0x3
  1C68    6ADB     CLRF 0xfdb, ACCESS
642:                   while (delay)
  1C6A    50D9     MOVF 0xfd9, W, ACCESS
  1C6C    0F02     ADDLW 0x2
  1C6E    6EE9     MOVWF 0xfe9, ACCESS
  1C70    CFDA     MOVFF 0xfda, 0xfea
  1C72    FFEA     NOP
  1C74    50EE     MOVF 0xfee, W, ACCESS
  1C76    10ED     IORWF 0xfed, W, ACCESS
  1C78    E006     BZ 0x1c86
  1C84    D7F2     BRA 0x1c6a
643:                       delay--;
  1C7A    0E02     MOVLW 0x2
  1C7C    06DB     DECF 0xfdb, F, ACCESS
  1C7E    0E03     MOVLW 0x3
  1C80    E2F4     BC 0x1c6a
  1C82    06DB     DECF 0xfdb, F, ACCESS
644:                 
645:                   //Now, must wait for the start token of data block
646:                   do
647:                   {
648:                       data_token = MDD_SDSPI_ReadMedia();
  1C86    D9FC     RCALL 0x2080
  1C88    6EE7     MOVWF 0xfe7, ACCESS
  1C8A    0E09     MOVLW 0x9
  1C8C    CFE7     MOVFF 0xfe7, 0xfdb
  1C8E    FFDB     NOP
649:                       index--;   
  1C90    06DF     DECF 0xfdf, F, ACCESS
  1C92    0E01     MOVLW 0x1
  1C94    E201     BC 0x1c98
  1C96    06DB     DECF 0xfdb, F, ACCESS
650:                       
651:                       delay = 0x40;
  1C98    0E40     MOVLW 0x40
  1C9A    6EF3     MOVWF 0xff3, ACCESS
  1C9C    0E02     MOVLW 0x2
  1C9E    CFF3     MOVFF 0xff3, 0xfdb
  1CA0    FFDB     NOP
  1CA2    0E03     MOVLW 0x3
  1CA4    6ADB     CLRF 0xfdb, ACCESS
652:                       while (delay)
  1CA6    50D9     MOVF 0xfd9, W, ACCESS
  1CA8    0F02     ADDLW 0x2
  1CAA    6EE9     MOVWF 0xfe9, ACCESS
  1CAC    CFDA     MOVFF 0xfda, 0xfea
  1CAE    FFEA     NOP
  1CB0    50EE     MOVF 0xfee, W, ACCESS
  1CB2    10ED     IORWF 0xfed, W, ACCESS
  1CB4    E006     BZ 0x1cc2
  1CC0    D7F2     BRA 0x1ca6
653:                           delay--;
  1CB6    0E02     MOVLW 0x2
  1CB8    06DB     DECF 0xfdb, F, ACCESS
  1CBA    0E03     MOVLW 0x3
  1CBC    E2F4     BC 0x1ca6
  1CBE    06DB     DECF 0xfdb, F, ACCESS
654:               
655:                   }while((data_token == MMC_FLOATING_BUS) && (index != 0));
  1CC2    0E09     MOVLW 0x9
  1CC4    50DB     MOVF 0xfdb, W, ACCESS
  1CC6    08FF     SUBLW 0xff
  1CC8    E107     BNZ 0x1cd8
  1CCA    CFD9     MOVFF 0xfd9, 0xfe9
  1CCC    FFE9     NOP
  1CCE    CFDA     MOVFF 0xfda, 0xfea
  1CD0    FFEA     NOP
  1CD2    50EE     MOVF 0xfee, W, ACCESS
  1CD4    10ED     IORWF 0xfed, W, ACCESS
  1CD6    E1D7     BNZ 0x1c86
656:               
657:                   // Hopefully that zero is the datatoken
658:                   if((index == 0) || (data_token != DATA_START_TOKEN))
  1CD8    CFD9     MOVFF 0xfd9, 0xfe9
  1CDA    FFE9     NOP
  1CDC    CFDA     MOVFF 0xfda, 0xfea
  1CDE    FFEA     NOP
  1CE0    50EE     MOVF 0xfee, W, ACCESS
  1CE2    10ED     IORWF 0xfed, W, ACCESS
  1CE4    E004     BZ 0x1cee
  1CE6    0E09     MOVLW 0x9
  1CE8    50DB     MOVF 0xfdb, W, ACCESS
  1CEA    08FE     SUBLW 0xfe
  1CEC    E003     BZ 0x1cf4
659:                   {
660:                       status = FALSE;
  1CEE    0E0A     MOVLW 0xa
  1CF0    6ADB     CLRF 0xfdb, ACCESS
661:                   }
662:                   else
  1CF2    D037     BRA 0x1d62
663:                   {
664:                       for(index = 0; index < gMediaSectorSize; index++)      //Reads in a sector of data (512 bytes)
  1CF4    6ADE     CLRF 0xfde, ACCESS
  1CF6    6ADD     CLRF 0xfdd, ACCESS
  1CF8    CFDE     MOVFF 0xfde, 0x14
  1CFA    F014     NOP
  1CFC    CFDD     MOVFF 0xfdd, 0x15
  1CFE    F015     NOP
  1D00    0101     MOVLB 0x1
  1D02    51D3     MOVF 0xd3, W, BANKED
  1D04    5C14     SUBWF 0x14, W, ACCESS
  1D06    51D4     MOVF 0xd4, W, BANKED
  1D08    5815     SUBWFB 0x15, W, ACCESS
  1D0A    E225     BC 0x1d56
  1D4C    2ADF     INCF 0xfdf, F, ACCESS
  1D4E    0E01     MOVLW 0x1
  1D50    E3D3     BNC 0x1cf8
  1D52    2ADB     INCF 0xfdb, F, ACCESS
  1D54    D7D1     BRA 0x1cf8
665:                       {
666:                           if(buffer != NULL)
  1D0C    50D9     MOVF 0xfd9, W, ACCESS
  1D0E    0FF9     ADDLW 0xf9
  1D10    6EE9     MOVWF 0xfe9, ACCESS
  1D12    0EFF     MOVLW 0xff
  1D14    20DA     ADDWFC 0xfda, W, ACCESS
  1D16    6EEA     MOVWF 0xfea, ACCESS
  1D18    50EE     MOVF 0xfee, W, ACCESS
  1D1A    10ED     IORWF 0xfed, W, ACCESS
  1D1C    E016     BZ 0x1d4a
667:                           {
668:               				#ifdef __18CXX
669:               	                data_token = SPIBUF;
  1D1E    0E09     MOVLW 0x9
  1D20    CF75     MOVFF 0xf75, 0xfdb
  1D22    FFDB     NOP
670:               	                SPI_INTERRUPT_FLAG = 0;
  1D24    9EA4     BCF 0xfa4, 0x7, ACCESS
671:               	                SPIBUF = 0xFF;
  1D26    6875     SETF 0xf75, ACCESS
672:               	                while(!SPI_INTERRUPT_FLAG);
  1D28    AEA4     BTFSS 0xfa4, 0x7, ACCESS
  1D2A    D7FE     BRA 0x1d28
673:               	                buffer[index] = SPIBUF;
  1D2C    0EF9     MOVLW 0xf9
  1D2E    CFDB     MOVFF 0xfdb, 0x14
  1D30    F014     NOP
  1D32    0EFA     MOVLW 0xfa
  1D34    CFDB     MOVFF 0xfdb, 0x15
  1D36    F015     NOP
  1D38    50DE     MOVF 0xfde, W, ACCESS
  1D3A    2414     ADDWF 0x14, W, ACCESS
  1D3C    6EE9     MOVWF 0xfe9, ACCESS
  1D3E    50DD     MOVF 0xfdd, W, ACCESS
  1D40    2015     ADDWFC 0x15, W, ACCESS
  1D42    6EEA     MOVWF 0xfea, ACCESS
  1D44    CF75     MOVFF 0xf75, 0xfef
  1D46    FFEF     NOP
674:               				#elif defined (__PIC32MX__)
675:                               	buffer[index] = MDD_SDSPI_ReadMedia();
676:               				#else
677:               	                SPIBUF = 0xFF;
678:               	                while (!SPISTAT_RBF);
679:               	                buffer[index] = SPIBUF;
680:               				#endif
681:                           }
682:                           else
  1D48    D001     BRA 0x1d4c
683:                           {
684:                               MDD_SDSPI_ReadMedia();
  1D4A    D99A     RCALL 0x2080
685:                           }
686:                       }
687:                       // Now ensure CRC
688:                       mReadCRC();               //Read 2 bytes of CRC
  1D56    68E6     SETF 0xfe6, ACCESS
  1D58    D97C     RCALL 0x2052
  1D5A    52E5     MOVF 0xfe5, F, ACCESS
  1D5C    68E6     SETF 0xfe6, ACCESS
  1D5E    D979     RCALL 0x2052
  1D60    52E5     MOVF 0xfe5, F, ACCESS
689:                       //status = mmcCardCRCError;
690:                   }
691:               
692:                   mSend8ClkCycles();            //Required clocking (see spec)
  1D62    68E6     SETF 0xfe6, ACCESS
  1D64    D976     RCALL 0x2052
  1D66    52E5     MOVF 0xfe5, F, ACCESS
693:               
694:                   SD_CS = 1;
  1D68    8081     BSF 0xf81, 0, ACCESS
695:               
696:                   return(status);
  1D6A    0E0A     MOVLW 0xa
  1D6C    50DB     MOVF 0xfdb, W, ACCESS
697:               }//end SectorRead
  1D6E    6E14     MOVWF 0x14, ACCESS
  1D70    0E0F     MOVLW 0xf
  1D72    5CE1     SUBWF 0xfe1, W, ACCESS
  1D74    E202     BC 0x1d7a
  1D76    6AE1     CLRF 0xfe1, ACCESS
  1D78    52E5     MOVF 0xfe5, F, ACCESS
  1D7A    6EE1     MOVWF 0xfe1, ACCESS
  1D7C    5014     MOVF 0x14, W, ACCESS
  1D7E    52E5     MOVF 0xfe5, F, ACCESS
  1D80    CFE7     MOVFF 0xfe7, 0xfd9
  1D82    FFD9     NOP
  1D84    0012     RETURN 0
698:               
699:               
700:               /*****************************************************************************
701:                 Function:
702:                   BYTE MDD_SDSPI_SectorWrite (DWORD sector_addr, BYTE * buffer, BYTE allowWriteToZero)
703:                 Summary:
704:                   Writes a sector of data to an SD card.
705:                 Conditions:
706:                   The MDD_SectorWrite function pointer must be pointing to this function.
707:                 Input:
708:                   sector_addr -      The address of the sector on the card.
709:                   buffer -           The buffer with the data to write.
710:                   allowWriteToZero -
711:                                    - TRUE -  Writes to the 0 sector (MBR) are allowed
712:                                    - FALSE - Any write to the 0 sector will fail.
713:                 Return Values:
714:                   TRUE -  The sector was written successfully.
715:                   FALSE - The sector could not be written.
716:                 Side Effects:
717:                   None.
718:                 Description:
719:                   The MDD_SDSPI_SectorWrite function writes one sector of data (512 bytes) 
720:                   of data from the location pointed to by 'buffer' to the specified sector of 
721:                   the SD card.
722:                 Remarks:
723:                   The card expects the address field in the command packet to be a byte address.
724:                   The sector_addr value is ocnverted to a byte address by shifting it left nine
725:                   times (multiplying by 512).
726:                 ***************************************************************************************/
727:               
728:               BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero)
  1D86    CFD9     MOVFF 0xfd9, 0xfe6
  1D88    FFE6     NOP
  1D8A    CFE1     MOVFF 0xfe1, 0xfd9
  1D8C    FFD9     NOP
  1D8E    0E0D     MOVLW 0xd
  1D90    26E1     ADDWF 0xfe1, F, ACCESS
729:               {
730:                   WORD            index;
731:                   DWORD           counter;
732:                   BYTE            data_response;
733:                   MMC_RESPONSE    response; 
734:                   BYTE            status = TRUE;
  1D92    0E01     MOVLW 0x1
  1D94    6EF3     MOVWF 0xff3, ACCESS
  1D96    0E0C     MOVLW 0xc
  1D98    CFF3     MOVFF 0xff3, 0xfdb
  1D9A    FFDB     NOP
735:               
736:                   if (sector_addr == 0 && allowWriteToZero == FALSE)
  1D9C    0EFB     MOVLW 0xfb
  1D9E    CFDB     MOVFF 0xfdb, 0x14
  1DA0    F014     NOP
  1DA2    0EFC     MOVLW 0xfc
  1DA4    CFDB     MOVFF 0xfdb, 0x15
  1DA6    F015     NOP
  1DA8    0EFD     MOVLW 0xfd
  1DAA    CFDB     MOVFF 0xfdb, 0x16
  1DAC    F016     NOP
  1DAE    0EFE     MOVLW 0xfe
  1DB0    CFDB     MOVFF 0xfdb, 0x17
  1DB2    F017     NOP
  1DB4    5014     MOVF 0x14, W, ACCESS
  1DB6    1015     IORWF 0x15, W, ACCESS
  1DB8    1016     IORWF 0x16, W, ACCESS
  1DBA    1017     IORWF 0x17, W, ACCESS
  1DBC    E106     BNZ 0x1dca
  1DBE    0EF8     MOVLW 0xf8
  1DC0    50DB     MOVF 0xfdb, W, ACCESS
  1DC2    E103     BNZ 0x1dca
737:                       status = FALSE;
  1DC4    0E0C     MOVLW 0xc
  1DC6    6ADB     CLRF 0xfdb, ACCESS
738:                   else
  1DC8    D0F3     BRA 0x1fb0
739:                   {
740:                       // send the cmd
741:               
742:                       if (gSDMode == SD_MODE_NORMAL)
  1DCA    0101     MOVLB 0x1
  1DCC    51D5     MOVF 0xd5, W, BANKED
  1DCE    E131     BNZ 0x1e32
743:                           response = SendMMCCmd(WRITE_SINGLE_BLOCK,(sector_addr << 9));
  1DD0    0EFB     MOVLW 0xfb
  1DD2    CFDB     MOVFF 0xfdb, 0x19
  1DD4    F019     NOP
  1DD6    0EFC     MOVLW 0xfc
  1DD8    CFDB     MOVFF 0xfdb, 0x1a
  1DDA    F01A     NOP
  1DDC    0EFD     MOVLW 0xfd
  1DDE    CFDB     MOVFF 0xfdb, 0x1b
  1DE0    F01B     NOP
  1DE2    0EFE     MOVLW 0xfe
  1DE4    CFDB     MOVFF 0xfdb, 0x1c
  1DE6    F01C     NOP
  1DE8    0E09     MOVLW 0x9
  1DEA    0B1F     ANDLW 0x1f
  1DEC    E007     BZ 0x1dfc
  1DEE    90D8     BCF 0xfd8, 0, ACCESS
  1DF0    3619     RLCF 0x19, F, ACCESS
  1DF2    361A     RLCF 0x1a, F, ACCESS
  1DF4    361B     RLCF 0x1b, F, ACCESS
  1DF6    361C     RLCF 0x1c, F, ACCESS
  1DF8    06E8     DECF 0xfe8, F, ACCESS
  1DFA    E1F9     BNZ 0x1dee
  1DFC    C019     MOVFF 0x19, 0xfe6
  1DFE    FFE6     NOP
  1E00    C01A     MOVFF 0x1a, 0xfe6
  1E02    FFE6     NOP
  1E04    C01B     MOVFF 0x1b, 0xfe6
  1E06    FFE6     NOP
  1E08    C01C     MOVFF 0x1c, 0xfe6
  1E0A    FFE6     NOP
  1E0C    0E0A     MOVLW 0xa
  1E0E    6EE6     MOVWF 0xfe6, ACCESS
  1E10    EC81     CALL 0x1102, 0
  1E12    F008     NOP
  1E14    CFEE     MOVFF 0xfee, 0x14
  1E16    F014     NOP
  1E18    CFEE     MOVFF 0xfee, 0x15
  1E1A    F015     NOP
  1E1C    CFEE     MOVFF 0xfee, 0x16
  1E1E    F016     NOP
  1E20    CFEE     MOVFF 0xfee, 0x17
  1E22    F017     NOP
  1E24    CFEE     MOVFF 0xfee, 0x18
  1E26    F018     NOP
  1E28    6E1D     MOVWF 0x1d, ACCESS
  1E2A    0E05     MOVLW 0x5
  1E2C    5EE1     SUBWF 0xfe1, F, ACCESS
  1E2E    501D     MOVF 0x1d, W, ACCESS
744:                       else
  1E30    D020     BRA 0x1e72
745:                           response = SendMMCCmd(WRITE_SINGLE_BLOCK,(sector_addr));
  1E32    50D9     MOVF 0xfd9, W, ACCESS
  1E34    0FFB     ADDLW 0xfb
  1E36    6EE9     MOVWF 0xfe9, ACCESS
  1E38    0EFF     MOVLW 0xff
  1E3A    20DA     ADDWFC 0xfda, W, ACCESS
  1E3C    6EEA     MOVWF 0xfea, ACCESS
  1E3E    CFEE     MOVFF 0xfee, 0xfe6
  1E40    FFE6     NOP
  1E42    CFEE     MOVFF 0xfee, 0xfe6
  1E44    FFE6     NOP
  1E46    CFEE     MOVFF 0xfee, 0xfe6
  1E48    FFE6     NOP
  1E4A    CFEF     MOVFF 0xfef, 0xfe6
  1E4C    FFE6     NOP
  1E4E    0E0A     MOVLW 0xa
  1E50    6EE6     MOVWF 0xfe6, ACCESS
  1E52    EC81     CALL 0x1102, 0
  1E54    F008     NOP
  1E56    CFEE     MOVFF 0xfee, 0x14
  1E58    F014     NOP
  1E5A    CFEE     MOVFF 0xfee, 0x15
  1E5C    F015     NOP
  1E5E    CFEE     MOVFF 0xfee, 0x16
  1E60    F016     NOP
  1E62    CFEE     MOVFF 0xfee, 0x17
  1E64    F017     NOP
  1E66    CFEE     MOVFF 0xfee, 0x18
  1E68    F018     NOP
  1E6A    6E19     MOVWF 0x19, ACCESS
  1E6C    0E05     MOVLW 0x5
  1E6E    5EE1     SUBWF 0xfe1, F, ACCESS
  1E70    5019     MOVF 0x19, W, ACCESS
  1E72    0E07     MOVLW 0x7
  1E74    C014     MOVFF 0x14, 0xfdb
  1E76    FFDB     NOP
  1E78    0E08     MOVLW 0x8
  1E7A    C015     MOVFF 0x15, 0xfdb
  1E7C    FFDB     NOP
  1E7E    0E09     MOVLW 0x9
  1E80    C016     MOVFF 0x16, 0xfdb
  1E82    FFDB     NOP
  1E84    0E0A     MOVLW 0xa
  1E86    C017     MOVFF 0x17, 0xfdb
  1E88    FFDB     NOP
  1E8A    0E0B     MOVLW 0xb
  1E8C    C018     MOVFF 0x18, 0xfdb
  1E8E    FFDB     NOP
746:                       
747:                       // see if it was accepted
748:                       if(response.r1._byte != 0x00)
  1E90    0E07     MOVLW 0x7
  1E92    50DB     MOVF 0xfdb, W, ACCESS
  1E94    E003     BZ 0x1e9c
749:                           status = FALSE;
  1E96    0E0C     MOVLW 0xc
  1E98    6ADB     CLRF 0xfdb, ACCESS
750:                       else
  1E9A    D089     BRA 0x1fae
751:                       {
752:                           WriteSPIM(DATA_START_TOKEN);                 //Send data start token
  1E9C    0EFE     MOVLW 0xfe
  1E9E    6EE6     MOVWF 0xfe6, ACCESS
  1EA0    D8D8     RCALL 0x2052
  1EA2    52E5     MOVF 0xfe5, F, ACCESS
753:               
754:                           for(index = 0; index < gMediaSectorSize; index++)      //Send 512 bytes
  1EA4    6ADE     CLRF 0xfde, ACCESS
  1EA6    6ADD     CLRF 0xfdd, ACCESS
  1EA8    CFDE     MOVFF 0xfde, 0x14
  1EAA    F014     NOP
  1EAC    CFDD     MOVFF 0xfdd, 0x15
  1EAE    F015     NOP
  1EB0    0101     MOVLB 0x1
  1EB2    51D3     MOVF 0xd3, W, BANKED
  1EB4    5C14     SUBWF 0x14, W, ACCESS
  1EB6    51D4     MOVF 0xd4, W, BANKED
  1EB8    5815     SUBWFB 0x15, W, ACCESS
  1EBA    E21C     BC 0x1ef4
  1EEA    2ADF     INCF 0xfdf, F, ACCESS
  1EEC    0E01     MOVLW 0x1
  1EEE    E3DC     BNC 0x1ea8
  1EF0    2ADB     INCF 0xfdb, F, ACCESS
  1EF2    D7DA     BRA 0x1ea8
755:                           {
756:               				#ifdef __18CXX
757:               	                data_response = SPIBUF;			//Clear BF flag, just in case it was previously left set.
  1EBC    0E06     MOVLW 0x6
  1EBE    CF75     MOVFF 0xf75, 0xfdb
  1EC0    FFDB     NOP
758:               	                SPI_INTERRUPT_FLAG = 0;			//Clear interrupt flag, in case it was previously left set.
  1EC2    9EA4     BCF 0xfa4, 0x7, ACCESS
759:               	                SPIBUF = buffer[index];         // write byte to SSP1BUF register
  1EC4    0EF9     MOVLW 0xf9
  1EC6    CFDB     MOVFF 0xfdb, 0x14
  1EC8    F014     NOP
  1ECA    0EFA     MOVLW 0xfa
  1ECC    CFDB     MOVFF 0xfdb, 0x15
  1ECE    F015     NOP
  1ED0    50DE     MOVF 0xfde, W, ACCESS
  1ED2    2414     ADDWF 0x14, W, ACCESS
  1ED4    6EE9     MOVWF 0xfe9, ACCESS
  1ED6    50DD     MOVF 0xfdd, W, ACCESS
  1ED8    2015     ADDWFC 0x15, W, ACCESS
  1EDA    6EEA     MOVWF 0xfea, ACCESS
  1EDC    50EF     MOVF 0xfef, W, ACCESS
  1EDE    6E75     MOVWF 0xf75, ACCESS
760:               	                while( !SPI_INTERRUPT_FLAG );   // wait until bus cycle complete
  1EE0    AEA4     BTFSS 0xfa4, 0x7, ACCESS
  1EE2    D7FE     BRA 0x1ee0
761:               	                data_response = SPIBUF;         // Clear the SPIBUF
  1EE4    0E06     MOVLW 0x6
  1EE6    CF75     MOVFF 0xf75, 0xfdb
  1EE8    FFDB     NOP
762:               				#elif defined (__PIC32MX__)
763:                   	            WriteSPIM(buffer[index]);
764:               				#else
765:               	                SPIBUF = buffer[index];
766:               	                while (!SPISTAT_RBF);
767:               	                data_response = SPIBUF;
768:               				#endif
769:                           }
770:               
771:                           // calc crc
772:                           mSendCRC();                                 //Send 2 bytes of CRC
  1EF4    68E6     SETF 0xfe6, ACCESS
  1EF6    D8AD     RCALL 0x2052
  1EF8    52E5     MOVF 0xfe5, F, ACCESS
  1EFA    68E6     SETF 0xfe6, ACCESS
  1EFC    D8AA     RCALL 0x2052
  1EFE    52E5     MOVF 0xfe5, F, ACCESS
773:                           
774:                           data_response = MDD_SDSPI_ReadMedia();                //Read response
  1F00    D8BF     RCALL 0x2080
  1F02    6EE7     MOVWF 0xfe7, ACCESS
  1F04    0E06     MOVLW 0x6
  1F06    CFE7     MOVFF 0xfe7, 0xfdb
  1F08    FFDB     NOP
775:                           
776:                           if((data_response & 0x0F) != DATA_ACCEPTED)
  1F0A    50DB     MOVF 0xfdb, W, ACCESS
  1F0C    0B0F     ANDLW 0xf
  1F0E    0805     SUBLW 0x5
  1F10    E149     BNZ 0x1fa4
777:                           {
778:                               status = FALSE;
779:                           }
780:                           else
781:                           {
782:               				#if defined (__PIC32MX__)
783:               					do
784:               					{
785:               					    putcSPI((unsigned int)0xFF);
786:               					    data_response = getcSPI();
787:               					}while(!data_response);
788:               				#else
789:               					#ifdef __18CXX
790:                               		counter = GetInstructionClock() / 82;                
  1F12    0E95     MOVLW 0x95
  1F14    6EF3     MOVWF 0xff3, ACCESS
  1F16    0E02     MOVLW 0x2
  1F18    CFF3     MOVFF 0xff3, 0xfdb
  1F1A    FFDB     NOP
  1F1C    0EEE     MOVLW 0xee
  1F1E    6EF3     MOVWF 0xff3, ACCESS
  1F20    0E03     MOVLW 0x3
  1F22    CFF3     MOVFF 0xff3, 0xfdb
  1F24    FFDB     NOP
  1F26    0E08     MOVLW 0x8
  1F28    6EF3     MOVWF 0xff3, ACCESS
  1F2A    0E04     MOVLW 0x4
  1F2C    CFF3     MOVFF 0xff3, 0xfdb
  1F2E    FFDB     NOP
  1F30    0E05     MOVLW 0x5
  1F32    6ADB     CLRF 0xfdb, ACCESS
791:               		                do                  //Wait for write completion
792:               		                {
793:               		                    data_response = SPIBUF;
  1F34    0E06     MOVLW 0x6
  1F36    CF75     MOVFF 0xf75, 0xfdb
  1F38    FFDB     NOP
794:               		                    SPI_INTERRUPT_FLAG = 0;
  1F3A    9EA4     BCF 0xfa4, 0x7, ACCESS
795:               		                    SPIBUF = 0xFF;
  1F3C    6875     SETF 0xf75, ACCESS
796:               		                    counter--;
  1F3E    50D9     MOVF 0xfd9, W, ACCESS
  1F40    0F02     ADDLW 0x2
  1F42    6EE9     MOVWF 0xfe9, ACCESS
  1F44    CFDA     MOVFF 0xfda, 0xfea
  1F46    FFEA     NOP
  1F48    06EE     DECF 0xfee, F, ACCESS
  1F4A    0E00     MOVLW 0
  1F4C    5AEE     SUBWFB 0xfee, F, ACCESS
  1F4E    5AEE     SUBWFB 0xfee, F, ACCESS
  1F50    5AEE     SUBWFB 0xfee, F, ACCESS
797:               		                    while(!SPI_INTERRUPT_FLAG);
  1F52    AEA4     BTFSS 0xfa4, 0x7, ACCESS
  1F54    D7FE     BRA 0x1f52
798:               		                    data_response = SPIBUF;
  1F56    0E06     MOVLW 0x6
  1F58    CF75     MOVFF 0xf75, 0xfdb
  1F5A    FFDB     NOP
799:               		                }while((data_response == 0x00) && (counter != 0));		                    
  1F5C    50DB     MOVF 0xfdb, W, ACCESS
  1F5E    E111     BNZ 0x1f82
  1F60    0E02     MOVLW 0x2
  1F62    CFDB     MOVFF 0xfdb, 0x14
  1F64    F014     NOP
  1F66    0E03     MOVLW 0x3
  1F68    CFDB     MOVFF 0xfdb, 0x15
  1F6A    F015     NOP
  1F6C    0E04     MOVLW 0x4
  1F6E    CFDB     MOVFF 0xfdb, 0x16
  1F70    F016     NOP
  1F72    0E05     MOVLW 0x5
  1F74    CFDB     MOVFF 0xfdb, 0x17
  1F76    F017     NOP
  1F78    5014     MOVF 0x14, W, ACCESS
  1F7A    1015     IORWF 0x15, W, ACCESS
  1F7C    1016     IORWF 0x16, W, ACCESS
  1F7E    1017     IORWF 0x17, W, ACCESS
  1F80    E1D9     BNZ 0x1f34
800:               					#else
801:                               		counter = GetInstructionClock() / 44;                
802:               		                do                  //Wait for write completion
803:               		                {
804:               		                    SPIBUF = 0xFF;
805:               		                    counter--;
806:               		                    while(!SPISTAT_RBF);
807:               		                    data_response = SPIBUF;
808:               		                }while((data_response == 0x00) && (counter != 0));
809:               					#endif
810:               					
811:               	                if(counter == 0)                                  //if timeout first
  1F82    0E02     MOVLW 0x2
  1F84    CFDB     MOVFF 0xfdb, 0x14
  1F86    F014     NOP
  1F88    0E03     MOVLW 0x3
  1F8A    CFDB     MOVFF 0xfdb, 0x15
  1F8C    F015     NOP
  1F8E    0E04     MOVLW 0x4
  1F90    CFDB     MOVFF 0xfdb, 0x16
  1F92    F016     NOP
  1F94    0E05     MOVLW 0x5
  1F96    CFDB     MOVFF 0xfdb, 0x17
  1F98    F017     NOP
  1F9A    5014     MOVF 0x14, W, ACCESS
  1F9C    1015     IORWF 0x15, W, ACCESS
  1F9E    1016     IORWF 0x16, W, ACCESS
  1FA0    1017     IORWF 0x17, W, ACCESS
  1FA2    E102     BNZ 0x1fa8
812:               	                    status = FALSE;
  1FA4    0E0C     MOVLW 0xc
  1FA6    6ADB     CLRF 0xfdb, ACCESS
813:               				#endif
814:                           }
815:               
816:                           mSend8ClkCycles();
  1FA8    68E6     SETF 0xfe6, ACCESS
  1FAA    D853     RCALL 0x2052
  1FAC    52E5     MOVF 0xfe5, F, ACCESS
817:                       }
818:               
819:                       SD_CS = 1;
  1FAE    8081     BSF 0xf81, 0, ACCESS
820:               
821:                   } // Not writing to 0 sector
822:               
823:                   return(status);
  1FB0    0E0C     MOVLW 0xc
  1FB2    50DB     MOVF 0xfdb, W, ACCESS
824:               } //end SectorWrite
  1FB4    6E14     MOVWF 0x14, ACCESS
  1FB6    0E0D     MOVLW 0xd
  1FB8    5CE1     SUBWF 0xfe1, W, ACCESS
  1FBA    E202     BC 0x1fc0
  1FBC    6AE1     CLRF 0xfe1, ACCESS
  1FBE    52E5     MOVF 0xfe5, F, ACCESS
  1FC0    6EE1     MOVWF 0xfe1, ACCESS
  1FC2    5014     MOVF 0x14, W, ACCESS
  1FC4    52E5     MOVF 0xfe5, F, ACCESS
  1FC6    CFE7     MOVFF 0xfe7, 0xfd9
  1FC8    FFD9     NOP
  1FCA    0012     RETURN 0
825:               
826:               
827:               /*****************************************************************************
828:                 Function:
829:                   BYTE MDD_SDSPI_WriteProtectState
830:                 Summary:
831:                   Indicates whether the card is write-protected.
832:                 Conditions:
833:                   The MDD_WriteProtectState function pointer must be pointing to this function.
834:                 Input:
835:                   None.
836:                 Return Values:
837:                   TRUE -  The card is write-protected
838:                   FALSE - The card is not write-protected
839:                 Side Effects:
840:                   None.
841:                 Description:
842:                   The MDD_SDSPI_WriteProtectState function will determine if the SD card is
843:                   write protected by checking the electrical signal that corresponds to the
844:                   physical write-protect switch.
845:                 Remarks:
846:                   None
847:                 ***************************************************************************************/
848:               
849:               BYTE MDD_SDSPI_WriteProtectState(void)
850:               {
851:               #if defined(MEDIA_SOFT_DETECT)
852:               	return FALSE;	// uSD does not have WP switch so ignore
853:               #else
854:                   return(SD_WE);
855:               #endif
856:               }
  1FCC    0C00     RETLW 0
857:               
858:               
859:               /*****************************************************************************
860:                 Function:
861:                   void Delayms (BYTE milliseconds)
862:                 Summary:
863:                   Delay.
864:                 Conditions:
865:                   None.
866:                 Input:
867:                   BYTE milliseconds - Number of ms to delay
868:                 Return:
869:                   None.
870:                 Side Effects:
871:                   None.
872:                 Description:
873:                   The Delayms function will delay a specified number of milliseconds.  Used for SPI
874:                   timing.
875:                 Remarks:
876:                   Depending on compiler revisions, this function may delay for the exact time
877:                   specified.  This shouldn't create a significant problem.
878:                 ***************************************************************************************/
879:               
880:               void Delayms(BYTE milliseconds)
  1FCE    CFD9     MOVFF 0xfd9, 0xfe6
  1FD0    FFE6     NOP
  1FD2    CFE1     MOVFF 0xfe1, 0xfd9
  1FD4    FFD9     NOP
  1FD6    0E05     MOVLW 0x5
  1FD8    26E1     ADDWF 0xfe1, F, ACCESS
881:               {
882:                   BYTE    ms;
883:                   DWORD   count;
884:                   
885:                   ms = milliseconds;
  1FDA    0EFE     MOVLW 0xfe
  1FDC    50DB     MOVF 0xfdb, W, ACCESS
  1FDE    6EDF     MOVWF 0xfdf, ACCESS
886:                   while (ms--)
  1FE0    50DF     MOVF 0xfdf, W, ACCESS
  1FE2    06DF     DECF 0xfdf, F, ACCESS
  1FE4    0900     IORLW 0
  1FE6    E027     BZ 0x2036
  2034    D7D5     BRA 0x1fe0
887:                   {
888:                       count = MILLISECDELAY;
  1FE8    0E6B     MOVLW 0x6b
  1FEA    6EF3     MOVWF 0xff3, ACCESS
  1FEC    0E01     MOVLW 0x1
  1FEE    CFF3     MOVFF 0xff3, 0xfdb
  1FF0    FFDB     NOP
  1FF2    0E17     MOVLW 0x17
  1FF4    6EF3     MOVWF 0xff3, ACCESS
  1FF6    0E02     MOVLW 0x2
  1FF8    CFF3     MOVFF 0xff3, 0xfdb
  1FFA    FFDB     NOP
  1FFC    0E03     MOVLW 0x3
  1FFE    6ADB     CLRF 0xfdb, ACCESS
  2000    0E04     MOVLW 0x4
  2002    6ADB     CLRF 0xfdb, ACCESS
889:                       while (count--);
  2004    50D9     MOVF 0xfd9, W, ACCESS
  2006    0F01     ADDLW 0x1
  2008    6EE9     MOVWF 0xfe9, ACCESS
  200A    CFDA     MOVFF 0xfda, 0xfea
  200C    FFEA     NOP
  200E    CFEF     MOVFF 0xfef, 0x14
  2010    F014     NOP
  2012    06EE     DECF 0xfee, F, ACCESS
  2014    0E00     MOVLW 0
  2016    CFEF     MOVFF 0xfef, 0x15
  2018    F015     NOP
  201A    5AEE     SUBWFB 0xfee, F, ACCESS
  201C    CFEF     MOVFF 0xfef, 0x16
  201E    F016     NOP
  2020    5AEE     SUBWFB 0xfee, F, ACCESS
  2022    CFEF     MOVFF 0xfef, 0x17
  2024    F017     NOP
  2026    5AEF     SUBWFB 0xfef, F, ACCESS
  2028    5014     MOVF 0x14, W, ACCESS
  202A    1015     IORWF 0x15, W, ACCESS
  202C    1016     IORWF 0x16, W, ACCESS
  202E    1017     IORWF 0x17, W, ACCESS
  2030    E001     BZ 0x2034
  2032    D7E8     BRA 0x2004
890:                   }
891:                   Nop();
  2036    0000     NOP
892:                   return;
  2038    D000     BRA 0x203a
893:               }
  203A    0E05     MOVLW 0x5
  203C    5CE1     SUBWF 0xfe1, W, ACCESS
  203E    E202     BC 0x2044
  2040    6AE1     CLRF 0xfe1, ACCESS
  2042    52E5     MOVF 0xfe5, F, ACCESS
  2044    6EE1     MOVWF 0xfe1, ACCESS
  2046    52E5     MOVF 0xfe5, F, ACCESS
  2048    CFE7     MOVFF 0xfe7, 0xfd9
  204A    FFD9     NOP
  204C    0012     RETURN 0
894:               
895:               
896:               /*****************************************************************************
897:                 Function:
898:                   void CloseSPIM (void)
899:                 Summary:
900:                   Disables the SPI module.
901:                 Conditions:
902:                   None.
903:                 Input:
904:                   None.
905:                 Return:
906:                   None.
907:                 Side Effects:
908:                   None.
909:                 Description:
910:                   Disables the SPI module.
911:                 Remarks:
912:                   None.
913:                 ***************************************************************************************/
914:               
915:               void CloseSPIM (void)
916:               {
917:               #if defined __C30__ || defined __C32__
918:               
919:                   SPISTAT &= 0x7FFF;
920:               
921:               #elif defined __18CXX
922:               
923:                   SPICON1 &= 0xDF;
  204E    9A72     BCF 0xf72, 0x5, ACCESS
924:               
925:               #endif
926:               }
  2050    0012     RETURN 0
927:               
928:               
929:               
930:               /*****************************************************************************
931:                 Function:
932:                   unsigned char WriteSPIM (unsigned char data_out)
933:                 Summary:
934:                   Writes data to the SD card.
935:                 Conditions:
936:                   None.
937:                 Input:
938:                   data_out - The data to write.
939:                 Return:
940:                   0.
941:                 Side Effects:
942:                   None.
943:                 Description:
944:                   The WriteSPIM function will write a byte of data from the microcontroller to the
945:                   SD card.
946:                 Remarks:
947:                   None.
948:                 ***************************************************************************************/
949:               
950:               unsigned char WriteSPIM( unsigned char data_out )
  2052    CFD9     MOVFF 0xfd9, 0xfe6
  2054    FFE6     NOP
  2056    CFE1     MOVFF 0xfe1, 0xfd9
  2058    FFD9     NOP
  205A    52E6     MOVF 0xfe6, F, ACCESS
951:               {
952:               #ifdef __PIC32MX__
953:                   BYTE   clear;
954:                   putcSPI((BYTE)data_out);
955:                   clear = getcSPI();
956:                   return ( 0 );                // return non-negative#
957:               #elif defined __18CXX
958:                   BYTE clear;
959:                   clear = SPIBUF;
  205C    5075     MOVF 0xf75, W, ACCESS
  205E    6EDF     MOVWF 0xfdf, ACCESS
960:                   SPI_INTERRUPT_FLAG = 0;
  2060    9EA4     BCF 0xfa4, 0x7, ACCESS
961:                   SPIBUF = data_out;
  2062    0EFE     MOVLW 0xfe
  2064    50DB     MOVF 0xfdb, W, ACCESS
  2066    6E75     MOVWF 0xf75, ACCESS
962:                   if (SPICON1 & 0x80)
  2068    AE72     BTFSS 0xf72, 0x7, ACCESS
  206A    D002     BRA 0x2070
963:                       return -1;
  206C    0EFF     MOVLW 0xff
  206E    D003     BRA 0x2076
964:                   else
965:                       while (!SPI_INTERRUPT_FLAG);
  2070    AEA4     BTFSS 0xfa4, 0x7, ACCESS
  2072    D7FE     BRA 0x2070
966:                   return 0;
  2074    0E00     MOVLW 0
967:               #else
968:                   BYTE   clear;
969:                   SPIBUF = data_out;          // write byte to SSP1BUF register
970:                   while( !SPISTAT_RBF ); // wait until bus cycle complete
971:                   clear = SPIBUF;
972:                   return ( 0 );                // return non-negative#
973:               #endif
974:               }
  2076    52E5     MOVF 0xfe5, F, ACCESS
  2078    52E5     MOVF 0xfe5, F, ACCESS
  207A    CFE7     MOVFF 0xfe7, 0xfd9
  207C    FFD9     NOP
  207E    0012     RETURN 0
975:               
976:               
977:               
978:               /*****************************************************************************
979:                 Function:
980:                   BYTE MDD_SDSPI_ReadMedia (void)
981:                 Summary:
982:                   Reads a byte of data from the SD card.
983:                 Conditions:
984:                   None.
985:                 Input:
986:                   None.
987:                 Return:
988:                   The byte read.
989:                 Side Effects:
990:                   None.
991:                 Description:
992:                   The MDD_SDSPI_ReadMedia function will read one byte from the SPI port.
993:                 Remarks:
994:                   This function replaces ReadSPI, since some implementations of that function
995:                   will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF.
996:                 ***************************************************************************************/
997:               BYTE MDD_SDSPI_ReadMedia(void)
  2080    CFD9     MOVFF 0xfd9, 0xfe6
  2082    FFE6     NOP
  2084    CFE1     MOVFF 0xfe1, 0xfd9
  2086    FFD9     NOP
  2088    52E6     MOVF 0xfe6, F, ACCESS
998:               {
999:               
1000:              #ifdef __C32__
1001:              
1002:                  putcSPI((BYTE)0xFF);
1003:                  return (BYTE)getcSPI();
1004:              
1005:              #elif defined __18CXX
1006:              
1007:                  BYTE clear;
1008:                  clear = SPIBUF;
  208A    5075     MOVF 0xf75, W, ACCESS
  208C    6EDF     MOVWF 0xfdf, ACCESS
1009:                  SPI_INTERRUPT_FLAG = 0;
  208E    9EA4     BCF 0xfa4, 0x7, ACCESS
1010:                  SPIBUF = 0xFF;
  2090    6875     SETF 0xf75, ACCESS
1011:                  while (!SPI_INTERRUPT_FLAG);
  2092    AEA4     BTFSS 0xfa4, 0x7, ACCESS
  2094    D7FE     BRA 0x2092
1012:                  return SPIBUF;
  2096    5075     MOVF 0xf75, W, ACCESS
1013:              
1014:              #else
1015:                  SPIBUF = 0xFF;                              //Data Out - Logic ones
1016:                  while(!SPISTAT_RBF);                     //Wait until cycle complete
1017:                  return(SPIBUF);                             //Return with byte read
1018:              #endif
1019:              }
  2098    52E5     MOVF 0xfe5, F, ACCESS
  209A    52E5     MOVF 0xfe5, F, ACCESS
  209C    CFE7     MOVFF 0xfe7, 0xfd9
  209E    FFD9     NOP
  20A0    0012     RETURN 0
1020:              
1021:              /*****************************************************************************
1022:                Function:
1023:                  void OpenSPIM (unsigned int sync_mode)
1024:                Summary:
1025:                  Initializes the SPI module
1026:                Conditions:
1027:                  None.
1028:                Input:
1029:                  sync_mode - Sets synchronization
1030:                Return:
1031:                  None.
1032:                Side Effects:
1033:                  None.
1034:                Description:
1035:                  The OpenSPIM function will enable and configure the SPI module.
1036:                Remarks:
1037:                  None.
1038:                ***************************************************************************************/
1039:              
1040:              #ifdef __18CXX
1041:              void OpenSPIM (unsigned char sync_mode)
  20A2    CFD9     MOVFF 0xfd9, 0xfe6
  20A4    FFE6     NOP
  20A6    CFE1     MOVFF 0xfe1, 0xfd9
  20A8    FFD9     NOP
1042:              #else
1043:              void OpenSPIM( unsigned int sync_mode)
1044:              #endif
1045:              {
1046:                  SPISTAT = 0x0000;               // power on state 
  20AA    6A73     CLRF 0xf73, ACCESS
1047:              
1048:              #ifndef __PIC32MX__
1049:                  SPICON1 = 0x0000;                // power on state
  20AC    6A72     CLRF 0xf72, ACCESS
1050:                  SPICON1 |= sync_mode;          // select serial mode 
  20AE    0EFE     MOVLW 0xfe
  20B0    50DB     MOVF 0xfdb, W, ACCESS
  20B2    1272     IORWF 0xf72, F, ACCESS
1051:              #endif
1052:              
1053:              #ifdef __18CXX
1054:                  SPICON1 |= 0x80;
  20B4    8E72     BSF 0xf72, 0x7, ACCESS
1055:                  SPISTATbits.CKE = 1;
  20B6    8C73     BSF 0xf73, 0x6, ACCESS
1056:              #else
1057:                  SPICON1bits.CKP = 1;
1058:                  SPICON1bits.CKE = 0;
1059:              #endif
1060:              
1061:                  SPICLOCK = 0;
  20B8    9493     BCF 0xf93, 0x2, ACCESS
1062:                  SPIOUT = 0;                  // define SDO1 as output (master or slave)
  20BA    9293     BCF 0xf93, 0x1, ACCESS
1063:                  SPIIN = 1;                  // define SDI1 as input (master or slave)
  20BC    8693     BSF 0xf93, 0x3, ACCESS
1064:                  SPIENABLE = 1;             // enable synchronous serial port
  20BE    8A72     BSF 0xf72, 0x5, ACCESS
1065:              }
  20C0    52E5     MOVF 0xfe5, F, ACCESS
  20C2    CFE7     MOVFF 0xfe7, 0xfd9
  20C4    FFD9     NOP
  20C6    0012     RETURN 0
1066:              
1067:              
1068:              #ifdef __18CXX
1069:              #if (GetSystemClock() >= 25600000)
1070:              
1071:              // Description: Delay value for the manual SPI clock
1072:              #define MANUAL_SPI_CLOCK_VALUE             1
1073:              /*****************************************************************************
1074:                Function:
1075:                  unsigned char WriteSPIManual (unsigned char data_out)
1076:                Summary:
1077:                  Write a character to the SD card with bit-bang SPI.
1078:                Conditions:
1079:                  Make sure the SDI pin is pre-configured as a digital pin, if it is 
1080:                  multiplexed with analog functionality.
1081:                Input:
1082:                  data_out - Data to send.
1083:                Return:
1084:                  0.
1085:                Side Effects:
1086:                  None.
1087:                Description:
1088:                  Writes a character to the SD card.
1089:                Remarks:
1090:                  The WriteSPIManual function is for use on a PIC18 when the clock speed is so
1091:                  high that the maximum SPI clock divider cannot reduce the SPI clock speed below
1092:                  the maximum SD card initialization speed.
1093:                ***************************************************************************************/
1094:              unsigned char WriteSPIManual(unsigned char data_out)
  20C8    CFD9     MOVFF 0xfd9, 0xfe6
  20CA    FFE6     NOP
  20CC    CFE1     MOVFF 0xfe1, 0xfd9
  20CE    FFD9     NOP
  20D0    0E02     MOVLW 0x2
  20D2    26E1     ADDWF 0xfe1, F, ACCESS
1095:              {
1096:                  unsigned char i;
1097:                  unsigned char clock;
1098:              
1099:                  SPICLOCKLAT = 0;
  20D4    948A     BCF 0xf8a, 0x2, ACCESS
1100:                  SPIOUTLAT = 1;
  20D6    828A     BSF 0xf8a, 0x1, ACCESS
1101:                  SPICLOCK = OUTPUT;
  20D8    9493     BCF 0xf93, 0x2, ACCESS
1102:                  SPIOUT = OUTPUT;
  20DA    9293     BCF 0xf93, 0x1, ACCESS
1103:              
1104:              	//Loop to send out 8 bits of SDO data and associated SCK clock.
1105:              	for(i = 0; i < 8; i++)
  20DC    6ADF     CLRF 0xfdf, ACCESS
  20DE    0E08     MOVLW 0x8
  20E0    5CDF     SUBWF 0xfdf, W, ACCESS
  20E2    E223     BC 0x212a
  2126    2ADF     INCF 0xfdf, F, ACCESS
  2128    D7DA     BRA 0x20de
1106:              	{
1107:              		SPICLOCKLAT = 0;
  20E4    948A     BCF 0xf8a, 0x2, ACCESS
1108:              		if(data_out & 0x80)
  20E6    0EFE     MOVLW 0xfe
  20E8    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  20EA    D002     BRA 0x20f0
1109:              			SPIOUTLAT = 1;
  20EC    828A     BSF 0xf8a, 0x1, ACCESS
1110:              		else
  20EE    D001     BRA 0x20f2
1111:              			SPIOUTLAT = 0;
  20F0    928A     BCF 0xf8a, 0x1, ACCESS
1112:              		data_out = data_out << 1;				//Bit shift, so next bit to send is in MSb position
  20F2    50DB     MOVF 0xfdb, W, ACCESS
  20F4    0D02     MULLW 0x2
  20F6    0EFE     MOVLW 0xfe
  20F8    CFF3     MOVFF 0xff3, 0xfdb
  20FA    FFDB     NOP
1113:                  	clock = MANUAL_SPI_CLOCK_VALUE;
  20FC    52DE     MOVF 0xfde, F, ACCESS
  20FE    0E01     MOVLW 0x1
  2100    6EDD     MOVWF 0xfdd, ACCESS
1114:                  	while (clock--);
  2102    0E01     MOVLW 0x1
  2104    CFDB     MOVFF 0xfdb, 0xff3
  2106    FFF3     NOP
  2108    06DB     DECF 0xfdb, F, ACCESS
  210A    50F3     MOVF 0xff3, W, ACCESS
  210C    0900     IORLW 0
  210E    E1F9     BNZ 0x2102
1115:                  	SPICLOCKLAT = 1;
  2110    848A     BSF 0xf8a, 0x2, ACCESS
1116:                  	clock = MANUAL_SPI_CLOCK_VALUE;
  2112    52DE     MOVF 0xfde, F, ACCESS
  2114    0E01     MOVLW 0x1
  2116    6EDD     MOVWF 0xfdd, ACCESS
1117:                  	while (clock--);    			
  2118    0E01     MOVLW 0x1
  211A    CFDB     MOVFF 0xfdb, 0xff3
  211C    FFF3     NOP
  211E    06DB     DECF 0xfdb, F, ACCESS
  2120    50F3     MOVF 0xff3, W, ACCESS
  2122    0900     IORLW 0
  2124    E1F9     BNZ 0x2118
1118:              	}	
1119:                  SPICLOCKLAT = 0;
  212A    948A     BCF 0xf8a, 0x2, ACCESS
1120:              
1121:                  return 0; 
  212C    0E00     MOVLW 0
1122:              }
  212E    6E14     MOVWF 0x14, ACCESS
  2130    0E02     MOVLW 0x2
  2132    5CE1     SUBWF 0xfe1, W, ACCESS
  2134    E202     BC 0x213a
  2136    6AE1     CLRF 0xfe1, ACCESS
  2138    52E5     MOVF 0xfe5, F, ACCESS
  213A    6EE1     MOVWF 0xfe1, ACCESS
  213C    5014     MOVF 0x14, W, ACCESS
  213E    52E5     MOVF 0xfe5, F, ACCESS
  2140    CFE7     MOVFF 0xfe7, 0xfd9
  2142    FFD9     NOP
  2144    0012     RETURN 0
1123:              
1124:              
1125:              /*****************************************************************************
1126:                Function:
1127:                  BYTE ReadMediaManual (void)
1128:                Summary:
1129:                  Reads a byte of data from the SD card.
1130:                Conditions:
1131:                  None.
1132:                Input:
1133:                  None.
1134:                Return:
1135:                  The byte read.
1136:                Side Effects:
1137:                  None.
1138:                Description:
1139:                  The MDD_SDSPI_ReadMedia function will read one byte from the SPI port.
1140:                Remarks:
1141:                  This function replaces ReadSPI, since some implementations of that function
1142:                  will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF.
1143:                  This function is for use on a PIC18 when the clock speed is so high that the
1144:                  maximum SPI clock prescaler cannot reduce the SPI clock below the maximum SD card
1145:                  initialization speed.
1146:                ***************************************************************************************/
1147:              BYTE ReadMediaManual (void)
  2146    CFD9     MOVFF 0xfd9, 0xfe6
  2148    FFE6     NOP
  214A    CFE1     MOVFF 0xfe1, 0xfd9
  214C    FFD9     NOP
  214E    0E04     MOVLW 0x4
  2150    26E1     ADDWF 0xfe1, F, ACCESS
1148:              {
1149:                  unsigned char i, t;
1150:                  unsigned char clock;
1151:                  unsigned char result = 0x00;
  2152    0E03     MOVLW 0x3
  2154    6ADB     CLRF 0xfdb, ACCESS
1152:              
1153:                  SPIOUTLAT = 1;
  2156    828A     BSF 0xf8a, 0x1, ACCESS
1154:                  SPIOUT = OUTPUT;
  2158    9293     BCF 0xf93, 0x1, ACCESS
1155:                  SPIIN = INPUT;
  215A    8693     BSF 0xf93, 0x3, ACCESS
1156:                  SPICLOCKLAT = 0;
  215C    948A     BCF 0xf8a, 0x2, ACCESS
1157:                  SPICLOCK = OUTPUT;
  215E    9493     BCF 0xf93, 0x2, ACCESS
1158:               
1159:               	//Loop to send 8 clock pulses and read in the returned bits of data. Data "sent" will be = 0xFF
1160:              	for(i = 0; i < 8; i++)
  2160    6ADF     CLRF 0xfdf, ACCESS
  2162    0E08     MOVLW 0x8
  2164    5CDF     SUBWF 0xfdf, W, ACCESS
  2166    E229     BC 0x21ba
  21B6    2ADF     INCF 0xfdf, F, ACCESS
  21B8    D7D4     BRA 0x2162
1161:              	{
1162:              		SPICLOCKLAT = 0;
  2168    948A     BCF 0xf8a, 0x2, ACCESS
1163:                  	clock = MANUAL_SPI_CLOCK_VALUE;
  216A    0E01     MOVLW 0x1
  216C    6EF3     MOVWF 0xff3, ACCESS
  216E    0E02     MOVLW 0x2
  2170    CFF3     MOVFF 0xff3, 0xfdb
  2172    FFDB     NOP
1164:                  	while (clock--);
  2174    0E02     MOVLW 0x2
  2176    CFDB     MOVFF 0xfdb, 0xff3
  2178    FFF3     NOP
  217A    06DB     DECF 0xfdb, F, ACCESS
  217C    50F3     MOVF 0xff3, W, ACCESS
  217E    0900     IORLW 0
  2180    E1F9     BNZ 0x2174
1165:                  	SPICLOCKLAT = 1;
  2182    848A     BSF 0xf8a, 0x2, ACCESS
1166:                  	clock = MANUAL_SPI_CLOCK_VALUE;
  2184    0E01     MOVLW 0x1
  2186    6EF3     MOVWF 0xff3, ACCESS
  2188    0E02     MOVLW 0x2
  218A    CFF3     MOVFF 0xff3, 0xfdb
  218C    FFDB     NOP
1167:                  	while (clock--);
  218E    0E02     MOVLW 0x2
  2190    CFDB     MOVFF 0xfdb, 0xff3
  2192    FFF3     NOP
  2194    06DB     DECF 0xfdb, F, ACCESS
  2196    50F3     MOVF 0xff3, W, ACCESS
  2198    0900     IORLW 0
  219A    E1F9     BNZ 0x218e
1168:              		result = result << 1;	//Bit shift the previous result.  We receive the byte MSb first. This operation makes LSb = 0.  
  219C    0E03     MOVLW 0x3
  219E    50DB     MOVF 0xfdb, W, ACCESS
  21A0    0D02     MULLW 0x2
  21A2    0E03     MOVLW 0x3
  21A4    CFF3     MOVFF 0xff3, 0xfdb
  21A6    FFDB     NOP
1169:                  	if(SPIINPORT)
  21A8    A681     BTFSS 0xf81, 0x3, ACCESS
  21AA    D002     BRA 0x21b0
1170:                  		result++;			//Set the LSb if we detected a '1' on the SPIINPORT pin, otherwise leave as 0.
  21AC    2ADB     INCF 0xfdb, F, ACCESS
1171:              		else 
  21AE    D003     BRA 0x21b6
1172:              			t = 1;
  21B0    52DE     MOVF 0xfde, F, ACCESS
  21B2    0E01     MOVLW 0x1
  21B4    6EDD     MOVWF 0xfdd, ACCESS
1173:              	}	
1174:                  SPICLOCKLAT = 0;
  21BA    948A     BCF 0xf8a, 0x2, ACCESS
1175:              
1176:                  return result;
  21BC    0E03     MOVLW 0x3
  21BE    50DB     MOVF 0xfdb, W, ACCESS
1177:              }//end ReadMedia
  21C0    6E14     MOVWF 0x14, ACCESS
  21C2    0E04     MOVLW 0x4
  21C4    5CE1     SUBWF 0xfe1, W, ACCESS
  21C6    E202     BC 0x21cc
  21C8    6AE1     CLRF 0xfe1, ACCESS
  21CA    52E5     MOVF 0xfe5, F, ACCESS
  21CC    6EE1     MOVWF 0xfe1, ACCESS
  21CE    5014     MOVF 0x14, W, ACCESS
  21D0    52E5     MOVF 0xfe5, F, ACCESS
  21D2    CFE7     MOVFF 0xfe7, 0xfd9
  21D4    FFD9     NOP
  21D6    0012     RETURN 0
1178:              
1179:              #endif      // End >25600000
1180:              #endif      // End __18CXX
1181:              
1182:              
1183:              /*****************************************************************************
1184:                Function:
1185:                  MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize (void)
1186:                Summary:
1187:                  Initializes the SD card.
1188:                Conditions:
1189:                  The MDD_MediaInitialize function pointer must be pointing to this function.
1190:                Input:
1191:                  None.
1192:                Return Values:
1193:                  The function returns a pointer to the MEDIA_INFORMATION structure.  The
1194:                  errorCode member may contain the following values:
1195:                      * MEDIA_NO_ERROR - The media initialized successfully
1196:                      * MEDIA_CANNOT_INITIALIZE - Cannot initialize the media.  
1197:                Side Effects:
1198:                  None.
1199:                Description:
1200:                  This function will send initialization commands to and SD card.
1201:                Remarks:
1202:                  None.
1203:                ***************************************************************************************/
1204:              MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize(void)
  21D8    CFD9     MOVFF 0xfd9, 0xfe6
  21DA    FFE6     NOP
  21DC    CFE1     MOVFF 0xfe1, 0xfd9
  21DE    FFD9     NOP
  21E0    0E23     MOVLW 0x23
  21E2    26E1     ADDWF 0xfe1, F, ACCESS
1205:              {
1206:                  WORD timeout;
1207:                  MMC_RESPONSE    response;
1208:              	BYTE CSDResponse[20];
1209:              	BYTE count, index;
1210:              	DWORD c_size;
1211:              	BYTE c_size_mult;
1212:              	BYTE block_len;
1213:               
1214:              	#if defined __C30__ || defined __C32__
1215:                  	WORD spiconvalue = 0x0003;
1216:              	#endif
1217:                  mediaInformation.errorCode = MEDIA_NO_ERROR;
  21E4    0101     MOVLB 0x1
  21E6    6BD6     CLRF 0xd6, BANKED
1218:                  mediaInformation.validityFlags.value = 0;
  21E8    6BD7     CLRF 0xd7, BANKED
1219:                  MDD_SDSPI_finalLBA = 0x00000000;	//Will compute a valid value later, from the CSD register values we get from the card
  21EA    6BCF     CLRF 0xcf, BANKED
  21EC    6BD0     CLRF 0xd0, BANKED
  21EE    6BD1     CLRF 0xd1, BANKED
  21F0    6BD2     CLRF 0xd2, BANKED
1220:              
1221:                  SD_CS = 1;               //Initialize Chip Select line
  21F2    8081     BSF 0xf81, 0, ACCESS
1222:                  
1223:                  //Media powers up in the open-drain mode and cannot handle a clock faster
1224:                  //than 400kHz. Initialize SPI port to slower than 400kHz
1225:              	#if defined __C30__ || defined __C32__
1226:              		#ifdef __PIC32MX__
1227:              			OpenSPI(SPI_START_CFG_1, SPI_START_CFG_2);
1228:              		    SPIBRG = SPICalutateBRG(GetPeripheralClock(), 400000);
1229:              		#else	//else C30 = PIC24/dsPIC devices
1230:              		    // Calculate the prescaler needed for the clock
1231:              		    timeout = GetSystemClock() / 400000;
1232:              		    // if timeout is less than 400k and greater than 100k use a 1:1 prescaler
1233:              		    if (timeout == 0)
1234:              		    {
1235:              		        OpenSPIM (MASTER_ENABLE_ON | PRI_PRESCAL_1_1 | SEC_PRESCAL_1_1);
1236:              		    }
1237:              		    else
1238:              		    {
1239:              		        while (timeout != 0)
1240:              		        {
1241:              		            if (timeout > 8)
1242:              		            {
1243:              		                spiconvalue--;
1244:              		                // round up
1245:              		                if ((timeout % 4) != 0)
1246:              		                    timeout += 4;
1247:              		                timeout /= 4;
1248:              		            }
1249:              		            else
1250:              		            {
1251:              		                break;
1252:              		            }
1253:              		        }
1254:              		        
1255:              		        timeout--;
1256:              		    
1257:              		        OpenSPIM (MASTER_ENABLE_ON | spiconvalue | ((~(timeout << 2)) & 0x1C));
1258:              		    }
1259:              		#endif   //#ifdef __PIC32MX__ (and corresponding #else)
1260:              
1261:              
1262:              	    // let the card power on and initialize
1263:              	    Delayms(1);
1264:              	    
1265:              	    //Media requires 80 clock cycles to startup [8 clocks/BYTE * 10 us]
1266:              	    for(timeout=0; timeout<10; timeout++)
1267:              	        mSend8ClkCycles();
1268:              	
1269:              	    SD_CS = 0;
1270:              	    
1271:              	    Delayms(1);
1272:              	    
1273:              	    // Send CMD0 to reset the media
1274:              	    response = SendMMCCmd(GO_IDLE_STATE,0x0);
1275:              	    
1276:              	    if((response.r1._byte == MMC_BAD_RESPONSE) || ((response.r1._byte & 0xF7) != 0x01))
1277:              	    {
1278:              	        SD_CS = 1;                               // deselect the devices
1279:              	        mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
1280:              	        return &mediaInformation;
1281:              	    }
1282:              	
1283:              	    response = SendMMCCmd(SEND_IF_COND, 0x1AA);
1284:              	    if (((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD))
1285:              		{
1286:              	        timeout = 0xFFF;
1287:              	        do
1288:              	        {
1289:              	        	response = SendMMCCmd(SEND_OP_COND, 0x40000000);
1290:              	            timeout--;
1291:              	        }while(response.r1._byte != 0x00 && timeout != 0);
1292:              			response = SendMMCCmd(READ_OCR, 0x0);
1293:              	        if (((response.r7.bytewise._returnVal & 0xC0000000) == 0xC0000000) && (response.r7.bytewise._byte == 0))
1294:              			{
1295:              	        	gSDMode = SD_MODE_HC;
1296:              			}
1297:              	        else //if (((response.r7.bytewise._returnVal & 0xC0000000) == 0x80000000) && (response.r7.bytewise._byte == 0))
1298:              			{
1299:              				gSDMode = SD_MODE_NORMAL;
1300:              			}
1301:              		}
1302:              	    else
1303:              		{
1304:              	        gSDMode = SD_MODE_NORMAL;
1305:              	
1306:              		    // According to spec cmd1 must be repeated until the card is fully initialized
1307:              		    timeout = 0xFFF;
1308:              		    do
1309:              		    {
1310:              		        response = SendMMCCmd(SEND_OP_COND,0x0);
1311:              		        timeout--;
1312:              		    }while(response.r1._byte != 0x00 && timeout != 0);
1313:              		}
1314:              	
1315:              	    // see if it failed
1316:              	    if(timeout == 0)
1317:              	    {
1318:              	        mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
1319:              	        SD_CS = 1;                               // deselect the devices
1320:              	    }
1321:              	    else      
1322:              	    {
1323:              	#else	//PIC18 device (#else of: #if defined __C30__ || defined __C32__)
1324:                  
1325:              	    // let the card power on and initialize
1326:              	    Delayms(1);
  21F4    0E01     MOVLW 0x1
  21F6    6EE6     MOVWF 0xfe6, ACCESS
  21F8    DEEA     RCALL 0x1fce
  21FA    52E5     MOVF 0xfe5, F, ACCESS
1327:              	    
1328:              	    #if (GetSystemClock() < 25600000)
1329:              	
1330:              	        #if (GetSystemClock() < 1600000)
1331:              	            OpenSPIM (SYNC_MODE_FAST);
1332:              	        #elif (GetSystemClock() < 6400000)
1333:              	            OpenSPIM (SYNC_MODE_MED);
1334:              	        #else
1335:              	            OpenSPIM (SYNC_MODE_SLOW);
1336:              	        #endif
1337:              	        
1338:              	        // let the card power on and initialize
1339:              	        Delayms(1);
1340:              	        
1341:              	        //Media requires 80 clock cycles to startup [8 clocks/BYTE * 10 us]
1342:              	        for(timeout=0; timeout<10; timeout++)
1343:              	            mSend8ClkCycles();
1344:              	    
1345:              	        SD_CS = 0;
1346:              	        
1347:              	        Delayms(1);
1348:              	        
1349:              	        // Send CMD0 to reset the media
1350:              	        response = SendMMCCmd(GO_IDLE_STATE,0x0);
1351:              	        
1352:              	        if((response.r1._byte == MMC_BAD_RESPONSE) || ((response.r1._byte & 0xF7) != 0x01))
1353:              	        {
1354:              	            mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
1355:              	            SD_CS = 1;                               // deselect the devices
1356:              	            return &mediaInformation;
1357:              	        }
1358:              	
1359:              	        response = SendMMCCmd(SEND_IF_COND, 0x1AA);
1360:              	        if (((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD))
1361:              			{
1362:              		        timeout = 0xFFF;
1363:              		        do
1364:              		        {
1365:              	                response = SendMMCCmd(SEND_OP_COND, 0x40000000);
1366:              		            timeout--;
1367:              		        }while(response.r1._byte != 0x00 && timeout != 0);
1368:              				response = SendMMCCmd(READ_OCR, 0x0);
1369:              		        if (((response.r7.bytewise._returnVal & 0xC0000000) == 0xC0000000) && (response.r7.bytewise._byte == 0))
1370:              				{
1371:              	            	gSDMode = SD_MODE_HC;
1372:              				}
1373:              		        else //if (((response.r7.bytewise._returnVal & 0xC0000000) == 0x80000000) && (response.r7.bytewise._byte == 0))
1374:              				{
1375:              					gSDMode = SD_MODE_NORMAL;
1376:              				}
1377:              			}
1378:              	        else
1379:              			{
1380:              	            gSDMode = SD_MODE_NORMAL;
1381:              	
1382:              		        // According to spec cmd1 must be repeated until the card is fully initialized
1383:              		        timeout = 0xFFF;
1384:              		        do
1385:              		        {
1386:              		            response = SendMMCCmd(SEND_OP_COND,0x0);
1387:              		            timeout--;
1388:              		        }while(response.r1._byte != 0x00 && timeout != 0);
1389:              			}
1390:              
1391:                 		#else	//else of (#if (GetSystemClock() < 25600000))
1392:              	        // Make sure the SPI module doesn't control the bus
1393:              	        SPICON1 = 0x00;
  21FC    6A72     CLRF 0xf72, ACCESS
1394:              	
1395:              	        //Media requires 80 clock cycles to startup [8 clocks/BYTE * 10 us]
1396:              	        for(timeout=0; timeout<10; timeout++)
  21FE    6ADE     CLRF 0xfde, ACCESS
  2200    6ADD     CLRF 0xfdd, ACCESS
  2202    CFDE     MOVFF 0xfde, 0x14
  2204    F014     NOP
  2206    CFDD     MOVFF 0xfdd, 0x15
  2208    F015     NOP
  220A    0E0A     MOVLW 0xa
  220C    5C14     SUBWF 0x14, W, ACCESS
  220E    0E00     MOVLW 0
  2210    5815     SUBWFB 0x15, W, ACCESS
  2212    E208     BC 0x2224
  221A    2ADF     INCF 0xfdf, F, ACCESS
  221C    0E01     MOVLW 0x1
  221E    E3F1     BNC 0x2202
  2220    2ADB     INCF 0xfdb, F, ACCESS
  2222    D7EF     BRA 0x2202
1397:              	            WriteSPIManual(0xFF);
  2214    68E6     SETF 0xfe6, ACCESS
  2216    DF58     RCALL 0x20c8
  2218    52E5     MOVF 0xfe5, F, ACCESS
1398:              	    
1399:              	        SD_CS = 0;
  2224    9081     BCF 0xf81, 0, ACCESS
1400:              	        
1401:              	        Delayms(1);
  2226    0E01     MOVLW 0x1
  2228    6EE6     MOVWF 0xfe6, ACCESS
  222A    DED1     RCALL 0x1fce
  222C    52E5     MOVF 0xfe5, F, ACCESS
1402:              	    
1403:              	        // Send CMD0 to reset the media
1404:              	        response = SendMMCCmdManual (GO_IDLE_STATE, 0x0);
  222E    6AE6     CLRF 0xfe6, ACCESS
  2230    6AE6     CLRF 0xfe6, ACCESS
  2232    6AE6     CLRF 0xfe6, ACCESS
  2234    6AE6     CLRF 0xfe6, ACCESS
  2236    6AE6     CLRF 0xfe6, ACCESS
  2238    EC05     CALL 0x160a, 0
  223A    F00B     NOP
  223C    CFEE     MOVFF 0xfee, 0x14
  223E    F014     NOP
  2240    CFEE     MOVFF 0xfee, 0x15
  2242    F015     NOP
  2244    CFEE     MOVFF 0xfee, 0x16
  2246    F016     NOP
  2248    CFEE     MOVFF 0xfee, 0x17
  224A    F017     NOP
  224C    CFEE     MOVFF 0xfee, 0x18
  224E    F018     NOP
  2250    6E19     MOVWF 0x19, ACCESS
  2252    0E05     MOVLW 0x5
  2254    5EE1     SUBWF 0xfe1, F, ACCESS
  2256    5019     MOVF 0x19, W, ACCESS
  2258    0E02     MOVLW 0x2
  225A    C014     MOVFF 0x14, 0xfdb
  225C    FFDB     NOP
  225E    0E03     MOVLW 0x3
  2260    C015     MOVFF 0x15, 0xfdb
  2262    FFDB     NOP
  2264    0E04     MOVLW 0x4
  2266    C016     MOVFF 0x16, 0xfdb
  2268    FFDB     NOP
  226A    0E05     MOVLW 0x5
  226C    C017     MOVFF 0x17, 0xfdb
  226E    FFDB     NOP
  2270    0E06     MOVLW 0x6
  2272    C018     MOVFF 0x18, 0xfdb
  2274    FFDB     NOP
1405:              	
1406:              	        if ((response.r1._byte == MMC_BAD_RESPONSE) || ((response.r1._byte & 0xF7) != 0x01))
  2276    0E02     MOVLW 0x2
  2278    50DB     MOVF 0xfdb, W, ACCESS
  227A    08FF     SUBLW 0xff
  227C    E005     BZ 0x2288
  227E    0E02     MOVLW 0x2
  2280    50DB     MOVF 0xfdb, W, ACCESS
  2282    0BF7     ANDLW 0xf7
  2284    0801     SUBLW 0x1
  2286    E005     BZ 0x2292
1407:              	        {
1408:              	            SD_CS = 1;                              // deselect the devices
  2288    8081     BSF 0xf81, 0, ACCESS
1409:              	            mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
  228A    0101     MOVLB 0x1
  228C    0E02     MOVLW 0x2
  228E    6FD6     MOVWF 0xd6, BANKED
1410:              	            return &mediaInformation;
  2290    D31D     BRA 0x28cc
1411:              	        }
1412:              	
1413:              	        response = SendMMCCmdManual(SEND_IF_COND, 0x1AA);
  2292    0EAA     MOVLW 0xaa
  2294    6EE6     MOVWF 0xfe6, ACCESS
  2296    0E01     MOVLW 0x1
  2298    6EE6     MOVWF 0xfe6, ACCESS
  229A    6AE6     CLRF 0xfe6, ACCESS
  229C    6AE6     CLRF 0xfe6, ACCESS
  229E    0E02     MOVLW 0x2
  22A0    6EE6     MOVWF 0xfe6, ACCESS
  22A2    EC05     CALL 0x160a, 0
  22A4    F00B     NOP
  22A6    CFEE     MOVFF 0xfee, 0x14
  22A8    F014     NOP
  22AA    CFEE     MOVFF 0xfee, 0x15
  22AC    F015     NOP
  22AE    CFEE     MOVFF 0xfee, 0x16
  22B0    F016     NOP
  22B2    CFEE     MOVFF 0xfee, 0x17
  22B4    F017     NOP
  22B6    CFEE     MOVFF 0xfee, 0x18
  22B8    F018     NOP
  22BA    6E19     MOVWF 0x19, ACCESS
  22BC    0E05     MOVLW 0x5
  22BE    5EE1     SUBWF 0xfe1, F, ACCESS
  22C0    5019     MOVF 0x19, W, ACCESS
  22C2    0E02     MOVLW 0x2
  22C4    C014     MOVFF 0x14, 0xfdb
  22C6    FFDB     NOP
  22C8    0E03     MOVLW 0x3
  22CA    C015     MOVFF 0x15, 0xfdb
  22CC    FFDB     NOP
  22CE    0E04     MOVLW 0x4
  22D0    C016     MOVFF 0x16, 0xfdb
  22D2    FFDB     NOP
  22D4    0E05     MOVLW 0x5
  22D6    C017     MOVFF 0x17, 0xfdb
  22D8    FFDB     NOP
  22DA    0E06     MOVLW 0x6
  22DC    C018     MOVFF 0x18, 0xfdb
  22DE    FFDB     NOP
1414:              	        if (((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD))
  22E0    6814     SETF 0x14, ACCESS
  22E2    0E0F     MOVLW 0xf
  22E4    6E15     MOVWF 0x15, ACCESS
  22E6    6A16     CLRF 0x16, ACCESS
  22E8    6A17     CLRF 0x17, ACCESS
  22EA    50D9     MOVF 0xfd9, W, ACCESS
  22EC    0F03     ADDLW 0x3
  22EE    6EE9     MOVWF 0xfe9, ACCESS
  22F0    CFDA     MOVFF 0xfda, 0xfea
  22F2    FFEA     NOP
  22F4    50EE     MOVF 0xfee, W, ACCESS
  22F6    1614     ANDWF 0x14, F, ACCESS
  22F8    50EE     MOVF 0xfee, W, ACCESS
  22FA    1615     ANDWF 0x15, F, ACCESS
  22FC    50EE     MOVF 0xfee, W, ACCESS
  22FE    1616     ANDWF 0x16, F, ACCESS
  2300    50EE     MOVF 0xfee, W, ACCESS
  2302    1617     ANDWF 0x17, F, ACCESS
  2304    0EAA     MOVLW 0xaa
  2306    1814     XORWF 0x14, W, ACCESS
  2308    E001     BZ 0x230c
  230A    D094     BRA 0x2434
  230C    0E01     MOVLW 0x1
  230E    1815     XORWF 0x15, W, ACCESS
  2310    E001     BZ 0x2314
  2312    D090     BRA 0x2434
  2314    5016     MOVF 0x16, W, ACCESS
  2316    E001     BZ 0x231a
  2318    D08D     BRA 0x2434
  231A    5017     MOVF 0x17, W, ACCESS
  231C    E001     BZ 0x2320
  231E    D08A     BRA 0x2434
  2320    50D9     MOVF 0xfd9, W, ACCESS
  2322    0F02     ADDLW 0x2
  2324    6EE9     MOVWF 0xfe9, ACCESS
  2326    CFDA     MOVFF 0xfda, 0xfea
  2328    FFEA     NOP
  232A    50EF     MOVF 0xfef, W, ACCESS
  232C    0B04     ANDLW 0x4
  232E    E001     BZ 0x2332
  2330    D081     BRA 0x2434
1415:              			{
1416:              		        timeout = 0xFFF;
  2332    68DE     SETF 0xfde, ACCESS
  2334    0E0F     MOVLW 0xf
  2336    6EDD     MOVWF 0xfdd, ACCESS
1417:              		        do
1418:              		        {
1419:              	                response = SendMMCCmdManual(SEND_OP_COND, 0x40000000);
  2338    6AE6     CLRF 0xfe6, ACCESS
  233A    6AE6     CLRF 0xfe6, ACCESS
  233C    6AE6     CLRF 0xfe6, ACCESS
  233E    0E40     MOVLW 0x40
  2340    6EE6     MOVWF 0xfe6, ACCESS
  2342    0E01     MOVLW 0x1
  2344    6EE6     MOVWF 0xfe6, ACCESS
  2346    EC05     CALL 0x160a, 0
  2348    F00B     NOP
  234A    CFEE     MOVFF 0xfee, 0x14
  234C    F014     NOP
  234E    CFEE     MOVFF 0xfee, 0x15
  2350    F015     NOP
  2352    CFEE     MOVFF 0xfee, 0x16
  2354    F016     NOP
  2356    CFEE     MOVFF 0xfee, 0x17
  2358    F017     NOP
  235A    CFEE     MOVFF 0xfee, 0x18
  235C    F018     NOP
  235E    6E19     MOVWF 0x19, ACCESS
  2360    0E05     MOVLW 0x5
  2362    5EE1     SUBWF 0xfe1, F, ACCESS
  2364    5019     MOVF 0x19, W, ACCESS
  2366    0E02     MOVLW 0x2
  2368    C014     MOVFF 0x14, 0xfdb
  236A    FFDB     NOP
  236C    0E03     MOVLW 0x3
  236E    C015     MOVFF 0x15, 0xfdb
  2370    FFDB     NOP
  2372    0E04     MOVLW 0x4
  2374    C016     MOVFF 0x16, 0xfdb
  2376    FFDB     NOP
  2378    0E05     MOVLW 0x5
  237A    C017     MOVFF 0x17, 0xfdb
  237C    FFDB     NOP
  237E    0E06     MOVLW 0x6
  2380    C018     MOVFF 0x18, 0xfdb
  2382    FFDB     NOP
1420:              		            timeout--;
  2384    06DF     DECF 0xfdf, F, ACCESS
  2386    0E01     MOVLW 0x1
  2388    E201     BC 0x238c
  238A    06DB     DECF 0xfdb, F, ACCESS
1421:              		        }while(response.r1._byte != 0x00 && timeout != 0);
  238C    0E02     MOVLW 0x2
  238E    50DB     MOVF 0xfdb, W, ACCESS
  2390    E007     BZ 0x23a0
  2392    CFD9     MOVFF 0xfd9, 0xfe9
  2394    FFE9     NOP
  2396    CFDA     MOVFF 0xfda, 0xfea
  2398    FFEA     NOP
  239A    50EE     MOVF 0xfee, W, ACCESS
  239C    10ED     IORWF 0xfed, W, ACCESS
  239E    E1CC     BNZ 0x2338
1422:              				response = SendMMCCmdManual(READ_OCR, 0x0);
  23A0    6AE6     CLRF 0xfe6, ACCESS
  23A2    6AE6     CLRF 0xfe6, ACCESS
  23A4    6AE6     CLRF 0xfe6, ACCESS
  23A6    6AE6     CLRF 0xfe6, ACCESS
  23A8    0E10     MOVLW 0x10
  23AA    6EE6     MOVWF 0xfe6, ACCESS
  23AC    EC05     CALL 0x160a, 0
  23AE    F00B     NOP
  23B0    CFEE     MOVFF 0xfee, 0x14
  23B2    F014     NOP
  23B4    CFEE     MOVFF 0xfee, 0x15
  23B6    F015     NOP
  23B8    CFEE     MOVFF 0xfee, 0x16
  23BA    F016     NOP
  23BC    CFEE     MOVFF 0xfee, 0x17
  23BE    F017     NOP
  23C0    CFEE     MOVFF 0xfee, 0x18
  23C2    F018     NOP
  23C4    6E19     MOVWF 0x19, ACCESS
  23C6    0E05     MOVLW 0x5
  23C8    5EE1     SUBWF 0xfe1, F, ACCESS
  23CA    5019     MOVF 0x19, W, ACCESS
  23CC    0E02     MOVLW 0x2
  23CE    C014     MOVFF 0x14, 0xfdb
  23D0    FFDB     NOP
  23D2    0E03     MOVLW 0x3
  23D4    C015     MOVFF 0x15, 0xfdb
  23D6    FFDB     NOP
  23D8    0E04     MOVLW 0x4
  23DA    C016     MOVFF 0x16, 0xfdb
  23DC    FFDB     NOP
  23DE    0E05     MOVLW 0x5
  23E0    C017     MOVFF 0x17, 0xfdb
  23E2    FFDB     NOP
  23E4    0E06     MOVLW 0x6
  23E6    C018     MOVFF 0x18, 0xfdb
  23E8    FFDB     NOP
1423:              		        if (((response.r7.bytewise._returnVal & 0xC0000000) == 0xC0000000) && (response.r7.bytewise._byte == 0))
  23EA    6A14     CLRF 0x14, ACCESS
  23EC    6A15     CLRF 0x15, ACCESS
  23EE    6A16     CLRF 0x16, ACCESS
  23F0    0EC0     MOVLW 0xc0
  23F2    6E17     MOVWF 0x17, ACCESS
  23F4    50D9     MOVF 0xfd9, W, ACCESS
  23F6    0F03     ADDLW 0x3
  23F8    6EE9     MOVWF 0xfe9, ACCESS
  23FA    CFDA     MOVFF 0xfda, 0xfea
  23FC    FFEA     NOP
  23FE    50EE     MOVF 0xfee, W, ACCESS
  2400    1614     ANDWF 0x14, F, ACCESS
  2402    50EE     MOVF 0xfee, W, ACCESS
  2404    1615     ANDWF 0x15, F, ACCESS
  2406    50EE     MOVF 0xfee, W, ACCESS
  2408    1616     ANDWF 0x16, F, ACCESS
  240A    50EE     MOVF 0xfee, W, ACCESS
  240C    1617     ANDWF 0x17, F, ACCESS
  240E    5014     MOVF 0x14, W, ACCESS
  2410    E10E     BNZ 0x242e
  2412    5015     MOVF 0x15, W, ACCESS
  2414    E10C     BNZ 0x242e
  2416    5016     MOVF 0x16, W, ACCESS
  2418    E10A     BNZ 0x242e
  241A    0EC0     MOVLW 0xc0
  241C    1817     XORWF 0x17, W, ACCESS
  241E    E107     BNZ 0x242e
  2420    0E02     MOVLW 0x2
  2422    50DB     MOVF 0xfdb, W, ACCESS
  2424    E104     BNZ 0x242e
1424:              				{
1425:              	            	gSDMode = SD_MODE_HC;
  2426    0101     MOVLB 0x1
  2428    0E01     MOVLW 0x1
  242A    6FD5     MOVWF 0xd5, BANKED
1426:              				}
1427:              		        else //if (((response.r7.bytewise._returnVal & 0xC0000000) == 0x80000000) && (response.r7.bytewise._byte == 0))
  242C    D03B     BRA 0x24a4
1428:              				{
1429:              					gSDMode = SD_MODE_NORMAL;
  242E    0101     MOVLB 0x1
  2430    6BD5     CLRF 0xd5, BANKED
1430:              				}
1431:              			}
1432:              	        else
  2432    D038     BRA 0x24a4
1433:              			{
1434:              	            gSDMode = SD_MODE_NORMAL;
  2434    0101     MOVLB 0x1
  2436    6BD5     CLRF 0xd5, BANKED
1435:              	        	// According to the spec cmd1 must be repeated until the card is fully initialized
1436:              	        	timeout = 0xFFF;
  2438    68DE     SETF 0xfde, ACCESS
  243A    0E0F     MOVLW 0xf
  243C    6EDD     MOVWF 0xfdd, ACCESS
1437:              		        do
1438:              		        {
1439:              		            response = SendMMCCmdManual (SEND_OP_COND, 0x0);
  243E    6AE6     CLRF 0xfe6, ACCESS
  2440    6AE6     CLRF 0xfe6, ACCESS
  2442    6AE6     CLRF 0xfe6, ACCESS
  2444    6AE6     CLRF 0xfe6, ACCESS
  2446    0E01     MOVLW 0x1
  2448    6EE6     MOVWF 0xfe6, ACCESS
  244A    EC05     CALL 0x160a, 0
  244C    F00B     NOP
  244E    CFEE     MOVFF 0xfee, 0x14
  2450    F014     NOP
  2452    CFEE     MOVFF 0xfee, 0x15
  2454    F015     NOP
  2456    CFEE     MOVFF 0xfee, 0x16
  2458    F016     NOP
  245A    CFEE     MOVFF 0xfee, 0x17
  245C    F017     NOP
  245E    CFEE     MOVFF 0xfee, 0x18
  2460    F018     NOP
  2462    6E19     MOVWF 0x19, ACCESS
  2464    0E05     MOVLW 0x5
  2466    5EE1     SUBWF 0xfe1, F, ACCESS
  2468    5019     MOVF 0x19, W, ACCESS
  246A    0E02     MOVLW 0x2
  246C    C014     MOVFF 0x14, 0xfdb
  246E    FFDB     NOP
  2470    0E03     MOVLW 0x3
  2472    C015     MOVFF 0x15, 0xfdb
  2474    FFDB     NOP
  2476    0E04     MOVLW 0x4
  2478    C016     MOVFF 0x16, 0xfdb
  247A    FFDB     NOP
  247C    0E05     MOVLW 0x5
  247E    C017     MOVFF 0x17, 0xfdb
  2480    FFDB     NOP
  2482    0E06     MOVLW 0x6
  2484    C018     MOVFF 0x18, 0xfdb
  2486    FFDB     NOP
1440:              		            timeout--;
  2488    06DF     DECF 0xfdf, F, ACCESS
  248A    0E01     MOVLW 0x1
  248C    E201     BC 0x2490
  248E    06DB     DECF 0xfdb, F, ACCESS
1441:              		        }while(response.r1._byte != 0x00 && timeout != 0);
  2490    0E02     MOVLW 0x2
  2492    50DB     MOVF 0xfdb, W, ACCESS
  2494    E007     BZ 0x24a4
  2496    CFD9     MOVFF 0xfd9, 0xfe9
  2498    FFE9     NOP
  249A    CFDA     MOVFF 0xfda, 0xfea
  249C    FFEA     NOP
  249E    50EE     MOVF 0xfee, W, ACCESS
  24A0    10ED     IORWF 0xfed, W, ACCESS
  24A2    E1CD     BNZ 0x243e
1442:              			}
1443:                  	#endif //end of #if (GetSystemClock() < 25600000), and #else
1444:              
1445:                  // see if it failed
1446:                  if (timeout == 0)
  24A4    CFD9     MOVFF 0xfd9, 0xfe9
  24A6    FFE9     NOP
  24A8    CFDA     MOVFF 0xfda, 0xfea
  24AA    FFEA     NOP
  24AC    50EE     MOVF 0xfee, W, ACCESS
  24AE    10ED     IORWF 0xfed, W, ACCESS
  24B0    E105     BNZ 0x24bc
1447:                  {
1448:                      mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE;
  24B2    0101     MOVLB 0x1
  24B4    0E02     MOVLW 0x2
  24B6    6FD6     MOVWF 0xd6, BANKED
1449:                      SD_CS = 1;                              // deselect the devices
  24B8    8081     BSF 0xf81, 0, ACCESS
1450:                  }
1451:                  else
  24BA    D208     BRA 0x28cc
1452:                  {
1453:              	#endif	//end of (#if defined __C30__ || defined __C32__)), and #else (PIC18)
1454:              	//Common code below for all processors.
1455:              
1456:                      Delayms (2);
  24BC    0E02     MOVLW 0x2
  24BE    6EE6     MOVWF 0xfe6, ACCESS
  24C0    DD86     RCALL 0x1fce
  24C2    52E5     MOVF 0xfe5, F, ACCESS
1457:              
1458:                      #ifdef __PIC32MX__
1459:                          #if (GetSystemClock() <= 20000000)
1460:                              SPIBRG = SPICalutateBRG(GetPeripheralClock(), 10000);
1461:                          #else
1462:                              SPIBRG = SPICalutateBRG(GetPeripheralClock(), SPI_FREQUENCY);
1463:                          #endif
1464:                      #else
1465:                          OpenSPIM(SYNC_MODE_FAST);
  24C4    6AE6     CLRF 0xfe6, ACCESS
  24C6    DDED     RCALL 0x20a2
  24C8    52E5     MOVF 0xfe5, F, ACCESS
1466:                      #endif
1467:              
1468:              		/* Send the CMD9 to read the CSD register */
1469:                      timeout = 0xFFF;
  24CA    68DE     SETF 0xfde, ACCESS
  24CC    0E0F     MOVLW 0xf
  24CE    6EDD     MOVWF 0xfdd, ACCESS
1470:                      do
1471:                      {
1472:              			response = SendMMCCmd(SEND_CSD, 0x00);
  24D0    6AE6     CLRF 0xfe6, ACCESS
  24D2    6AE6     CLRF 0xfe6, ACCESS
  24D4    6AE6     CLRF 0xfe6, ACCESS
  24D6    6AE6     CLRF 0xfe6, ACCESS
  24D8    0E03     MOVLW 0x3
  24DA    6EE6     MOVWF 0xfe6, ACCESS
  24DC    EC81     CALL 0x1102, 0
  24DE    F008     NOP
  24E0    CFEE     MOVFF 0xfee, 0x14
  24E2    F014     NOP
  24E4    CFEE     MOVFF 0xfee, 0x15
  24E6    F015     NOP
  24E8    CFEE     MOVFF 0xfee, 0x16
  24EA    F016     NOP
  24EC    CFEE     MOVFF 0xfee, 0x17
  24EE    F017     NOP
  24F0    CFEE     MOVFF 0xfee, 0x18
  24F2    F018     NOP
  24F4    6E19     MOVWF 0x19, ACCESS
  24F6    0E05     MOVLW 0x5
  24F8    5EE1     SUBWF 0xfe1, F, ACCESS
  24FA    5019     MOVF 0x19, W, ACCESS
  24FC    0E02     MOVLW 0x2
  24FE    C014     MOVFF 0x14, 0xfdb
  2500    FFDB     NOP
  2502    0E03     MOVLW 0x3
  2504    C015     MOVFF 0x15, 0xfdb
  2506    FFDB     NOP
  2508    0E04     MOVLW 0x4
  250A    C016     MOVFF 0x16, 0xfdb
  250C    FFDB     NOP
  250E    0E05     MOVLW 0x5
  2510    C017     MOVFF 0x17, 0xfdb
  2512    FFDB     NOP
  2514    0E06     MOVLW 0x6
  2516    C018     MOVFF 0x18, 0xfdb
  2518    FFDB     NOP
1473:                          timeout--;
  251A    06DF     DECF 0xfdf, F, ACCESS
  251C    0E01     MOVLW 0x1
  251E    E201     BC 0x2522
  2520    06DB     DECF 0xfdb, F, ACCESS
1474:                      }while((response.r1._byte != 0x00) && (timeout != 0));
  2522    0E02     MOVLW 0x2
  2524    50DB     MOVF 0xfdb, W, ACCESS
  2526    E007     BZ 0x2536
  2528    CFD9     MOVFF 0xfd9, 0xfe9
  252A    FFE9     NOP
  252C    CFDA     MOVFF 0xfda, 0xfea
  252E    FFEA     NOP
  2530    50EE     MOVF 0xfee, W, ACCESS
  2532    10ED     IORWF 0xfed, W, ACCESS
  2534    E1CD     BNZ 0x24d0
1475:              
1476:              		/* According to the simplified spec, section 7.2.6, the card will respond
1477:              		with a standard response token, followed by a data block of 16 bytes
1478:              		suffixed with a 16-bit CRC.*/
1479:              		index = 0;
  2536    0E1C     MOVLW 0x1c
  2538    6ADB     CLRF 0xfdb, ACCESS
1480:              		for (count = 0; count < 20; count ++)
  253A    0E1B     MOVLW 0x1b
  253C    6ADB     CLRF 0xfdb, ACCESS
  253E    0E14     MOVLW 0x14
  2540    6EF3     MOVWF 0xff3, ACCESS
  2542    0E1B     MOVLW 0x1b
  2544    CFDB     MOVFF 0xfdb, 0xff4
  2546    FFF4     NOP
  2548    50F3     MOVF 0xff3, W, ACCESS
  254A    5CF4     SUBWF 0xff4, W, ACCESS
  254C    E220     BC 0x258e
  2588    0E1B     MOVLW 0x1b
  258A    2ADB     INCF 0xfdb, F, ACCESS
  258C    D7D8     BRA 0x253e
1481:              		{
1482:              			CSDResponse[index] = MDD_SDSPI_ReadMedia();
  254E    DD98     RCALL 0x2080
  2550    6EE6     MOVWF 0xfe6, ACCESS
  2552    50D9     MOVF 0xfd9, W, ACCESS
  2554    0F07     ADDLW 0x7
  2556    6E14     MOVWF 0x14, ACCESS
  2558    CFDA     MOVFF 0xfda, 0x15
  255A    F015     NOP
  255C    0E1C     MOVLW 0x1c
  255E    50DB     MOVF 0xfdb, W, ACCESS
  2560    010F     MOVLB 0xf
  2562    2414     ADDWF 0x14, W, ACCESS
  2564    6EE9     MOVWF 0xfe9, ACCESS
  2566    0E00     MOVLW 0
  2568    20DA     ADDWFC 0xfda, W, ACCESS
  256A    6EEA     MOVWF 0xfea, ACCESS
  256C    52E5     MOVF 0xfe5, F, ACCESS
  256E    50E7     MOVF 0xfe7, W, ACCESS
  2570    6EEF     MOVWF 0xfef, ACCESS
1483:              			index ++;			
  2572    0E1C     MOVLW 0x1c
  2574    2ADB     INCF 0xfdb, F, ACCESS
1484:              			/* Hopefully the first byte is the datatoken, however, some cards do
1485:              			not send the response token before the CSD register.*/
1486:              			if((count == 0) && (CSDResponse[0] == DATA_START_TOKEN))
  2576    0E1B     MOVLW 0x1b
  2578    50DB     MOVF 0xfdb, W, ACCESS
  257A    E106     BNZ 0x2588
  257C    0E07     MOVLW 0x7
  257E    50DB     MOVF 0xfdb, W, ACCESS
  2580    08FE     SUBLW 0xfe
  2582    E102     BNZ 0x2588
1487:              			{
1488:              				/* As the first byte was the datatoken, we can drop it. */
1489:              				index = 0;
  2584    0E1C     MOVLW 0x1c
  2586    6ADB     CLRF 0xfdb, ACCESS
1490:              			}
1491:              		}
1492:              
1493:              		//Extract some fields from the response for computing the card capacity.
1494:              		//Note: The structure format depends on if it is a CSD V1 or V2 device.
1495:              		//Therefore, need to first determine version of the specs that the card 
1496:              		//is designed for, before interpreting the individual fields.
1497:              
1498:               		//-------------------------------------------------------------
1499:               		//READ_BL_LEN: CSD Structure v1 cards always support 512 byte
1500:               		//read and write block lengths.  Some v1 cards may optionally report
1501:               		//READ_BL_LEN = 1024 or 2048 bytes (and therefore WRITE_BL_LEN also 
1502:               		//1024 or 2048).  However, even on these cards, 512 byte partial reads
1503:               		//and 512 byte write are required to be supported.
1504:               		//On CSD structure v2 cards, it is always required that READ_BL_LEN 
1505:               		//(and therefore WRITE_BL_LEN) be 512 bytes, and partial reads and
1506:               		//writes are not allowed.
1507:               		//Therefore, all cards support 512 byte reads/writes, but only a subset
1508:               		//of cards support other sizes.  For best compatibility with all cards,
1509:               		//and the simplest firmware design, it is therefore preferrable to 
1510:               		//simply ignore the READ_BL_LEN and WRITE_BL_LEN values altogether,
1511:               		//and simply hardcode the read/write block size as 512 bytes.
1512:               		//-------------------------------------------------------------
1513:              		gMediaSectorSize = 512u;
  258E    0101     MOVLB 0x1
  2590    6BD3     CLRF 0xd3, BANKED
  2592    0E02     MOVLW 0x2
  2594    6FD4     MOVWF 0xd4, BANKED
1514:              		mediaInformation.validityFlags.bits.sectorSize = TRUE;
  2596    81D7     BSF 0xd7, 0, BANKED
1515:               		mediaInformation.sectorSize = gMediaSectorSize;
  2598    C1D3     MOVFF 0x1d3, 0x1d8
  259A    F1D8     NOP
  259C    6FD9     MOVWF 0xd9, BANKED
1516:               		//-------------------------------------------------------------
1517:              
1518:              		//Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2).
1519:              		//In USB mass storage applications, we will need this information to 
1520:              		//correctly respond to SCSI get capacity requests.  Note: method of computing 
1521:              		//MDD_SDSPI_finalLBA depends on CSD structure spec version (either v1 or v2).
1522:              		if(CSDResponse[0] & 0xC0)	//Check CSD_STRUCTURE field for v2+ struct device
  259E    0E07     MOVLW 0x7
  25A0    50DB     MOVF 0xfdb, W, ACCESS
  25A2    0BC0     ANDLW 0xc0
  25A4    E05A     BZ 0x265a
1523:              		{
1524:              			//Must be a v2 device (or a reserved higher version, that doesn't currently exist)
1525:              
1526:              			//Extract the C_SIZE field from the response.  It is a 22-bit number in bit position 69:48.  This is different from v1.  
1527:              			//It spans bytes 7, 8, and 9 of the response.
1528:              			c_size = (((DWORD)CSDResponse[7] & 0x3F) << 16) | ((WORD)CSDResponse[8] << 8) | CSDResponse[9];
  25A6    0E0E     MOVLW 0xe
  25A8    CFDB     MOVFF 0xfdb, 0x14
  25AA    F014     NOP
  25AC    6A15     CLRF 0x15, ACCESS
  25AE    6A16     CLRF 0x16, ACCESS
  25B0    6A17     CLRF 0x17, ACCESS
  25B2    0E3F     MOVLW 0x3f
  25B4    1614     ANDWF 0x14, F, ACCESS
  25B6    6A15     CLRF 0x15, ACCESS
  25B8    6A16     CLRF 0x16, ACCESS
  25BA    6A17     CLRF 0x17, ACCESS
  25BC    0E10     MOVLW 0x10
  25BE    0B1F     ANDLW 0x1f
  25C0    E007     BZ 0x25d0
  25C2    90D8     BCF 0xfd8, 0, ACCESS
  25C4    3614     RLCF 0x14, F, ACCESS
  25C6    3615     RLCF 0x15, F, ACCESS
  25C8    3616     RLCF 0x16, F, ACCESS
  25CA    3617     RLCF 0x17, F, ACCESS
  25CC    06E8     DECF 0xfe8, F, ACCESS
  25CE    E1F9     BNZ 0x25c2
  25D0    0E0F     MOVLW 0xf
  25D2    CFDB     MOVFF 0xfdb, 0x18
  25D4    F018     NOP
  25D6    C018     MOVFF 0x18, 0x19
  25D8    F019     NOP
  25DA    6A18     CLRF 0x18, ACCESS
  25DC    6A1A     CLRF 0x1a, ACCESS
  25DE    6A1B     CLRF 0x1b, ACCESS
  25E0    5018     MOVF 0x18, W, ACCESS
  25E2    1214     IORWF 0x14, F, ACCESS
  25E4    5019     MOVF 0x19, W, ACCESS
  25E6    1215     IORWF 0x15, F, ACCESS
  25E8    501A     MOVF 0x1a, W, ACCESS
  25EA    1216     IORWF 0x16, F, ACCESS
  25EC    501B     MOVF 0x1b, W, ACCESS
  25EE    1217     IORWF 0x17, F, ACCESS
  25F0    0E10     MOVLW 0x10
  25F2    CFDB     MOVFF 0xfdb, 0x1c
  25F4    F01C     NOP
  25F6    6A1D     CLRF 0x1d, ACCESS
  25F8    6A1E     CLRF 0x1e, ACCESS
  25FA    6A1F     CLRF 0x1f, ACCESS
  25FC    501C     MOVF 0x1c, W, ACCESS
  25FE    1214     IORWF 0x14, F, ACCESS
  2600    501D     MOVF 0x1d, W, ACCESS
  2602    1215     IORWF 0x15, F, ACCESS
  2604    501E     MOVF 0x1e, W, ACCESS
  2606    1216     IORWF 0x16, F, ACCESS
  2608    501F     MOVF 0x1f, W, ACCESS
  260A    1217     IORWF 0x17, F, ACCESS
  260C    0E1D     MOVLW 0x1d
  260E    C014     MOVFF 0x14, 0xfdb
  2610    FFDB     NOP
  2612    0E1E     MOVLW 0x1e
  2614    C015     MOVFF 0x15, 0xfdb
  2616    FFDB     NOP
  2618    0E1F     MOVLW 0x1f
  261A    C016     MOVFF 0x16, 0xfdb
  261C    FFDB     NOP
  261E    0E20     MOVLW 0x20
  2620    C017     MOVFF 0x17, 0xfdb
  2622    FFDB     NOP
1529:              			
1530:              			MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)(1024u)) - 1; //-1 on end is correction factor, since LBA = 0 is valid.
  2624    0E1D     MOVLW 0x1d
  2626    CFDB     MOVFF 0xfdb, 0x1cf
  2628    F1CF     NOP
  262A    0E1E     MOVLW 0x1e
  262C    CFDB     MOVFF 0xfdb, 0x1d0
  262E    F1D0     NOP
  2630    0E1F     MOVLW 0x1f
  2632    CFDB     MOVFF 0xfdb, 0x1d1
  2634    F1D1     NOP
  2636    0E20     MOVLW 0x20
  2638    CFDB     MOVFF 0xfdb, 0x1d2
  263A    F1D2     NOP
  263C    0101     MOVLB 0x1
  263E    2BCF     INCF 0xcf, F, BANKED
  2640    0E00     MOVLW 0
  2642    23D0     ADDWFC 0xd0, F, BANKED
  2644    23D1     ADDWFC 0xd1, F, BANKED
  2646    23D2     ADDWFC 0xd2, F, BANKED
  2648    0E0A     MOVLW 0xa
  264A    90D8     BCF 0xfd8, 0, ACCESS
  264C    37CF     RLCF 0xcf, F, BANKED
  264E    37D0     RLCF 0xd0, F, BANKED
  2650    37D1     RLCF 0xd1, F, BANKED
  2652    37D2     RLCF 0xd2, F, BANKED
  2654    06E8     DECF 0xfe8, F, ACCESS
  2656    E1F9     BNZ 0x264a
1531:              		}
1532:              		else //if(CSDResponse[0] & 0xC0)	//Check CSD_STRUCTURE field for v1 struct device
  2658    D0DF     BRA 0x2818
1533:              		{
1534:              			//Must be a v1 device.
1535:              			//Extract the C_SIZE field from the response.  It is a 12-bit number in bit position 73:62.  
1536:              			//Although it is only a 12-bit number, it spans bytes 6, 7, and 8, since it isn't byte aligned.
1537:              			c_size = ((DWORD)CSDResponse[6] << 16) | ((WORD)CSDResponse[7] << 8) | CSDResponse[8];	//Get the bytes in the correct positions
  265A    0E0D     MOVLW 0xd
  265C    CFDB     MOVFF 0xfdb, 0x14
  265E    F014     NOP
  2660    6A15     CLRF 0x15, ACCESS
  2662    6A16     CLRF 0x16, ACCESS
  2664    6A17     CLRF 0x17, ACCESS
  2666    0E10     MOVLW 0x10
  2668    0B1F     ANDLW 0x1f
  266A    E007     BZ 0x267a
  266C    90D8     BCF 0xfd8, 0, ACCESS
  266E    3614     RLCF 0x14, F, ACCESS
  2670    3615     RLCF 0x15, F, ACCESS
  2672    3616     RLCF 0x16, F, ACCESS
  2674    3617     RLCF 0x17, F, ACCESS
  2676    06E8     DECF 0xfe8, F, ACCESS
  2678    E1F9     BNZ 0x266c
  267A    0E0E     MOVLW 0xe
  267C    CFDB     MOVFF 0xfdb, 0x18
  267E    F018     NOP
  2680    C018     MOVFF 0x18, 0x19
  2682    F019     NOP
  2684    6A18     CLRF 0x18, ACCESS
  2686    6A1A     CLRF 0x1a, ACCESS
  2688    6A1B     CLRF 0x1b, ACCESS
  268A    5018     MOVF 0x18, W, ACCESS
  268C    1214     IORWF 0x14, F, ACCESS
  268E    5019     MOVF 0x19, W, ACCESS
  2690    1215     IORWF 0x15, F, ACCESS
  2692    501A     MOVF 0x1a, W, ACCESS
  2694    1216     IORWF 0x16, F, ACCESS
  2696    501B     MOVF 0x1b, W, ACCESS
  2698    1217     IORWF 0x17, F, ACCESS
  269A    0E0F     MOVLW 0xf
  269C    CFDB     MOVFF 0xfdb, 0x1c
  269E    F01C     NOP
  26A0    6A1D     CLRF 0x1d, ACCESS
  26A2    6A1E     CLRF 0x1e, ACCESS
  26A4    6A1F     CLRF 0x1f, ACCESS
  26A6    501C     MOVF 0x1c, W, ACCESS
  26A8    1214     IORWF 0x14, F, ACCESS
  26AA    501D     MOVF 0x1d, W, ACCESS
  26AC    1215     IORWF 0x15, F, ACCESS
  26AE    501E     MOVF 0x1e, W, ACCESS
  26B0    1216     IORWF 0x16, F, ACCESS
  26B2    501F     MOVF 0x1f, W, ACCESS
  26B4    1217     IORWF 0x17, F, ACCESS
  26B6    0E1D     MOVLW 0x1d
  26B8    C014     MOVFF 0x14, 0xfdb
  26BA    FFDB     NOP
  26BC    0E1E     MOVLW 0x1e
  26BE    C015     MOVFF 0x15, 0xfdb
  26C0    FFDB     NOP
  26C2    0E1F     MOVLW 0x1f
  26C4    C016     MOVFF 0x16, 0xfdb
  26C6    FFDB     NOP
  26C8    0E20     MOVLW 0x20
  26CA    C017     MOVFF 0x17, 0xfdb
  26CC    FFDB     NOP
1538:              			c_size &= 0x0003FFC0;	//Clear all bits that aren't part of the C_SIZE
  26CE    50D9     MOVF 0xfd9, W, ACCESS
  26D0    0F1D     ADDLW 0x1d
  26D2    6EE9     MOVWF 0xfe9, ACCESS
  26D4    CFDA     MOVFF 0xfda, 0xfea
  26D6    FFEA     NOP
  26D8    0EC0     MOVLW 0xc0
  26DA    16EE     ANDWF 0xfee, F, ACCESS
  26DC    52EE     MOVF 0xfee, F, ACCESS
  26DE    0E03     MOVLW 0x3
  26E0    16EE     ANDWF 0xfee, F, ACCESS
  26E2    6AEE     CLRF 0xfee, ACCESS
1539:              			c_size = c_size >> 6;	//Shift value down, so the 12-bit C_SIZE is properly right justified in the DWORD.
  26E4    0E1D     MOVLW 0x1d
  26E6    CFDB     MOVFF 0xfdb, 0x14
  26E8    F014     NOP
  26EA    0E1E     MOVLW 0x1e
  26EC    CFDB     MOVFF 0xfdb, 0x15
  26EE    F015     NOP
  26F0    0E1F     MOVLW 0x1f
  26F2    CFDB     MOVFF 0xfdb, 0x16
  26F4    F016     NOP
  26F6    0E20     MOVLW 0x20
  26F8    CFDB     MOVFF 0xfdb, 0x17
  26FA    F017     NOP
  26FC    0E06     MOVLW 0x6
  26FE    90D8     BCF 0xfd8, 0, ACCESS
  2700    3217     RRCF 0x17, F, ACCESS
  2702    3216     RRCF 0x16, F, ACCESS
  2704    3215     RRCF 0x15, F, ACCESS
  2706    3214     RRCF 0x14, F, ACCESS
  2708    06E8     DECF 0xfe8, F, ACCESS
  270A    E1F9     BNZ 0x26fe
  270C    0E1D     MOVLW 0x1d
  270E    C014     MOVFF 0x14, 0xfdb
  2710    FFDB     NOP
  2712    0E1E     MOVLW 0x1e
  2714    C015     MOVFF 0x15, 0xfdb
  2716    FFDB     NOP
  2718    0E1F     MOVLW 0x1f
  271A    C016     MOVFF 0x16, 0xfdb
  271C    FFDB     NOP
  271E    0E20     MOVLW 0x20
  2720    C017     MOVFF 0x17, 0xfdb
  2722    FFDB     NOP
1540:              			
1541:              			//Extract the C_SIZE_MULT field from the response.  It is a 3-bit number in bit position 49:47.
1542:              			c_size_mult = ((WORD)((CSDResponse[9] & 0x03) << 1)) | ((WORD)((CSDResponse[10] & 0x80) >> 7));
  2724    0E10     MOVLW 0x10
  2726    50DB     MOVF 0xfdb, W, ACCESS
  2728    0B03     ANDLW 0x3
  272A    24E8     ADDWF 0xfe8, W, ACCESS
  272C    6E14     MOVWF 0x14, ACCESS
  272E    0E11     MOVLW 0x11
  2730    50DB     MOVF 0xfdb, W, ACCESS
  2732    0B80     ANDLW 0x80
  2734    44E8     RLNCF 0xfe8, W, ACCESS
  2736    0B01     ANDLW 0x1
  2738    1014     IORWF 0x14, W, ACCESS
  273A    6EE7     MOVWF 0xfe7, ACCESS
  273C    0E21     MOVLW 0x21
  273E    CFE7     MOVFF 0xfe7, 0xfdb
  2740    FFDB     NOP
1543:              
1544:                          //Extract the BLOCK_LEN field from the response. It is a 4-bit number in bit position 83:80.
1545:                          block_len = CSDResponse[5] & 0x0F;
  2742    0E0C     MOVLW 0xc
  2744    50DB     MOVF 0xfdb, W, ACCESS
  2746    0B0F     ANDLW 0xf
  2748    6EE7     MOVWF 0xfe7, ACCESS
  274A    0E22     MOVLW 0x22
  274C    CFE7     MOVFF 0xfe7, 0xfdb
  274E    FFDB     NOP
1546:              
1547:                          block_len = 1 << (block_len - 9); //-9 because we report the size in sectors of 512 bytes each
  2750    50DB     MOVF 0xfdb, W, ACCESS
  2752    0FF7     ADDLW 0xf7
  2754    6E14     MOVWF 0x14, ACCESS
  2756    0E01     MOVLW 0x1
  2758    5214     MOVF 0x14, F, ACCESS
  275A    E004     BZ 0x2764
  275C    46E8     RLNCF 0xfe8, F, ACCESS
  275E    0BFE     ANDLW 0xfe
  2760    0614     DECF 0x14, F, ACCESS
  2762    E1FC     BNZ 0x275c
  2764    6EE7     MOVWF 0xfe7, ACCESS
  2766    0E22     MOVLW 0x22
  2768    CFE7     MOVFF 0xfe7, 0xfdb
  276A    FFDB     NOP
1548:              			
1549:              			//Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2).
1550:              			//In USB mass storage applications, we will need this information to 
1551:              			//correctly respond to SCSI get capacity requests (which will cause MDD_SDSPI_ReadCapacity() to get called).
1552:              			MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)((WORD)1 << (c_size_mult + 2)) * block_len) - 1;	//-1 on end is correction factor, since LBA = 0 is valid.		
  276C    CFDB     MOVFF 0xfdb, 0x20
  276E    F020     NOP
  2770    6A21     CLRF 0x21, ACCESS
  2772    6A22     CLRF 0x22, ACCESS
  2774    6A23     CLRF 0x23, ACCESS
  2776    0E21     MOVLW 0x21
  2778    50DB     MOVF 0xfdb, W, ACCESS
  277A    0F02     ADDLW 0x2
  277C    ECAA     CALL 0x6754, 0
  277E    F033     NOP
  2780    CFF3     MOVFF 0xff3, 0x1c
  2782    F01C     NOP
  2784    CFF4     MOVFF 0xff4, 0x1d
  2786    F01D     NOP
  2788    6A1E     CLRF 0x1e, ACCESS
  278A    6A1F     CLRF 0x1f, ACCESS
  278C    0E01     MOVLW 0x1
  278E    6E18     MOVWF 0x18, ACCESS
  2790    6A19     CLRF 0x19, ACCESS
  2792    6A1A     CLRF 0x1a, ACCESS
  2794    6A1B     CLRF 0x1b, ACCESS
  2796    50D9     MOVF 0xfd9, W, ACCESS
  2798    0F1D     ADDLW 0x1d
  279A    6EE9     MOVWF 0xfe9, ACCESS
  279C    CFDA     MOVFF 0xfda, 0xfea
  279E    FFEA     NOP
  27A0    50EE     MOVF 0xfee, W, ACCESS
  27A2    2618     ADDWF 0x18, F, ACCESS
  27A4    50EE     MOVF 0xfee, W, ACCESS
  27A6    2219     ADDWFC 0x19, F, ACCESS
  27A8    50EE     MOVF 0xfee, W, ACCESS
  27AA    221A     ADDWFC 0x1a, F, ACCESS
  27AC    50EE     MOVF 0xfee, W, ACCESS
  27AE    221B     ADDWFC 0x1b, F, ACCESS
  27B0    C018     MOVFF 0x18, 0x6
  27B2    F006     NOP
  27B4    C019     MOVFF 0x19, 0x7
  27B6    F007     NOP
  27B8    C01A     MOVFF 0x1a, 0x8
  27BA    F008     NOP
  27BC    C01B     MOVFF 0x1b, 0x9
  27BE    F009     NOP
  27C0    CFF3     MOVFF 0xff3, 0xb
  27C2    F00B     NOP
  27C4    CFF4     MOVFF 0xff4, 0xc
  27C6    F00C     NOP
  27C8    C01E     MOVFF 0x1e, 0xd
  27CA    F00D     NOP
  27CC    C01F     MOVFF 0x1f, 0xe
  27CE    F00E     NOP
  27D0    ECBC     CALL 0x6578, 0
  27D2    F032     NOP
  27D4    C002     MOVFF 0x2, 0x14
  27D6    F014     NOP
  27D8    C003     MOVFF 0x3, 0x15
  27DA    F015     NOP
  27DC    C004     MOVFF 0x4, 0x16
  27DE    F016     NOP
  27E0    C005     MOVFF 0x5, 0x17
  27E2    F017     NOP
  27E4    C002     MOVFF 0x2, 0x6
  27E6    F006     NOP
  27E8    C003     MOVFF 0x3, 0x7
  27EA    F007     NOP
  27EC    C004     MOVFF 0x4, 0x8
  27EE    F008     NOP
  27F0    C005     MOVFF 0x5, 0x9
  27F2    F009     NOP
  27F4    C020     MOVFF 0x20, 0xb
  27F6    F00B     NOP
  27F8    C021     MOVFF 0x21, 0xc
  27FA    F00C     NOP
  27FC    C022     MOVFF 0x22, 0xd
  27FE    F00D     NOP
  2800    C023     MOVFF 0x23, 0xe
  2802    F00E     NOP
  2804    ECBC     CALL 0x6578, 0
  2806    F032     NOP
  2808    C002     MOVFF 0x2, 0x1cf
  280A    F1CF     NOP
  280C    C003     MOVFF 0x3, 0x1d0
  280E    F1D0     NOP
  2810    C004     MOVFF 0x4, 0x1d1
  2812    F1D1     NOP
  2814    C005     MOVFF 0x5, 0x1d2
  2816    F1D2     NOP
  2818    0101     MOVLB 0x1
  281A    07CF     DECF 0xcf, F, BANKED
  281C    0E00     MOVLW 0
  281E    5BD0     SUBWFB 0xd0, F, BANKED
  2820    5BD1     SUBWFB 0xd1, F, BANKED
  2822    5BD2     SUBWFB 0xd2, F, BANKED
1553:              		}	
1554:              
1555:                      // Turn off CRC7 if we can, might be an invalid cmd on some cards (CMD59)
1556:                      response = SendMMCCmd(CRC_ON_OFF,0x0);
  2824    6AE6     CLRF 0xfe6, ACCESS
  2826    6AE6     CLRF 0xfe6, ACCESS
  2828    6AE6     CLRF 0xfe6, ACCESS
  282A    6AE6     CLRF 0xfe6, ACCESS
  282C    0E11     MOVLW 0x11
  282E    6EE6     MOVWF 0xfe6, ACCESS
  2830    EC81     CALL 0x1102, 0
  2832    F008     NOP
  2834    CFEE     MOVFF 0xfee, 0x14
  2836    F014     NOP
  2838    CFEE     MOVFF 0xfee, 0x15
  283A    F015     NOP
  283C    CFEE     MOVFF 0xfee, 0x16
  283E    F016     NOP
  2840    CFEE     MOVFF 0xfee, 0x17
  2842    F017     NOP
  2844    CFEE     MOVFF 0xfee, 0x18
  2846    F018     NOP
  2848    6E19     MOVWF 0x19, ACCESS
  284A    0E05     MOVLW 0x5
  284C    5EE1     SUBWF 0xfe1, F, ACCESS
  284E    5019     MOVF 0x19, W, ACCESS
  2850    0E02     MOVLW 0x2
  2852    C014     MOVFF 0x14, 0xfdb
  2854    FFDB     NOP
  2856    0E03     MOVLW 0x3
  2858    C015     MOVFF 0x15, 0xfdb
  285A    FFDB     NOP
  285C    0E04     MOVLW 0x4
  285E    C016     MOVFF 0x16, 0xfdb
  2860    FFDB     NOP
  2862    0E05     MOVLW 0x5
  2864    C017     MOVFF 0x17, 0xfdb
  2866    FFDB     NOP
  2868    0E06     MOVLW 0x6
  286A    C018     MOVFF 0x18, 0xfdb
  286C    FFDB     NOP
1557:              
1558:                      // Now set the block length to media sector size. It should be already
1559:                      response = SendMMCCmd(SET_BLOCKLEN,gMediaSectorSize);
  286E    C1D3     MOVFF 0x1d3, 0x19
  2870    F019     NOP
  2872    C1D4     MOVFF 0x1d4, 0x1a
  2874    F01A     NOP
  2876    6A1B     CLRF 0x1b, ACCESS
  2878    6A1C     CLRF 0x1c, ACCESS
  287A    C1D3     MOVFF 0x1d3, 0xfe6
  287C    FFE6     NOP
  287E    C1D4     MOVFF 0x1d4, 0xfe6
  2880    FFE6     NOP
  2882    C01B     MOVFF 0x1b, 0xfe6
  2884    FFE6     NOP
  2886    C01C     MOVFF 0x1c, 0xfe6
  2888    FFE6     NOP
  288A    0E07     MOVLW 0x7
  288C    6EE6     MOVWF 0xfe6, ACCESS
  288E    EC81     CALL 0x1102, 0
  2890    F008     NOP
  2892    CFEE     MOVFF 0xfee, 0x14
  2894    F014     NOP
  2896    CFEE     MOVFF 0xfee, 0x15
  2898    F015     NOP
  289A    CFEE     MOVFF 0xfee, 0x16
  289C    F016     NOP
  289E    CFEE     MOVFF 0xfee, 0x17
  28A0    F017     NOP
  28A2    CFEE     MOVFF 0xfee, 0x18
  28A4    F018     NOP
  28A6    6E1D     MOVWF 0x1d, ACCESS
  28A8    0E05     MOVLW 0x5
  28AA    5EE1     SUBWF 0xfe1, F, ACCESS
  28AC    501D     MOVF 0x1d, W, ACCESS
  28AE    0E02     MOVLW 0x2
  28B0    C014     MOVFF 0x14, 0xfdb
  28B2    FFDB     NOP
  28B4    0E03     MOVLW 0x3
  28B6    C015     MOVFF 0x15, 0xfdb
  28B8    FFDB     NOP
  28BA    0E04     MOVLW 0x4
  28BC    C016     MOVFF 0x16, 0xfdb
  28BE    FFDB     NOP
  28C0    0E05     MOVLW 0x5
  28C2    C017     MOVFF 0x17, 0xfdb
  28C4    FFDB     NOP
  28C6    0E06     MOVLW 0x6
  28C8    C018     MOVFF 0x18, 0xfdb
  28CA    FFDB     NOP
1560:                  }
1561:              
1562:                  return &mediaInformation;
  28CC    0ED6     MOVLW 0xd6
  28CE    6E14     MOVWF 0x14, ACCESS
  28D0    0E01     MOVLW 0x1
  28D2    6E15     MOVWF 0x15, ACCESS
  28D4    C014     MOVFF 0x14, 0xff3
  28D6    FFF3     NOP
  28D8    6EF4     MOVWF 0xff4, ACCESS
1563:              }//end MediaInitialize
  28DA    0E23     MOVLW 0x23
  28DC    5CE1     SUBWF 0xfe1, W, ACCESS
  28DE    E202     BC 0x28e4
  28E0    6AE1     CLRF 0xfe1, ACCESS
  28E2    52E5     MOVF 0xfe5, F, ACCESS
  28E4    6EE1     MOVWF 0xfe1, ACCESS
  28E6    52E5     MOVF 0xfe5, F, ACCESS
  28E8    CFE7     MOVFF 0xfe7, 0xfd9
  28EA    FFD9     NOP
  28EC    0012     RETURN 0
---  E:\Projects\DevPFG\Microchip\USB\CDC Device Driver\usb_function_cdc.c  ----------------------
1:                 /********************************************************************************
2:                   File Information:
3:                     FileName:       usb_function_cdc.c
4:                     Dependencies:   See INCLUDES section
5:                     Processor:      PIC18 or PIC24 USB Microcontrollers
6:                     Hardware:       The code is natively intended to be used on the following
7:                                     hardware platforms: PICDEMT FS USB Demo Board,
8:                                     PIC18F87J50 FS USB Plug-In Module, or
9:                                     Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                                    modified for use on other USB platforms by editing the
11:                                    HardwareProfile.h file.
12:                    Complier:   Microchip C18 (for PIC18) or C30 (for PIC24)
13:                    Company:        Microchip Technology, Inc.
14:                
15:                    Software License Agreement:
16:                
17:                    The software supplied herewith by Microchip Technology Incorporated
18:                    (the "Company") for its PICr Microcontroller is intended and
19:                    supplied to you, the Company's customer, for use solely and
20:                    exclusively on Microchip PIC Microcontroller products. The
21:                    software is owned by the Company and/or its supplier, and is
22:                    protected under applicable copyright laws. All rights are reserved.
23:                    Any use in violation of the foregoing restrictions may subject the
24:                    user to criminal sanctions under applicable laws, as well as to
25:                    civil liability for the breach of the terms and conditions of this
26:                    license.
27:                
28:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                    
35:                  Summary:
36:                    This file contains all of functions, macros, definitions, variables,
37:                    datatypes, etc. that are required for usage with the CDC function
38:                    driver. This file should be included in projects that use the CDC
39:                    \function driver.
40:                    
41:                    
42:                    
43:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
44:                    Device Driver" directory.
45:                  Description:
46:                    USB CDC Function Driver File
47:                    
48:                    This file contains all of functions, macros, definitions, variables,
49:                    datatypes, etc. that are required for usage with the CDC function
50:                    driver. This file should be included in projects that use the CDC
51:                    \function driver.
52:                    
53:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
54:                    Device Driver" directory.
55:                    
56:                    When including this file in a new project, this file can either be
57:                    referenced from the directory in which it was installed or copied
58:                    directly into the user application folder. If the first method is
59:                    chosen to keep the file located in the folder in which it is installed
60:                    then include paths need to be added so that the library and the
61:                    application both know where to reference each others files. If the
62:                    application folder is located in the same folder as the Microchip
63:                    folder (like the current demo folders), then the following include
64:                    paths need to be added to the application's project:
65:                    
66:                    ..\\Include
67:                    
68:                    .
69:                    
70:                    If a different directory structure is used, modify the paths as
71:                    required. An example using absolute paths instead of relative paths
72:                    would be the following:
73:                    
74:                    C:\\Microchip Solutions\\Microchip\\Include
75:                    
76:                    C:\\Microchip Solutions\\My Demo Application                                 
77:                  ********************************************************************************/
78:                
79:                /********************************************************************
80:                 Change History:
81:                  Rev    Description
82:                  ----   -----------
83:                  2.3    Decricated the mUSBUSARTIsTxTrfReady() macro.  It is 
84:                         replaced by the USBUSARTIsTxTrfReady() function.
85:                
86:                  2.6    Minor definition changes
87:                
88:                  2.6a   No Changes
89:                
90:                  2.7    Fixed error in the part support list of the variables section
91:                         where the address of the CDC variables are defined.  The 
92:                         PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
93:                         was incorrectly named PIC18F4458.
94:                
95:                         http://www.microchip.com/forums/fb.aspx?m=487397
96:                
97:                  2.8    Minor change to CDCInitEP() to enhance ruggedness in
98:                         multithreaded usage scenarios.
99:                
100:               ********************************************************************/
101:               
102:               /** I N C L U D E S **********************************************************/
103:               #include "USB/usb.h"
104:               #include "USB/usb_function_cdc.h"
105:               //#include "HardwareProfile.h"
106:               
107:               #ifdef USB_USE_CDC
108:               
109:               /** V A R I A B L E S ********************************************************/
110:               #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50) 
111:                   #pragma udata usbram2
112:               #elif defined(__18F2455) || defined(__18F2550) || defined(__18F4455) || defined(__18F4550)\
113:                   || defined(__18F2458) || defined(__18F2553) || defined(__18F4458) || defined(__18F4553)
114:                   #pragma udata USB_VARIABLES=0x500
115:               #elif defined(__18F4450) || defined(__18F2450)
116:               	#pragma udata USB_VARIABLES=0x480
117:               #else
118:                   #pragma udata
119:               #endif
120:               
121:               volatile FAR CDC_NOTICE cdc_notice;
122:               volatile FAR unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE];
123:               volatile FAR unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE];
124:               LINE_CODING line_coding;    // Buffer to store line coding information
125:               
126:               #pragma udata
127:               BYTE cdc_rx_len;            // total rx length
128:               
129:               BYTE cdc_trf_state;         // States are defined cdc.h
130:               POINTER pCDCSrc;            // Dedicated source pointer
131:               POINTER pCDCDst;            // Dedicated destination pointer
132:               BYTE cdc_tx_len;            // total tx length
133:               BYTE cdc_mem_type;          // _ROM, _RAM
134:               
135:               USB_HANDLE CDCDataOutHandle;
136:               USB_HANDLE CDCDataInHandle;
137:               
138:               
139:               CONTROL_SIGNAL_BITMAP control_signal_bitmap;
140:               DWORD BaudRateGen;			// BRG value calculated from baudrate
141:               extern BYTE  i;
142:               extern BYTE_VAL *pDst;
143:               
144:               /**************************************************************************
145:                 SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
146:                 requests according to the CDC specification.
147:                 However, it is not really being used here, therefore a dummy buffer is
148:                 used for conformance.
149:                **************************************************************************/
150:               #define dummy_length    0x08
151:               BYTE_VAL dummy_encapsulated_cmd_response[dummy_length];
152:               
153:               #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
154:               CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
155:               #endif
156:               
157:               /** P R I V A T E  P R O T O T Y P E S ***************************************/
158:               void USBCDCSetLineCoding(void);
159:               
160:               /** D E C L A R A T I O N S **************************************************/
161:               //#pragma code
162:               
163:               /** C L A S S  S P E C I F I C  R E Q ****************************************/
164:               /******************************************************************************
165:                	Function:
166:                		void USBCheckCDCRequest(void)
167:                
168:                	Description:
169:                		This routine checks the setup data packet to see if it
170:                		knows how to handle it
171:                		
172:                	PreCondition:
173:                		None
174:               
175:               	Parameters:
176:               		None
177:               		
178:               	Return Values:
179:               		None
180:               		
181:               	Remarks:
182:               		None
183:               		 
184:                 *****************************************************************************/
185:               void USBCheckCDCRequest(void)
186:               {
187:                   /*
188:                    * If request recipient is not an interface then return
189:                    */
190:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
  5C82    0104     MOVLB 0x4
  5C84    5140     MOVF 0x40, W, BANKED
  5C86    0B1F     ANDLW 0x1f
  5C88    0801     SUBLW 0x1
  5C8A    E001     BZ 0x5c8e
  5C8C    0012     RETURN 0
191:               
192:                   /*
193:                    * If request type is not class-specific then return
194:                    */
195:                   if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
  5C8E    5140     MOVF 0x40, W, BANKED
  5C90    0B60     ANDLW 0x60
  5C92    42E8     RRNCF 0xfe8, F, ACCESS
  5C94    42E8     RRNCF 0xfe8, F, ACCESS
  5C96    42E8     RRNCF 0xfe8, F, ACCESS
  5C98    42E8     RRNCF 0xfe8, F, ACCESS
  5C9A    42E8     RRNCF 0xfe8, F, ACCESS
  5C9C    0801     SUBLW 0x1
  5C9E    E001     BZ 0x5ca2
  5CA0    0012     RETURN 0
196:               
197:                   /*
198:                    * Interface ID must match interface numbers associated with
199:                    * CDC class, else return
200:                    */
201:                   if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
  5CA2    0544     DECF 0x44, W, BANKED
202:                      (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
  5CA4    E003     BZ 0x5cac
  5CA6    0544     DECF 0x44, W, BANKED
  5CA8    E001     BZ 0x5cac
  5CAA    0012     RETURN 0
203:                   
204:                   switch(SetupPkt.bRequest)
  5CAC    5141     MOVF 0x41, W, BANKED
  5CAE    0A22     XORLW 0x22
  5CB0    E035     BZ 0x5d1c
  5CB2    0A03     XORLW 0x3
  5CB4    E028     BZ 0x5d06
  5CB6    0A01     XORLW 0x1
  5CB8    E015     BZ 0x5ce4
  5CBA    0A21     XORLW 0x21
  5CBC    E00D     BZ 0x5cd8
  5CBE    0A01     XORLW 0x1
  5CC0    E001     BZ 0x5cc4
  5CC2    0012     RETURN 0
205:                   {
206:                       //****** These commands are required ******//
207:                       case SEND_ENCAPSULATED_COMMAND:
208:                        //send the packet
209:                           inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
  5CC4    0100     MOVLB 0
  5CC6    0EF3     MOVLW 0xf3
  5CC8    6F79     MOVWF 0x79, BANKED
  5CCA    0E05     MOVLW 0x5
  5CCC    6F7A     MOVWF 0x7a, BANKED
210:                           inPipes[0].wCount.Val = dummy_length;
  5CCE    0E08     MOVLW 0x8
  5CD0    6F7D     MOVWF 0x7d, BANKED
  5CD2    6B7E     CLRF 0x7e, BANKED
211:                           inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
  5CD4    817C     BSF 0x7c, 0, BANKED
212:                           inPipes[0].info.bits.busy = 1;
213:                           break;
  5CD6    D025     BRA 0x5d22
214:                       case GET_ENCAPSULATED_RESPONSE:
215:                           // Populate dummy_encapsulated_cmd_response first.
216:                           inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
  5CD8    0100     MOVLB 0
  5CDA    0EF3     MOVLW 0xf3
  5CDC    6F79     MOVWF 0x79, BANKED
  5CDE    0E05     MOVLW 0x5
  5CE0    6F7A     MOVWF 0x7a, BANKED
217:                           inPipes[0].info.bits.busy = 1;
218:                           break;
  5CE2    D01F     BRA 0x5d22
219:                       //****** End of required commands ******//
220:               
221:                       #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
222:                       case SET_LINE_CODING:
223:                           outPipes[0].wCount.Val = SetupPkt.wLength;
  5CE4    C446     MOVFF 0x446, 0x82
  5CE6    F082     NOP
  5CE8    C447     MOVFF 0x447, 0x83
  5CEA    F083     NOP
224:                           outPipes[0].pDst.bRam = (BYTE*)LINE_CODING_TARGET;
  5CEC    0100     MOVLB 0
  5CEE    0E51     MOVLW 0x51
  5CF0    6F7F     MOVWF 0x7f, BANKED
  5CF2    0E05     MOVLW 0x5
  5CF4    6F80     MOVWF 0x80, BANKED
225:                           outPipes[0].pFunc = LINE_CODING_PFUNC;
  5CF6    0E62     MOVLW 0x62
  5CF8    6F84     MOVWF 0x84, BANKED
  5CFA    0E56     MOVLW 0x56
  5CFC    6F85     MOVWF 0x85, BANKED
  5CFE    0E00     MOVLW 0
  5D00    6F86     MOVWF 0x86, BANKED
226:                           outPipes[0].info.bits.busy = 1;
  5D02    8F81     BSF 0x81, 0x7, BANKED
227:                           break;
  5D04    0012     RETURN 0
228:                           
229:                       case GET_LINE_CODING:
230:                           USBEP0SendRAMPtr(
  5D06    0100     MOVLB 0
  5D08    0ED9     MOVLW 0xd9
  5D0A    6F79     MOVWF 0x79, BANKED
  5D0C    0E05     MOVLW 0x5
  5D0E    6F7A     MOVWF 0x7a, BANKED
  5D10    0E07     MOVLW 0x7
  5D12    6F7D     MOVWF 0x7d, BANKED
  5D14    6B7E     CLRF 0x7e, BANKED
  5D16    0EC1     MOVLW 0xc1
  5D18    6F7C     MOVWF 0x7c, BANKED
231:                               (BYTE*)&line_coding,
  5D1A    0012     RETURN 0
232:                               LINE_CODING_LENGTH,
233:                               USB_EP0_INCLUDE_ZERO);
234:                           break;
  5D1C    C442     MOVFF 0x442, 0x5ee
  5D1E    F5EE     NOP
235:               
236:                       case SET_CONTROL_LINE_STATE:
237:                           control_signal_bitmap._byte = (BYTE)SetupPkt.W_Value.v[0];
  5D20    0100     MOVLB 0
  5D22    8F7C     BSF 0x7c, 0x7, BANKED
238:                           CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);
  5D24    0012     RETURN 0
239:                           CONFIGURE_DTR(control_signal_bitmap.DTE_PRESENT);
240:                           inPipes[0].info.bits.busy = 1;
241:                           break;
242:                       #endif
243:               
244:                       #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
245:                       case SEND_BREAK:                        // Optional
246:                           inPipes[0].info.bits.busy = 1;
247:               			if (SetupPkt.wValue == 0xFFFF)
248:               			{
249:               				UART_ENABLE = 0;  // turn off USART
250:               				UART_TRISTx = 0;   // Make TX pin an output
251:               				UART_Tx = 0;   // make it low
252:               			}
253:               			else if (SetupPkt.wValue == 0x0000)
254:               			{
255:               				UART_ENABLE = 1;  // turn on USART
256:               				UART_TRISTx = 1;   // Make TX pin an input
257:               			}
258:               			else
259:               			{
260:                               UART_SEND_BREAK();
261:               			}
262:                           break;
263:                       #endif
264:                       default:
265:                           break;
266:                   }//end switch(SetupPkt.bRequest)
267:               
268:               }//end USBCheckCDCRequest
269:               
270:               /** U S E R  A P I ***********************************************************/
271:               
272:               /**************************************************************************
273:                 Function:
274:                       void CDCInitEP(void)
275:                   
276:                 Summary:
277:                   This function initializes the CDC function driver. This function should
278:                   be called after the SET_CONFIGURATION command.
279:                 Description:
280:                   This function initializes the CDC function driver. This function sets
281:                   the default line coding (baud rate, bit parity, number of data bits,
282:                   and format). This function also enables the endpoints and prepares for
283:                   the first transfer from the host.
284:                   
285:                   This function should be called after the SET_CONFIGURATION command.
286:                   This is most simply done by calling this function from the
287:                   USBCBInitEP() function.
288:                   
289:                   Typical Usage:
290:                   <code>
291:                       void USBCBInitEP(void)
292:                       {
293:                           CDCInitEP();
294:                       }
295:                   </code>
296:                 Conditions:
297:                   None
298:                 Remarks:
299:                   None                                                                   
300:                 **************************************************************************/
301:               void CDCInitEP(void)
302:               {
303:                  	//Abstract line coding information
304:                  	line_coding.dwDTERate.Val = 19200;      // baud rate
  5D26    0105     MOVLB 0x5
  5D28    6BD9     CLRF 0xd9, BANKED
  5D2A    0E4B     MOVLW 0x4b
  5D2C    6FDA     MOVWF 0xda, BANKED
  5D2E    6BDB     CLRF 0xdb, BANKED
  5D30    6BDC     CLRF 0xdc, BANKED
305:                  	line_coding.bCharFormat = 0x00;             // 1 stop bit
  5D32    6BDD     CLRF 0xdd, BANKED
306:                  	line_coding.bParityType = 0x00;             // None
  5D34    6BDE     CLRF 0xde, BANKED
307:                  	line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
  5D36    0E08     MOVLW 0x8
  5D38    6FDF     MOVWF 0xdf, BANKED
308:               
309:                   cdc_rx_len = 0;
  5D3A    6BE0     CLRF 0xe0, BANKED
310:                   
311:                   /*
312:                    * Do not have to init Cnt of IN pipes here.
313:                    * Reason:  Number of BYTEs to send to the host
314:                    *          varies from one transaction to
315:                    *          another. Cnt should equal the exact
316:                    *          number of BYTEs to transmit for
317:                    *          a given IN transaction.
318:                    *          This number of BYTEs will only
319:                    *          be known right before the data is
320:                    *          sent.
321:                    */
322:                   USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
  5D3C    0E1A     MOVLW 0x1a
  5D3E    6EE6     MOVWF 0xfe6, ACCESS
  5D40    0E02     MOVLW 0x2
  5D42    6EE6     MOVWF 0xfe6, ACCESS
  5D44    EC59     CALL 0x38b2, 0
  5D46    F01C     NOP
  5D48    52E5     MOVF 0xfe5, F, ACCESS
  5D4A    52E5     MOVF 0xfe5, F, ACCESS
323:                   USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
  5D4C    0E1E     MOVLW 0x1e
  5D4E    6EE6     MOVWF 0xfe6, ACCESS
  5D50    0E03     MOVLW 0x3
  5D52    6EE6     MOVWF 0xfe6, ACCESS
  5D54    EC59     CALL 0x38b2, 0
  5D56    F01C     NOP
  5D58    52E5     MOVF 0xfe5, F, ACCESS
  5D5A    52E5     MOVF 0xfe5, F, ACCESS
324:               
325:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
  5D5C    0E40     MOVLW 0x40
  5D5E    6EE6     MOVWF 0xfe6, ACCESS
  5D60    0E59     MOVLW 0x59
  5D62    6EE6     MOVWF 0xfe6, ACCESS
  5D64    0E05     MOVLW 0x5
  5D66    6EE6     MOVWF 0xfe6, ACCESS
  5D68    6AE6     CLRF 0xfe6, ACCESS
  5D6A    0E03     MOVLW 0x3
  5D6C    6EE6     MOVWF 0xfe6, ACCESS
  5D6E    ECFE     CALL 0x39fc, 0
  5D70    F01C     NOP
  5D72    6E14     MOVWF 0x14, ACCESS
  5D74    0E05     MOVLW 0x5
  5D76    5EE1     SUBWF 0xfe1, F, ACCESS
  5D78    5014     MOVF 0x14, W, ACCESS
  5D7A    CFF3     MOVFF 0xff3, 0x5ea
  5D7C    F5EA     NOP
  5D7E    CFF4     MOVFF 0xff4, 0x5eb
  5D80    F5EB     NOP
326:                   CDCDataInHandle = NULL;
  5D82    0105     MOVLB 0x5
  5D84    6BEC     CLRF 0xec, BANKED
  5D86    6BED     CLRF 0xed, BANKED
327:                   
328:                   cdc_trf_state = CDC_TX_READY;
  5D88    6BE1     CLRF 0xe1, BANKED
329:               }//end CDCInitEP
  5D8A    0012     RETURN 0
330:               
331:               /**********************************************************************************
332:                 Function:
333:                       BYTE getsUSBUSART(char *buffer, BYTE len)
334:                   
335:                 Summary:
336:                   getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
337:                   endpoint to a user's specified location. It is a non-blocking function.
338:                   It does not wait for data if there is no data available. Instead it
339:                   returns '0' to notify the caller that there is no data available.
340:               
341:                 Description:
342:                   getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
343:                   endpoint to a user's specified location. It is a non-blocking function.
344:                   It does not wait for data if there is no data available. Instead it
345:                   returns '0' to notify the caller that there is no data available.
346:                   
347:                   Typical Usage:
348:                   <code>
349:                       BYTE numBytes;
350:                       BYTE buffer[64]
351:                   
352:                       numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
353:                       if(numBytes \> 0)
354:                       {
355:                           //we received numBytes bytes of data and they are copied into
356:                           //  the "buffer" variable.  We can do something with the data
357:                           //  here.
358:                       }
359:                   </code>
360:                 Conditions:
361:                   Value of input argument 'len' should be smaller than the maximum
362:                   endpoint size responsible for receiving bulk data from USB host for CDC
363:                   class. Input argument 'buffer' should point to a buffer area that is
364:                   bigger or equal to the size specified by 'len'.
365:                 Input:
366:                   buffer -  Pointer to where received BYTEs are to be stored
367:                   len -     The number of BYTEs expected.
368:                                                                                                  
369:                 **********************************************************************************/
370:               BYTE getsUSBUSART(char *buffer, BYTE len)
  5D8C    CFD9     MOVFF 0xfd9, 0xfe6
  5D8E    FFE6     NOP
  5D90    CFE1     MOVFF 0xfe1, 0xfd9
  5D92    FFD9     NOP
371:               {
372:                   cdc_rx_len = 0;
  5D94    0105     MOVLB 0x5
  5D96    6BE0     CLRF 0xe0, BANKED
373:                   
374:                   if(!USBHandleBusy(CDCDataOutHandle))
  5D98    51EA     MOVF 0xea, W, BANKED
  5D9A    11EB     IORWF 0xeb, W, BANKED
  5D9C    E102     BNZ 0x5da2
  5D9E    0E00     MOVLW 0
  5DA0    D008     BRA 0x5db2
  5DA2    C5EA     MOVFF 0x5ea, 0xfe9
  5DA4    FFE9     NOP
  5DA6    C5EB     MOVFF 0x5eb, 0xfea
  5DA8    FFEA     NOP
  5DAA    50EF     MOVF 0xfef, W, ACCESS
  5DAC    0B80     ANDLW 0x80
  5DAE    E001     BZ 0x5db2
  5DB0    0E01     MOVLW 0x1
  5DB2    0900     IORLW 0
  5DB4    E145     BNZ 0x5e40
375:                   {
376:                       /*
377:                        * Adjust the expected number of BYTEs to equal
378:                        * the actual number of BYTEs received.
379:                        */
380:                       if(len > USBHandleGetLength(CDCDataOutHandle))
  5DB6    0EFC     MOVLW 0xfc
  5DB8    CFDB     MOVFF 0xfdb, 0x14
  5DBA    F014     NOP
  5DBC    C5EA     MOVFF 0x5ea, 0xfe9
  5DBE    FFE9     NOP
  5DC0    C5EB     MOVFF 0x5eb, 0xfea
  5DC2    FFEA     NOP
  5DC4    52EE     MOVF 0xfee, F, ACCESS
  5DC6    50EF     MOVF 0xfef, W, ACCESS
  5DC8    80D8     BSF 0xfd8, 0, ACCESS
  5DCA    5414     SUBFWB 0x14, W, ACCESS
  5DCC    E208     BC 0x5dde
381:                           len = USBHandleGetLength(CDCDataOutHandle);
  5DCE    C5EA     MOVFF 0x5ea, 0xfe9
  5DD0    FFE9     NOP
  5DD2    C5EB     MOVFF 0x5eb, 0xfea
  5DD4    FFEA     NOP
  5DD6    52EE     MOVF 0xfee, F, ACCESS
  5DD8    0EFC     MOVLW 0xfc
  5DDA    CFEF     MOVFF 0xfef, 0xfdb
  5DDC    FFDB     NOP
382:                       
383:                       /*
384:                        * Copy data from dual-ram buffer to user's buffer
385:                        */
386:                       for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
  5DDE    6BE0     CLRF 0xe0, BANKED
  5DE0    0EFC     MOVLW 0xfc
  5DE2    50DB     MOVF 0xfdb, W, ACCESS
  5DE4    5DE0     SUBWF 0xe0, W, BANKED
  5DE6    E219     BC 0x5e1a
  5E16    2BE0     INCF 0xe0, F, BANKED
  5E18    D7E3     BRA 0x5de0
387:                           buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
  5DE8    51E0     MOVF 0xe0, W, BANKED
  5DEA    6AEA     CLRF 0xfea, ACCESS
  5DEC    0F59     ADDLW 0x59
  5DEE    6EE9     MOVWF 0xfe9, ACCESS
  5DF0    0E05     MOVLW 0x5
  5DF2    22EA     ADDWFC 0xfea, F, ACCESS
  5DF4    50EF     MOVF 0xfef, W, ACCESS
  5DF6    6EE6     MOVWF 0xfe6, ACCESS
  5DF8    51E0     MOVF 0xe0, W, BANKED
  5DFA    6EE7     MOVWF 0xfe7, ACCESS
  5DFC    0EFD     MOVLW 0xfd
  5DFE    CFDB     MOVFF 0xfdb, 0xfe9
  5E00    FFE9     NOP
  5E02    0EFE     MOVLW 0xfe
  5E04    CFDB     MOVFF 0xfdb, 0xfea
  5E06    FFEA     NOP
  5E08    50E7     MOVF 0xfe7, W, ACCESS
  5E0A    26E9     ADDWF 0xfe9, F, ACCESS
  5E0C    0E00     MOVLW 0
  5E0E    22EA     ADDWFC 0xfea, F, ACCESS
  5E10    52E5     MOVF 0xfe5, F, ACCESS
  5E12    50E7     MOVF 0xfe7, W, ACCESS
  5E14    6EEF     MOVWF 0xfef, ACCESS
388:               
389:                       /*
390:                        * Prepare dual-ram buffer for next OUT transaction
391:                        */
392:               
393:                       CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
  5E1A    0E40     MOVLW 0x40
  5E1C    6EE6     MOVWF 0xfe6, ACCESS
  5E1E    0E59     MOVLW 0x59
  5E20    6EE6     MOVWF 0xfe6, ACCESS
  5E22    0E05     MOVLW 0x5
  5E24    6EE6     MOVWF 0xfe6, ACCESS
  5E26    6AE6     CLRF 0xfe6, ACCESS
  5E28    0E03     MOVLW 0x3
  5E2A    6EE6     MOVWF 0xfe6, ACCESS
  5E2C    ECFE     CALL 0x39fc, 0
  5E2E    F01C     NOP
  5E30    6E14     MOVWF 0x14, ACCESS
  5E32    0E05     MOVLW 0x5
  5E34    5EE1     SUBWF 0xfe1, F, ACCESS
  5E36    5014     MOVF 0x14, W, ACCESS
  5E38    CFF3     MOVFF 0xff3, 0x5ea
  5E3A    F5EA     NOP
  5E3C    CFF4     MOVFF 0xff4, 0x5eb
  5E3E    F5EB     NOP
394:               
395:                   }//end if
396:                   
397:                   return cdc_rx_len;
  5E40    0105     MOVLB 0x5
  5E42    51E0     MOVF 0xe0, W, BANKED
398:                   
399:               }//end getsUSBUSART
  5E44    52E5     MOVF 0xfe5, F, ACCESS
  5E46    CFE7     MOVFF 0xfe7, 0xfd9
  5E48    FFD9     NOP
  5E4A    0012     RETURN 0
400:               
401:               /******************************************************************************
402:                 Function:
403:               	void putUSBUSART(char *data, BYTE length)
404:               		
405:                 Summary:
406:                   putUSBUSART writes an array of data to the USB. Use this version, is
407:                   capable of transfering 0x00 (what is typically a NULL character in any of
408:                   the string transfer functions).
409:               
410:                 Description:
411:                   putUSBUSART writes an array of data to the USB. Use this version, is
412:                   capable of transfering 0x00 (what is typically a NULL character in any of
413:                   the string transfer functions).
414:                   
415:                   Typical Usage:
416:                   <code>
417:                       if(USBUSARTIsTxTrfReady())
418:                       {
419:                           char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
420:                           putUSBUSART(data,5);
421:                       }
422:                   </code>
423:                   
424:                   The transfer mechanism for device-to-host(put) is more flexible than
425:                   host-to-device(get). It can handle a string of data larger than the
426:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
427:                   \long string of data over multiple USB transactions. CDCTxService()
428:                   must be called periodically to keep sending blocks of data to the host.
429:               
430:                 Conditions:
431:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
432:                   transfer is complete and is ready to receive a new block of data. The
433:                   string of characters pointed to by 'data' must equal to or smaller than
434:                   255 BYTEs.
435:               
436:                 Input:
437:                   char *data - pointer to a RAM array of data to be transfered to the host
438:                   BYTE length - the number of bytes to be transfered (must be less than 255).
439:               		
440:                *****************************************************************************/
441:               void putUSBUSART(char *data, BYTE  length)
  5E4C    CFD9     MOVFF 0xfd9, 0xfe6
  5E4E    FFE6     NOP
  5E50    CFE1     MOVFF 0xfe1, 0xfd9
  5E52    FFD9     NOP
442:               {
443:                   /*
444:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
445:                    * before calling this function.
446:                    * As a safety precaution, this fuction checks the state one more time
447:                    * to make sure it does not override any pending transactions.
448:                    *
449:                    * Currently it just quits the routine without reporting any errors back
450:                    * to the user.
451:                    *
452:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
453:                    *             before calling this function!
454:                    * Example:
455:                    * if(USBUSARTIsTxTrfReady())
456:                    *     putUSBUSART(pData, Length);
457:                    *
458:                    * IMPORTANT: Never use the following blocking while loop to wait:
459:                    * while(!USBUSARTIsTxTrfReady())
460:                    *     putUSBUSART(pData, Length);
461:                    *
462:                    * The whole firmware framework is written based on cooperative
463:                    * multi-tasking and a blocking code is not acceptable.
464:                    * Use a state machine instead.
465:                    */
466:                   USBMaskInterrupts();
  5E54    98A0     BCF 0xfa0, 0x4, ACCESS
467:                   if(cdc_trf_state == CDC_TX_READY)
  5E56    0105     MOVLB 0x5
  5E58    51E1     MOVF 0xe1, W, BANKED
  5E5A    E10C     BNZ 0x5e74
468:                   {
469:                       mUSBUSARTTxRam((BYTE*)data, length);     // See cdc.h
  5E5C    0EFD     MOVLW 0xfd
  5E5E    CFDB     MOVFF 0xfdb, 0x5e2
  5E60    F5E2     NOP
  5E62    0EFE     MOVLW 0xfe
  5E64    CFDB     MOVFF 0xfdb, 0x5e3
  5E66    F5E3     NOP
  5E68    0EFC     MOVLW 0xfc
  5E6A    CFDB     MOVFF 0xfdb, 0x5e8
  5E6C    F5E8     NOP
  5E6E    0E01     MOVLW 0x1
  5E70    6FE9     MOVWF 0xe9, BANKED
  5E72    6FE1     MOVWF 0xe1, BANKED
470:                   }
471:                   USBUnmaskInterrupts();
  5E74    88A0     BSF 0xfa0, 0x4, ACCESS
472:               }//end putUSBUSART
  5E76    52E5     MOVF 0xfe5, F, ACCESS
  5E78    CFE7     MOVFF 0xfe7, 0xfd9
  5E7A    FFD9     NOP
  5E7C    0012     RETURN 0
473:               
474:               /******************************************************************************
475:               	Function:
476:               		void putsUSBUSART(char *data)
477:               		
478:                 Summary:
479:                   putsUSBUSART writes a string of data to the USB including the null
480:                   character. Use this version, 'puts', to transfer data from a RAM buffer.
481:               
482:                 Description:
483:                   putsUSBUSART writes a string of data to the USB including the null
484:                   character. Use this version, 'puts', to transfer data from a RAM buffer.
485:                   
486:                   Typical Usage:
487:                   <code>
488:                       if(USBUSARTIsTxTrfReady())
489:                       {
490:                           char data[] = "Hello World";
491:                           putsUSBUSART(data);
492:                       }
493:                   </code>
494:                   
495:                   The transfer mechanism for device-to-host(put) is more flexible than
496:                   host-to-device(get). It can handle a string of data larger than the
497:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
498:                   \long string of data over multiple USB transactions. CDCTxService()
499:                   must be called periodically to keep sending blocks of data to the host.
500:               
501:                 Conditions:
502:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
503:                   transfer is complete and is ready to receive a new block of data. The
504:                   string of characters pointed to by 'data' must equal to or smaller than
505:                   255 BYTEs.
506:               
507:                 Input:
508:                   char *data -  null\-terminated string of constant data. If a
509:                                           null character is not found, 255 BYTEs of data
510:                                           will be transferred to the host.
511:               		
512:                *****************************************************************************/
513:                
514:               void putsUSBUSART(char *data)
  5E7E    CFD9     MOVFF 0xfd9, 0xfe6
  5E80    FFE6     NOP
  5E82    CFE1     MOVFF 0xfe1, 0xfd9
  5E84    FFD9     NOP
  5E86    0E03     MOVLW 0x3
  5E88    26E1     ADDWF 0xfe1, F, ACCESS
515:               {
516:                   BYTE len;
517:                   char *pData;
518:               
519:                   /*
520:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
521:                    * before calling this function.
522:                    * As a safety precaution, this fuction checks the state one more time
523:                    * to make sure it does not override any pending transactions.
524:                    *
525:                    * Currently it just quits the routine without reporting any errors back
526:                    * to the user.
527:                    *
528:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
529:                    *             before calling this function!
530:                    * Example:
531:                    * if(USBUSARTIsTxTrfReady())
532:                    *     putsUSBUSART(pData, Length);
533:                    *
534:                    * IMPORTANT: Never use the following blocking while loop to wait:
535:                    * while(!USBUSARTIsTxTrfReady())
536:                    *     putsUSBUSART(pData);
537:                    *
538:                    * The whole firmware framework is written based on cooperative
539:                    * multi-tasking and a blocking code is not acceptable.
540:                    * Use a state machine instead.
541:                    */
542:                   USBMaskInterrupts();
  5E8A    98A0     BCF 0xfa0, 0x4, ACCESS
543:                   if(cdc_trf_state != CDC_TX_READY)
  5E8C    0105     MOVLB 0x5
  5E8E    51E1     MOVF 0xe1, W, BANKED
  5E90    E12D     BNZ 0x5eec
544:                   {
545:                       USBUnmaskInterrupts();
546:                       return;
547:                   }
548:                   
549:                   /*
550:                    * While loop counts the number of BYTEs to send including the
551:                    * null character.
552:                    */
553:                   len = 0;
  5E92    6ADF     CLRF 0xfdf, ACCESS
554:                   pData = data;
  5E94    0EFD     MOVLW 0xfd
  5E96    CFDB     MOVFF 0xfdb, 0x8
  5E98    F008     NOP
  5E9A    0EFE     MOVLW 0xfe
  5E9C    CFDB     MOVFF 0xfdb, 0x9
  5E9E    F009     NOP
  5EA0    52DE     MOVF 0xfde, F, ACCESS
  5EA2    C008     MOVFF 0x8, 0xfde
  5EA4    FFDE     NOP
  5EA6    C009     MOVFF 0x9, 0xfdd
  5EA8    FFDD     NOP
  5EAA    52DD     MOVF 0xfdd, F, ACCESS
555:                   do
556:                   {
557:                       len++;
  5EAC    2ADF     INCF 0xfdf, F, ACCESS
558:                       if(len == 255) break;       // Break loop once max len is reached.
  5EAE    50DF     MOVF 0xfdf, W, ACCESS
  5EB0    6E14     MOVWF 0x14, ACCESS
  5EB2    6A15     CLRF 0x15, ACCESS
  5EB4    0EFF     MOVLW 0xff
  5EB6    1814     XORWF 0x14, W, ACCESS
  5EB8    E102     BNZ 0x5ebe
  5EBA    5015     MOVF 0x15, W, ACCESS
  5EBC    E00B     BZ 0x5ed4
559:                   }while(*pData++);
  5EBE    0E01     MOVLW 0x1
  5EC0    CFDB     MOVFF 0xfdb, 0xfe9
  5EC2    FFE9     NOP
  5EC4    2ADB     INCF 0xfdb, F, ACCESS
  5EC6    0E02     MOVLW 0x2
  5EC8    CFDB     MOVFF 0xfdb, 0xfea
  5ECA    FFEA     NOP
  5ECC    E301     BNC 0x5ed0
  5ECE    2ADB     INCF 0xfdb, F, ACCESS
  5ED0    50EF     MOVF 0xfef, W, ACCESS
  5ED2    E1EC     BNZ 0x5eac
560:                   
561:                   /*
562:                    * Second piece of information (length of data to send) is ready.
563:                    * Call mUSBUSARTTxRam to setup the transfer.
564:                    * The actual transfer process will be handled by CDCTxService(),
565:                    * which should be called once per Main Program loop.
566:                    */
567:               //    mUSBUSARTTxRam((BYTE*)data, len);     // See cdc.h
568:                   mUSBUSARTTxRam((BYTE*)data, len-1);     // fucking STUPID, DON'T send the null
  5ED4    0EFD     MOVLW 0xfd
  5ED6    CFDB     MOVFF 0xfdb, 0x5e2
  5ED8    F5E2     NOP
  5EDA    0EFE     MOVLW 0xfe
  5EDC    CFDB     MOVFF 0xfdb, 0x5e3
  5EDE    F5E3     NOP
  5EE0    04DF     DECF 0xfdf, W, ACCESS
  5EE2    0105     MOVLB 0x5
  5EE4    6FE8     MOVWF 0xe8, BANKED
  5EE6    0E01     MOVLW 0x1
  5EE8    6FE9     MOVWF 0xe9, BANKED
  5EEA    6FE1     MOVWF 0xe1, BANKED
569:                   USBUnmaskInterrupts();
  5EEC    88A0     BSF 0xfa0, 0x4, ACCESS
570:               }//end putsUSBUSART
  5EEE    0E03     MOVLW 0x3
  5EF0    5CE1     SUBWF 0xfe1, W, ACCESS
  5EF2    E202     BC 0x5ef8
  5EF4    6AE1     CLRF 0xfe1, ACCESS
  5EF6    52E5     MOVF 0xfe5, F, ACCESS
  5EF8    6EE1     MOVWF 0xfe1, ACCESS
  5EFA    52E5     MOVF 0xfe5, F, ACCESS
  5EFC    CFE7     MOVFF 0xfe7, 0xfd9
  5EFE    FFD9     NOP
  5F00    0012     RETURN 0
571:               
572:               /**************************************************************************
573:                 Function:
574:                       void putrsUSBUSART(const ROM char *data)
575:                   
576:                 Summary:
577:                   putrsUSBUSART writes a string of data to the USB including the null
578:                   character. Use this version, 'putrs', to transfer data literals and
579:                   data located in program memory.
580:               
581:                 Description:
582:                   putrsUSBUSART writes a string of data to the USB including the null
583:                   character. Use this version, 'putrs', to transfer data literals and
584:                   data located in program memory.
585:                   
586:                   Typical Usage:
587:                   <code>
588:                       if(USBUSARTIsTxTrfReady())
589:                       {
590:                           putrsUSBUSART("Hello World");
591:                       }
592:                   </code>
593:                   
594:                   The transfer mechanism for device-to-host(put) is more flexible than
595:                   host-to-device(get). It can handle a string of data larger than the
596:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
597:                   \long string of data over multiple USB transactions. CDCTxService()
598:                   must be called periodically to keep sending blocks of data to the host.
599:               
600:                 Conditions:
601:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
602:                   transfer is complete and is ready to receive a new block of data. The
603:                   string of characters pointed to by 'data' must equal to or smaller than
604:                   255 BYTEs.
605:               
606:                 Input:
607:                   const ROM char *data -  null\-terminated string of constant data. If a
608:                                           null character is not found, 255 BYTEs of data
609:                                           will be transferred to the host.
610:                                                                                          
611:                 **************************************************************************/
612:               void putrsUSBUSART(const ROM char *data)
  5F02    CFD9     MOVFF 0xfd9, 0xfe6
  5F04    FFE6     NOP
  5F06    CFE1     MOVFF 0xfe1, 0xfd9
  5F08    FFD9     NOP
  5F0A    0E04     MOVLW 0x4
  5F0C    26E1     ADDWF 0xfe1, F, ACCESS
613:               {
614:                   BYTE len;
615:                   const ROM char *pData;
616:               
617:                   /*
618:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
619:                    * before calling this function.
620:                    * As a safety precaution, this fuction checks the state one more time
621:                    * to make sure it does not override any pending transactions.
622:                    *
623:                    * Currently it just quits the routine without reporting any errors back
624:                    * to the user.
625:                    *
626:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()
627:                    *             before calling this function!
628:                    * Example:
629:                    * if(USBUSARTIsTxTrfReady())
630:                    *     putsUSBUSART(pData);
631:                    *
632:                    * IMPORTANT: Never use the following blocking while loop to wait:
633:                    * while(cdc_trf_state != CDC_TX_READY)
634:                    *     putsUSBUSART(pData);
635:                    *
636:                    * The whole firmware framework is written based on cooperative
637:                    * multi-tasking and a blocking code is not acceptable.
638:                    * Use a state machine instead.
639:                    */
640:                   USBMaskInterrupts();
  5F0E    98A0     BCF 0xfa0, 0x4, ACCESS
641:                   if(cdc_trf_state != CDC_TX_READY)
  5F10    0105     MOVLB 0x5
  5F12    51E1     MOVF 0xe1, W, BANKED
  5F14    E13A     BNZ 0x5f8a
642:                   {
643:                       USBUnmaskInterrupts();
644:                       return;
645:                   }
646:                   
647:                   /*
648:                    * While loop counts the number of BYTEs to send including the
649:                    * null character.
650:                    */
651:                   len = 0;
  5F16    6ADF     CLRF 0xfdf, ACCESS
652:                   pData = data;
  5F18    50D9     MOVF 0xfd9, W, ACCESS
  5F1A    0FFC     ADDLW 0xfc
  5F1C    6EE9     MOVWF 0xfe9, ACCESS
  5F1E    0EFF     MOVLW 0xff
  5F20    20DA     ADDWFC 0xfda, W, ACCESS
  5F22    6EEA     MOVWF 0xfea, ACCESS
  5F24    0E01     MOVLW 0x1
  5F26    CFEE     MOVFF 0xfee, 0xfdb
  5F28    FFDB     NOP
  5F2A    0E02     MOVLW 0x2
  5F2C    CFEE     MOVFF 0xfee, 0xfdb
  5F2E    FFDB     NOP
  5F30    0E03     MOVLW 0x3
  5F32    CFEE     MOVFF 0xfee, 0xfdb
  5F34    FFDB     NOP
653:                   do
654:                   {
655:                       len++;
  5F36    2ADF     INCF 0xfdf, F, ACCESS
656:                       if(len == 255) break;       // Break loop once max len is reached.
  5F38    50DF     MOVF 0xfdf, W, ACCESS
  5F3A    6E14     MOVWF 0x14, ACCESS
  5F3C    6A15     CLRF 0x15, ACCESS
  5F3E    0EFF     MOVLW 0xff
  5F40    1814     XORWF 0x14, W, ACCESS
  5F42    E102     BNZ 0x5f48
  5F44    5015     MOVF 0x15, W, ACCESS
  5F46    E012     BZ 0x5f6c
657:                   }while(*pData++);
  5F48    50D9     MOVF 0xfd9, W, ACCESS
  5F4A    0F01     ADDLW 0x1
  5F4C    6EE9     MOVWF 0xfe9, ACCESS
  5F4E    CFDA     MOVFF 0xfda, 0xfea
  5F50    FFEA     NOP
  5F52    CFEF     MOVFF 0xfef, 0xff6
  5F54    FFF6     NOP
  5F56    2AEE     INCF 0xfee, F, ACCESS
  5F58    CFEF     MOVFF 0xfef, 0xff7
  5F5A    FFF7     NOP
  5F5C    0E00     MOVLW 0
  5F5E    22EE     ADDWFC 0xfee, F, ACCESS
  5F60    CFEF     MOVFF 0xfef, 0xff8
  5F62    FFF8     NOP
  5F64    22EE     ADDWFC 0xfee, F, ACCESS
  5F66    0008     TBLRD*
  5F68    50F5     MOVF 0xff5, W, ACCESS
  5F6A    E1E5     BNZ 0x5f36
658:                   
659:                   /*
660:                    * Second piece of information (length of data to send) is ready.
661:                    * Call mUSBUSARTTxRom to setup the transfer.
662:                    * The actual transfer process will be handled by CDCTxService(),
663:                    * which should be called once per Main Program loop.
664:                    */
665:               
666:               //    mUSBUSARTTxRom((ROM BYTE*)data,len); // See cdc.h
667:                   mUSBUSARTTxRom((ROM BYTE*)data,len); // fucking STUPID, DON'T send the null
  5F6C    0EFC     MOVLW 0xfc
  5F6E    CFDB     MOVFF 0xfdb, 0x5e2
  5F70    F5E2     NOP
  5F72    0EFD     MOVLW 0xfd
  5F74    CFDB     MOVFF 0xfdb, 0x5e3
  5F76    F5E3     NOP
  5F78    0EFE     MOVLW 0xfe
  5F7A    CFDB     MOVFF 0xfdb, 0x5e4
  5F7C    F5E4     NOP
  5F7E    CFDF     MOVFF 0xfdf, 0x5e8
  5F80    F5E8     NOP
  5F82    0105     MOVLB 0x5
  5F84    6BE9     CLRF 0xe9, BANKED
  5F86    0E01     MOVLW 0x1
  5F88    6FE1     MOVWF 0xe1, BANKED
668:                   USBUnmaskInterrupts();
  5F8A    88A0     BSF 0xfa0, 0x4, ACCESS
669:               
670:               }//end putrsUSBUSART
  5F8C    0E04     MOVLW 0x4
  5F8E    5CE1     SUBWF 0xfe1, W, ACCESS
  5F90    E202     BC 0x5f96
  5F92    6AE1     CLRF 0xfe1, ACCESS
  5F94    52E5     MOVF 0xfe5, F, ACCESS
  5F96    6EE1     MOVWF 0xfe1, ACCESS
  5F98    52E5     MOVF 0xfe5, F, ACCESS
  5F9A    CFE7     MOVFF 0xfe7, 0xfd9
  5F9C    FFD9     NOP
  5F9E    0012     RETURN 0
671:               
672:               /************************************************************************
673:                 Function:
674:                       void CDCTxService(void)
675:                   
676:                 Summary:
677:                   CDCTxService handles device-to-host transaction(s). This function
678:                   should be called once per Main Program loop after the device reaches
679:                   the configured state.
680:                 Description:
681:                   CDCTxService handles device-to-host transaction(s). This function
682:                   should be called once per Main Program loop after the device reaches
683:                   the configured state.
684:                   
685:                   Typical Usage:
686:                   <code>
687:                   void main(void)
688:                   {
689:                       USBDeviceInit();
690:                       while(1)
691:                       {
692:                           USBDeviceTasks();
693:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
694:                              (USBIsDeviceSuspended() == TRUE))
695:                           {
696:                               //Either the device is not configured or we are suspended
697:                               //  so we don't want to do execute any application code
698:                               continue;   //go back to the top of the while loop
699:                           }
700:                           else
701:                           {
702:                               //Keep trying to send data to the PC as required
703:                               CDCTxService();
704:                   
705:                               //Run application code.
706:                               UserApplication();
707:                           }
708:                       }
709:                   }
710:                   </code>
711:                 Conditions:
712:                   None
713:                 Remarks:
714:                   None                                                                 
715:                 ************************************************************************/
716:                
717:               void CDCTxService(void)
  5FA0    CFD9     MOVFF 0xfd9, 0xfe6
  5FA2    FFE6     NOP
  5FA4    CFE1     MOVFF 0xfe1, 0xfd9
  5FA6    FFD9     NOP
  5FA8    0E02     MOVLW 0x2
  5FAA    26E1     ADDWF 0xfe1, F, ACCESS
718:               {
719:                   BYTE byte_to_send;
720:                   BYTE i;
721:                   
722:                   USBMaskInterrupts();
  5FAC    98A0     BCF 0xfa0, 0x4, ACCESS
723:                   if(USBHandleBusy(CDCDataInHandle)) 
  5FAE    0105     MOVLB 0x5
  5FB0    51EC     MOVF 0xec, W, BANKED
  5FB2    11ED     IORWF 0xed, W, BANKED
  5FB4    E102     BNZ 0x5fba
  5FB6    0E00     MOVLW 0
  5FB8    D008     BRA 0x5fca
  5FBA    C5EC     MOVFF 0x5ec, 0xfe9
  5FBC    FFE9     NOP
  5FBE    C5ED     MOVFF 0x5ed, 0xfea
  5FC0    FFEA     NOP
  5FC2    50EF     MOVF 0xfef, W, ACCESS
  5FC4    0B80     ANDLW 0x80
  5FC6    E001     BZ 0x5fca
  5FC8    0E01     MOVLW 0x1
  5FCA    0900     IORLW 0
  5FCC    E106     BNZ 0x5fda
724:                   {
725:                       USBUnmaskInterrupts();
726:                       return;
727:                   }
728:               
729:                   /*
730:                    * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
731:                    * By having this stage, user can always check cdc_trf_state,
732:                    * and not having to call mCDCUsartTxIsBusy() directly.
733:                    */
734:                   if(cdc_trf_state == CDC_TX_COMPLETING)
  5FCE    0E03     MOVLW 0x3
  5FD0    5DE1     SUBWF 0xe1, W, BANKED
  5FD2    E101     BNZ 0x5fd6
735:                       cdc_trf_state = CDC_TX_READY;
  5FD4    6BE1     CLRF 0xe1, BANKED
736:                   
737:                   /*
738:                    * If CDC_TX_READY state, nothing to do, just return.
739:                    */
740:                   if(cdc_trf_state == CDC_TX_READY)
  5FD6    51E1     MOVF 0xe1, W, BANKED
  5FD8    E102     BNZ 0x5fde
741:                   {
742:                       USBUnmaskInterrupts();
  5FDA    88A0     BSF 0xfa0, 0x4, ACCESS
743:                       return;
  5FDC    D081     BRA 0x60e0
744:                   }
745:                   
746:                   /*
747:                    * If CDC_TX_BUSY_ZLP state, send zero length packet
748:                    */
749:                   if(cdc_trf_state == CDC_TX_BUSY_ZLP)
  5FDE    0E02     MOVLW 0x2
  5FE0    5DE1     SUBWF 0xe1, W, BANKED
  5FE2    E116     BNZ 0x6010
750:                   {
751:                       CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
  5FE4    6AE6     CLRF 0xfe6, ACCESS
  5FE6    0E00     MOVLW 0
  5FE8    6EE6     MOVWF 0xfe6, ACCESS
  5FEA    6AE6     CLRF 0xfe6, ACCESS
  5FEC    0E01     MOVLW 0x1
  5FEE    6EE6     MOVWF 0xfe6, ACCESS
  5FF0    0E03     MOVLW 0x3
  5FF2    6EE6     MOVWF 0xfe6, ACCESS
  5FF4    ECFE     CALL 0x39fc, 0
  5FF6    F01C     NOP
  5FF8    6E14     MOVWF 0x14, ACCESS
  5FFA    0E05     MOVLW 0x5
  5FFC    5EE1     SUBWF 0xfe1, F, ACCESS
  5FFE    5014     MOVF 0x14, W, ACCESS
  6000    CFF3     MOVFF 0xff3, 0x5ec
  6002    F5EC     NOP
  6004    CFF4     MOVFF 0xff4, 0x5ed
  6006    F5ED     NOP
752:                       //CDC_DATA_BD_IN.CNT = 0;
753:                       cdc_trf_state = CDC_TX_COMPLETING;
  6008    0105     MOVLB 0x5
  600A    0E03     MOVLW 0x3
  600C    6FE1     MOVWF 0xe1, BANKED
754:                   }
755:                   else if(cdc_trf_state == CDC_TX_BUSY)
  600E    D067     BRA 0x60de
  6010    05E1     DECF 0xe1, W, BANKED
  6012    E165     BNZ 0x60de
756:                   {
757:                       /*
758:                        * First, have to figure out how many byte of data to send.
759:                        */
760:                   	if(cdc_tx_len > sizeof(cdc_data_tx))
  6014    0E40     MOVLW 0x40
  6016    6E14     MOVWF 0x14, ACCESS
  6018    6A15     CLRF 0x15, ACCESS
  601A    51E8     MOVF 0xe8, W, BANKED
  601C    5C14     SUBWF 0x14, W, ACCESS
  601E    0E00     MOVLW 0
  6020    5815     SUBWFB 0x15, W, ACCESS
  6022    E203     BC 0x602a
761:                   	    byte_to_send = sizeof(cdc_data_tx);
  6024    0E40     MOVLW 0x40
  6026    6EDF     MOVWF 0xfdf, ACCESS
762:                   	else
  6028    D002     BRA 0x602e
763:                   	    byte_to_send = cdc_tx_len;
  602A    C5E8     MOVFF 0x5e8, 0xfdf
  602C    FFDF     NOP
764:               
765:                       /*
766:                        * Subtract the number of bytes just about to be sent from the total.
767:                        */
768:                   	cdc_tx_len = cdc_tx_len - byte_to_send;
  602E    50DF     MOVF 0xfdf, W, ACCESS
  6030    5DE8     SUBWF 0xe8, W, BANKED
  6032    6FE8     MOVWF 0xe8, BANKED
769:                   	  
770:                       pCDCDst.bRam = (BYTE*)&cdc_data_tx; // Set destination pointer
  6034    0E99     MOVLW 0x99
  6036    6FE5     MOVWF 0xe5, BANKED
  6038    0E05     MOVLW 0x5
  603A    6FE6     MOVWF 0xe6, BANKED
771:                       
772:                       i = byte_to_send;
  603C    0E01     MOVLW 0x1
  603E    CFDF     MOVFF 0xfdf, 0xfdb
  6040    FFDB     NOP
773:                       if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
  6042    51E9     MOVF 0xe9, W, BANKED
  6044    E119     BNZ 0x6078
774:                       {
775:                           while(i)
  6046    0E01     MOVLW 0x1
  6048    50DB     MOVF 0xfdb, W, ACCESS
  604A    E02B     BZ 0x60a2
  6076    D7E7     BRA 0x6046
776:                           {
777:                               *pCDCDst.bRam = *pCDCSrc.bRom;
  604C    C5E2     MOVFF 0x5e2, 0xff6
  604E    FFF6     NOP
  6050    C5E3     MOVFF 0x5e3, 0xff7
  6052    FFF7     NOP
  6054    C5E4     MOVFF 0x5e4, 0xff8
  6056    FFF8     NOP
  6058    0008     TBLRD*
  605A    50F5     MOVF 0xff5, W, ACCESS
  605C    C5E5     MOVFF 0x5e5, 0xfe9
  605E    FFE9     NOP
  6060    C5E6     MOVFF 0x5e6, 0xfea
  6062    FFEA     NOP
  6064    6EEF     MOVWF 0xfef, ACCESS
778:                               pCDCDst.bRam++;
  6066    2BE5     INCF 0xe5, F, BANKED
  6068    0E00     MOVLW 0
  606A    23E6     ADDWFC 0xe6, F, BANKED
779:                               pCDCSrc.bRom++;
  606C    2BE2     INCF 0xe2, F, BANKED
  606E    23E3     ADDWFC 0xe3, F, BANKED
  6070    23E4     ADDWFC 0xe4, F, BANKED
780:                               i--;
  6072    0E01     MOVLW 0x1
  6074    06DB     DECF 0xfdb, F, ACCESS
781:                           }//end while(byte_to_send)
782:                       }
783:                       else // _RAM
784:                       {
785:                           while(i)
  6078    0E01     MOVLW 0x1
  607A    50DB     MOVF 0xfdb, W, ACCESS
  607C    E012     BZ 0x60a2
  60A0    D7EB     BRA 0x6078
786:                           {
787:                               *pCDCDst.bRam = *pCDCSrc.bRam;
  607E    C5E2     MOVFF 0x5e2, 0xfe9
  6080    FFE9     NOP
  6082    C5E3     MOVFF 0x5e3, 0xfea
  6084    FFEA     NOP
  6086    50EF     MOVF 0xfef, W, ACCESS
  6088    C5E5     MOVFF 0x5e5, 0xfe9
  608A    FFE9     NOP
  608C    C5E6     MOVFF 0x5e6, 0xfea
  608E    FFEA     NOP
  6090    6EEF     MOVWF 0xfef, ACCESS
788:                               pCDCDst.bRam++;
  6092    2BE5     INCF 0xe5, F, BANKED
  6094    0E00     MOVLW 0
  6096    23E6     ADDWFC 0xe6, F, BANKED
789:                               pCDCSrc.bRam++;
  6098    2BE2     INCF 0xe2, F, BANKED
  609A    23E3     ADDWFC 0xe3, F, BANKED
790:                               i--;
  609C    0E01     MOVLW 0x1
  609E    06DB     DECF 0xfdb, F, ACCESS
791:                           }//end while(byte_to_send._word)
792:                       }//end if(cdc_mem_type...)
793:                       
794:                       /*
795:                        * Lastly, determine if a zero length packet state is necessary.
796:                        * See explanation in USB Specification 2.0: Section 5.8.3
797:                        */
798:                       if(cdc_tx_len == 0)
  60A2    0105     MOVLB 0x5
  60A4    51E8     MOVF 0xe8, W, BANKED
  60A6    E107     BNZ 0x60b6
799:                       {
800:                           if(byte_to_send == CDC_DATA_IN_EP_SIZE)
  60A8    0E40     MOVLW 0x40
  60AA    5CDF     SUBWF 0xfdf, W, ACCESS
  60AC    E102     BNZ 0x60b2
801:                               cdc_trf_state = CDC_TX_BUSY_ZLP;
  60AE    0E02     MOVLW 0x2
802:                           else
  60B0    D001     BRA 0x60b4
803:                               cdc_trf_state = CDC_TX_COMPLETING;
  60B2    0E03     MOVLW 0x3
  60B4    6FE1     MOVWF 0xe1, BANKED
804:                       }//end if(cdc_tx_len...)
805:                       CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_tx,byte_to_send);
  60B6    CFDF     MOVFF 0xfdf, 0xfe6
  60B8    FFE6     NOP
  60BA    0E99     MOVLW 0x99
  60BC    6EE6     MOVWF 0xfe6, ACCESS
  60BE    0E05     MOVLW 0x5
  60C0    6EE6     MOVWF 0xfe6, ACCESS
  60C2    0E01     MOVLW 0x1
  60C4    6EE6     MOVWF 0xfe6, ACCESS
  60C6    0E03     MOVLW 0x3
  60C8    6EE6     MOVWF 0xfe6, ACCESS
  60CA    ECFE     CALL 0x39fc, 0
  60CC    F01C     NOP
  60CE    6E14     MOVWF 0x14, ACCESS
  60D0    0E05     MOVLW 0x5
  60D2    5EE1     SUBWF 0xfe1, F, ACCESS
  60D4    5014     MOVF 0x14, W, ACCESS
  60D6    CFF3     MOVFF 0xff3, 0x5ec
  60D8    F5EC     NOP
  60DA    CFF4     MOVFF 0xff4, 0x5ed
  60DC    F5ED     NOP
806:               
807:                   }//end if(cdc_tx_sate == CDC_TX_BUSY)
808:                   USBUnmaskInterrupts();
  60DE    88A0     BSF 0xfa0, 0x4, ACCESS
809:               }//end CDCTxService
  60E0    0E02     MOVLW 0x2
  60E2    5CE1     SUBWF 0xfe1, W, ACCESS
  60E4    E202     BC 0x60ea
  60E6    6AE1     CLRF 0xfe1, ACCESS
  60E8    52E5     MOVF 0xfe5, F, ACCESS
  60EA    6EE1     MOVWF 0xfe1, ACCESS
  60EC    52E5     MOVF 0xfe5, F, ACCESS
  60EE    CFE7     MOVFF 0xfe7, 0xfd9
  60F0    FFD9     NOP
  60F2    0012     RETURN 0
---  E:\Projects\DevPFG\Microchip\USB\MSD Device Driver\usb_function_msd.c  ----------------------
1:                 /*********************************************************************
2:                   File Information:
3:                     FileName:        usb_function_msd.c
4:                     Dependencies:    See INCLUDES section below
5:                     Processor:       PIC18, PIC24, or PIC32
6:                     Compiler:        C18, C30, or C32
7:                     Company:         Microchip Technology, Inc.
8:                 
9:                     Software License Agreement
10:                
11:                    The software supplied herewith by Microchip Technology Incorporated
12:                    (the "Company") for its PICmicror Microcontroller is intended and
13:                    supplied to you, the Company's customer, for use solely and
14:                    exclusively on Microchip PICmicro Microcontroller products. The
15:                    software is owned by the Company and/or its supplier, and is
16:                    protected under applicable copyright laws. All rights are reserved.
17:                    Any use in violation of the foregoing restrictions may subject the
18:                    user to criminal sanctions under applicable laws, as well as to
19:                    civil liability for the breach of the terms and conditions of this
20:                    license.
21:                
22:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
23:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
24:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
25:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
26:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
27:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
28:                
29:                  Summary:
30:                    This file contains functions, macros, definitions, variables,
31:                    datatypes, etc. that are required for use of the MSD function
32:                    driver. This file should be included in projects that use the MSD
33:                    \function driver.
34:                    
35:                    
36:                    
37:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\MSD
38:                    Device Driver" directory.
39:                
40:                  Description:
41:                    USB MSD Function Driver File
42:                    
43:                    This file contains functions, macros, definitions, variables,
44:                    datatypes, etc. that are required for use of the MSD function
45:                    driver. This file should be included in projects that use the MSD
46:                    \function driver.
47:                    
48:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\MSD
49:                    Device Driver" directory.
50:                    
51:                    When including this file in a new project, this file can either be
52:                    referenced from the directory in which it was installed or copied
53:                    directly into the user application folder. If the first method is
54:                    chosen to keep the file located in the folder in which it is installed
55:                    then include paths need to be added so that the library and the
56:                    application both know where to reference each others files. If the
57:                    application folder is located in the same folder as the Microchip
58:                    folder (like the current demo folders), then the following include
59:                    paths need to be added to the application's project:
60:                    
61:                    ..\\..\\Microchip\\Include
62:                    .
63:                    
64:                    If a different directory structure is used, modify the paths as
65:                    required. An example using absolute paths instead of relative paths
66:                    would be the following:
67:                    
68:                    C:\\Microchip Solutions\\Microchip\\Include
69:                    
70:                    C:\\Microchip Solutions\\My Demo Application
71:                
72:                Change History:
73:                  Rev         Description
74:                  ----------  ----------------------------------------------------------
75:                  2.6 - 2.7a  No change
76:                  2.7b		  Improved error case checking, error case recovery, and 
77:                			  sense key/status reporting to the host.
78:                  			  Implemented adjustable read/write failure retry feature.
79:                			  Fixed minor bug that would have interfered with supporting 
80:                			  more than 7 LUNs simultaneously.
81:                
82:                ********************************************************************/
83:                 
84:                /** I N C L U D E S **************************************************/
85:                #include "USB/USB.h"
86:                #include "HardwareProfile.h"
87:                #include "FSConfig.h"
88:                
89:                #include "./USB/usb_function_msd.h"
90:                
91:                #ifdef USB_USE_MSD
92:                
93:                #if MAX_LUN == 0
94:                    #define LUN_INDEX 0
95:                #else
96:                    #define LUN_INDEX gblCBW.bCBWLUN
97:                #endif
98:                
99:                #if defined(__C30__) || defined(__C32__)
100:                   #if defined(USE_INTERNAL_FLASH)
101:                       #include "MDD File System/Internal Flash.h"
102:                   #endif
103:               
104:                   #if defined(USE_SD_INTERFACE_WITH_SPI)
105:                       #include "MDD File System/SD-SPI.h"
106:                   #endif
107:               
108:                   extern LUN_FUNCTIONS LUN[MAX_LUN + 1];
109:                   #define LUNMediaInitialize()                LUN[LUN_INDEX].MediaInitialize()
110:                   #define LUNReadCapacity()                   LUN[LUN_INDEX].ReadCapacity()
111:                   #define LUNReadSectorSize()                 LUN[LUN_INDEX].ReadSectorSize()
112:                   #define LUNMediaDetect()                    LUN[LUN_INDEX].MediaDetect()
113:                   #define LUNSectorWrite(bLBA,pDest,Write0)   LUN[LUN_INDEX].SectorWrite(bLBA, pDest, Write0)
114:                   #define LUNWriteProtectState()              LUN[LUN_INDEX].WriteProtectState()
115:                   #define LUNSectorRead(bLBA,pSrc)            LUN[LUN_INDEX].SectorRead(bLBA, pSrc)
116:               #else
117:                   #if defined(USE_INTERNAL_FLASH)
118:                       #include "MDD File System/Internal Flash.h"
119:                   #endif
120:               
121:                   #if defined(USE_SD_INTERFACE_WITH_SPI)
122:                       #include "MDD File System/SD-SPI.h"
123:                   #endif
124:               
125:                   #define LUNMediaInitialize()                MDD_MediaInitialize()
126:                   #define LUNReadCapacity()                   MDD_ReadCapacity()
127:                   #define LUNReadSectorSize()                 MDD_ReadSectorSize()
128:                   #define LUNMediaDetect()                    MDD_MediaDetect()
129:                   #define LUNSectorWrite(bLBA,pDest,Write0)   MDD_SectorWrite(bLBA, pDest, Write0)
130:                   #define LUNWriteProtectState()              MDD_WriteProtectState()
131:                   #define LUNSectorRead(bLBA,pSrc)            MDD_SectorRead(bLBA, pSrc)
132:               #endif
133:               
134:               //Adjustable user options
135:               #define MSD_FAILED_READ_MAX_ATTEMPTS  (BYTE)100u    //Used for error case handling
136:               #define MSD_FAILED_WRITE_MAX_ATTEMPTS (BYTE)100u    //Used for error case handling
137:               
138:               /** V A R I A B L E S ************************************************/
139:               #pragma udata
140:               BYTE MSD_State;			// Takes values MSD_WAIT, MSD_DATA_IN or MSD_DATA_OUT
141:               BYTE MSDReadState;
142:               BYTE MSDWriteState;
143:               BYTE MSDRetryAttempt;
144:               USB_MSD_CBW gblCBW;	
145:               BYTE gblCBWLength;
146:               RequestSenseResponse gblSenseData[MAX_LUN + 1];
147:               BYTE *ptrNextData;
148:               USB_HANDLE USBMSDOutHandle;
149:               USB_HANDLE USBMSDInHandle;
150:               WORD MSBBufferIndex;
151:               WORD gblMediaPresent; 
152:               BOOL SoftDetach[MAX_LUN + 1];
153:               static BYTE MSDCommandState = MSD_COMMAND_WAIT;
154:               
155:               static WORD_VAL TransferLength;
156:               static DWORD_VAL LBA;
157:               
158:               /* 
159:                * Number of Blocks and Block Length are global because 
160:                * for every READ_10 and WRITE_10 command need to verify if the last LBA 
161:                * is less than gblNumBLKS	
162:                */	
163:               DWORD_VAL gblNumBLKS,gblBLKLen;	
164:               extern const ROM InquiryResponse inq_resp;
165:               
166:               /** P R I V A T E  P R O T O T Y P E S ***************************************/
167:               BYTE MSDProcessCommand(void);
168:               BYTE MSDReadHandler(void);
169:               BYTE MSDWriteHandler(void);
170:               void ResetSenseData(void);
171:               
172:               /** D E C L A R A T I O N S **************************************************/
173:               #pragma code
174:               
175:               /** C L A S S  S P E C I F I C  R E Q ****************************************/
176:               
177:               /******************************************************************************
178:                 Function:
179:                   void USBMSDInit(void)
180:                   
181:                 Summary:
182:                   This routine initializes the MSD class packet handles, prepares to
183:                   receive a MSD packet, and initializes the MSD state machine. This
184:                   \function should be called once after the device is enumerated.
185:               
186:                 Description:
187:                   This routine initializes the MSD class packet handles, prepares to
188:                   receive a MSD packet, and initializes the MSD state machine. This
189:                   \function should be called once after the device is enumerated.
190:                   
191:                   Typical Usage:
192:                   <code>
193:                   void USBCBInitEP(void)
194:                   {
195:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
196:                       USBMSDInit();
197:                   }
198:                   </code>
199:                 Conditions:
200:                   The device should already be enumerated with a configuration that
201:                   supports MSD before calling this function.
202:                   
203:                 Paramters: None
204:               
205:                 Remarks:
206:                   None                                                                                                          
207:                 ****************************************************************************/	
208:               void USBMSDInit(void)
209:               {
210:                   USBMSDInHandle = 0;
  47FC    0104     MOVLB 0x4
  47FE    6BB6     CLRF 0xb6, BANKED
  4800    6BB7     CLRF 0xb7, BANKED
211:                   USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(BYTE*)&msd_cbw,MSD_OUT_EP_SIZE);
  4802    0E40     MOVLW 0x40
  4804    6EE6     MOVWF 0xfe6, ACCESS
  4806    0E50     MOVLW 0x50
  4808    6EE6     MOVWF 0xfe6, ACCESS
  480A    0E04     MOVLW 0x4
  480C    6EE6     MOVWF 0xfe6, ACCESS
  480E    6AE6     CLRF 0xfe6, ACCESS
  4810    0E01     MOVLW 0x1
  4812    6EE6     MOVWF 0xfe6, ACCESS
  4814    ECFE     CALL 0x39fc, 0
  4816    F01C     NOP
  4818    6E14     MOVWF 0x14, ACCESS
  481A    0E05     MOVLW 0x5
  481C    5EE1     SUBWF 0xfe1, F, ACCESS
  481E    5014     MOVF 0x14, W, ACCESS
  4820    CFF3     MOVFF 0xff3, 0x4b4
  4822    F4B4     NOP
  4824    CFF4     MOVFF 0xff4, 0x4b5
  4826    F4B5     NOP
212:                   MSD_State = MSD_WAIT;
  4828    0104     MOVLB 0x4
  482A    6B7C     CLRF 0x7c, BANKED
213:                   MSDCommandState = MSD_COMMAND_WAIT;
  482C    0105     MOVLB 0x5
  482E    69FD     SETF 0xfd, BANKED
214:                   MSDReadState = MSD_READ10_WAIT;
  4830    0104     MOVLB 0x4
  4832    6B7D     CLRF 0x7d, BANKED
215:                   MSDWriteState = MSD_WRITE10_WAIT;
  4834    6B7E     CLRF 0x7e, BANKED
216:                   gblNumBLKS.Val = 0;
  4836    6BC3     CLRF 0xc3, BANKED
  4838    6BC4     CLRF 0xc4, BANKED
  483A    6BC5     CLRF 0xc5, BANKED
  483C    6BC6     CLRF 0xc6, BANKED
217:                   gblBLKLen.Val = 0;
  483E    6BC7     CLRF 0xc7, BANKED
  4840    6BC8     CLRF 0xc8, BANKED
  4842    6BC9     CLRF 0xc9, BANKED
  4844    6BCA     CLRF 0xca, BANKED
218:               
219:                   gblMediaPresent = 0;
  4846    6BBA     CLRF 0xba, BANKED
  4848    6BBB     CLRF 0xbb, BANKED
220:               
221:                   //For each of the possible logical units
222:                   for(gblCBW.bCBWLUN=0;gblCBW.bCBWLUN<(MAX_LUN + 1);gblCBW.bCBWLUN++)
  484A    6B8D     CLRF 0x8d, BANKED
  484C    0E01     MOVLW 0x1
  484E    5D8D     SUBWF 0x8d, W, BANKED
  4850    E222     BC 0x4896
  4890    0104     MOVLB 0x4
  4892    2B8D     INCF 0x8d, F, BANKED
  4894    D7DB     BRA 0x484c
223:                   {
224:                       //clear all of the soft detach variables
225:                       SoftDetach[gblCBW.bCBWLUN] =  FALSE;
  4852    518D     MOVF 0x8d, W, BANKED
  4854    6AEA     CLRF 0xfea, ACCESS
  4856    0FBC     ADDLW 0xbc
  4858    6EE9     MOVWF 0xfe9, ACCESS
  485A    0E04     MOVLW 0x4
  485C    22EA     ADDWFC 0xfea, F, ACCESS
  485E    6AEF     CLRF 0xfef, ACCESS
226:               
227:                       //see if the media is attached
228:                       if(LUNMediaDetect())
  4860    EC1C     CALL 0x1038, 0
  4862    F008     NOP
  4864    0900     IORLW 0
  4866    E012     BZ 0x488c
229:                       {
230:                           //initialize the media
231:                           if(LUNMediaInitialize())
  4868    ECEC     CALL 0x21d8, 0
  486A    F010     NOP
  486C    CFF3     MOVFF 0xff3, 0x14
  486E    F014     NOP
  4870    CFF4     MOVFF 0xff4, 0x15
  4872    F015     NOP
  4874    50F3     MOVF 0xff3, W, ACCESS
  4876    10F4     IORWF 0xff4, W, ACCESS
  4878    E009     BZ 0x488c
232:                           {
233:                               //if the media was present and successfully initialized
234:                               //  then mark and indicator that the media is ready
235:                               gblMediaPresent |= ((WORD)1<<gblCBW.bCBWLUN);
  487A    0104     MOVLB 0x4
  487C    518D     MOVF 0x8d, W, BANKED
  487E    ECAA     CALL 0x6754, 0
  4880    F033     NOP
  4882    50F3     MOVF 0xff3, W, ACCESS
  4884    0104     MOVLB 0x4
  4886    13BA     IORWF 0xba, F, BANKED
  4888    50F4     MOVF 0xff4, W, ACCESS
  488A    13BB     IORWF 0xbb, F, BANKED
236:                           }
237:                       }
238:                       ResetSenseData();
  488C    EC38     CALL 0x5270, 0
  488E    F029     NOP
239:                   }
240:               }
  4896    0012     RETURN 0
241:               
242:               /******************************************************************************
243:                	Function:
244:                		void USBCheckMSDRequest(void)
245:               
246:                	Summary:
247:                		This routine handles MSD specific request that happen on EP0.  
248:                       This function should be called from the USBCBCheckOtherReq() call back 
249:                       function whenever implementing an MSD device.
250:               
251:                	Description:
252:                		This routine handles MSD specific request that happen on EP0.  These
253:                       include, but are not limited to, the standard RESET and GET_MAX_LUN 
254:                		command requests.  This function should be called from the 
255:                       USBCBCheckOtherReq() call back function whenever using an MSD device.	
256:               
257:                       Typical Usage:
258:                       <code>
259:                       void USBCBCheckOtherReq(void)
260:                       {
261:                           //Since the stack didn't handle the request I need to check
262:                           //  my class drivers to see if it is for them
263:                           USBCheckMSDRequest();
264:                       }
265:                       </code>
266:               
267:                	PreCondition:
268:                		None
269:                		
270:                	Parameters:
271:                		None
272:                	
273:                	Return Values:
274:                		None
275:                		
276:                	Remarks:
277:                		None
278:                
279:                *****************************************************************************/	
280:               void USBCheckMSDRequest(void)
281:               {
282:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
  4898    0104     MOVLB 0x4
  489A    5140     MOVF 0x40, W, BANKED
  489C    0B1F     ANDLW 0x1f
  489E    0801     SUBLW 0x1
  48A0    E001     BZ 0x48a4
  48A2    0012     RETURN 0
283:                   if(SetupPkt.bIntfID != MSD_INTF_ID) return;
  48A4    5144     MOVF 0x44, W, BANKED
  48A6    E001     BZ 0x48aa
  48A8    0012     RETURN 0
284:               
285:               	switch(SetupPkt.bRequest)
  48AA    5141     MOVF 0x41, W, BANKED
  48AC    0AFE     XORLW 0xfe
  48AE    E00B     BZ 0x48c6
  48B0    0A01     XORLW 0x1
  48B2    E001     BZ 0x48b6
  48B4    0012     RETURN 0
286:                   {
287:               	    case MSD_RESET:
288:               	        //Host would typically issue this after a STALL event on an MSD
289:               	        //bulk endpoint.  The MSD reset should re-initialize status
290:               	        //so as to prepare for a new CBW.  Any currently ongoing command
291:               	        //block should be aborted, but the STALL and DTS states need to be
292:               	        //maintained (host will re-initialize these seperately using 
293:               	        //CLEAR_FEATURE, endpoint halt).
294:                           MSD_State = MSD_WAIT;
  48B6    0104     MOVLB 0x4
  48B8    6B7C     CLRF 0x7c, BANKED
295:                           MSDCommandState = MSD_COMMAND_WAIT;
  48BA    0105     MOVLB 0x5
  48BC    69FD     SETF 0xfd, BANKED
296:                           MSDReadState = MSD_READ10_WAIT;
  48BE    0104     MOVLB 0x4
  48C0    6B7D     CLRF 0x7d, BANKED
297:                           MSDWriteState = MSD_WRITE10_WAIT;
  48C2    6B7E     CLRF 0x7e, BANKED
298:               	    	break;
  48C4    0012     RETURN 0
299:               	    case GET_MAX_LUN:
300:                           //If the host asks for the maximum number of logical units
301:                           //  then send out a packet with that information
302:               	    	CtrlTrfData[0] = MAX_LUN;
  48C6    0104     MOVLB 0x4
  48C8    6B48     CLRF 0x48, BANKED
303:                           USBEP0SendRAMPtr((BYTE*)&CtrlTrfData[0],1,USB_EP0_INCLUDE_ZERO);
  48CA    0100     MOVLB 0
  48CC    0E48     MOVLW 0x48
  48CE    6F79     MOVWF 0x79, BANKED
  48D0    0E04     MOVLW 0x4
  48D2    6F7A     MOVWF 0x7a, BANKED
  48D4    0E01     MOVLW 0x1
  48D6    6F7D     MOVWF 0x7d, BANKED
  48D8    6B7E     CLRF 0x7e, BANKED
  48DA    0EC1     MOVLW 0xc1
  48DC    6F7C     MOVWF 0x7c, BANKED
304:               	    	break;
305:                   }	//end switch(SetupPkt.bRequest)
306:               }
  48DE    0012     RETURN 0
307:               
308:               /*********************************************************************************
309:                 Function:
310:                       BYTE MSDTasks(void)
311:                   
312:                 Summary:
313:                   This function runs the MSD class state machines and all of its
314:                   sub-systems. This function should be called periodically once the
315:                   device is in the configured state in order to keep the MSD state
316:                   machine going.
317:                 Description:
318:                   This function runs the MSD class state machines and all of its
319:                   sub-systems. This function should be called periodically once the
320:                   device is in the configured state in order to keep the MSD state
321:                   machine going.
322:                   
323:                   Typical Usage:
324:                   <code>
325:                   void main(void)
326:                   {
327:                       USBDeviceInit();
328:                       while(1)
329:                       {
330:                           USBDeviceTasks();
331:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
332:                              (USBIsDeviceSuspended() == TRUE))
333:                           {
334:                               //Either the device is not configured or we are suspended
335:                               //  so we don't want to do execute any application code
336:                               continue;   //go back to the top of the while loop
337:                           }
338:                           else
339:                           {
340:                               //Keep the MSD state machine going
341:                               MSDTasks();
342:                   
343:                               //Run application code.
344:                               UserApplication();
345:                           }
346:                       }
347:                   }
348:                   </code>
349:                 Conditions:
350:                   None
351:                 Return Values:
352:                   BYTE -  the current state of the MSD state machine the valid values are
353:                           defined in MSD.h under the MSDTasks state machine declaration section.
354:                           The possible values are the following\:
355:                           * MSD_WAIT
356:                           * MSD_DATA_IN
357:                           * MSD_DATA_OUT
358:                           * MSD_SEND_CSW
359:                 Remarks:
360:                   None                                                                          
361:                 *********************************************************************************/	
362:               BYTE MSDTasks(void)
  48E0    CFD9     MOVFF 0xfd9, 0xfe6
  48E2    FFE6     NOP
  48E4    CFE1     MOVFF 0xfe1, 0xfd9
  48E6    FFD9     NOP
  48E8    52E6     MOVF 0xfe6, F, ACCESS
363:               {
364:                   BYTE i;
365:                   
366:                   switch(MSD_State)
  48EA    0104     MOVLB 0x4
  48EC    517C     MOVF 0x7c, W, BANKED
  48EE    0A03     XORLW 0x3
  48F0    E101     BNZ 0x48f4
  48F2    D0B7     BRA 0x4a62
  48F4    0A01     XORLW 0x1
  48F6    E101     BNZ 0x48fa
  48F8    D0A3     BRA 0x4a40
  48FA    0A03     XORLW 0x3
  48FC    E101     BNZ 0x4900
  48FE    D09C     BRA 0x4a38
  4900    0A01     XORLW 0x1
  4902    E001     BZ 0x4906
  4904    D0F6     BRA 0x4af2
367:                   {
368:                       case MSD_WAIT:
369:                       {
370:                           //If the MSD state machine is waiting for something to happen
371:                           if(!USBHandleBusy(USBMSDOutHandle))
  4906    51B4     MOVF 0xb4, W, BANKED
  4908    11B5     IORWF 0xb5, W, BANKED
  490A    E102     BNZ 0x4910
  490C    0E00     MOVLW 0
  490E    D008     BRA 0x4920
  4910    C4B4     MOVFF 0x4b4, 0xfe9
  4912    FFE9     NOP
  4914    C4B5     MOVFF 0x4b5, 0xfea
  4916    FFEA     NOP
  4918    50EF     MOVF 0xfef, W, ACCESS
  491A    0B80     ANDLW 0x80
  491C    E001     BZ 0x4920
  491E    0E01     MOVLW 0x1
  4920    0900     IORLW 0
  4922    E001     BZ 0x4926
  4924    D0E7     BRA 0x4af4
372:                           {
373:                       		//If we received an OUT packet from the host
374:                               //  then copy the data from the buffer to a global
375:                               //  buffer so that we can keep the information but
376:                               //  reuse the buffer
377:                       		gblCBW.dCBWSignature=msd_cbw.dCBWSignature;					
  4926    C450     MOVFF 0x450, 0x480
  4928    F480     NOP
  492A    C451     MOVFF 0x451, 0x481
  492C    F481     NOP
  492E    C452     MOVFF 0x452, 0x482
  4930    F482     NOP
  4932    C453     MOVFF 0x453, 0x483
  4934    F483     NOP
378:                       		gblCBW.dCBWTag=msd_cbw.dCBWTag;
  4936    C454     MOVFF 0x454, 0x484
  4938    F484     NOP
  493A    C455     MOVFF 0x455, 0x485
  493C    F485     NOP
  493E    C456     MOVFF 0x456, 0x486
  4940    F486     NOP
  4942    C457     MOVFF 0x457, 0x487
  4944    F487     NOP
379:                       		gblCBW.dCBWDataTransferLength=msd_cbw.dCBWDataTransferLength;
  4946    C458     MOVFF 0x458, 0x488
  4948    F488     NOP
  494A    C459     MOVFF 0x459, 0x489
  494C    F489     NOP
  494E    C45A     MOVFF 0x45a, 0x48a
  4950    F48A     NOP
  4952    C45B     MOVFF 0x45b, 0x48b
  4954    F48B     NOP
380:                           	gblCBW.bCBWFlags=msd_cbw.bCBWFlags;
  4956    C45C     MOVFF 0x45c, 0x48c
  4958    F48C     NOP
381:                           	gblCBW.bCBWLUN=msd_cbw.bCBWLUN;
  495A    C45D     MOVFF 0x45d, 0x48d
  495C    F48D     NOP
382:                       	    gblCBW.bCBWCBLength=msd_cbw.bCBWCBLength;		// 3 MSB are zero
  495E    C45E     MOVFF 0x45e, 0x48e
  4960    F48E     NOP
383:               
384:                           	for (i=0;i<msd_cbw.bCBWCBLength;i++)
  4962    6ADF     CLRF 0xfdf, ACCESS
  4964    0104     MOVLB 0x4
  4966    515E     MOVF 0x5e, W, BANKED
  4968    5CDF     SUBWF 0xfdf, W, ACCESS
  496A    E213     BC 0x4992
  498E    2ADF     INCF 0xfdf, F, ACCESS
  4990    D7E9     BRA 0x4964
385:                           	{
386:                           		gblCBW.CBWCB[i]=msd_cbw.CBWCB[i];
  496C    50DF     MOVF 0xfdf, W, ACCESS
  496E    6AEA     CLRF 0xfea, ACCESS
  4970    0F5F     ADDLW 0x5f
  4972    6EE9     MOVWF 0xfe9, ACCESS
  4974    0E04     MOVLW 0x4
  4976    22EA     ADDWFC 0xfea, F, ACCESS
  4978    50EF     MOVF 0xfef, W, ACCESS
  497A    6EE6     MOVWF 0xfe6, ACCESS
  497C    50DF     MOVF 0xfdf, W, ACCESS
  497E    6AEA     CLRF 0xfea, ACCESS
  4980    0F8F     ADDLW 0x8f
  4982    6EE9     MOVWF 0xfe9, ACCESS
  4984    0E04     MOVLW 0x4
  4986    22EA     ADDWFC 0xfea, F, ACCESS
  4988    52E5     MOVF 0xfe5, F, ACCESS
  498A    50E7     MOVF 0xfe7, W, ACCESS
  498C    6EEF     MOVWF 0xfef, ACCESS
387:                               }
388:                           		
389:                               gblCBWLength=USBHandleGetLength(USBMSDOutHandle);
  4992    C4B4     MOVFF 0x4b4, 0xfe9
  4994    FFE9     NOP
  4996    C4B5     MOVFF 0x4b5, 0xfea
  4998    FFEA     NOP
  499A    52EE     MOVF 0xfee, F, ACCESS
  499C    CFEF     MOVFF 0xfef, 0x49f
  499E    F49F     NOP
390:               
391:                       	    //If this CBW is valid?
392:                       		if ((gblCBWLength==MSD_CBW_SIZE)&&(gblCBW.dCBWSignature==0x43425355)) 
  49A0    0E1F     MOVLW 0x1f
  49A2    0104     MOVLB 0x4
  49A4    5D9F     SUBWF 0x9f, W, BANKED
  49A6    E001     BZ 0x49aa
  49A8    D0A5     BRA 0x4af4
  49AA    0E55     MOVLW 0x55
  49AC    1980     XORWF 0x80, W, BANKED
  49AE    E001     BZ 0x49b2
  49B0    D0A1     BRA 0x4af4
  49B2    0E53     MOVLW 0x53
  49B4    1981     XORWF 0x81, W, BANKED
  49B6    E001     BZ 0x49ba
  49B8    D09D     BRA 0x4af4
  49BA    0E42     MOVLW 0x42
  49BC    1982     XORWF 0x82, W, BANKED
  49BE    E001     BZ 0x49c2
  49C0    D099     BRA 0x4af4
  49C2    0E43     MOVLW 0x43
  49C4    1983     XORWF 0x83, W, BANKED
  49C6    E001     BZ 0x49ca
  49C8    D095     BRA 0x4af4
393:                           	{
394:                                   //Is this CBW meaningful?	
395:                      				if((gblCBW.bCBWLUN<=0x0f)
  49CA    518D     MOVF 0x8d, W, BANKED
  49CC    080F     SUBLW 0xf
396:                              		&&(gblCBW.bCBWCBLength<=0x10)
  49D2    518E     MOVF 0x8e, W, BANKED
  49D4    0810     SUBLW 0x10
397:                              		&&(gblCBW.bCBWCBLength>=0x01)
  49CE    E201     BC 0x49d2
  49D0    D091     BRA 0x4af4
  49D6    E201     BC 0x49da
  49D8    D08D     BRA 0x4af4
  49DA    0E01     MOVLW 0x1
  49DC    5D8E     SUBWF 0x8e, W, BANKED
398:                              		&&(gblCBW.bCBWFlags==0x00||gblCBW.bCBWFlags==0x80)) 
  49DE    E201     BC 0x49e2
  49E0    D089     BRA 0x4af4
  49E2    518C     MOVF 0x8c, W, BANKED
  49E4    E004     BZ 0x49ee
  49E6    0E80     MOVLW 0x80
  49E8    5D8C     SUBWF 0x8c, W, BANKED
  49EA    E001     BZ 0x49ee
  49EC    D083     BRA 0x4af4
399:                           		{
400:                               		//Prepare the CSW to be sent
401:                                   	msd_csw.dCSWTag=gblCBW.dCBWTag;
  49EE    C484     MOVFF 0x484, 0x473
  49F0    F473     NOP
  49F2    C485     MOVFF 0x485, 0x474
  49F4    F474     NOP
  49F6    C486     MOVFF 0x486, 0x475
  49F8    F475     NOP
  49FA    C487     MOVFF 0x487, 0x476
  49FC    F476     NOP
402:                                   	msd_csw.dCSWSignature=0x53425355;
  49FE    0104     MOVLB 0x4
  4A00    0E55     MOVLW 0x55
  4A02    6F6F     MOVWF 0x6f, BANKED
  4A04    0E53     MOVLW 0x53
  4A06    6F70     MOVWF 0x70, BANKED
  4A08    0E42     MOVLW 0x42
  4A0A    6F71     MOVWF 0x71, BANKED
  4A0C    0E53     MOVLW 0x53
  4A0E    6F72     MOVWF 0x72, BANKED
403:                                   	
404:                                   	//Keep track of retry attempts, in case of temporary failures
405:                                   	//during processing of a command.
406:                                   	MSDRetryAttempt = 0;
  4A10    0104     MOVLB 0x4
  4A12    6B7F     CLRF 0x7f, BANKED
407:                                   	
408:                                   	//Check the command.  With the exception of the REQUEST_SENSE
409:                                   	//command, we should reset the sense key info for each new command block.
410:                                   	//Assume the command will get processed successfully (and hence "NO SENSE" 
411:                                   	//response, which is used for success cases), unless handler code
412:                                   	//later on detects some kind of error.  If it does, it should
413:                                   	//update the sense keys to reflect the type of error detected,
414:                                   	//prior to sending the CSW.
415:                                   	if(gblCBW.CBWCB[0] != MSD_REQUEST_SENSE)
  4A14    0E03     MOVLW 0x3
  4A16    5D8F     SUBWF 0x8f, W, BANKED
  4A18    E006     BZ 0x4a26
416:                                   	{
417:                                     		gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
  4A1A    91A2     BCF 0xa2, 0, BANKED
  4A1C    93A2     BCF 0xa2, 0x1, BANKED
  4A1E    95A2     BCF 0xa2, 0x2, BANKED
  4A20    97A2     BCF 0xa2, 0x3, BANKED
418:                       			        gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
  4A22    6BAC     CLRF 0xac, BANKED
419:                       			        gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
  4A24    6BAD     CLRF 0xad, BANKED
420:                   			        }
421:                                   	
422:                       				/* If direction is device to host*/
423:                       				if (gblCBW.bCBWFlags==0x80)
  4A26    0E80     MOVLW 0x80
  4A28    5D8C     SUBWF 0x8c, W, BANKED
  4A2A    E102     BNZ 0x4a30
424:                       				{
425:                       					MSD_State=MSD_DATA_IN;
  4A2C    0E01     MOVLW 0x1
426:                       				}
427:                       				else if (gblCBW.bCBWFlags==0x00) 
  4A2E    D017     BRA 0x4a5e
  4A30    518C     MOVF 0x8c, W, BANKED
  4A32    E160     BNZ 0x4af4
428:                           			{
429:                       					/* If direction is host to device*/
430:                       					/* prepare to read data in msd_buffer */
431:                           			    MSD_State=MSD_DATA_OUT;
  4A34    0E02     MOVLW 0x2
432:                       				}        								
433:                       			}
434:                       		}
435:                           }
436:                           break;
  4A36    D013     BRA 0x4a5e
437:                       }
438:                       case MSD_DATA_IN:
439:                           if(MSDProcessCommand() == MSD_COMMAND_WAIT)
  4A38    DA1D     RCALL 0x4e74
  4A3A    08FF     SUBLW 0xff
  4A3C    E15B     BNZ 0x4af4
440:                           {
441:                               // Done processing the command, send the status
442:                               MSD_State = MSD_SEND_CSW;
443:                           }
444:                           break;
  4A3E    D00D     BRA 0x4a5a
445:                       case MSD_DATA_OUT:
446:                           if(MSDProcessCommand() == MSD_COMMAND_WAIT)
  4A40    DA19     RCALL 0x4e74
  4A42    08FF     SUBLW 0xff
  4A44    E157     BNZ 0x4af4
447:                           {
448:                   			/* Finished receiving the data prepare and send the status */
449:                   		  	if ((msd_csw.bCSWStatus==0x00)&&(msd_csw.dCSWDataResidue!=0)) 
  4A46    0104     MOVLB 0x4
  4A48    517B     MOVF 0x7b, W, BANKED
  4A4A    E107     BNZ 0x4a5a
  4A4C    5177     MOVF 0x77, W, BANKED
  4A4E    1178     IORWF 0x78, W, BANKED
  4A50    1179     IORWF 0x79, W, BANKED
  4A52    117A     IORWF 0x7a, W, BANKED
  4A54    E002     BZ 0x4a5a
450:                   		  	{
451:                   		  		msd_csw.bCSWStatus=0x02;
  4A56    0E02     MOVLW 0x2
  4A58    6F7B     MOVWF 0x7b, BANKED
452:                   		    }
453:                               MSD_State = MSD_SEND_CSW;
  4A5A    0104     MOVLB 0x4
  4A5C    0E03     MOVLW 0x3
  4A5E    6F7C     MOVWF 0x7c, BANKED
454:                           }
455:                           break;
  4A60    D049     BRA 0x4af4
456:                       case MSD_SEND_CSW:
457:                           if(USBHandleBusy(USBMSDInHandle))
  4A62    51B6     MOVF 0xb6, W, BANKED
  4A64    11B7     IORWF 0xb7, W, BANKED
  4A66    E102     BNZ 0x4a6c
  4A68    0E00     MOVLW 0
  4A6A    D008     BRA 0x4a7c
  4A6C    C4B6     MOVFF 0x4b6, 0xfe9
  4A6E    FFE9     NOP
  4A70    C4B7     MOVFF 0x4b7, 0xfea
  4A72    FFEA     NOP
  4A74    50EF     MOVF 0xfef, W, ACCESS
  4A76    0B80     ANDLW 0x80
  4A78    E001     BZ 0x4a7c
  4A7A    0E01     MOVLW 0x1
  4A7C    0900     IORLW 0
  4A7E    E13A     BNZ 0x4af4
458:                           {
459:                               //The TX buffer is not ready to send the status yet.
460:                               break;
461:                           }
462:                           
463:                           USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(BYTE*)&msd_csw,MSD_CSW_SIZE);
  4A80    0E0D     MOVLW 0xd
  4A82    6EE6     MOVWF 0xfe6, ACCESS
  4A84    0E6F     MOVLW 0x6f
  4A86    6EE6     MOVWF 0xfe6, ACCESS
  4A88    0E04     MOVLW 0x4
  4A8A    6EE6     MOVWF 0xfe6, ACCESS
  4A8C    0E01     MOVLW 0x1
  4A8E    6EE6     MOVWF 0xfe6, ACCESS
  4A90    6EE6     MOVWF 0xfe6, ACCESS
  4A92    ECFE     CALL 0x39fc, 0
  4A94    F01C     NOP
  4A96    6E14     MOVWF 0x14, ACCESS
  4A98    0E05     MOVLW 0x5
  4A9A    5EE1     SUBWF 0xfe1, F, ACCESS
  4A9C    5014     MOVF 0x14, W, ACCESS
  4A9E    CFF3     MOVFF 0xff3, 0x4b6
  4AA0    F4B6     NOP
  4AA2    CFF4     MOVFF 0xff4, 0x4b7
  4AA4    F4B7     NOP
464:                           
465:                           //Get ready for next command to come in
466:                           if(!USBHandleBusy(USBMSDOutHandle))
  4AA6    0104     MOVLB 0x4
  4AA8    51B4     MOVF 0xb4, W, BANKED
  4AAA    11B5     IORWF 0xb5, W, BANKED
  4AAC    E102     BNZ 0x4ab2
  4AAE    0E00     MOVLW 0
  4AB0    D008     BRA 0x4ac2
  4AB2    C4B4     MOVFF 0x4b4, 0xfe9
  4AB4    FFE9     NOP
  4AB6    C4B5     MOVFF 0x4b5, 0xfea
  4AB8    FFEA     NOP
  4ABA    50EF     MOVF 0xfef, W, ACCESS
  4ABC    0B80     ANDLW 0x80
  4ABE    E001     BZ 0x4ac2
  4AC0    0E01     MOVLW 0x1
  4AC2    0900     IORLW 0
  4AC4    E113     BNZ 0x4aec
467:                           {
468:                               USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(BYTE*)&msd_cbw,sizeof(msd_cbw));
  4AC6    0E1F     MOVLW 0x1f
  4AC8    6EE6     MOVWF 0xfe6, ACCESS
  4ACA    0E50     MOVLW 0x50
  4ACC    6EE6     MOVWF 0xfe6, ACCESS
  4ACE    0E04     MOVLW 0x4
  4AD0    6EE6     MOVWF 0xfe6, ACCESS
  4AD2    6AE6     CLRF 0xfe6, ACCESS
  4AD4    0E01     MOVLW 0x1
  4AD6    6EE6     MOVWF 0xfe6, ACCESS
  4AD8    ECFE     CALL 0x39fc, 0
  4ADA    F01C     NOP
  4ADC    6E14     MOVWF 0x14, ACCESS
  4ADE    0E05     MOVLW 0x5
  4AE0    5EE1     SUBWF 0xfe1, F, ACCESS
  4AE2    5014     MOVF 0x14, W, ACCESS
  4AE4    CFF3     MOVFF 0xff3, 0x4b4
  4AE6    F4B4     NOP
  4AE8    CFF4     MOVFF 0xff4, 0x4b5
  4AEA    F4B5     NOP
469:                           }
470:                       
471:                          	MSD_State=MSD_WAIT;
  4AEC    0104     MOVLB 0x4
  4AEE    6B7C     CLRF 0x7c, BANKED
472:                           break;
  4AF0    D001     BRA 0x4af4
473:                           
474:                       default:
475:                           //Illegal condition that should not happen, but might occur if the
476:                           //device firmware incorrectly calls MSDTasks() prior to calling
477:                           //USBMSDInit() during the set-configuration portion of enumeration.
478:                           MSD_State=MSD_WAIT;
  4AF2    6B7C     CLRF 0x7c, BANKED
479:                   }
480:                   
481:                   return MSD_State;
  4AF4    0104     MOVLB 0x4
  4AF6    517C     MOVF 0x7c, W, BANKED
482:               }
  4AF8    52E5     MOVF 0xfe5, F, ACCESS
  4AFA    52E5     MOVF 0xfe5, F, ACCESS
  4AFC    CFE7     MOVFF 0xfe7, 0xfd9
  4AFE    FFD9     NOP
  4B00    0012     RETURN 0
483:               
484:               /******************************************************************************
485:                	Function:
486:                		void MSDProcessCommandMediaPresent(void)
487:                		
488:                	Description:
489:                		This funtion processes a command received through the MSD
490:                		class driver
491:                		
492:                	PreCondition:
493:                		None
494:                		
495:                	Paramters:
496:                		None
497:                	
498:                	Return Values:
499:                		BYTE - the current state of the MSDProcessCommand state
500:                		machine.  The valid values are defined in MSD.h under the 
501:                		MSDProcessCommand state machine declaration section
502:                		
503:                	Remarks:
504:                		None
505:                
506:                *****************************************************************************/	
507:               void MSDProcessCommandMediaPresent(void)
  4B02    CFD9     MOVFF 0xfd9, 0xfe6
  4B04    FFE6     NOP
  4B06    CFE1     MOVFF 0xfe1, 0xfd9
  4B08    FFD9     NOP
  4B0A    0E09     MOVLW 0x9
  4B0C    26E1     ADDWF 0xfe1, F, ACCESS
508:               {
509:                   BYTE i; 
510:               
511:                   switch(MSDCommandState)
  4B0E    0105     MOVLB 0x5
  4B10    51FD     MOVF 0xfd, W, BANKED
  4B12    0AFE     XORLW 0xfe
  4B14    E101     BNZ 0x4b18
  4B16    D0F7     BRA 0x4d06
  4B18    0A03     XORLW 0x3
  4B1A    E101     BNZ 0x4b1e
  4B1C    D0C9     BRA 0x4cb0
  4B1E    0AD2     XORLW 0xd2
  4B20    E101     BNZ 0x4b24
  4B22    D0BD     BRA 0x4c9e
  4B24    0A34     XORLW 0x34
  4B26    E101     BNZ 0x4b2a
  4B28    D0BA     BRA 0x4c9e
  4B2A    0A1B     XORLW 0x1b
  4B2C    E101     BNZ 0x4b30
  4B2E    D0AC     BRA 0x4c88
  4B30    0A1E     XORLW 0x1e
  4B32    E101     BNZ 0x4b36
  4B34    D099     BRA 0x4c68
  4B36    0A04     XORLW 0x4
  4B38    E101     BNZ 0x4b3c
  4B3A    D08B     BRA 0x4c52
  4B3C    0A19     XORLW 0x19
  4B3E    E065     BZ 0x4c0a
  4B40    0A29     XORLW 0x29
  4B42    E05E     BZ 0x4c00
  4B44    0A02     XORLW 0x2
  4B46    E057     BZ 0x4bf6
  4B48    0A0D     XORLW 0xd
  4B4A    E01E     BZ 0x4b88
  4B4C    0A37     XORLW 0x37
  4B4E    E006     BZ 0x4b5c
  4B50    0AED     XORLW 0xed
  4B52    E001     BZ 0x4b56
  4B54    D0D8     BRA 0x4d06
512:                   {
513:                       case MSD_COMMAND_WAIT:
514:                           //copy the received command to the command state machine
515:                           MSDCommandState = gblCBW.CBWCB[0];
  4B56    C48F     MOVFF 0x48f, 0x5fd
  4B58    F5FD     NOP
516:                           break;
  4B5A    D0E8     BRA 0x4d2c
517:                   	case MSD_INQUIRY:
518:                   	{
519:                           //copy the inquiry results from the defined ROM buffer 
520:                           //  into the USB buffer so that it can be transmitted
521:                       	memcpypgm2ram(
522:                       	    (void *)&msd_buffer[0],
  4B6E    0E00     MOVLW 0
  4B70    6EE6     MOVWF 0xfe6, ACCESS
  4B72    0E06     MOVLW 0x6
  4B74    6EE6     MOVWF 0xfe6, ACCESS
523:                       	    (ROM void*)&inq_resp,
  4B62    0ED8     MOVLW 0xd8
  4B64    6EE6     MOVWF 0xfe6, ACCESS
  4B66    0E66     MOVLW 0x66
  4B68    6EE6     MOVWF 0xfe6, ACCESS
  4B6A    0E00     MOVLW 0
  4B6C    6EE6     MOVWF 0xfe6, ACCESS
524:                       	    sizeof(InquiryResponse)
  4B5C    0E24     MOVLW 0x24
525:                       	    );
  4B5E    6EE6     MOVWF 0xfe6, ACCESS
  4B60    6AE6     CLRF 0xfe6, ACCESS
  4B76    EC65     CALL 0x62ca, 0
  4B78    F031     NOP
  4B7A    6E14     MOVWF 0x14, ACCESS
  4B7C    0E07     MOVLW 0x7
  4B7E    5EE1     SUBWF 0xfe1, F, ACCESS
  4B80    5014     MOVF 0x14, W, ACCESS
526:                       	msd_csw.dCSWDataResidue=sizeof(InquiryResponse);
  4B82    0104     MOVLB 0x4
  4B84    0E24     MOVLW 0x24
527:                       	msd_csw.bCSWStatus=0x00;			// success
528:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
529:                           break;
  4B86    D05F     BRA 0x4c46
530:                       }
531:                       case MSD_READ_CAPACITY:
532:                       {
533:                           //If the host asked for the capacity of the device
534:                           DWORD_VAL sectorSize;
535:                           DWORD_VAL capacity;
536:               
537:                       	msd_csw.bCSWStatus=0x00;			  // success
  4B88    0104     MOVLB 0x4
  4B8A    6B7B     CLRF 0x7b, BANKED
538:                           
539:                           //get the information from the physical media
540:                           capacity.Val = LUNReadCapacity();
  4B8C    EC71     CALL 0x10e2, 0
  4B8E    F008     NOP
  4B90    0E05     MOVLW 0x5
  4B92    C006     MOVFF 0x6, 0xfdb
  4B94    FFDB     NOP
  4B96    0E06     MOVLW 0x6
  4B98    C007     MOVFF 0x7, 0xfdb
  4B9A    FFDB     NOP
  4B9C    0E07     MOVLW 0x7
  4B9E    C008     MOVFF 0x8, 0xfdb
  4BA0    FFDB     NOP
  4BA2    0E08     MOVLW 0x8
  4BA4    C009     MOVFF 0x9, 0xfdb
  4BA6    FFDB     NOP
541:                           sectorSize.Val = LUNReadSectorSize();
  4BA8    EC6C     CALL 0x10d8, 0
  4BAA    F008     NOP
  4BAC    0E01     MOVLW 0x1
  4BAE    CFF3     MOVFF 0xff3, 0xfdb
  4BB0    FFDB     NOP
  4BB2    0E02     MOVLW 0x2
  4BB4    CFF4     MOVFF 0xff4, 0xfdb
  4BB6    FFDB     NOP
  4BB8    0E03     MOVLW 0x3
  4BBA    6ADB     CLRF 0xfdb, ACCESS
  4BBC    0E04     MOVLW 0x4
  4BBE    6ADB     CLRF 0xfdb, ACCESS
542:                           
543:                           //copy the data to the buffer
544:                       	msd_buffer[0]=capacity.v[3];
  4BC0    0E08     MOVLW 0x8
  4BC2    CFDB     MOVFF 0xfdb, 0x600
  4BC4    F600     NOP
545:                       	msd_buffer[1]=capacity.v[2];
  4BC6    0E07     MOVLW 0x7
  4BC8    CFDB     MOVFF 0xfdb, 0x601
  4BCA    F601     NOP
546:                       	msd_buffer[2]=capacity.v[1];
  4BCC    0E06     MOVLW 0x6
  4BCE    CFDB     MOVFF 0xfdb, 0x602
  4BD0    F602     NOP
547:                       	msd_buffer[3]=capacity.v[0];
  4BD2    0E05     MOVLW 0x5
  4BD4    CFDB     MOVFF 0xfdb, 0x603
  4BD6    F603     NOP
548:                       	
549:                       	msd_buffer[4]=sectorSize.v[3];
  4BD8    0E04     MOVLW 0x4
  4BDA    CFDB     MOVFF 0xfdb, 0x604
  4BDC    F604     NOP
550:                       	msd_buffer[5]=sectorSize.v[2];
  4BDE    0E03     MOVLW 0x3
  4BE0    CFDB     MOVFF 0xfdb, 0x605
  4BE2    F605     NOP
551:                       	msd_buffer[6]=sectorSize.v[1];
  4BE4    0E02     MOVLW 0x2
  4BE6    CFDB     MOVFF 0xfdb, 0x606
  4BE8    F606     NOP
552:                       	msd_buffer[7]=sectorSize.v[0];
  4BEA    0E01     MOVLW 0x1
  4BEC    CFDB     MOVFF 0xfdb, 0x607
  4BEE    F607     NOP
553:                       
554:                       	msd_csw.dCSWDataResidue=0x08;		  // size of response
  4BF0    0104     MOVLB 0x4
  4BF2    0E08     MOVLW 0x8
555:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
556:                           break;
  4BF4    D037     BRA 0x4c64
557:                       }
558:               		case MSD_READ_10:
559:                       	if(MSDReadHandler() == MSD_READ10_WAIT)
  4BF6    D98B     RCALL 0x4f0e
  4BF8    0900     IORLW 0
  4BFA    E001     BZ 0x4bfe
  4BFC    D097     BRA 0x4d2c
560:                       	{
561:               			    MSDCommandState = MSD_COMMAND_WAIT;
562:                           }
563:                           break;
  4BFE    D055     BRA 0x4caa
564:                   	case MSD_WRITE_10:
565:                       	if(MSDWriteHandler() == MSD_WRITE10_WAIT)
  4C00    DA45     RCALL 0x508c
  4C02    0900     IORLW 0
  4C04    E001     BZ 0x4c08
  4C06    D092     BRA 0x4d2c
566:                       	{
567:               			    MSDCommandState = MSD_COMMAND_WAIT;
568:                           }
569:               		    break;
  4C08    D050     BRA 0x4caa
570:                       case MSD_REQUEST_SENSE:    
571:                         	for(i=0;i<sizeof(RequestSenseResponse);i++)
  4C0A    6ADF     CLRF 0xfdf, ACCESS
  4C0C    50DF     MOVF 0xfdf, W, ACCESS
  4C0E    6E14     MOVWF 0x14, ACCESS
  4C10    6A15     CLRF 0x15, ACCESS
  4C12    0E12     MOVLW 0x12
  4C14    5C14     SUBWF 0x14, W, ACCESS
  4C16    0E00     MOVLW 0
  4C18    5815     SUBWFB 0x15, W, ACCESS
  4C1A    E213     BC 0x4c42
  4C3E    2ADF     INCF 0xfdf, F, ACCESS
  4C40    D7E5     BRA 0x4c0c
572:                         	{
573:                         		msd_buffer[i]=gblSenseData[LUN_INDEX]._byte[i];
  4C1C    50DF     MOVF 0xfdf, W, ACCESS
  4C1E    6AEA     CLRF 0xfea, ACCESS
  4C20    0FA0     ADDLW 0xa0
  4C22    6EE9     MOVWF 0xfe9, ACCESS
  4C24    0E04     MOVLW 0x4
  4C26    22EA     ADDWFC 0xfea, F, ACCESS
  4C28    50EF     MOVF 0xfef, W, ACCESS
  4C2A    6EE6     MOVWF 0xfe6, ACCESS
  4C2C    50DF     MOVF 0xfdf, W, ACCESS
  4C2E    6AEA     CLRF 0xfea, ACCESS
  4C30    0F00     ADDLW 0
  4C32    6EE9     MOVWF 0xfe9, ACCESS
  4C34    0E06     MOVLW 0x6
  4C36    22EA     ADDWFC 0xfea, F, ACCESS
  4C38    52E5     MOVF 0xfe5, F, ACCESS
  4C3A    50E7     MOVF 0xfe7, W, ACCESS
  4C3C    6EEF     MOVWF 0xfef, ACCESS
574:                           }
575:                         	
576:                           msd_csw.dCSWDataResidue=sizeof(RequestSenseResponse);
  4C42    0104     MOVLB 0x4
  4C44    0E12     MOVLW 0x12
  4C46    6F77     MOVWF 0x77, BANKED
  4C48    6B78     CLRF 0x78, BANKED
  4C4A    6B79     CLRF 0x79, BANKED
  4C4C    6B7A     CLRF 0x7a, BANKED
577:                         	msd_csw.bCSWStatus=0x0;					// success
  4C4E    6B7B     CLRF 0x7b, BANKED
578:                         	MSDCommandState = MSD_COMMAND_RESPONSE;
579:                           break;
  4C50    D06A     BRA 0x4d26
580:               	    case MSD_MODE_SENSE:
581:                       	msd_buffer[0]=0x02;
  4C52    0106     MOVLB 0x6
  4C54    0E02     MOVLW 0x2
  4C56    6F00     MOVWF 0, BANKED
582:                       	msd_buffer[1]=0x00;
  4C58    6B01     CLRF 0x1, BANKED
583:                       	msd_buffer[2]=0x00;
  4C5A    6B02     CLRF 0x2, BANKED
584:                       	msd_buffer[3]=0x00;
  4C5C    6B03     CLRF 0x3, BANKED
585:                       	
586:                       	msd_csw.bCSWStatus=0x0;
  4C5E    0104     MOVLB 0x4
  4C60    6B7B     CLRF 0x7b, BANKED
587:                       	msd_csw.dCSWDataResidue=0x04;
  4C62    0E04     MOVLW 0x4
  4C64    6F77     MOVWF 0x77, BANKED
588:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
589:                   	    break;
  4C66    D05C     BRA 0x4d20
590:               		case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
591:                           if(LUNMediaDetect())
  4C68    EC1C     CALL 0x1038, 0
  4C6A    F008     NOP
  4C6C    0900     IORLW 0
  4C6E    E117     BNZ 0x4c9e
592:                           {
593:                       		msd_csw.bCSWStatus=0x00;
594:                       		msd_csw.dCSWDataResidue=0x00;
595:                       	}
596:                           else
597:                           {
598:                       		gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
  4C70    0104     MOVLB 0x4
  4C72    91A2     BCF 0xa2, 0, BANKED
  4C74    83A2     BSF 0xa2, 0x1, BANKED
  4C76    95A2     BCF 0xa2, 0x2, BANKED
  4C78    97A2     BCF 0xa2, 0x3, BANKED
599:                       		gblSenseData[LUN_INDEX].ASC=ASC_MEDIUM_NOT_PRESENT;
  4C7A    0E3A     MOVLW 0x3a
  4C7C    6FAC     MOVWF 0xac, BANKED
600:                       		gblSenseData[LUN_INDEX].ASCQ=ASCQ_MEDIUM_NOT_PRESENT;
  4C7E    6BAD     CLRF 0xad, BANKED
601:                       		msd_csw.bCSWStatus=0x01;
  4C80    0104     MOVLB 0x4
  4C82    0E01     MOVLW 0x1
  4C84    6F7B     MOVWF 0x7b, BANKED
602:                       	}
603:               			MSDCommandState = MSD_COMMAND_WAIT;
604:                           break;
  4C86    D011     BRA 0x4caa
605:               		case MSD_TEST_UNIT_READY:
606:                           if((gblSenseData[LUN_INDEX].SenseKey==S_UNIT_ATTENTION) && (msd_csw.bCSWStatus==1))
  4C88    0104     MOVLB 0x4
  4C8A    51A2     MOVF 0xa2, W, BANKED
  4C8C    0B0F     ANDLW 0xf
  4C8E    0806     SUBLW 0x6
  4C90    E103     BNZ 0x4c98
  4C92    0104     MOVLB 0x4
  4C94    057B     DECF 0x7b, W, BANKED
  4C96    E009     BZ 0x4caa
607:                           {
608:                               MSDCommandState = MSD_COMMAND_WAIT;
609:                           }
610:                           else
611:                           {
612:                           	ResetSenseData();
  4C98    DAEB     RCALL 0x5270
613:                           	msd_csw.dCSWDataResidue=0x00;
  4C9A    0104     MOVLB 0x4
614:                   			MSDCommandState = MSD_COMMAND_WAIT;
615:                           }
616:                           break;
  4C9C    D002     BRA 0x4ca2
617:               		case MSD_VERIFY:
618:                           //Fall through to STOP_START
619:               		case MSD_STOP_START:
620:                       	msd_csw.bCSWStatus=0x0;
  4C9E    0104     MOVLB 0x4
  4CA0    6B7B     CLRF 0x7b, BANKED
621:                       	msd_csw.dCSWDataResidue=0x00;
  4CA2    6B77     CLRF 0x77, BANKED
  4CA4    6B78     CLRF 0x78, BANKED
  4CA6    6B79     CLRF 0x79, BANKED
  4CA8    6B7A     CLRF 0x7a, BANKED
622:               			MSDCommandState = MSD_COMMAND_WAIT;
  4CAA    0105     MOVLB 0x5
  4CAC    69FD     SETF 0xfd, BANKED
623:                           break;
  4CAE    D03E     BRA 0x4d2c
624:                       case MSD_COMMAND_RESPONSE:
625:                           if(USBHandleBusy(USBMSDInHandle) == FALSE)
  4CB0    0104     MOVLB 0x4
  4CB2    51B6     MOVF 0xb6, W, BANKED
  4CB4    11B7     IORWF 0xb7, W, BANKED
  4CB6    E102     BNZ 0x4cbc
  4CB8    0E00     MOVLW 0
  4CBA    D008     BRA 0x4ccc
  4CBC    C4B6     MOVFF 0x4b6, 0xfe9
  4CBE    FFE9     NOP
  4CC0    C4B7     MOVFF 0x4b7, 0xfea
  4CC2    FFEA     NOP
  4CC4    50EF     MOVF 0xfef, W, ACCESS
  4CC6    0B80     ANDLW 0x80
  4CC8    E001     BZ 0x4ccc
  4CCA    0E01     MOVLW 0x1
  4CCC    0900     IORLW 0
  4CCE    E12E     BNZ 0x4d2c
626:                           {
627:                               USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(BYTE*)&msd_buffer[0],msd_csw.dCSWDataResidue);
  4CD0    C477     MOVFF 0x477, 0xfe6
  4CD2    FFE6     NOP
  4CD4    0E00     MOVLW 0
  4CD6    6EE6     MOVWF 0xfe6, ACCESS
  4CD8    0E06     MOVLW 0x6
  4CDA    6EE6     MOVWF 0xfe6, ACCESS
  4CDC    0E01     MOVLW 0x1
  4CDE    6EE6     MOVWF 0xfe6, ACCESS
  4CE0    6EE6     MOVWF 0xfe6, ACCESS
  4CE2    ECFE     CALL 0x39fc, 0
  4CE4    F01C     NOP
  4CE6    6E14     MOVWF 0x14, ACCESS
  4CE8    0E05     MOVLW 0x5
  4CEA    5EE1     SUBWF 0xfe1, F, ACCESS
  4CEC    5014     MOVF 0x14, W, ACCESS
  4CEE    CFF3     MOVFF 0xff3, 0x4b6
  4CF0    F4B6     NOP
  4CF2    CFF4     MOVFF 0xff4, 0x4b7
  4CF4    F4B7     NOP
628:               			    MSDCommandState = MSD_COMMAND_WAIT;
  4CF6    0105     MOVLB 0x5
  4CF8    69FD     SETF 0xfd, BANKED
629:               
630:                       		msd_csw.dCSWDataResidue=0;
  4CFA    0104     MOVLB 0x4
  4CFC    6B77     CLRF 0x77, BANKED
  4CFE    6B78     CLRF 0x78, BANKED
  4D00    6B79     CLRF 0x79, BANKED
  4D02    6B7A     CLRF 0x7a, BANKED
631:                           }
632:                           break;
  4D04    D013     BRA 0x4d2c
633:                       case MSD_COMMAND_ERROR:
634:               		default:
635:                       	ResetSenseData();
  4D06    DAB4     RCALL 0x5270
636:               			gblSenseData[LUN_INDEX].SenseKey=S_ILLEGAL_REQUEST;
  4D08    0104     MOVLB 0x4
  4D0A    81A2     BSF 0xa2, 0, BANKED
  4D0C    93A2     BCF 0xa2, 0x1, BANKED
  4D0E    85A2     BSF 0xa2, 0x2, BANKED
  4D10    97A2     BCF 0xa2, 0x3, BANKED
637:               			gblSenseData[LUN_INDEX].ASC=ASC_INVALID_COMMAND_OPCODE;
  4D12    0E20     MOVLW 0x20
  4D14    6FAC     MOVWF 0xac, BANKED
638:               			gblSenseData[LUN_INDEX].ASCQ=ASCQ_INVALID_COMMAND_OPCODE;
  4D16    6BAD     CLRF 0xad, BANKED
639:               			msd_csw.bCSWStatus=0x01;
  4D18    0104     MOVLB 0x4
  4D1A    0E01     MOVLW 0x1
  4D1C    6F7B     MOVWF 0x7b, BANKED
640:               			msd_csw.dCSWDataResidue=0x00;
  4D1E    6B77     CLRF 0x77, BANKED
  4D20    6B78     CLRF 0x78, BANKED
  4D22    6B79     CLRF 0x79, BANKED
  4D24    6B7A     CLRF 0x7a, BANKED
641:               			MSDCommandState = MSD_COMMAND_RESPONSE;
  4D26    0105     MOVLB 0x5
  4D28    0EFD     MOVLW 0xfd
  4D2A    6FFD     MOVWF 0xfd, BANKED
642:                		    break;
643:               	} // end switch	
644:               }
  4D2C    0E09     MOVLW 0x9
  4D2E    5CE1     SUBWF 0xfe1, W, ACCESS
  4D30    E202     BC 0x4d36
  4D32    6AE1     CLRF 0xfe1, ACCESS
  4D34    52E5     MOVF 0xfe5, F, ACCESS
  4D36    6EE1     MOVWF 0xfe1, ACCESS
  4D38    52E5     MOVF 0xfe5, F, ACCESS
  4D3A    CFE7     MOVFF 0xfe7, 0xfd9
  4D3C    FFD9     NOP
  4D3E    0012     RETURN 0
645:               
646:               /******************************************************************************
647:                	Function:
648:                		void MSDProcessCommandMediaAbsent(void)
649:                		
650:                	Description:
651:                		This funtion processes a command received through the MSD
652:                		class driver
653:                		
654:                	PreCondition:
655:                		None
656:                		
657:                	Parameters:
658:                		None
659:                	
660:                	Return Values:
661:                		BYTE - the current state of the MSDProcessCommand state
662:                		machine.  The valid values are defined in MSD.h under the 
663:                		MSDProcessCommand state machine declaration section
664:                		
665:                	Remarks:
666:                		None
667:                
668:                 *****************************************************************************/	
669:               void MSDProcessCommandMediaAbsent(void)
  4D40    CFD9     MOVFF 0xfd9, 0xfe6
  4D42    FFE6     NOP
  4D44    CFE1     MOVFF 0xfe1, 0xfd9
  4D46    FFD9     NOP
  4D48    52E6     MOVF 0xfe6, F, ACCESS
670:               {
671:                   BYTE i;
672:               
673:                   switch(MSDCommandState)
  4D4A    0105     MOVLB 0x5
  4D4C    51FD     MOVF 0xfd, W, BANKED
  4D4E    0AFD     XORLW 0xfd
  4D50    E055     BZ 0x4dfc
  4D52    0A02     XORLW 0x2
  4D54    E050     BZ 0x4df6
  4D56    0AED     XORLW 0xed
  4D58    E030     BZ 0x4dba
  4D5A    0A0C     XORLW 0xc
  4D5C    E101     BNZ 0x4d60
  4D5E    D080     BRA 0x4e60
  4D60    0A1E     XORLW 0x1e
  4D62    E101     BNZ 0x4d66
  4D64    D07D     BRA 0x4e60
  4D66    0A03     XORLW 0x3
  4D68    E174     BNZ 0x4e52
674:                   {
675:                       case MSD_REQUEST_SENSE:
676:                       {
677:                           ResetSenseData();
  4D6A    DA82     RCALL 0x5270
678:                           gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
  4D6C    0104     MOVLB 0x4
  4D6E    91A2     BCF 0xa2, 0, BANKED
  4D70    83A2     BSF 0xa2, 0x1, BANKED
  4D72    95A2     BCF 0xa2, 0x2, BANKED
  4D74    97A2     BCF 0xa2, 0x3, BANKED
679:                   		gblSenseData[LUN_INDEX].ASC=ASC_MEDIUM_NOT_PRESENT;
  4D76    0E3A     MOVLW 0x3a
  4D78    6FAC     MOVWF 0xac, BANKED
680:                   		gblSenseData[LUN_INDEX].ASCQ=ASCQ_MEDIUM_NOT_PRESENT;
  4D7A    6BAD     CLRF 0xad, BANKED
681:               
682:                         	for(i=0;i<sizeof(RequestSenseResponse);i++)
  4D7C    6ADF     CLRF 0xfdf, ACCESS
  4D7E    50DF     MOVF 0xfdf, W, ACCESS
  4D80    6E14     MOVWF 0x14, ACCESS
  4D82    6A15     CLRF 0x15, ACCESS
  4D84    0E12     MOVLW 0x12
  4D86    5C14     SUBWF 0x14, W, ACCESS
  4D88    0E00     MOVLW 0
  4D8A    5815     SUBWFB 0x15, W, ACCESS
  4D8C    E213     BC 0x4db4
  4DB0    2ADF     INCF 0xfdf, F, ACCESS
  4DB2    D7E5     BRA 0x4d7e
683:                         	{
684:                         		msd_buffer[i]=gblSenseData[LUN_INDEX]._byte[i];
  4D8E    50DF     MOVF 0xfdf, W, ACCESS
  4D90    6AEA     CLRF 0xfea, ACCESS
  4D92    0FA0     ADDLW 0xa0
  4D94    6EE9     MOVWF 0xfe9, ACCESS
  4D96    0E04     MOVLW 0x4
  4D98    22EA     ADDWFC 0xfea, F, ACCESS
  4D9A    50EF     MOVF 0xfef, W, ACCESS
  4D9C    6EE6     MOVWF 0xfe6, ACCESS
  4D9E    50DF     MOVF 0xfdf, W, ACCESS
  4DA0    6AEA     CLRF 0xfea, ACCESS
  4DA2    0F00     ADDLW 0
  4DA4    6EE9     MOVWF 0xfe9, ACCESS
  4DA6    0E06     MOVLW 0x6
  4DA8    22EA     ADDWFC 0xfea, F, ACCESS
  4DAA    52E5     MOVF 0xfe5, F, ACCESS
  4DAC    50E7     MOVF 0xfe7, W, ACCESS
  4DAE    6EEF     MOVWF 0xfef, ACCESS
685:                           }
686:                         	
687:                           msd_csw.dCSWDataResidue=sizeof(RequestSenseResponse);
  4DB4    0104     MOVLB 0x4
  4DB6    0E12     MOVLW 0x12
688:                         	msd_csw.bCSWStatus=0x0;					// success
689:                         	MSDCommandState = MSD_COMMAND_RESPONSE;
690:                           break;
  4DB8    D015     BRA 0x4de4
691:                       } 
692:                       case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
693:                       case MSD_TEST_UNIT_READY:
694:                       {
695:                   		msd_csw.bCSWStatus=0x01;
696:                           MSDCommandState = MSD_COMMAND_WAIT;
697:                           break;
698:                       }
699:                       case MSD_INQUIRY:
700:                       {
701:                       	memcpypgm2ram(
702:                       	    (void *)&msd_buffer[0],
  4DCC    0E00     MOVLW 0
  4DCE    6EE6     MOVWF 0xfe6, ACCESS
  4DD0    0E06     MOVLW 0x6
  4DD2    6EE6     MOVWF 0xfe6, ACCESS
703:                       	    (ROM void*)&inq_resp,
  4DC0    0ED8     MOVLW 0xd8
  4DC2    6EE6     MOVWF 0xfe6, ACCESS
  4DC4    0E66     MOVLW 0x66
  4DC6    6EE6     MOVWF 0xfe6, ACCESS
  4DC8    0E00     MOVLW 0
  4DCA    6EE6     MOVWF 0xfe6, ACCESS
704:                       	    sizeof(InquiryResponse)
  4DBA    0E24     MOVLW 0x24
705:                       	    );
  4DBC    6EE6     MOVWF 0xfe6, ACCESS
  4DBE    6AE6     CLRF 0xfe6, ACCESS
  4DD4    EC65     CALL 0x62ca, 0
  4DD6    F031     NOP
  4DD8    6E14     MOVWF 0x14, ACCESS
  4DDA    0E07     MOVLW 0x7
  4DDC    5EE1     SUBWF 0xfe1, F, ACCESS
  4DDE    5014     MOVF 0x14, W, ACCESS
706:                       	msd_csw.dCSWDataResidue=sizeof(InquiryResponse);
  4DE0    0104     MOVLB 0x4
  4DE2    0E24     MOVLW 0x24
  4DE4    6F77     MOVWF 0x77, BANKED
  4DE6    6B78     CLRF 0x78, BANKED
  4DE8    6B79     CLRF 0x79, BANKED
  4DEA    6B7A     CLRF 0x7a, BANKED
707:                       	msd_csw.bCSWStatus=0x00;			// success
  4DEC    6B7B     CLRF 0x7b, BANKED
708:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
  4DEE    0105     MOVLB 0x5
  4DF0    0EFD     MOVLW 0xfd
  4DF2    6FFD     MOVWF 0xfd, BANKED
709:                           break;
  4DF4    D03A     BRA 0x4e6a
710:                       }
711:                       case MSD_COMMAND_WAIT:
712:                       {
713:                           MSDCommandState = gblCBW.CBWCB[0];
  4DF6    C48F     MOVFF 0x48f, 0x5fd
  4DF8    F5FD     NOP
714:                           break;
  4DFA    D037     BRA 0x4e6a
715:                       }
716:                       case MSD_COMMAND_RESPONSE:
717:                           if(USBHandleBusy(USBMSDInHandle) == FALSE)
  4DFC    0104     MOVLB 0x4
  4DFE    51B6     MOVF 0xb6, W, BANKED
  4E00    11B7     IORWF 0xb7, W, BANKED
  4E02    E102     BNZ 0x4e08
  4E04    0E00     MOVLW 0
  4E06    D008     BRA 0x4e18
  4E08    C4B6     MOVFF 0x4b6, 0xfe9
  4E0A    FFE9     NOP
  4E0C    C4B7     MOVFF 0x4b7, 0xfea
  4E0E    FFEA     NOP
  4E10    50EF     MOVF 0xfef, W, ACCESS
  4E12    0B80     ANDLW 0x80
  4E14    E001     BZ 0x4e18
  4E16    0E01     MOVLW 0x1
  4E18    0900     IORLW 0
  4E1A    E127     BNZ 0x4e6a
718:                           {
719:                               USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(BYTE*)&msd_buffer[0],msd_csw.dCSWDataResidue);
  4E1C    C477     MOVFF 0x477, 0xfe6
  4E1E    FFE6     NOP
  4E20    0E00     MOVLW 0
  4E22    6EE6     MOVWF 0xfe6, ACCESS
  4E24    0E06     MOVLW 0x6
  4E26    6EE6     MOVWF 0xfe6, ACCESS
  4E28    0E01     MOVLW 0x1
  4E2A    6EE6     MOVWF 0xfe6, ACCESS
  4E2C    6EE6     MOVWF 0xfe6, ACCESS
  4E2E    ECFE     CALL 0x39fc, 0
  4E30    F01C     NOP
  4E32    6E14     MOVWF 0x14, ACCESS
  4E34    0E05     MOVLW 0x5
  4E36    5EE1     SUBWF 0xfe1, F, ACCESS
  4E38    5014     MOVF 0x14, W, ACCESS
  4E3A    CFF3     MOVFF 0xff3, 0x4b6
  4E3C    F4B6     NOP
  4E3E    CFF4     MOVFF 0xff4, 0x4b7
  4E40    F4B7     NOP
720:               			    MSDCommandState = MSD_COMMAND_WAIT;
  4E42    0105     MOVLB 0x5
  4E44    69FD     SETF 0xfd, BANKED
721:               
722:                       		msd_csw.dCSWDataResidue=0;
  4E46    0104     MOVLB 0x4
  4E48    6B77     CLRF 0x77, BANKED
  4E4A    6B78     CLRF 0x78, BANKED
  4E4C    6B79     CLRF 0x79, BANKED
  4E4E    6B7A     CLRF 0x7a, BANKED
723:                           }
724:                           break;
  4E50    D00C     BRA 0x4e6a
725:                       default:
726:                       {
727:                           //Stall MSD endpoint IN
728:                           USBStallEndpoint(MSD_DATA_IN_EP,1);
  4E52    0E01     MOVLW 0x1
  4E54    6EE6     MOVWF 0xfe6, ACCESS
  4E56    6EE6     MOVWF 0xfe6, ACCESS
  4E58    EC90     CALL 0x3920, 0
  4E5A    F01C     NOP
  4E5C    52E5     MOVF 0xfe5, F, ACCESS
  4E5E    52E5     MOVF 0xfe5, F, ACCESS
729:                   		msd_csw.bCSWStatus=0x01;
  4E60    0104     MOVLB 0x4
  4E62    0E01     MOVLW 0x1
  4E64    6F7B     MOVWF 0x7b, BANKED
730:                           MSDCommandState = MSD_COMMAND_WAIT;
  4E66    0105     MOVLB 0x5
  4E68    69FD     SETF 0xfd, BANKED
731:                           break;
732:                       }
733:                   }
734:               }
  4E6A    52E5     MOVF 0xfe5, F, ACCESS
  4E6C    52E5     MOVF 0xfe5, F, ACCESS
  4E6E    CFE7     MOVFF 0xfe7, 0xfd9
  4E70    FFD9     NOP
  4E72    0012     RETURN 0
735:               
736:               /******************************************************************************
737:                	Function:
738:                		BYTE MSDProcessCommand(void)
739:                		
740:                	Description:
741:                		This funtion processes a command received through the MSD
742:                		class driver
743:                		
744:                	PreCondition:
745:                		None
746:                		
747:                	Paramters:
748:                		None
749:                		
750:                	Return Values:
751:                		BYTE - the current state of the MSDProcessCommand state
752:                		machine.  The valid values are defined in MSD.h under the
753:                		MSDProcessCommand state machine declaration section
754:                		
755:                	Remarks:
756:                		None
757:                
758:                *****************************************************************************/	
759:               BYTE MSDProcessCommand(void)
760:               {   
761:                 	if(LUNMediaDetect() == FALSE || SoftDetach[gblCBW.bCBWLUN] == TRUE)
  4E74    EC1C     CALL 0x1038, 0
  4E76    F008     NOP
  4E78    0900     IORLW 0
  4E7A    E009     BZ 0x4e8e
  4E7C    0104     MOVLB 0x4
  4E7E    518D     MOVF 0x8d, W, BANKED
  4E80    6AEA     CLRF 0xfea, ACCESS
  4E82    0FBC     ADDLW 0xbc
  4E84    6EE9     MOVWF 0xfe9, ACCESS
  4E86    0E04     MOVLW 0x4
  4E88    22EA     ADDWFC 0xfea, F, ACCESS
  4E8A    04EF     DECF 0xfef, W, ACCESS
  4E8C    E110     BNZ 0x4eae
762:                   {
763:                       gblMediaPresent &= ~((WORD)1<<gblCBW.bCBWLUN);
  4E8E    0104     MOVLB 0x4
  4E90    518D     MOVF 0x8d, W, BANKED
  4E92    ECAA     CALL 0x6754, 0
  4E94    F033     NOP
  4E96    CFF3     MOVFF 0xff3, 0x14
  4E98    F014     NOP
  4E9A    CFF4     MOVFF 0xff4, 0x15
  4E9C    F015     NOP
  4E9E    1E14     COMF 0x14, F, ACCESS
  4EA0    1E15     COMF 0x15, F, ACCESS
  4EA2    5014     MOVF 0x14, W, ACCESS
  4EA4    0104     MOVLB 0x4
  4EA6    17BA     ANDWF 0xba, F, BANKED
  4EA8    5015     MOVF 0x15, W, ACCESS
  4EAA    17BB     ANDWF 0xbb, F, BANKED
764:               
765:                       MSDProcessCommandMediaAbsent();
766:                  	}
767:                   else
  4EAC    D02A     BRA 0x4f02
768:                   {
769:                       if((gblMediaPresent & ((WORD)1<<gblCBW.bCBWLUN)) == 0)
  4EAE    518D     MOVF 0x8d, W, BANKED
  4EB0    ECAA     CALL 0x6754, 0
  4EB2    F033     NOP
  4EB4    0104     MOVLB 0x4
  4EB6    51BA     MOVF 0xba, W, BANKED
  4EB8    14F3     ANDWF 0xff3, W, ACCESS
  4EBA    6E14     MOVWF 0x14, ACCESS
  4EBC    51BB     MOVF 0xbb, W, BANKED
  4EBE    14F4     ANDWF 0xff4, W, ACCESS
  4EC0    6E15     MOVWF 0x15, ACCESS
  4EC2    5014     MOVF 0x14, W, ACCESS
  4EC4    1015     IORWF 0x15, W, ACCESS
  4EC6    E11F     BNZ 0x4f06
770:                       {
771:                           if(LUNMediaInitialize())
  4EC8    ECEC     CALL 0x21d8, 0
  4ECA    F010     NOP
  4ECC    CFF3     MOVFF 0xff3, 0x14
  4ECE    F014     NOP
  4ED0    CFF4     MOVFF 0xff4, 0x15
  4ED2    F015     NOP
  4ED4    50F3     MOVF 0xff3, W, ACCESS
  4ED6    10F4     IORWF 0xff4, W, ACCESS
  4ED8    E014     BZ 0x4f02
772:                           {
773:                               gblMediaPresent |= ((WORD)1<<gblCBW.bCBWLUN);
  4EDA    0104     MOVLB 0x4
  4EDC    518D     MOVF 0x8d, W, BANKED
  4EDE    ECAA     CALL 0x6754, 0
  4EE0    F033     NOP
  4EE2    50F3     MOVF 0xff3, W, ACCESS
  4EE4    0104     MOVLB 0x4
  4EE6    13BA     IORWF 0xba, F, BANKED
  4EE8    50F4     MOVF 0xff4, W, ACCESS
  4EEA    13BB     IORWF 0xbb, F, BANKED
774:               
775:                       		gblSenseData[LUN_INDEX].SenseKey=S_UNIT_ATTENTION;
  4EEC    91A2     BCF 0xa2, 0, BANKED
  4EEE    83A2     BSF 0xa2, 0x1, BANKED
  4EF0    85A2     BSF 0xa2, 0x2, BANKED
  4EF2    97A2     BCF 0xa2, 0x3, BANKED
776:                       		gblSenseData[LUN_INDEX].ASC=0x28;
  4EF4    0E28     MOVLW 0x28
  4EF6    6FAC     MOVWF 0xac, BANKED
777:                       		gblSenseData[LUN_INDEX].ASCQ=0x00;
  4EF8    6BAD     CLRF 0xad, BANKED
778:                               msd_csw.bCSWStatus=0x01;
  4EFA    0104     MOVLB 0x4
  4EFC    0E01     MOVLW 0x1
  4EFE    6F7B     MOVWF 0x7b, BANKED
779:               
780:                               MSDProcessCommandMediaPresent();
781:                           }
782:                           else
  4F00    D002     BRA 0x4f06
783:                           {
784:                               MSDProcessCommandMediaAbsent();
  4F02    DF1E     RCALL 0x4d40
785:                           }
786:                       }
787:                       else
  4F04    D001     BRA 0x4f08
788:                       {
789:                           MSDProcessCommandMediaPresent();
  4F06    DDFD     RCALL 0x4b02
790:                       }
791:                   }
792:               
793:                   return MSDCommandState;
  4F08    0105     MOVLB 0x5
  4F0A    51FD     MOVF 0xfd, W, BANKED
794:               }
  4F0C    0012     RETURN 0
795:               
796:               /******************************************************************************
797:                	Function:
798:                		BYTE MSDReadHandler(void)
799:                		
800:                	Description:
801:                		This funtion processes a read command received through 
802:                		the MSD class driver
803:                		
804:                	PreCondition:
805:                		None
806:                		
807:                	Parameters:
808:                		None
809:                		
810:                	Return Values:
811:                		BYTE - the current state of the MSDReadHandler state
812:                		machine.  The valid values are defined in MSD.h under the 
813:                		MSDReadHandler state machine declaration section
814:                		
815:                	Remarks:
816:                		None
817:                
818:                 *****************************************************************************/
819:               
820:               BYTE MSDReadHandler(void)
821:               {
822:                   switch(MSDReadState)
  4F0E    0104     MOVLB 0x4
  4F10    517D     MOVF 0x7d, W, BANKED
  4F12    0A04     XORLW 0x4
  4F14    E101     BNZ 0x4f18
  4F16    D07B     BRA 0x500e
  4F18    0A07     XORLW 0x7
  4F1A    E06C     BZ 0x4ff4
  4F1C    0A01     XORLW 0x1
  4F1E    E023     BZ 0x4f66
  4F20    0A03     XORLW 0x3
  4F22    E018     BZ 0x4f54
  4F24    0A01     XORLW 0x1
  4F26    E001     BZ 0x4f2a
  4F28    D0AA     BRA 0x507e
823:                   {
824:                       case MSD_READ10_WAIT:
825:                       	LBA.v[3]=gblCBW.CBWCB[2];
  4F2A    C491     MOVFF 0x491, 0x4c2
  4F2C    F4C2     NOP
826:                       	LBA.v[2]=gblCBW.CBWCB[3];
  4F2E    C492     MOVFF 0x492, 0x4c1
  4F30    F4C1     NOP
827:                       	LBA.v[1]=gblCBW.CBWCB[4];
  4F32    C493     MOVFF 0x493, 0x4c0
  4F34    F4C0     NOP
828:                       	LBA.v[0]=gblCBW.CBWCB[5];
  4F36    C494     MOVFF 0x494, 0x4bf
  4F38    F4BF     NOP
829:                       	
830:                       	TransferLength.v[1]=gblCBW.CBWCB[7];
  4F3A    C496     MOVFF 0x496, 0x4be
  4F3C    F4BE     NOP
831:                       	TransferLength.v[0]=gblCBW.CBWCB[8];
  4F3E    C497     MOVFF 0x497, 0x4bd
  4F40    F4BD     NOP
832:               
833:                           //Assume success initially, msd_csw.bCSWStatus will get set to 0x01 
834:                           //or 0x02 later if an error is detected during the actual read sequence.        	
835:                       	msd_csw.bCSWStatus=0x0;
  4F42    0104     MOVLB 0x4
  4F44    6B7B     CLRF 0x7b, BANKED
836:                       	msd_csw.dCSWDataResidue=0x0;
  4F46    6B77     CLRF 0x77, BANKED
  4F48    6B78     CLRF 0x78, BANKED
  4F4A    6B79     CLRF 0x79, BANKED
  4F4C    6B7A     CLRF 0x7a, BANKED
837:                       	
838:                           MSDReadState = MSD_READ10_BLOCK;
  4F4E    0104     MOVLB 0x4
  4F50    0E01     MOVLW 0x1
  4F52    6F7D     MOVWF 0x7d, BANKED
839:                           //Fall through to MSD_READ_BLOCK
840:                       case MSD_READ10_BLOCK:
841:                           if(TransferLength.Val == 0)
  4F54    51BD     MOVF 0xbd, W, BANKED
  4F56    11BE     IORWF 0xbe, W, BANKED
  4F58    E101     BNZ 0x4f5c
  4F5A    D095     BRA 0x5086
842:                           {
843:                               MSDReadState = MSD_READ10_WAIT;
844:                               break;
845:                           }
846:                           
847:                           TransferLength.Val--;					// we have read 1 LBA
  4F5C    07BD     DECF 0xbd, F, BANKED
  4F5E    0E00     MOVLW 0
  4F60    5BBE     SUBWFB 0xbe, F, BANKED
848:                           MSDReadState = MSD_READ10_SECTOR;
  4F62    0E02     MOVLW 0x2
  4F64    6F7D     MOVWF 0x7d, BANKED
849:                           //Fall through to MSD_READ10_SECTOR
850:                       case MSD_READ10_SECTOR:
851:                           //if the old data isn't completely sent yet
852:                           if(USBHandleBusy(USBMSDInHandle) != 0)
  4F66    51B6     MOVF 0xb6, W, BANKED
  4F68    11B7     IORWF 0xb7, W, BANKED
  4F6A    E102     BNZ 0x4f70
  4F6C    0E00     MOVLW 0
  4F6E    D008     BRA 0x4f80
  4F70    C4B6     MOVFF 0x4b6, 0xfe9
  4F72    FFE9     NOP
  4F74    C4B7     MOVFF 0x4b7, 0xfea
  4F76    FFEA     NOP
  4F78    50EF     MOVF 0xfef, W, ACCESS
  4F7A    0B80     ANDLW 0x80
  4F7C    E001     BZ 0x4f80
  4F7E    0E01     MOVLW 0x1
  4F80    0900     IORLW 0
  4F82    E001     BZ 0x4f86
  4F84    D081     BRA 0x5088
853:                           {
854:                               break;
855:                           }
856:                           
857:                           //Try to read a sector worth of data from the media, but check for
858:                           //possible errors.
859:                   		if(LUNSectorRead(LBA.Val, (BYTE*)&msd_buffer[0]) != TRUE)
  4F86    0E00     MOVLW 0
  4F88    6EE6     MOVWF 0xfe6, ACCESS
  4F8A    0E06     MOVLW 0x6
  4F8C    6EE6     MOVWF 0xfe6, ACCESS
  4F8E    C4BF     MOVFF 0x4bf, 0xfe6
  4F90    FFE6     NOP
  4F92    C4C0     MOVFF 0x4c0, 0xfe6
  4F94    FFE6     NOP
  4F96    C4C1     MOVFF 0x4c1, 0xfe6
  4F98    FFE6     NOP
  4F9A    C4C2     MOVFF 0x4c2, 0xfe6
  4F9C    FFE6     NOP
  4F9E    EC84     CALL 0x1b08, 0
  4FA0    F00D     NOP
  4FA2    6E14     MOVWF 0x14, ACCESS
  4FA4    0E06     MOVLW 0x6
  4FA6    5EE1     SUBWF 0xfe1, F, ACCESS
  4FA8    5014     MOVF 0x14, W, ACCESS
  4FAA    0801     SUBLW 0x1
  4FAC    E010     BZ 0x4fce
860:                   		{
861:               				if(MSDRetryAttempt < MSD_FAILED_READ_MAX_ATTEMPTS)
  4FAE    0E64     MOVLW 0x64
  4FB0    0104     MOVLB 0x4
  4FB2    5D7F     SUBWF 0x7f, W, BANKED
  4FB4    E202     BC 0x4fba
862:               				{
863:               				    MSDRetryAttempt++;
  4FB6    2B7F     INCF 0x7f, F, BANKED
864:                                   break;
  4FB8    D067     BRA 0x5088
865:               				}
866:               				else
867:               				{  
868:                   				//Too many consecutive failed reads have occurred.  Need to
869:                   				//give up and abandon the sector read attempt; something must
870:                   				//be wrong and we don't want to get stuck in an infinite loop.
871:                   				//Need to indicate to the host that a device error occurred.
872:                   				//However, we can't send the CSW immediately, since the host
873:                   				//still expects to receive sector read data on the IN endpoint 
874:                   				//first.  Therefore, we still send dummy bytes, before
875:                   				//we send the CSW with the failed status in it.
876:                   				msd_csw.bCSWStatus=0x01;		// Error 0x01 Refer page#18
  4FBA    0104     MOVLB 0x4
  4FBC    0E01     MOVLW 0x1
  4FBE    6F7B     MOVWF 0x7b, BANKED
877:                                                                   // of BOT specifications
878:                                   //Set error status sense keys, so the host can check them later
879:                                   //to determine how to proceed.
880:                                   gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
  4FC0    0104     MOVLB 0x4
  4FC2    81A2     BSF 0xa2, 0, BANKED
  4FC4    83A2     BSF 0xa2, 0x1, BANKED
  4FC6    95A2     BCF 0xa2, 0x2, BANKED
  4FC8    97A2     BCF 0xa2, 0x3, BANKED
881:               			        gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
  4FCA    6BAC     CLRF 0xac, BANKED
882:               			        gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
  4FCC    6BAD     CLRF 0xad, BANKED
883:                               }
884:                           }//else we successfully read a sector worth of data from our media
885:               
886:                           LBA.Val++;
  4FCE    0104     MOVLB 0x4
  4FD0    2BBF     INCF 0xbf, F, BANKED
  4FD2    0E00     MOVLW 0
  4FD4    23C0     ADDWFC 0xc0, F, BANKED
  4FD6    23C1     ADDWFC 0xc1, F, BANKED
  4FD8    23C2     ADDWFC 0xc2, F, BANKED
887:               			msd_csw.dCSWDataResidue=BLOCKLEN_512;//in order to send the
  4FDA    0104     MOVLB 0x4
  4FDC    6B77     CLRF 0x77, BANKED
  4FDE    0E02     MOVLW 0x2
  4FE0    6F78     MOVWF 0x78, BANKED
  4FE2    6B79     CLRF 0x79, BANKED
  4FE4    6B7A     CLRF 0x7a, BANKED
888:                                                                //512 bytes of data read
889:                                                                
890:                           ptrNextData=(BYTE *)&msd_buffer[0];
  4FE6    0104     MOVLB 0x4
  4FE8    0E00     MOVLW 0
  4FEA    6FB2     MOVWF 0xb2, BANKED
  4FEC    0E06     MOVLW 0x6
  4FEE    6FB3     MOVWF 0xb3, BANKED
891:                           
892:                           MSDReadState = MSD_READ10_TX_SECTOR;
  4FF0    0E03     MOVLW 0x3
  4FF2    6F7D     MOVWF 0x7d, BANKED
893:                   
894:                           //Fall through to MSD_READ10_TX_SECTOR
895:                       case MSD_READ10_TX_SECTOR:
896:                           if(msd_csw.dCSWDataResidue == 0)
  4FF4    0104     MOVLB 0x4
  4FF6    5177     MOVF 0x77, W, BANKED
  4FF8    1178     IORWF 0x78, W, BANKED
  4FFA    1179     IORWF 0x79, W, BANKED
  4FFC    117A     IORWF 0x7a, W, BANKED
  4FFE    E104     BNZ 0x5008
897:                           {
898:                               MSDReadState = MSD_READ10_BLOCK;
  5000    0104     MOVLB 0x4
  5002    0E01     MOVLW 0x1
  5004    6F7D     MOVWF 0x7d, BANKED
899:                               break;
  5006    D040     BRA 0x5088
900:                           }
901:                           
902:                           MSDReadState = MSD_READ10_TX_PACKET;
  5008    0104     MOVLB 0x4
  500A    0E04     MOVLW 0x4
  500C    6F7D     MOVWF 0x7d, BANKED
903:                           //Fall through to MSD_READ10_TX_PACKET
904:                           
905:                       case MSD_READ10_TX_PACKET:
906:                   		/* Write next chunk of data to EP Buffer and send */
907:                           
908:                           //Make sure the endpoint is available before using it.
909:                           if(USBHandleBusy(USBMSDInHandle))
  500E    51B6     MOVF 0xb6, W, BANKED
  5010    11B7     IORWF 0xb7, W, BANKED
  5012    E102     BNZ 0x5018
  5014    0E00     MOVLW 0
  5016    D008     BRA 0x5028
  5018    C4B6     MOVFF 0x4b6, 0xfe9
  501A    FFE9     NOP
  501C    C4B7     MOVFF 0x4b7, 0xfea
  501E    FFEA     NOP
  5020    50EF     MOVF 0xfef, W, ACCESS
  5022    0B80     ANDLW 0x80
  5024    E001     BZ 0x5028
  5026    0E01     MOVLW 0x1
  5028    0900     IORLW 0
  502A    E12E     BNZ 0x5088
910:                           {
911:                               break;
912:                           }
913:                           //Prepare the USB module to send an IN transaction worth of data to the host.
914:                           USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,ptrNextData,MSD_IN_EP_SIZE);
  502C    0E40     MOVLW 0x40
  502E    6EE6     MOVWF 0xfe6, ACCESS
  5030    C4B2     MOVFF 0x4b2, 0xfe6
  5032    FFE6     NOP
  5034    C4B3     MOVFF 0x4b3, 0xfe6
  5036    FFE6     NOP
  5038    0E01     MOVLW 0x1
  503A    6EE6     MOVWF 0xfe6, ACCESS
  503C    6EE6     MOVWF 0xfe6, ACCESS
  503E    ECFE     CALL 0x39fc, 0
  5040    F01C     NOP
  5042    6E14     MOVWF 0x14, ACCESS
  5044    0E05     MOVLW 0x5
  5046    5EE1     SUBWF 0xfe1, F, ACCESS
  5048    5014     MOVF 0x14, W, ACCESS
  504A    CFF3     MOVFF 0xff3, 0x4b6
  504C    F4B6     NOP
  504E    CFF4     MOVFF 0xff4, 0x4b7
  5050    F4B7     NOP
915:                           
916:                			MSDReadState = MSD_READ10_TX_SECTOR;
  5052    0104     MOVLB 0x4
  5054    0E03     MOVLW 0x3
  5056    6F7D     MOVWF 0x7d, BANKED
917:               
918:                   		gblCBW.dCBWDataTransferLength-=	MSD_IN_EP_SIZE;
  5058    0E40     MOVLW 0x40
  505A    5F88     SUBWF 0x88, F, BANKED
  505C    0E00     MOVLW 0
  505E    5B89     SUBWFB 0x89, F, BANKED
  5060    5B8A     SUBWFB 0x8a, F, BANKED
  5062    5B8B     SUBWFB 0x8b, F, BANKED
919:                   		msd_csw.dCSWDataResidue-=MSD_IN_EP_SIZE;
  5064    0E40     MOVLW 0x40
  5066    0104     MOVLB 0x4
  5068    5F77     SUBWF 0x77, F, BANKED
  506A    0E00     MOVLW 0
  506C    5B78     SUBWFB 0x78, F, BANKED
  506E    5B79     SUBWFB 0x79, F, BANKED
  5070    5B7A     SUBWFB 0x7a, F, BANKED
920:                   		ptrNextData+=MSD_IN_EP_SIZE;
  5072    0E40     MOVLW 0x40
  5074    0104     MOVLB 0x4
  5076    27B2     ADDWF 0xb2, F, BANKED
  5078    0E00     MOVLW 0
  507A    23B3     ADDWFC 0xb3, F, BANKED
921:                           break;
  507C    D005     BRA 0x5088
922:                       
923:                       default:
924:                           //Illegal condition, should never occur.  In the event that it ever
925:                           //did occur anyway, try to notify the host of the error.
926:                           msd_csw.bCSWStatus=0x02;  //indicate "Phase Error"
  507E    0104     MOVLB 0x4
  5080    0E02     MOVLW 0x2
  5082    6F7B     MOVWF 0x7b, BANKED
927:                           //Advance state machine
928:                           MSDReadState = MSD_READ10_WAIT;
  5084    0104     MOVLB 0x4
  5086    6B7D     CLRF 0x7d, BANKED
929:                   }
930:                   
931:                   return MSDReadState;
  5088    517D     MOVF 0x7d, W, BANKED
932:               }
  508A    0012     RETURN 0
933:               
934:               
935:               /******************************************************************************
936:                	Function:
937:                		BYTE MSDWriteHandler(void)
938:                		
939:                	Description:
940:                		This funtion processes a write command received through 
941:                		the MSD class driver
942:                		
943:                	PreCondition:
944:                		None
945:                		
946:                	Parameters:
947:                		None
948:                		
949:                	Return Values:
950:                		BYTE - the current state of the MSDWriteHandler state
951:                		machine.  The valid values are defined in MSD.h under the 
952:                		MSDWriteHandler state machine declaration section
953:                		
954:                	Remarks:
955:                		None
956:                
957:                *****************************************************************************/
958:               BYTE MSDWriteHandler(void)
959:               {
960:                   switch(MSDWriteState)
  508C    0104     MOVLB 0x4
  508E    517E     MOVF 0x7e, W, BANKED
  5090    0A02     XORLW 0x2
  5092    E101     BNZ 0x5096
  5094    D0AA     BRA 0x51ea
  5096    0A06     XORLW 0x6
  5098    E06D     BZ 0x5174
  509A    0A07     XORLW 0x7
  509C    E026     BZ 0x50ea
  509E    0A02     XORLW 0x2
  50A0    E014     BZ 0x50ca
  50A2    0A01     XORLW 0x1
  50A4    E001     BZ 0x50a8
  50A6    D0DD     BRA 0x5262
961:                   {
962:                       case MSD_WRITE10_WAIT:
963:                        	/* Read the LBA, TransferLength fields from Command Block
964:                              NOTE: CB is Big-Endian */
965:                       
966:                       	LBA.v[3]=gblCBW.CBWCB[2];
  50A8    C491     MOVFF 0x491, 0x4c2
  50AA    F4C2     NOP
967:                       	LBA.v[2]=gblCBW.CBWCB[3];
  50AC    C492     MOVFF 0x492, 0x4c1
  50AE    F4C1     NOP
968:                       	LBA.v[1]=gblCBW.CBWCB[4];
  50B0    C493     MOVFF 0x493, 0x4c0
  50B2    F4C0     NOP
969:                       	LBA.v[0]=gblCBW.CBWCB[5];
  50B4    C494     MOVFF 0x494, 0x4bf
  50B6    F4BF     NOP
970:                       	TransferLength.v[1]=gblCBW.CBWCB[7];
  50B8    C496     MOVFF 0x496, 0x4be
  50BA    F4BE     NOP
971:                       	TransferLength.v[0]=gblCBW.CBWCB[8];
  50BC    C497     MOVFF 0x497, 0x4bd
  50BE    F4BD     NOP
972:                       
973:                       	//Initially assume success, unless handler code later encounters an
974:                       	//error condition and sets the status to 0x01 or 0x02.
975:                       	msd_csw.bCSWStatus=0x0;	
  50C0    0104     MOVLB 0x4
  50C2    6B7B     CLRF 0x7b, BANKED
976:                       	
977:                       	MSD_State = MSD_WRITE10_BLOCK;
  50C4    0104     MOVLB 0x4
  50C6    0E01     MOVLW 0x1
  50C8    6F7C     MOVWF 0x7c, BANKED
978:                       	//Fall through to MSD_WRITE10_BLOCK
979:                       case MSD_WRITE10_BLOCK:
980:                           if(TransferLength.Val == 0)
  50CA    51BD     MOVF 0xbd, W, BANKED
  50CC    11BE     IORWF 0xbe, W, BANKED
  50CE    E101     BNZ 0x50d2
  50D0    D0CC     BRA 0x526a
981:                           {
982:                               MSDWriteState = MSD_WRITE10_WAIT;
983:                               break;
984:                           }
985:                           
986:                           MSDWriteState = MSD_WRITE10_RX_SECTOR;
  50D2    0E03     MOVLW 0x3
  50D4    6F7E     MOVWF 0x7e, BANKED
987:                           ptrNextData=(BYTE *)&msd_buffer[0];
  50D6    0E00     MOVLW 0
  50D8    6FB2     MOVWF 0xb2, BANKED
  50DA    0E06     MOVLW 0x6
  50DC    6FB3     MOVWF 0xb3, BANKED
988:                             
989:                       	msd_csw.dCSWDataResidue=BLOCKLEN_512;
  50DE    0104     MOVLB 0x4
  50E0    6B77     CLRF 0x77, BANKED
  50E2    0E02     MOVLW 0x2
  50E4    6F78     MOVWF 0x78, BANKED
  50E6    6B79     CLRF 0x79, BANKED
  50E8    6B7A     CLRF 0x7a, BANKED
990:                       	
991:                           //Fall through to MSD_WRITE10_RX_SECTOR
992:                       case MSD_WRITE10_RX_SECTOR:
993:                       {
994:                     		/* Read 512B into msd_buffer*/
995:                     		if(msd_csw.dCSWDataResidue>0) 
  50EA    80D8     BSF 0xfd8, 0, ACCESS
  50EC    0E00     MOVLW 0
  50EE    0104     MOVLB 0x4
  50F0    5577     SUBFWB 0x77, W, BANKED
  50F2    0E00     MOVLW 0
  50F4    5578     SUBFWB 0x78, W, BANKED
  50F6    0E00     MOVLW 0
  50F8    5579     SUBFWB 0x79, W, BANKED
  50FA    0E00     MOVLW 0
  50FC    557A     SUBFWB 0x7a, W, BANKED
  50FE    E228     BC 0x5150
996:                     		{
997:                               if(USBHandleBusy(USBMSDOutHandle) == TRUE)
  5100    0104     MOVLB 0x4
  5102    51B4     MOVF 0xb4, W, BANKED
  5104    11B5     IORWF 0xb5, W, BANKED
  5106    E102     BNZ 0x510c
  5108    0E00     MOVLW 0
  510A    D008     BRA 0x511c
  510C    C4B4     MOVFF 0x4b4, 0xfe9
  510E    FFE9     NOP
  5110    C4B5     MOVFF 0x4b5, 0xfea
  5112    FFEA     NOP
  5114    50EF     MOVF 0xfef, W, ACCESS
  5116    0B80     ANDLW 0x80
  5118    E001     BZ 0x511c
  511A    0E01     MOVLW 0x1
  511C    0900     IORLW 0
  511E    E001     BZ 0x5122
  5120    D0A5     BRA 0x526c
998:                               {
999:                                   break;
1000:                              }
1001:              
1002:                              USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,ptrNextData,MSD_OUT_EP_SIZE);
  5122    0E40     MOVLW 0x40
  5124    6EE6     MOVWF 0xfe6, ACCESS
  5126    C4B2     MOVFF 0x4b2, 0xfe6
  5128    FFE6     NOP
  512A    C4B3     MOVFF 0x4b3, 0xfe6
  512C    FFE6     NOP
  512E    6AE6     CLRF 0xfe6, ACCESS
  5130    0E01     MOVLW 0x1
  5132    6EE6     MOVWF 0xfe6, ACCESS
  5134    ECFE     CALL 0x39fc, 0
  5136    F01C     NOP
  5138    6E14     MOVWF 0x14, ACCESS
  513A    0E05     MOVLW 0x5
  513C    5EE1     SUBWF 0xfe1, F, ACCESS
  513E    5014     MOVF 0x14, W, ACCESS
  5140    CFF3     MOVFF 0xff3, 0x4b4
  5142    F4B4     NOP
  5144    CFF4     MOVFF 0xff4, 0x4b5
  5146    F4B5     NOP
1003:                              MSDWriteState = MSD_WRITE10_RX_PACKET;
  5148    0104     MOVLB 0x4
  514A    0E04     MOVLW 0x4
  514C    6F7E     MOVWF 0x7e, BANKED
1004:                              //Fall through to MSD_WRITE10_RX_PACKET
1005:                    	    }
1006:                    	    else
  514E    D012     BRA 0x5174
1007:                    	    {
1008:                        		//We finished receiving a sector worth of data from the host.
1009:                        		//Check if the media is write protected before deciding what
1010:                        		//to do with the data.
1011:                        		if(LUNWriteProtectState()) 
  5150    ECE6     CALL 0x1fcc, 0
  5152    F00F     NOP
  5154    0900     IORLW 0
  5156    E00B     BZ 0x516e
1012:                              {
1013:                                  //The device appears to be write protected.
1014:                            	    //Let host know error occurred.  The bCSWStatus flag is also used by
1015:                            	    //the write handler, to know not to even attempt the write sequence.
1016:                            	    msd_csw.bCSWStatus=0x01;    
  5158    0104     MOVLB 0x4
  515A    0E01     MOVLW 0x1
  515C    6F7B     MOVWF 0x7b, BANKED
1017:                            	    
1018:                                  //Set sense keys so the host knows what caused the error.
1019:                            	    gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
  515E    0104     MOVLB 0x4
  5160    91A2     BCF 0xa2, 0, BANKED
  5162    83A2     BSF 0xa2, 0x1, BANKED
  5164    95A2     BCF 0xa2, 0x2, BANKED
  5166    97A2     BCF 0xa2, 0x3, BANKED
1020:                            	    gblSenseData[LUN_INDEX].ASC=ASC_WRITE_PROTECTED;
  5168    0E27     MOVLW 0x27
  516A    6FAC     MOVWF 0xac, BANKED
1021:                            	    gblSenseData[LUN_INDEX].ASCQ=ASCQ_WRITE_PROTECTED;
  516C    6BAD     CLRF 0xad, BANKED
1022:                            	}
1023:                 			    MSDWriteState = MSD_WRITE10_SECTOR;     
  516E    0104     MOVLB 0x4
  5170    0E02     MOVLW 0x2
1024:                    			break;
  5172    D075     BRA 0x525e
1025:                        	}
1026:                      }
1027:                      //Fall through to MSD_WRITE10_RX_PACKET
1028:                      case MSD_WRITE10_RX_PACKET:
1029:                          if(USBHandleBusy(USBMSDOutHandle) == TRUE)
  5174    51B4     MOVF 0xb4, W, BANKED
  5176    11B5     IORWF 0xb5, W, BANKED
  5178    E102     BNZ 0x517e
  517A    0E00     MOVLW 0
  517C    D008     BRA 0x518e
  517E    C4B4     MOVFF 0x4b4, 0xfe9
  5180    FFE9     NOP
  5182    C4B5     MOVFF 0x4b5, 0xfea
  5184    FFEA     NOP
  5186    50EF     MOVF 0xfef, W, ACCESS
  5188    0B80     ANDLW 0x80
  518A    E001     BZ 0x518e
  518C    0E01     MOVLW 0x1
  518E    0900     IORLW 0
  5190    E16D     BNZ 0x526c
1030:                          {
1031:                              break;
1032:                          }
1033:                          
1034:                      	gblCBW.dCBWDataTransferLength-=USBHandleGetLength(USBMSDOutHandle);		// 64B read
  5192    C4B4     MOVFF 0x4b4, 0xfe9
  5194    FFE9     NOP
  5196    C4B5     MOVFF 0x4b5, 0xfea
  5198    FFEA     NOP
  519A    52EE     MOVF 0xfee, F, ACCESS
  519C    CFEF     MOVFF 0xfef, 0x14
  519E    F014     NOP
  51A0    6A15     CLRF 0x15, ACCESS
  51A2    6A16     CLRF 0x16, ACCESS
  51A4    6A17     CLRF 0x17, ACCESS
  51A6    5014     MOVF 0x14, W, ACCESS
  51A8    5F88     SUBWF 0x88, F, BANKED
  51AA    5015     MOVF 0x15, W, ACCESS
  51AC    5B89     SUBWFB 0x89, F, BANKED
  51AE    5016     MOVF 0x16, W, ACCESS
  51B0    5B8A     SUBWFB 0x8a, F, BANKED
  51B2    5017     MOVF 0x17, W, ACCESS
  51B4    5B8B     SUBWFB 0x8b, F, BANKED
1035:                      	msd_csw.dCSWDataResidue-=USBHandleGetLength(USBMSDOutHandle);
  51B6    C4B4     MOVFF 0x4b4, 0xfe9
  51B8    FFE9     NOP
  51BA    C4B5     MOVFF 0x4b5, 0xfea
  51BC    FFEA     NOP
  51BE    52EE     MOVF 0xfee, F, ACCESS
  51C0    CFEF     MOVFF 0xfef, 0x14
  51C2    F014     NOP
  51C4    6A15     CLRF 0x15, ACCESS
  51C6    6A16     CLRF 0x16, ACCESS
  51C8    6A17     CLRF 0x17, ACCESS
  51CA    5014     MOVF 0x14, W, ACCESS
  51CC    0104     MOVLB 0x4
  51CE    5F77     SUBWF 0x77, F, BANKED
  51D0    5015     MOVF 0x15, W, ACCESS
  51D2    5B78     SUBWFB 0x78, F, BANKED
  51D4    5016     MOVF 0x16, W, ACCESS
  51D6    5B79     SUBWFB 0x79, F, BANKED
  51D8    5017     MOVF 0x17, W, ACCESS
  51DA    5B7A     SUBWFB 0x7a, F, BANKED
1036:                          ptrNextData += MSD_OUT_EP_SIZE;
  51DC    0E40     MOVLW 0x40
  51DE    0104     MOVLB 0x4
  51E0    27B2     ADDWF 0xb2, F, BANKED
  51E2    0E00     MOVLW 0
  51E4    23B3     ADDWFC 0xb3, F, BANKED
1037:                          
1038:                          MSDWriteState = MSD_WRITE10_RX_SECTOR;
  51E6    0E03     MOVLW 0x3
1039:                          break;
  51E8    D03A     BRA 0x525e
1040:                      case MSD_WRITE10_SECTOR:
1041:                      {
1042:                          //Make sure that no error has been detected, before performing the write
1043:                          //operation.  If there was an error, skip the write operation, but allow
1044:                          //the TransferLength to continue decrementing, so that we can eventually
1045:                          //receive all OUT bytes that the host is planning on sending us.  Only
1046:                          //after that is complete will the host send the IN token for the CSW packet,
1047:                          //which will contain the bCSWStatus letting it know an error occurred.
1048:                    		if(msd_csw.bCSWStatus == 0x00)
  51EA    0104     MOVLB 0x4
  51EC    517B     MOVF 0x7b, W, BANKED
  51EE    E12E     BNZ 0x524c
1049:                    		{
1050:                        		if(LUNSectorWrite(LBA.Val, (BYTE*)&msd_buffer[0], (LBA.Val==0)?TRUE:FALSE) != TRUE)
  51F0    0104     MOVLB 0x4
  51F2    51BF     MOVF 0xbf, W, BANKED
  51F4    11C0     IORWF 0xc0, W, BANKED
  51F6    11C1     IORWF 0xc1, W, BANKED
  51F8    11C2     IORWF 0xc2, W, BANKED
  51FA    E102     BNZ 0x5200
  51FC    0E01     MOVLW 0x1
  51FE    D001     BRA 0x5202
  5200    0E00     MOVLW 0
  5202    6EE6     MOVWF 0xfe6, ACCESS
  5204    0E00     MOVLW 0
  5206    6EE6     MOVWF 0xfe6, ACCESS
  5208    0E06     MOVLW 0x6
  520A    6EE6     MOVWF 0xfe6, ACCESS
  520C    C4BF     MOVFF 0x4bf, 0xfe6
  520E    FFE6     NOP
  5210    C4C0     MOVFF 0x4c0, 0xfe6
  5212    FFE6     NOP
  5214    C4C1     MOVFF 0x4c1, 0xfe6
  5216    FFE6     NOP
  5218    C4C2     MOVFF 0x4c2, 0xfe6
  521A    FFE6     NOP
  521C    ECC3     CALL 0x1d86, 0
  521E    F00E     NOP
  5220    6E14     MOVWF 0x14, ACCESS
  5222    0E07     MOVLW 0x7
  5224    5EE1     SUBWF 0xfe1, F, ACCESS
  5226    5014     MOVF 0x14, W, ACCESS
  5228    0801     SUBLW 0x1
  522A    E010     BZ 0x524c
1051:                        		{
1052:                            		//The write operation failed for some reason.  Keep track of retry
1053:                            		//attempts and abort if repeated write attempts also fail.
1054:                  				if(MSDRetryAttempt < MSD_FAILED_WRITE_MAX_ATTEMPTS)
  522C    0E64     MOVLW 0x64
  522E    0104     MOVLB 0x4
  5230    5D7F     SUBWF 0x7f, W, BANKED
  5232    E202     BC 0x5238
1055:                  				{
1056:                  				    MSDRetryAttempt++;
  5234    2B7F     INCF 0x7f, F, BANKED
1057:                                      break;
  5236    D01A     BRA 0x526c
1058:                  				}
1059:                  				else
1060:                  				{  
1061:                      				//Too many consecutive failed write attempts have occurred. 
1062:                      				//Need to give up and abandon the write attempt.
1063:                      				msd_csw.bCSWStatus=0x01;		// Error 0x01 Refer page#18
  5238    0104     MOVLB 0x4
  523A    0E01     MOVLW 0x1
  523C    6F7B     MOVWF 0x7b, BANKED
1064:                                                                      // of BOT specifications
1065:                                      //Set error status sense keys, so the host can check them later
1066:                                      //to determine how to proceed.
1067:                                      gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
  523E    0104     MOVLB 0x4
  5240    81A2     BSF 0xa2, 0, BANKED
  5242    83A2     BSF 0xa2, 0x1, BANKED
  5244    95A2     BCF 0xa2, 0x2, BANKED
  5246    97A2     BCF 0xa2, 0x3, BANKED
1068:                  			        gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
  5248    6BAC     CLRF 0xac, BANKED
1069:                  			        gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
  524A    6BAD     CLRF 0xad, BANKED
1070:                                  }              		
1071:                        		}
1072:                    		}
1073:                    
1074:                          //One LBA is written (unless an error occurred).  Advance state
1075:                          //variables so we can eventually finish handling the CBW request.
1076:                    		LBA.Val++;				
  524C    0104     MOVLB 0x4
  524E    2BBF     INCF 0xbf, F, BANKED
  5250    0E00     MOVLW 0
  5252    23C0     ADDWFC 0xc0, F, BANKED
  5254    23C1     ADDWFC 0xc1, F, BANKED
  5256    23C2     ADDWFC 0xc2, F, BANKED
1077:                    		TransferLength.Val--;      
  5258    07BD     DECF 0xbd, F, BANKED
  525A    5BBE     SUBWFB 0xbe, F, BANKED
1078:                          MSDWriteState = MSD_WRITE10_BLOCK;
  525C    0E01     MOVLW 0x1
  525E    6F7E     MOVWF 0x7e, BANKED
1079:                          break;
  5260    D005     BRA 0x526c
1080:                      } 
1081:                      
1082:                      default:
1083:                          //Illegal condition which should not occur.  If for some reason it
1084:                          //does, try to let the host know know an error has occurred.
1085:                          msd_csw.bCSWStatus=0x02;    //Phase Error
  5262    0104     MOVLB 0x4
  5264    0E02     MOVLW 0x2
  5266    6F7B     MOVWF 0x7b, BANKED
1086:                          MSDWriteState = MSD_WRITE10_WAIT;            
  5268    0104     MOVLB 0x4
  526A    6B7E     CLRF 0x7e, BANKED
1087:                  }
1088:                  
1089:                  return MSDWriteState;
  526C    517E     MOVF 0x7e, W, BANKED
1090:              }
  526E    0012     RETURN 0
1091:              
1092:              /******************************************************************************
1093:               	Function:
1094:               		void ResetSenseData(void)
1095:               		
1096:               	Description:
1097:               		This routine resets the Sense Data, initializing the
1098:               		structure RequestSenseResponse gblSenseData.
1099:               		
1100:               	PreCondition:
1101:               		None 
1102:               		
1103:               	Parameters:
1104:               		None
1105:               		
1106:               	Return Values:
1107:               		None
1108:               		
1109:               	Remarks:
1110:               		None
1111:               			
1112:                *****************************************************************************/
1113:              void ResetSenseData(void) 
1114:              {
1115:              	gblSenseData[LUN_INDEX].ResponseCode=S_CURRENT;
  5270    0104     MOVLB 0x4
  5272    91A0     BCF 0xa0, 0, BANKED
  5274    93A0     BCF 0xa0, 0x1, BANKED
  5276    95A0     BCF 0xa0, 0x2, BANKED
  5278    97A0     BCF 0xa0, 0x3, BANKED
  527A    89A0     BSF 0xa0, 0x4, BANKED
  527C    8BA0     BSF 0xa0, 0x5, BANKED
  527E    8DA0     BSF 0xa0, 0x6, BANKED
1116:              	gblSenseData[LUN_INDEX].VALID=0;			// no data in the information field
  5280    9FA0     BCF 0xa0, 0x7, BANKED
1117:              	gblSenseData[LUN_INDEX].Obsolete=0x0;
  5282    6BA1     CLRF 0xa1, BANKED
1118:              	gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
  5284    91A2     BCF 0xa2, 0, BANKED
  5286    93A2     BCF 0xa2, 0x1, BANKED
  5288    95A2     BCF 0xa2, 0x2, BANKED
  528A    97A2     BCF 0xa2, 0x3, BANKED
1119:              	//gblSenseData.Resv;
1120:              	gblSenseData[LUN_INDEX].ILI=0;
  528C    9BA2     BCF 0xa2, 0x5, BANKED
1121:              	gblSenseData[LUN_INDEX].EOM=0;
  528E    9DA2     BCF 0xa2, 0x6, BANKED
1122:              	gblSenseData[LUN_INDEX].FILEMARK=0;
  5290    9FA2     BCF 0xa2, 0x7, BANKED
1123:              	gblSenseData[LUN_INDEX].InformationB0=0x00;
  5292    6BA3     CLRF 0xa3, BANKED
1124:              	gblSenseData[LUN_INDEX].InformationB1=0x00;
  5294    6BA4     CLRF 0xa4, BANKED
1125:              	gblSenseData[LUN_INDEX].InformationB2=0x00;
  5296    6BA5     CLRF 0xa5, BANKED
1126:              	gblSenseData[LUN_INDEX].InformationB3=0x00;
  5298    6BA6     CLRF 0xa6, BANKED
1127:              	gblSenseData[LUN_INDEX].AddSenseLen=0x0a;	// n-7 (n=17 (0..17))
  529A    0E0A     MOVLW 0xa
  529C    6FA7     MOVWF 0xa7, BANKED
1128:              	gblSenseData[LUN_INDEX].CmdSpecificInfo.Val=0x0;
  529E    6BA8     CLRF 0xa8, BANKED
  52A0    6BA9     CLRF 0xa9, BANKED
  52A2    6BAA     CLRF 0xaa, BANKED
  52A4    6BAB     CLRF 0xab, BANKED
1129:              	gblSenseData[LUN_INDEX].ASC=0x0;
  52A6    6BAC     CLRF 0xac, BANKED
1130:              	gblSenseData[LUN_INDEX].ASCQ=0x0;
  52A8    6BAD     CLRF 0xad, BANKED
1131:              	gblSenseData[LUN_INDEX].FRUC=0x0;
  52AA    6BAE     CLRF 0xae, BANKED
1132:              	gblSenseData[LUN_INDEX].SenseKeySpecific[0]=0x0;
  52AC    6BAF     CLRF 0xaf, BANKED
1133:              	gblSenseData[LUN_INDEX].SenseKeySpecific[1]=0x0;
  52AE    6BB0     CLRF 0xb0, BANKED
1134:              	gblSenseData[LUN_INDEX].SenseKeySpecific[2]=0x0;
  52B0    6BB1     CLRF 0xb1, BANKED
1135:              }
  52B2    0012     RETURN 0
---  E:\Projects\DevPFG\Microchip\USB\usb_device.c  ----------------------------------------------
1:                 /********************************************************************
2:                   File Information:
3:                     FileName:     	usb_device.c
4:                     Dependencies:	See INCLUDES section
5:                     Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                     Hardware:		This code is natively intended to be used on Mirochip USB
7:                                     demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                     section) for list of available platforms.  The firmware may 
9:                                     be modified for use on other USB platforms by editing the
10:                    				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                    Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                    and C32 (for PIC32)
13:                    Company:		Microchip Technology, Inc.
14:                    
15:                    Software License Agreement:
16:                    
17:                    The software supplied herewith by Microchip Technology Incorporated
18:                    (the "Company") for its PICr Microcontroller is intended and
19:                    supplied to you, the Company's customer, for use solely and
20:                    exclusively on Microchip PIC Microcontroller products. The
21:                    software is owned by the Company and/or its supplier, and is
22:                    protected under applicable copyright laws. All rights are reserved.
23:                    Any use in violation of the foregoing restrictions may subject the
24:                    user to criminal sanctions under applicable laws, as well as to
25:                    civil liability for the breach of the terms and conditions of this
26:                    license.
27:                    
28:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                
35:                  Summary:
36:                    This file contains functions, macros, definitions, variables,
37:                    datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                    stack. This file should be included in projects that use the device stack. 
39:                    
40:                    This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                    directory.
42:                
43:                  Description:
44:                    USB Device Stack File
45:                    
46:                    This file contains functions, macros, definitions, variables,
47:                    datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                    stack. This file should be included in projects that use the device stack.
49:                    
50:                    This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                    directory.
52:                    
53:                    When including this file in a new project, this file can either be
54:                    referenced from the directory in which it was installed or copied
55:                    directly into the user application folder. If the first method is
56:                    chosen to keep the file located in the folder in which it is installed
57:                    then include paths need to be added so that the library and the
58:                    application both know where to reference each others files. If the
59:                    application folder is located in the same folder as the Microchip
60:                    folder (like the current demo folders), then the following include
61:                    paths need to be added to the application's project:
62:                    
63:                    .
64:                    ..\\..\\MicrochipInclude
65:                    
66:                    If a different directory structure is used, modify the paths as
67:                    required. An example using absolute paths instead of relative paths
68:                    would be the following:
69:                    
70:                    C:\\Microchip Solutions\\Microchip\\Include
71:                    
72:                    C:\\Microchip Solutions\\My Demo Application 
73:                
74:                ********************************************************************
75:                 File Description:
76:                
77:                 Change History:
78:                  Rev    Description
79:                  ----   -----------
80:                  2.6    Added USBCancelIO() function.  Moved and some stack
81:                         defintions to be more consistant with the host stack.
82:                
83:                  2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                         inability to transmit on an endpoint if using ping-pong
85:                         and an odd number of packets had been sent on that endpoint 
86:                
87:                  2.7    Fixed error where the USB error interrupt flag was not getting
88:                         cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                         http://www.microchip.com/forums/tm.aspx?m=479085
90:                
91:                         Fixed issue with dual role mode when device run in polling
92:                         mode.  Interrupts were remaining enabled after the host mode
93:                         operation was complete.  This was incompatible with polling
94:                         mode operation.
95:                
96:                         Changed how the bus sensing works.  In previous revisions it
97:                         was impossible to use the USBDeviceDetach to detach from the
98:                         bus if the bus voltage was still present.  This is now
99:                         possible.  It was also possible to move the device to the 
100:                        ATTACHED state in interrupt mode even if the bus voltage 
101:                        wasn't available.  This is now prohibited unless VBUS is
102:                        present.
103:                        
104:                        Improved error case handling when the host sends more OUT
105:                        bytes in a control transfer than the firmware was expecting
106:                        to receive (based on the size parameter when calling USBEP0Receive()).
107:                        
108:                        In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                        variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                        function.  
111:               
112:                 2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                        devices.
114:               
115:                        Fixed an error on 16-bit and 32-bit processors where a word access
116:                        could be performed on a byte pointer resulting in possible address
117:                        errors with odd aligned pointers.
118:                        
119:                 2.8    Several changes to the way control transfers get processed,
120:                        so as to support the ability to allow application/class specific
121:                        handler code to defer the status stage.  
122:                        Implemented USBCtrlEPAllowStatusStage() API function.
123:                        Implemented USBDeferStatusStage() API function (macro).
124:                        These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                        requirement, while allowing USB class handlers more flexibility.
126:                        
127:                        Also implemented the following API functions and macros, for delaying 
128:                        the data stage of a control transfer (with data stage):
129:                        USBDeferINDataStage()
130:                        USBDeferOUTDataStage()
131:                        USBOUTDataStageDeferred()
132:                        USBINDataStageDeferred()
133:                        USBCtrlEPAllowDataStage()      
134:                        
135:                        Fixed USB reset event handler issue, where the USB stack would 
136:                        re-initialize global interrupt settings in the interrupt context, on 
137:                        PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                        
139:                        Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                        Previous implementation would not always initialize endpoints correctly 
141:                        to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                        all ping pong mode and usage scenarios.
143:               ********************************************************************/
144:               
145:               /*----------------------------------------------------------------------------------
146:               The USBDeviceTasks() function is responsible for detecting and processing various
147:               USB bus events and host requests, such as those required for USB enumeration, when
148:               the USB cable is first attached to the host.  This function is the main dispatcher
149:               routine for the USB stack.
150:               
151:               Additional API functions and macros are also provided by the USB stack, which can be 
152:               used to send/receive USB data to/from the host, among other things.  A full list 
153:               of the available implemented functions/macros are provided in the 
154:               "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
155:               the USB API documentation can be found from:
156:               
157:               Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
158:               
159:               Once the help file is opened, the API functions/macros are described in the following section:
160:               Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
161:               Additional API functions may also be provided depending upon the specific USB device class
162:               implemented, and these functions are also documented in the MCHPFSUSB Library Help.
163:               
164:               
165:               If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
166:               usb_config.h), then the application firmware is reponsible for calling the 
167:               USBDeviceTasks() function periodically.  If the USB stack is operated in the 
168:               "USB_INTERRUPT" mode, then the application firmware does not have to directly 
169:               call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
170:               
171:               In order to properly operate a USB connection, and to correctly process and respond
172:               to control transfers in the maximum time allowed by the USB specifications, the
173:               USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
174:               fashion.
175:               
176:               When the USB module is enabled, the USB cable is attached to the host, the USB bus
177:               is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
178:               with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
179:               time between calls to the USBDeviceTasks() function needs to be:
180:               
181:               The faster of:
182:               1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
183:               2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
184:               3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
185:               
186:               Additional details of the above timing limits are provided:
187:               
188:               Timing item #1: This parameter originates from the 2ms set address "recovery interval"
189:               specification dictated by section "9.2.6.3 Set Address Processing" of the official 
190:               USB 2.0 specifications.
191:               
192:               Timing item #2: This parameter originates from several "10 ms" criteria in the 
193:               USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
194:               intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
195:               
196:               Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
197:               transaction rate implemented by the application.  The USBDeviceTasks() function is
198:               responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
199:               then no further USB transactions are allowed to occur, until the firmware pops entries
200:               off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
201:               a rate at least as fast as once every three times the USBTransferOnePacket() function
202:               is called.  This ensures that the rate that USTAT FIFO entries are getting added to
203:               the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
204:               USBDeviceTasks() function will pop up to 4 entries per call), which is a
205:               necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
206:               USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
207:               USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
208:               and is therefore recommended.
209:               
210:               When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
211:               parameters should be interpreted to be the longest allowed time that the USB 
212:               interrupts may be masked/disabled for, before re-enabling the USB interrupts.
213:               
214:               Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
215:               will still have potential USB data rate speed and processing latency benefits.
216:               It is also beneficial to call USBDeviceTasks() more often than theoretically 
217:               required, since it has been observed that not all host/drivers/bios/hubs are 
218:               100% consistently compliant with all timing parameters of the USB 2.0 specifications.
219:               Therefore, in a USB_POLLING based application, it is still suggested to call 
220:               USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
221:               performance, along with best possible compatibility with all existing USB 
222:               hosts/hubs (both those that are compliant and [partially] non-compliant).
223:               
224:               If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
225:               to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
226:               per 100us, or preferrably faster).  Therefore, in all applications, it is 
227:               normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
228:               USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
229:               allow for much more relaxed timing requirements, and therefore greater application
230:               firmware design flexibility.
231:               //----------------------------------------------------------------------------------*/
232:               
233:               /** INCLUDES *******************************************************/
234:               #include "./USB/USB.h"
235:               #include "HardwareProfile.h"
236:               
237:               #include "../USB/usb_device_local.h"
238:               
239:               
240:               #if defined(USB_USE_MSD)
241:                   #include "./USB/usb_function_msd.h"
242:               #endif
243:               
244:               #if !defined(USE_USB_BUS_SENSE_IO)
245:                   #undef USB_BUS_SENSE
246:                   #define USB_BUS_SENSE 1
247:               #endif
248:               
249:               /** Definitions ****************************************************/
250:               
251:               /** VARIABLES ******************************************************/
252:               #pragma udata
253:               
254:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
255:               USB_VOLATILE BYTE USBActiveConfiguration;
256:               USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
257:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
258:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
259:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
260:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
261:               USB_VOLATILE BYTE shortPacketStatus;
262:               USB_VOLATILE BYTE controlTransferState;
263:               USB_VOLATILE IN_PIPE inPipes[1];
264:               USB_VOLATILE OUT_PIPE outPipes[1];
265:               USB_VOLATILE BYTE *pDst;
266:               USB_VOLATILE BOOL RemoteWakeup;
267:               USB_VOLATILE BOOL USBBusIsSuspended;
268:               USB_VOLATILE USTAT_FIELDS USTATcopy;
269:               USB_VOLATILE BYTE endpoint_number;
270:               USB_VOLATILE BOOL BothEP0OutUOWNsSet;
271:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
272:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
273:               USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
274:               volatile BOOL USBDeferStatusStagePacket;
275:               volatile BOOL USBStatusStageEnabledFlag1;
276:               volatile BOOL USBStatusStageEnabledFlag2;
277:               volatile BOOL USBDeferINDataStagePackets;
278:               volatile BOOL USBDeferOUTDataStagePackets;
279:               
280:               
281:               /** USB FIXED LOCATION VARIABLES ***********************************/
282:               #if defined(__18CXX)
283:                   #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50)
284:                       #pragma udata USB_BDT=0x200     //See Linker Script, BDT in bank 2 on these devices - usb2:0x200-0x2FF(256-byte)
285:                   #elif defined(__18F47J53) || defined(__18F46J53) || defined(__18F27J53) || defined(__18F26J53) || defined(__18LF47J53) || defined(__18LF46J53) || defined(__18LF27J53) || defined(__18LF26J53)
286:               		#pragma udata USB_BDT=0xD00		//BDT in Bank 13 on these devices
287:                   #else
288:                       #pragma udata USB_BDT=0x400     //All other PIC18 devices place the BDT in usb4:0x400-0x4FF(256-byte)
289:               	#endif
290:               #endif
291:               
292:               /********************************************************************
293:                * Section A: Buffer Descriptor Table
294:                * - 256 bytes max.  Actual size depends on number of endpoints enabled and 
295:                *   the ping pong buffering mode.
296:                * - USB_MAX_EP_NUMBER is defined in usb_config.h
297:                *******************************************************************/
298:               #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
299:                   volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 2] __attribute__ ((aligned (512)));
300:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
301:                   volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 2)+1] __attribute__ ((aligned (512)));
302:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
303:                   volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 4] __attribute__ ((aligned (512)));
304:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
305:                   volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 4)-2] __attribute__ ((aligned (512)));
306:               #else
307:                   #error "No ping pong mode defined."
308:               #endif
309:               
310:               /********************************************************************
311:                * Section B: EP0 Buffer Space
312:                *******************************************************************/
313:               volatile CTRL_TRF_SETUP SetupPkt;           // 8-byte only
314:               volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE];
315:               
316:               /********************************************************************
317:                * Section C: non-EP0 Buffer Space
318:                *******************************************************************/
319:               // Can provide compile time option to do software pingpong
320:               #if defined(USB_USE_HID)
321:                   volatile unsigned char hid_report_out[HID_INT_OUT_EP_SIZE];
322:                   volatile unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
323:               #endif
324:               
325:               #if defined(USB_USE_MSD)
326:               	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
327:               	volatile USB_MSD_CBW msd_cbw;
328:               	volatile USB_MSD_CSW msd_csw;
329:               	//#pragma udata
330:               
331:               	#if defined(__18CXX)
332:               		#pragma udata myMSD=MSD_BUFFER_ADDRESS
333:               	#endif
334:               	volatile char msd_buffer[512];
335:               #endif
336:               
337:               #if defined(__18CXX)
338:               #pragma udata
339:               #endif
340:               
341:               ////Depricated in v2.2 - will be removed in a future revision
342:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
343:                   //Device descriptor
344:                   extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
345:               #else
346:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
347:               #endif
348:               
349:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
350:                   //Array of configuration descriptors
351:                   extern ROM BYTE *ROM USB_CD_Ptr[];
352:               #else
353:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
354:               #endif
355:               
356:               extern ROM BYTE *ROM USB_SD_Ptr[];
357:               
358:               /** DECLARATIONS ***************************************************/
359:               #pragma code
360:               
361:               /** Macros *********************************************************/
362:               
363:               /** Function Prototypes ********************************************/
364:               //External
365:               //This is the prototype for the required user event handler
366:               BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size);
367:               
368:               //Internal Functions
369:               static void USBCtrlEPService(void);
370:               static void USBCtrlTrfSetupHandler(void);
371:               static void USBCtrlTrfInHandler(void);
372:               static void USBCheckStdRequest(void);
373:               static void USBStdGetDscHandler(void);
374:               static void USBCtrlEPServiceComplete(void);
375:               static void USBCtrlTrfTxService(void);
376:               static void USBCtrlTrfRxService(void);
377:               static void USBStdSetCfgHandler(void);
378:               static void USBStdGetStatusHandler(void);
379:               static void USBStdFeatureReqHandler(void);
380:               static void USBCtrlTrfOutHandler(void);
381:               static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
382:               static void USBWakeFromSuspend(void);
383:               static void USBSuspend(void);
384:               static void USBStallHandler(void);
385:               
386:               //static BOOL USBIsTxBusy(BYTE EPNumber);
387:               //static void USBPut(BYTE EPNum, BYTE Data);
388:               //static void USBEPService(void);
389:               //static void USBProtocolResetHandler(void);
390:               
391:               /******************************************************************************/
392:               /** Functions Implementations *************************************************/
393:               /******************************************************************************/
394:               
395:               //DOM-IGNORE-BEGIN
396:               /****************************************************************************
397:                 Function:
398:                   void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
399:               
400:                 Description:
401:                   This function will advance the passed pointer to the next buffer based on
402:                   the ping pong option setting.  This function should be used for EP1-EP15
403:                   only.  This function is not valid for EP0.
404:               
405:                 Precondition:
406:                   None
407:               
408:                 Parameters:
409:                   BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
410:                   to the next buffer state
411:               
412:                 Return Values:
413:                   None
414:               
415:                 Remarks:
416:                   None
417:               
418:                 ***************************************************************************/
419:               //DOM-IGNORE-END
420:               #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
421:               #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
422:               #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
423:               
424:               //DOM-IGNORE-BEGIN
425:               /****************************************************************************
426:                 Function:
427:                   void USBDeviceInit(void)
428:               
429:                 Description:
430:                   This function initializes the device stack
431:                   it in the default state
432:               
433:                 Precondition:
434:                   None
435:               
436:                 Parameters:
437:                   None
438:               
439:                 Return Values:
440:                   None
441:               
442:                 Remarks:
443:                   The USB module will be completely reset including
444:                   all of the internal variables, registers, and
445:                   interrupt flags.
446:                 ***************************************************************************/
447:               //DOM-IGNORE-END
448:               void USBDeviceInit(void)
  28EE    CFD9     MOVFF 0xfd9, 0xfe6
  28F0    FFE6     NOP
  28F2    CFE1     MOVFF 0xfe1, 0xfd9
  28F4    FFD9     NOP
  28F6    52E6     MOVF 0xfe6, F, ACCESS
449:               {
450:                   BYTE i;
451:               
452:                   USBDisableInterrupts();
  28F8    98A0     BCF 0xfa0, 0x4, ACCESS
453:               
454:                   // Clear all USB error flags
455:                   USBClearInterruptRegister(U1EIR);  
  28FA    6A63     CLRF 0xf63, ACCESS
456:                      
457:                   // Clears all USB interrupts          
458:                   USBClearInterruptRegister(U1IR); 
  28FC    6A62     CLRF 0xf62, ACCESS
459:               
460:                   //Clear all of the endpoint control registers
461:                   U1EP0 = 0;
  28FE    010F     MOVLB 0xf
  2900    6B26     CLRF 0x26, BANKED
462:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
  2902    0E03     MOVLW 0x3
  2904    6EE6     MOVWF 0xfe6, ACCESS
  2906    6AE6     CLRF 0xfe6, ACCESS
  2908    6AE6     CLRF 0xfe6, ACCESS
  290A    0E27     MOVLW 0x27
  290C    6EE6     MOVWF 0xfe6, ACCESS
  290E    0E0F     MOVLW 0xf
  2910    6EE6     MOVWF 0xfe6, ACCESS
  2912    EC88     CALL 0x6310, 0
  2914    F031     NOP
  2916    6E14     MOVWF 0x14, ACCESS
  2918    0E05     MOVLW 0x5
  291A    5EE1     SUBWF 0xfe1, F, ACCESS
  291C    5014     MOVF 0x14, W, ACCESS
463:               
464:                   SetConfigurationOptions();
  291E    010F     MOVLB 0xf
  2920    0E16     MOVLW 0x16
  2922    6F39     MOVWF 0x39, BANKED
  2924    0E9F     MOVLW 0x9f
  2926    6F37     MOVWF 0x37, BANKED
  2928    0E7B     MOVLW 0x7b
  292A    6F36     MOVWF 0x36, BANKED
465:               
466:                   //power up the module (if not already powered)
467:                   USBPowerModule();
468:               
469:                   //set the address of the BDT (if applicable)
470:                   USBSetBDTAddress(BDT);
471:               
472:                   //Clear all of the BDT entries
473:                   for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
  292C    6ADF     CLRF 0xfdf, ACCESS
  292E    50DF     MOVF 0xfdf, W, ACCESS
  2930    6E14     MOVWF 0x14, ACCESS
  2932    6A15     CLRF 0x15, ACCESS
  2934    0E10     MOVLW 0x10
  2936    5C14     SUBWF 0x14, W, ACCESS
  2938    0E00     MOVLW 0
  293A    5815     SUBWFB 0x15, W, ACCESS
  293C    E210     BC 0x295e
  295A    2ADF     INCF 0xfdf, F, ACCESS
  295C    D7E8     BRA 0x292e
474:                   {
475:                       BDT[i].Val = 0x00;
  293E    50DF     MOVF 0xfdf, W, ACCESS
  2940    0D04     MULLW 0x4
  2942    CFF3     MOVFF 0xff3, 0xfe9
  2944    FFE9     NOP
  2946    CFF4     MOVFF 0xff4, 0xfea
  2948    FFEA     NOP
  294A    0E00     MOVLW 0
  294C    26E9     ADDWF 0xfe9, F, ACCESS
  294E    0E04     MOVLW 0x4
  2950    22EA     ADDWFC 0xfea, F, ACCESS
  2952    6AEE     CLRF 0xfee, ACCESS
  2954    6AEE     CLRF 0xfee, ACCESS
  2956    6AEE     CLRF 0xfee, ACCESS
  2958    6AEE     CLRF 0xfee, ACCESS
476:                   }
477:               
478:                   // Assert reset request to all of the Ping Pong buffer pointers
479:                   USBPingPongBufferReset = 1;                    
  295E    8C65     BSF 0xf65, 0x6, ACCESS
480:               
481:                   // Reset to default address
482:                   U1ADDR = 0x00;                   
  2960    010F     MOVLB 0xf
  2962    6B38     CLRF 0x38, BANKED
483:               
484:                   // Make sure packet processing is enabled
485:                   USBPacketDisable = 0;           
  2964    9865     BCF 0xf65, 0x4, ACCESS
486:               
487:                   //Stop trying to reset ping pong buffer pointers
488:                   USBPingPongBufferReset = 0;
  2966    9C65     BCF 0xf65, 0x6, ACCESS
489:               
490:                   // Flush any pending transactions
491:                   while(USBTransactionCompleteIF == 1)      
  2968    A662     BTFSS 0xf62, 0x3, ACCESS
  296A    D007     BRA 0x297a
  2978    D7F7     BRA 0x2968
492:                   {
493:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
  296C    9662     BCF 0xf62, 0x3, ACCESS
494:                       //Initialize USB stack software state variables
495:                       inPipes[0].info.Val = 0;
  296E    0100     MOVLB 0
  2970    6B7C     CLRF 0x7c, BANKED
496:                       outPipes[0].info.Val = 0;
  2972    6B81     CLRF 0x81, BANKED
497:                       outPipes[0].wCount.Val = 0;
  2974    6B82     CLRF 0x82, BANKED
  2976    6B83     CLRF 0x83, BANKED
498:                   }
499:               
500:                   //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
501:                   //try and arm a status stage, even before the first control transfer starts.
502:                   USBStatusStageEnabledFlag1 = TRUE;  
  297A    0100     MOVLB 0
  297C    0E01     MOVLW 0x1
  297E    6F98     MOVWF 0x98, BANKED
503:                   USBStatusStageEnabledFlag2 = TRUE;
  2980    6F99     MOVWF 0x99, BANKED
504:                   //Initialize other flags
505:                   USBDeferINDataStagePackets = FALSE;
  2982    6B9A     CLRF 0x9a, BANKED
506:                   USBDeferOUTDataStagePackets = FALSE;
  2984    6B9B     CLRF 0x9b, BANKED
507:                   USBBusIsSuspended = FALSE;
  2986    6B8A     CLRF 0x8a, BANKED
508:               
509:               	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
510:               	//pointers to NULL, so they don't get used inadvertently.  
511:               	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
  2988    6ADF     CLRF 0xfdf, ACCESS
  298A    0E04     MOVLW 0x4
  298C    5CDF     SUBWF 0xfdf, W, ACCESS
  298E    E226     BC 0x29dc
  29D8    2ADF     INCF 0xfdf, F, ACCESS
  29DA    D7D7     BRA 0x298a
512:               	{
513:               		pBDTEntryIn[i] = 0u;
  2990    6AEA     CLRF 0xfea, ACCESS
  2992    34DF     RLCF 0xfdf, W, ACCESS
  2994    0BFE     ANDLW 0xfe
  2996    36EA     RLCF 0xfea, F, ACCESS
  2998    6EE9     MOVWF 0xfe9, ACCESS
  299A    0E6F     MOVLW 0x6f
  299C    26E9     ADDWF 0xfe9, F, ACCESS
  299E    0E00     MOVLW 0
  29A0    22EA     ADDWFC 0xfea, F, ACCESS
  29A2    6AEE     CLRF 0xfee, ACCESS
  29A4    6AED     CLRF 0xfed, ACCESS
514:               		pBDTEntryOut[i] = 0u;		
  29A6    6AEA     CLRF 0xfea, ACCESS
  29A8    34DF     RLCF 0xfdf, W, ACCESS
  29AA    0BFE     ANDLW 0xfe
  29AC    36EA     RLCF 0xfea, F, ACCESS
  29AE    6EE9     MOVWF 0xfe9, ACCESS
  29B0    0E67     MOVLW 0x67
  29B2    26E9     ADDWF 0xfe9, F, ACCESS
  29B4    0E00     MOVLW 0
  29B6    22EA     ADDWFC 0xfea, F, ACCESS
  29B8    6AEE     CLRF 0xfee, ACCESS
  29BA    6AED     CLRF 0xfed, ACCESS
515:               		ep_data_in[i].Val = 0u;
  29BC    50DF     MOVF 0xfdf, W, ACCESS
  29BE    6AEA     CLRF 0xfea, ACCESS
  29C0    0F8E     ADDLW 0x8e
  29C2    6EE9     MOVWF 0xfe9, ACCESS
  29C4    0E00     MOVLW 0
  29C6    22EA     ADDWFC 0xfea, F, ACCESS
  29C8    6AEF     CLRF 0xfef, ACCESS
516:                       ep_data_out[i].Val = 0u;
  29CA    50DF     MOVF 0xfdf, W, ACCESS
  29CC    6AEA     CLRF 0xfea, ACCESS
  29CE    0F92     ADDLW 0x92
  29D0    6EE9     MOVWF 0xfe9, ACCESS
  29D2    0E00     MOVLW 0
  29D4    22EA     ADDWFC 0xfea, F, ACCESS
  29D6    6AEF     CLRF 0xfef, ACCESS
517:               	}
518:               
519:                   //Get ready for the first packet
520:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
  29DC    0100     MOVLB 0
  29DE    0E08     MOVLW 0x8
  29E0    6F6F     MOVWF 0x6f, BANKED
  29E2    0E04     MOVLW 0x4
  29E4    6F70     MOVWF 0x70, BANKED
521:                   // Initialize EP0 as a Ctrl EP
522:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
  29E6    010F     MOVLB 0xf
  29E8    0E16     MOVLW 0x16
  29EA    6F26     MOVWF 0x26, BANKED
523:               	//Prepare for the first SETUP on EP0 OUT
524:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
  29EC    0104     MOVLB 0x4
  29EE    0E40     MOVLW 0x40
  29F0    6F02     MOVWF 0x2, BANKED
  29F2    0E04     MOVLW 0x4
  29F4    6F03     MOVWF 0x3, BANKED
525:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
  29F6    0E08     MOVLW 0x8
  29F8    6F01     MOVWF 0x1, BANKED
526:                   BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
  29FA    0E84     MOVLW 0x84
  29FC    6F00     MOVWF 0, BANKED
527:               
528:                   // Clear active configuration
529:                   USBActiveConfiguration = 0;     
  29FE    0100     MOVLB 0
  2A00    6B61     CLRF 0x61, BANKED
530:               
531:                   //Indicate that we are now in the detached state        
532:                   USBDeviceState = DETACHED_STATE;
  2A02    6B60     CLRF 0x60, BANKED
533:               }
  2A04    52E5     MOVF 0xfe5, F, ACCESS
  2A06    52E5     MOVF 0xfe5, F, ACCESS
  2A08    CFE7     MOVFF 0xfe7, 0xfd9
  2A0A    FFD9     NOP
  2A0C    0012     RETURN 0
534:               
535:               //DOM-IGNORE-BEGIN
536:               /****************************************************************************
537:                 Function:
538:                   void USBDeviceTasks(void)
539:               
540:                 Description:
541:                   This function is the main state machine of the 
542:                   USB device side stack.  This function should be
543:                   called periodically to receive and transmit
544:                   packets through the stack.  This function should
545:                   be called  preferably once every 100us 
546:                   during the enumeration process.  After the
547:                   enumeration process this function still needs to
548:                   be called periodically to respond to various
549:                   situations on the bus but is more relaxed in its
550:                   time requirements.  This function should also
551:                   be called at least as fast as the OUT data
552:                   expected from the PC.
553:               
554:                 Precondition:
555:                   None
556:               
557:                 Parameters:
558:                   None
559:               
560:                 Return Values:
561:                   None
562:               
563:                 Remarks:
564:                   None
565:                 ***************************************************************************/
566:               //DOM-IGNORE-END
567:               
568:               #if defined(USB_INTERRUPT) 
569:                 #if defined(__18CXX)
570:                   void USBDeviceTasks(void)
  2A0E    CFD9     MOVFF 0xfd9, 0xfe6
  2A10    FFE6     NOP
  2A12    CFE1     MOVFF 0xfe1, 0xfd9
  2A14    FFD9     NOP
  2A16    52E6     MOVF 0xfe6, F, ACCESS
571:                 #elif defined(__C30__)
572:                   void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
573:                 #elif defined(__PIC32MX__)
574:                   void __attribute__((interrupt(),vector(45))) _USB1Interrupt( void ) 
575:                 #endif
576:               #else
577:               void USBDeviceTasks(void)
578:               #endif
579:               {
580:                   BYTE i;
581:               
582:               #ifdef USB_SUPPORT_OTG
583:                   //SRP Time Out Check
584:                   if (USBOTGSRPIsReady())
585:                   {
586:                       if (USBT1MSECIF && USBT1MSECIE)
587:                       {
588:                           if (USBOTGGetSRPTimeOutFlag())
589:                           {
590:                               if (USBOTGIsSRPTimeOutExpired())
591:                               {
592:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
593:                               }       
594:                           }
595:               
596:                           //Clear Interrupt Flag
597:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
598:                       }
599:                   }
600:               #endif
601:               
602:                   #if defined(USB_POLLING)
603:                   //If the interrupt option is selected then the customer is required
604:                   //  to notify the stack when the device is attached or removed from the
605:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
606:                   if (USB_BUS_SENSE != 1)
607:                   {
608:                        // Disable module & detach from bus
609:                        U1CON = 0;             
610:               
611:                        // Mask all USB interrupts              
612:                        U1IE = 0;          
613:               
614:                        //Move to the detached state                  
615:                        USBDeviceState = DETACHED_STATE;
616:               
617:                        #ifdef  USB_SUPPORT_OTG    
618:                            //Disable D+ Pullup
619:                            U1OTGCONbits.DPPULUP = 0;
620:               
621:                            //Disable HNP
622:                            USBOTGDisableHnp();
623:               
624:                            //Deactivate HNP
625:                            USBOTGDeactivateHnp();
626:                            
627:                            //If ID Pin Changed State
628:                            if (USBIDIF && USBIDIE)
629:                            {  
630:                                //Re-detect & Initialize
631:                                 USBOTGInitialize();
632:               
633:                                 //Clear ID Interrupt Flag
634:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
635:                            }
636:                        #endif
637:               
638:                        #ifdef __C30__
639:                            //USBClearInterruptFlag(U1OTGIR, 3); 
640:                        #endif
641:                           //return so that we don't go through the rest of 
642:                           //the state machine
643:                        USBClearUSBInterrupt();
644:                        return;
645:                   }
646:               
647:               	#ifdef USB_SUPPORT_OTG
648:                   //If Session Is Started Then
649:                   else
650:               	{
651:                       //If SRP Is Ready
652:                       if (USBOTGSRPIsReady())
653:                       {   
654:                           //Clear SRPReady
655:                           USBOTGClearSRPReady();
656:               
657:                           //Clear SRP Timeout Flag
658:                           USBOTGClearSRPTimeOutFlag();
659:               
660:                           //Indicate Session Started
661:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
662:                       }
663:                   }
664:               	#endif	//#ifdef USB_SUPPORT_OTG
665:               
666:                   //if we are in the detached state
667:                   if(USBDeviceState == DETACHED_STATE)
668:                   {
669:               	    //Initialize register to known value
670:                       U1CON = 0;                          
671:               
672:                       // Mask all USB interrupts
673:                       U1IE = 0;                                
674:               
675:                       //Enable/set things like: pull ups, full/low-speed mode, 
676:                       //set the ping pong mode, and set internal transceiver
677:                       SetConfigurationOptions();
678:               
679:                       // Enable module & attach to bus
680:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
681:               
682:                       //moved to the attached state
683:                       USBDeviceState = ATTACHED_STATE;
684:               
685:                       #ifdef  USB_SUPPORT_OTG
686:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
687:                       #endif
688:                   }
689:               	#endif  //#if defined(USB_POLLING)
690:               
691:                   if(USBDeviceState == ATTACHED_STATE)
  2A18    0100     MOVLB 0
  2A1A    0560     DECF 0x60, W, BANKED
  2A1C    E109     BNZ 0x2a30
692:                   {
693:                       /*
694:                        * After enabling the USB module, it takes some time for the
695:                        * voltage on the D+ or D- line to rise high enough to get out
696:                        * of the SE0 condition. The USB Reset interrupt should not be
697:                        * unmasked until the SE0 condition is cleared. This helps
698:                        * prevent the firmware from misinterpreting this unique event
699:                        * as a USB bus reset from the USB host.
700:                        */
701:               
702:                       if(!USBSE0Event)
  2A1E    BA65     BTFSC 0xf65, 0x5, ACCESS
  2A20    D007     BRA 0x2a30
703:                       {
704:                           USBClearInterruptRegister(U1IR);// Clear all USB interrupts
  2A22    6A62     CLRF 0xf62, ACCESS
705:                           #if defined(USB_POLLING)
706:                               U1IE=0;                        // Mask all USB interrupts
707:                           #endif
708:                           USBResetIE = 1;             // Unmask RESET interrupt
  2A24    010F     MOVLB 0xf
  2A26    8136     BSF 0x36, 0, BANKED
709:                           USBIdleIE = 1;             // Unmask IDLE interrupt
  2A28    8936     BSF 0x36, 0x4, BANKED
710:                           USBDeviceState = POWERED_STATE;
  2A2A    0100     MOVLB 0
  2A2C    0E02     MOVLW 0x2
  2A2E    6F60     MOVWF 0x60, BANKED
711:                       }
712:                   }
713:               
714:                   #ifdef  USB_SUPPORT_OTG
715:                       //If ID Pin Changed State
716:                       if (USBIDIF && USBIDIE)
717:                       {  
718:                           //Re-detect & Initialize
719:                           USBOTGInitialize();
720:               
721:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
722:                       }
723:                   #endif
724:               
725:                   /*
726:                    * Task A: Service USB Activity Interrupt
727:                    */
728:                   if(USBActivityIF && USBActivityIE)
  2A30    5062     MOVF 0xf62, W, ACCESS
  2A32    0B04     ANDLW 0x4
  2A34    E006     BZ 0x2a42
  2A36    010F     MOVLB 0xf
  2A38    5136     MOVF 0x36, W, BANKED
  2A3A    0B04     ANDLW 0x4
  2A3C    E002     BZ 0x2a42
729:                   {
730:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
  2A3E    9462     BCF 0xf62, 0x2, ACCESS
731:                       #if defined(USB_SUPPORT_OTG)
732:                           U1OTGIR = 0x10;        
733:                       #else
734:                           USBWakeFromSuspend();
  2A40    D8CE     RCALL 0x2bde
735:                       #endif
736:                   }
737:               
738:                   /*
739:                    * Pointless to continue servicing if the device is in suspend mode.
740:                    */
741:                   if(USBSuspendControl==1)
  2A42    B265     BTFSC 0xf65, 0x1, ACCESS
  2A44    D05C     BRA 0x2afe
742:                   {
743:                       USBClearUSBInterrupt();
744:                       return;
745:                   }
746:               
747:                   /*
748:                    * Task B: Service USB Bus Reset Interrupt.
749:                    * When bus reset is received during suspend, ACTVIF will be set first,
750:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
751:                    * This is why URSTIF is checked after ACTVIF.
752:                    *
753:                    * The USB reset flag is masked when the USB state is in
754:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
755:                    * cause a USB reset event during these two states.
756:                    */
757:                   if(USBResetIF && USBResetIE)
  2A46    5062     MOVF 0xf62, W, ACCESS
  2A48    0B01     ANDLW 0x1
  2A4A    E00A     BZ 0x2a60
  2A4C    010F     MOVLB 0xf
  2A4E    5136     MOVF 0x36, W, BANKED
  2A50    0B01     ANDLW 0x1
  2A52    E006     BZ 0x2a60
758:                   {
759:                       USBDeviceInit();
  2A54    DF4C     RCALL 0x28ee
760:               
761:                       //Re-enable the interrupts since the USBDeviceInit() function will
762:                       //  disable them.  This will do nothing in a polling setup
763:                       USBUnmaskInterrupts();
  2A56    88A0     BSF 0xfa0, 0x4, ACCESS
764:               
765:                       USBDeviceState = DEFAULT_STATE;
  2A58    0100     MOVLB 0
  2A5A    0E04     MOVLW 0x4
  2A5C    6F60     MOVWF 0x60, BANKED
766:               
767:                       #ifdef USB_SUPPORT_OTG
768:                            //Disable HNP
769:                            USBOTGDisableHnp();
770:               
771:                            //Deactivate HNP
772:                            USBOTGDeactivateHnp();
773:                       #endif
774:               
775:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
  2A5E    9062     BCF 0xf62, 0, ACCESS
776:                   }
777:               
778:                   /*
779:                    * Task C: Service other USB interrupts
780:                    */
781:                   if(USBIdleIF && USBIdleIE)
  2A60    5062     MOVF 0xf62, W, ACCESS
  2A62    0B10     ANDLW 0x10
  2A64    E006     BZ 0x2a72
  2A66    010F     MOVLB 0xf
  2A68    5136     MOVF 0x36, W, BANKED
  2A6A    0B10     ANDLW 0x10
  2A6C    E002     BZ 0x2a72
782:                   { 
783:                       #ifdef  USB_SUPPORT_OTG 
784:                           //If Suspended, Try to switch to Host
785:                           USBOTGSelectRole(ROLE_HOST);
786:                       #else
787:                           USBSuspend();
  2A6E    D8A1     RCALL 0x2bb2
788:                       #endif
789:                       
790:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
  2A70    9862     BCF 0xf62, 0x4, ACCESS
791:                   }
792:               
793:                   if(USBSOFIF)
  2A72    AC62     BTFSS 0xf62, 0x6, ACCESS
  2A74    D01A     BRA 0x2aaa
794:                   {
795:                       if(USBSOFIE)
  2A76    010F     MOVLB 0xf
  2A78    AD36     BTFSS 0x36, 0x6, BANKED
  2A7A    D00F     BRA 0x2a9a
796:                       {
797:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
  2A7C    0E01     MOVLW 0x1
  2A7E    6EE6     MOVWF 0xfe6, ACCESS
  2A80    6AE6     CLRF 0xfe6, ACCESS
  2A82    0E00     MOVLW 0
  2A84    6EE6     MOVWF 0xfe6, ACCESS
  2A86    6AE6     CLRF 0xfe6, ACCESS
  2A88    0E73     MOVLW 0x73
  2A8A    6EE6     MOVWF 0xfe6, ACCESS
  2A8C    6AE6     CLRF 0xfe6, ACCESS
  2A8E    ECF7     CALL 0x5bee, 0
  2A90    F02D     NOP
  2A92    6E14     MOVWF 0x14, ACCESS
  2A94    0E06     MOVLW 0x6
  2A96    5EE1     SUBWF 0xfe1, F, ACCESS
  2A98    5014     MOVF 0x14, W, ACCESS
798:                       }    
799:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
  2A9A    9C62     BCF 0xf62, 0x6, ACCESS
800:                       
801:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
802:                           //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
803:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
804:                               #warning "Double click this message.  See inline code comments."
805:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
806:                               //not strictly needed in all applications (ex: those that never call 
807:                               //USBDeferStatusStage() and don't use host to device (OUT) control
808:                               //transfers with data stage).  
809:                               //However, if this feature is enabled and used, it requires a timer 
810:                               //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
811:                               //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
812:                               //packets at a 1ms rate, which generates SOFIF interrupts.
813:                               //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
814:                               //below.  However, the host does not send SOF packets to Low Speed devices.  
815:                               //Therefore, some other method  (ex: using a general purpose microcontroller 
816:                               //timer, such as Timer0) needs to be implemented to call and execute the below code
817:                               //at a once/1ms rate, in a low speed USB application.
818:                               //Note: Pre-condition to executing the below code: USBDeviceInit() should have
819:                               //been called at least once (since the last microcontroller reset/power up), 
820:                               //prior to executing the below code.
821:                           #endif
822:                           
823:                           //Decrement our status stage counter.
824:                           if(USBStatusStageTimeoutCounter != 0u)
  2A9C    0100     MOVLB 0
  2A9E    5196     MOVF 0x96, W, BANKED
  2AA0    E001     BZ 0x2aa4
825:                           {
826:                               USBStatusStageTimeoutCounter--;
  2AA2    0796     DECF 0x96, F, BANKED
827:                           }
828:                           //Check if too much time has elapsed since progress was made in 
829:                           //processing the control transfer, without arming the status stage.  
830:                           //If so, auto-arm the status stage to ensure that the control 
831:                           //transfer can [eventually] complete, within the timing limits
832:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
833:                           if(USBStatusStageTimeoutCounter == 0)
  2AA4    5196     MOVF 0x96, W, BANKED
  2AA6    E101     BNZ 0x2aaa
834:                           {
835:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
  2AA8    DB54     RCALL 0x3152
836:                           } 
837:                       #endif
838:                   }
839:               
840:                   if(USBStallIF && USBStallIE)
  2AAA    5062     MOVF 0xf62, W, ACCESS
  2AAC    0B20     ANDLW 0x20
  2AAE    E005     BZ 0x2aba
  2AB0    010F     MOVLB 0xf
  2AB2    5136     MOVF 0x36, W, BANKED
  2AB4    0B20     ANDLW 0x20
  2AB6    E001     BZ 0x2aba
841:                   {
842:                       USBStallHandler();
  2AB8    D862     RCALL 0x2b7e
843:                   }
844:               
845:                   if(USBErrorIF && USBErrorIE)
  2ABA    5062     MOVF 0xf62, W, ACCESS
  2ABC    0B02     ANDLW 0x2
  2ABE    E014     BZ 0x2ae8
  2AC0    010F     MOVLB 0xf
  2AC2    5136     MOVF 0x36, W, BANKED
  2AC4    0B02     ANDLW 0x2
  2AC6    E010     BZ 0x2ae8
846:                   {
847:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
  2AC8    0E01     MOVLW 0x1
  2ACA    6EE6     MOVWF 0xfe6, ACCESS
  2ACC    6AE6     CLRF 0xfe6, ACCESS
  2ACE    0E00     MOVLW 0
  2AD0    6EE6     MOVWF 0xfe6, ACCESS
  2AD2    6AE6     CLRF 0xfe6, ACCESS
  2AD4    68E6     SETF 0xfe6, ACCESS
  2AD6    0E7F     MOVLW 0x7f
  2AD8    6EE6     MOVWF 0xfe6, ACCESS
  2ADA    ECF7     CALL 0x5bee, 0
  2ADC    F02D     NOP
  2ADE    6E14     MOVWF 0x14, ACCESS
  2AE0    0E06     MOVLW 0x6
  2AE2    5EE1     SUBWF 0xfe1, F, ACCESS
  2AE4    5014     MOVF 0x14, W, ACCESS
848:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
  2AE6    6A63     CLRF 0xf63, ACCESS
849:               
850:                       //On PIC18 or PIC24F, clearing the source of the error will automatically
851:                       //  clear the interrupt flag.  On PIC32 the interrut flag must be manually
852:                       //  cleared. 
853:                       #if defined(__C32__) || defined(__C30__)
854:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
855:                       #endif
856:                   }
857:               
858:                   /*
859:                    * Pointless to continue servicing if the host has not sent a bus reset.
860:                    * Once bus reset is received, the device transitions into the DEFAULT
861:                    * state and is ready for communication.
862:                    */
863:                   if(USBDeviceState < DEFAULT_STATE)
  2AE8    0E04     MOVLW 0x4
  2AEA    0100     MOVLB 0
  2AEC    6EE7     MOVWF 0xfe7, ACCESS
  2AEE    1960     XORWF 0x60, W, BANKED
  2AF0    AEE8     BTFSS 0xfe8, 0x7, ACCESS
  2AF2    D002     BRA 0x2af8
  2AF4    34E7     RLCF 0xfe7, W, ACCESS
  2AF6    D002     BRA 0x2afc
  2AF8    50E7     MOVF 0xfe7, W, ACCESS
  2AFA    5D60     SUBWF 0x60, W, BANKED
  2AFC    E202     BC 0x2b02
864:                   {
865:               	    USBClearUSBInterrupt();
  2AFE    98A1     BCF 0xfa1, 0x4, ACCESS
866:               	    return; 
  2B00    D039     BRA 0x2b74
867:               	}  
868:               
869:                   /*
870:                    * Task D: Servicing USB Transaction Complete Interrupt
871:                    */
872:                   if(USBTransactionCompleteIE)
  2B02    010F     MOVLB 0xf
  2B04    A736     BTFSS 0x36, 0x3, BANKED
  2B06    D035     BRA 0x2b72
873:                   {
874:               	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
  2B08    6ADF     CLRF 0xfdf, ACCESS
  2B0A    0E04     MOVLW 0x4
  2B0C    5CDF     SUBWF 0xfdf, W, ACCESS
  2B0E    E231     BC 0x2b72
  2B6E    2ADF     INCF 0xfdf, F, ACCESS
  2B70    D7CC     BRA 0x2b0a
875:               		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
876:               		    if(USBTransactionCompleteIF)
  2B10    A662     BTFSS 0xf62, 0x3, ACCESS
  2B12    D02F     BRA 0x2b72
877:               		    {
878:                   		    //Save and extract USTAT register info.  Will use this info later.
879:                               USTATcopy.Val = U1STAT;
  2B14    CF64     MOVFF 0xf64, 0x8b
  2B16    F08B     NOP
880:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
  2B18    0100     MOVLB 0
  2B1A    518B     MOVF 0x8b, W, BANKED
  2B1C    0B78     ANDLW 0x78
  2B1E    42E8     RRNCF 0xfe8, F, ACCESS
  2B20    42E8     RRNCF 0xfe8, F, ACCESS
  2B22    42E8     RRNCF 0xfe8, F, ACCESS
  2B24    6F8C     MOVWF 0x8c, BANKED
881:                               
882:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
  2B26    9662     BCF 0xf62, 0x3, ACCESS
883:                               
884:                               //Keep track of the hardware ping pong state for endpoints other
885:                               //than EP0, if ping pong buffering is enabled.
886:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
887:                                   if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
  2B28    B58B     BTFSC 0x8b, 0x2, BANKED
  2B2A    D006     BRA 0x2b38
888:                                   {
889:                                       ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
  2B2C    518C     MOVF 0x8c, W, BANKED
  2B2E    6AEA     CLRF 0xfea, ACCESS
  2B30    0F92     ADDLW 0x92
  2B32    6EE9     MOVWF 0xfe9, ACCESS
  2B34    0E00     MOVLW 0
890:                                   }   
891:                                   else
  2B36    D005     BRA 0x2b42
892:                                   {
893:                                       ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
  2B38    518C     MOVF 0x8c, W, BANKED
  2B3A    6AEA     CLRF 0xfea, ACCESS
  2B3C    0F8E     ADDLW 0x8e
  2B3E    6EE9     MOVWF 0xfe9, ACCESS
  2B40    0E00     MOVLW 0
  2B42    22EA     ADDWFC 0xfea, F, ACCESS
  2B44    70EF     BTG 0xfef, 0, ACCESS
894:                                   }         
895:                               #endif    
896:                               
897:                               //USBCtrlEPService only services transactions over EP0.
898:                               //It ignores all other EP transactions.
899:                               if(endpoint_number == 0)
  2B46    518C     MOVF 0x8c, W, BANKED
  2B48    E102     BNZ 0x2b4e
900:                               {
901:                                   USBCtrlEPService();
  2B4A    D861     RCALL 0x2c0e
902:                               }
903:                               else
  2B4C    D010     BRA 0x2b6e
904:                               {
905:                                   USB_TRASFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
  2B4E    0E00     MOVLW 0
  2B50    6EE6     MOVWF 0xfe6, ACCESS
  2B52    6AE6     CLRF 0xfe6, ACCESS
  2B54    0E8B     MOVLW 0x8b
  2B56    6EE6     MOVWF 0xfe6, ACCESS
  2B58    0E00     MOVLW 0
  2B5A    6EE6     MOVWF 0xfe6, ACCESS
  2B5C    0E72     MOVLW 0x72
  2B5E    6EE6     MOVWF 0xfe6, ACCESS
  2B60    6AE6     CLRF 0xfe6, ACCESS
  2B62    ECF7     CALL 0x5bee, 0
  2B64    F02D     NOP
  2B66    6E14     MOVWF 0x14, ACCESS
  2B68    0E06     MOVLW 0x6
  2B6A    5EE1     SUBWF 0xfe1, F, ACCESS
  2B6C    5014     MOVF 0x14, W, ACCESS
906:                               }
907:               		    }//end if(USBTransactionCompleteIF)
908:               		    else
909:               		    	break;	//USTAT FIFO must be empty.
910:               		}//end for()
911:               	}//end if(USBTransactionCompleteIE)   
912:               
913:                   USBClearUSBInterrupt();
  2B72    98A1     BCF 0xfa1, 0x4, ACCESS
914:               }//end of USBDeviceTasks()
  2B74    52E5     MOVF 0xfe5, F, ACCESS
  2B76    52E5     MOVF 0xfe5, F, ACCESS
  2B78    CFE7     MOVFF 0xfe7, 0xfd9
  2B7A    FFD9     NOP
  2B7C    0012     RETURN 0
915:               
916:               /********************************************************************
917:                * Function:        void USBStallHandler(void)
918:                *
919:                * PreCondition:    None
920:                *
921:                * Input:           None
922:                *
923:                * Output:          None
924:                *
925:                * Side Effects:    
926:                *
927:                * Overview:        This function handles the event of a STALL 
928:                *                  occuring on the bus
929:                *
930:                * Note:            None
931:                *******************************************************************/
932:               static void USBStallHandler(void)
933:               {
934:                   /*
935:                    * Does not really have to do anything here,
936:                    * even for the control endpoint.
937:                    * All BDs of Endpoint 0 are owned by SIE right now,
938:                    * but once a Setup Transaction is received, the ownership
939:                    * for EP0_OUT will be returned to CPU.
940:                    * When the Setup Transaction is serviced, the ownership
941:                    * for EP0_IN will then be forced back to CPU by firmware.
942:                    */
943:               
944:                   /* v2b fix */
945:                   if(U1EP0bits.EPSTALL == 1)
  2B7E    010F     MOVLB 0xf
  2B80    A126     BTFSS 0x26, 0, BANKED
  2B82    D015     BRA 0x2bae
946:                   {
947:                       // UOWN - if 0, owned by CPU, if 1, owned by SIE
948:                       if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
  2B84    C063     MOVFF 0x63, 0xfe9
  2B86    FFE9     NOP
  2B88    C064     MOVFF 0x64, 0xfea
  2B8A    FFEA     NOP
  2B8C    50EF     MOVF 0xfef, W, ACCESS
  2B8E    0880     SUBLW 0x80
  2B90    E10D     BNZ 0x2bac
  2B92    C06F     MOVFF 0x6f, 0xfe9
  2B94    FFE9     NOP
  2B96    C070     MOVFF 0x70, 0xfea
  2B98    FFEA     NOP
  2B9A    50EF     MOVF 0xfef, W, ACCESS
  2B9C    0884     SUBLW 0x84
  2B9E    E106     BNZ 0x2bac
949:                       {
950:                           // Set ep0Bo to stall also
951:                           pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
  2BA0    C063     MOVFF 0x63, 0xfe9
  2BA2    FFE9     NOP
  2BA4    C064     MOVFF 0x64, 0xfea
  2BA6    FFEA     NOP
  2BA8    0E8C     MOVLW 0x8c
  2BAA    6EEF     MOVWF 0xfef, ACCESS
952:                       }//end if
953:                       U1EP0bits.EPSTALL = 0;               // Clear stall status
  2BAC    9126     BCF 0x26, 0, BANKED
954:                   }//end if
955:               
956:                   USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
  2BAE    9A62     BCF 0xf62, 0x5, ACCESS
957:               }
  2BB0    0012     RETURN 0
958:               
959:               /********************************************************************
960:                * Function:        void USBSuspend(void)
961:                *
962:                * PreCondition:    None
963:                *
964:                * Input:           None
965:                *
966:                * Output:          None
967:                *
968:                * Side Effects:    
969:                *
970:                * Overview:        This function handles if the host tries to 
971:                *                  suspend the device
972:                *
973:                * Note:            None
974:                *******************************************************************/
975:               static void USBSuspend(void)
976:               {
977:                   /*
978:                    * NOTE: Do not clear UIRbits.ACTVIF here!
979:                    * Reason:
980:                    * ACTVIF is only generated once an IDLEIF has been generated.
981:                    * This is a 1:1 ratio interrupt generation.
982:                    * For every IDLEIF, there will be only one ACTVIF regardless of
983:                    * the number of subsequent bus transitions.
984:                    *
985:                    * If the ACTIF is cleared here, a problem could occur when:
986:                    * [       IDLE       ][bus activity ->
987:                    * <--- 3 ms ----->     ^
988:                    *                ^     ACTVIF=1
989:                    *                IDLEIF=1
990:                    *  #           #           #           #   (#=Program polling flags)
991:                    *                          ^
992:                    *                          This polling loop will see both
993:                    *                          IDLEIF=1 and ACTVIF=1.
994:                    *                          However, the program services IDLEIF first
995:                    *                          because ACTIVIE=0.
996:                    *                          If this routine clears the only ACTIVIF,
997:                    *                          then it can never get out of the suspend
998:                    *                          mode.
999:                    */
1000:                  USBActivityIE = 1;                     // Enable bus activity interrupt
  2BB2    010F     MOVLB 0xf
  2BB4    8536     BSF 0x36, 0x2, BANKED
1001:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
  2BB6    9862     BCF 0xf62, 0x4, ACCESS
1002:              
1003:              #if defined(__18CXX)
1004:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
  2BB8    8265     BSF 0xf65, 0x1, ACCESS
1005:                                                          // mode, SIE clock inactive
1006:              #endif
1007:                  USBBusIsSuspended = TRUE;
  2BBA    0100     MOVLB 0
  2BBC    0E01     MOVLW 0x1
  2BBE    6F8A     MOVWF 0x8a, BANKED
1008:               
1009:                  /*
1010:                   * At this point the PIC can go into sleep,idle, or
1011:                   * switch to a slower clock, etc.  This should be done in the
1012:                   * USBCBSuspend() if necessary.
1013:                   */
1014:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
  2BC0    0E00     MOVLW 0
  2BC2    6EE6     MOVWF 0xfe6, ACCESS
  2BC4    6AE6     CLRF 0xfe6, ACCESS
  2BC6    6EE6     MOVWF 0xfe6, ACCESS
  2BC8    6AE6     CLRF 0xfe6, ACCESS
  2BCA    0E75     MOVLW 0x75
  2BCC    6EE6     MOVWF 0xfe6, ACCESS
  2BCE    6AE6     CLRF 0xfe6, ACCESS
  2BD0    ECF7     CALL 0x5bee, 0
  2BD2    F02D     NOP
  2BD4    6E14     MOVWF 0x14, ACCESS
  2BD6    0E06     MOVLW 0x6
  2BD8    5EE1     SUBWF 0xfe1, F, ACCESS
  2BDA    5014     MOVF 0x14, W, ACCESS
1015:              }
  2BDC    0012     RETURN 0
1016:              
1017:              /********************************************************************
1018:               * Function:        void USBWakeFromSuspend(void)
1019:               *
1020:               * PreCondition:    None
1021:               *
1022:               * Input:           None
1023:               *
1024:               * Output:          None
1025:               *
1026:               * Side Effects:    None
1027:               *
1028:               * Overview:
1029:               *
1030:               * Note:            None
1031:               *******************************************************************/
1032:              static void USBWakeFromSuspend(void)
1033:              {
1034:                  USBBusIsSuspended = FALSE;
  2BDE    0100     MOVLB 0
  2BE0    6B8A     CLRF 0x8a, BANKED
1035:              
1036:                  /*
1037:                   * If using clock switching, the place to restore the original
1038:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
1039:                   */
1040:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
  2BE2    0E00     MOVLW 0
  2BE4    6EE6     MOVWF 0xfe6, ACCESS
  2BE6    6AE6     CLRF 0xfe6, ACCESS
  2BE8    6EE6     MOVWF 0xfe6, ACCESS
  2BEA    6AE6     CLRF 0xfe6, ACCESS
  2BEC    0E74     MOVLW 0x74
  2BEE    6EE6     MOVWF 0xfe6, ACCESS
  2BF0    6AE6     CLRF 0xfe6, ACCESS
  2BF2    ECF7     CALL 0x5bee, 0
  2BF4    F02D     NOP
  2BF6    6E14     MOVWF 0x14, ACCESS
  2BF8    0E06     MOVLW 0x6
  2BFA    5EE1     SUBWF 0xfe1, F, ACCESS
  2BFC    5014     MOVF 0x14, W, ACCESS
1041:              
1042:                  #if defined(__18CXX)
1043:                      //To avoid improperly clocking the USB module, make sure the oscillator
1044:                      //settings are consistant with USB operation before clearing the SUSPND bit.
1045:                      //Make sure the correct oscillator settings are selected in the 
1046:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
1047:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
  2BFE    9265     BCF 0xf65, 0x1, ACCESS
1048:                                              // mode.
1049:                  #endif
1050:              
1051:              
1052:                  USBActivityIE = 0;
  2C00    010F     MOVLB 0xf
  2C02    9536     BCF 0x36, 0x2, BANKED
1053:              
1054:                  /********************************************************************
1055:                  Bug Fix: Feb 26, 2007 v2.1
1056:                  *********************************************************************
1057:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
1058:                  up from Suspend or while the USB module is suspended. A few clock cycles
1059:                  are required to synchronize the internal hardware state machine before
1060:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
1061:                  before the internal hardware is synchronized may not have an effect on
1062:                  the value of ACTVIF. Additonally, if the USB module uses the clock from
1063:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
1064:                  module may not be immediately operational while waiting for the 96 MHz
1065:                  PLL to lock.
1066:                  ********************************************************************/
1067:              
1068:                  // UIRbits.ACTVIF = 0;                      // Removed
1069:                  #if defined(__18CXX)
1070:                  while(USBActivityIF)
  2C04    A462     BTFSS 0xf62, 0x2, ACCESS
  2C06    D002     BRA 0x2c0c
  2C0A    D7FC     BRA 0x2c04
1071:                  #endif
1072:                  {
1073:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
  2C08    9462     BCF 0xf62, 0x2, ACCESS
1074:                  }  // Added
1075:              
1076:              }//end USBWakeFromSuspend
  2C0C    0012     RETURN 0
1077:              
1078:              /********************************************************************
1079:               * Function:        void USBCtrlEPService(void)
1080:               *
1081:               * PreCondition:    USTAT is loaded with a valid endpoint address.
1082:               *
1083:               * Input:           None
1084:               *
1085:               * Output:          None
1086:               *
1087:               * Side Effects:    None
1088:               *
1089:               * Overview:        USBCtrlEPService checks for three transaction
1090:               *                  types that it knows how to service and services
1091:               *                  them:
1092:               *                  1. EP0 SETUP
1093:               *                  2. EP0 OUT
1094:               *                  3. EP0 IN
1095:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
1096:               *
1097:               * Note:            None
1098:               *******************************************************************/
1099:              static void USBCtrlEPService(void)
  2C0E    CFD9     MOVFF 0xfd9, 0xfe6
  2C10    FFE6     NOP
  2C12    CFE1     MOVFF 0xfe1, 0xfd9
  2C14    FFD9     NOP
  2C16    52E6     MOVF 0xfe6, F, ACCESS
1100:              {
1101:                  //If we get to here, that means a successful transaction has just occurred 
1102:                  //on EP0.  This means "progress" has occurred in the currently pending 
1103:                  //control transfer, so we should re-initialize our timeout counter.
1104:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
1105:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
  2C18    0100     MOVLB 0
  2C1A    0E2D     MOVLW 0x2d
  2C1C    6F96     MOVWF 0x96, BANKED
1106:                  #endif
1107:              	
1108:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
1109:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
  2C1E    0EFD     MOVLW 0xfd
  2C20    158B     ANDWF 0x8b, W, BANKED
  2C22    E153     BNZ 0x2cca
1110:                  {
1111:              		//Point to the EP0 OUT buffer of the buffer that arrived
1112:                      #if defined(__18CXX)
1113:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
  2C24    0E7E     MOVLW 0x7e
  2C26    158B     ANDWF 0x8b, W, BANKED
  2C28    40E8     RRNCF 0xfe8, W, ACCESS
  2C2A    0B7F     ANDLW 0x7f
  2C2C    0D04     MULLW 0x4
  2C2E    CFF3     MOVFF 0xff3, 0x63
  2C30    F063     NOP
  2C32    CFF4     MOVFF 0xff4, 0x64
  2C34    F064     NOP
  2C36    0E00     MOVLW 0
  2C38    2763     ADDWF 0x63, F, BANKED
  2C3A    0E04     MOVLW 0x4
  2C3C    2364     ADDWFC 0x64, F, BANKED
1114:                      #elif defined(__C30__) || defined(__C32__)
1115:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
1116:                      #else
1117:                          #error "unimplemented"
1118:                      #endif
1119:              
1120:              		//Set the next out to the current out packet
1121:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
  2C3E    C063     MOVFF 0x63, 0x65
  2C40    F065     NOP
  2C42    C064     MOVFF 0x64, 0x66
  2C44    F066     NOP
1122:              		//Toggle it to the next ping pong buffer (if applicable)
1123:                      ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
  2C46    7565     BTG 0x65, 0x2, BANKED
1124:              
1125:              		//If the current EP0 OUT buffer has a SETUP packet
1126:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
  2C48    C063     MOVFF 0x63, 0xfe9
  2C4A    FFE9     NOP
  2C4C    C064     MOVFF 0x64, 0xfea
  2C4E    FFEA     NOP
  2C50    50EF     MOVF 0xfef, W, ACCESS
  2C52    0B3C     ANDLW 0x3c
  2C54    42E8     RRNCF 0xfe8, F, ACCESS
  2C56    42E8     RRNCF 0xfe8, F, ACCESS
  2C58    080D     SUBLW 0xd
  2C5A    E135     BNZ 0x2cc6
1127:                      {
1128:                          unsigned char setup_cnt;
1129:              
1130:              	        //The SETUP transaction data may have gone into the the CtrlTrfData 
1131:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
1132:              	        //before the transaction.  Therefore, we should copy the data to the 
1133:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
1134:                          for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
  2C5C    6ADF     CLRF 0xfdf, ACCESS
  2C5E    0E08     MOVLW 0x8
  2C60    5CDF     SUBWF 0xfdf, W, ACCESS
  2C62    E223     BC 0x2caa
  2CA6    2ADF     INCF 0xfdf, F, ACCESS
  2CA8    D7DA     BRA 0x2c5e
1135:                          {
1136:                              *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
  2C64    C063     MOVFF 0x63, 0xfe9
  2C66    FFE9     NOP
  2C68    C064     MOVFF 0x64, 0xfea
  2C6A    FFEA     NOP
  2C6C    0E02     MOVLW 0x2
  2C6E    26E9     ADDWF 0xfe9, F, ACCESS
  2C70    0E00     MOVLW 0
  2C72    22EA     ADDWFC 0xfea, F, ACCESS
  2C74    50EE     MOVF 0xfee, W, ACCESS
  2C76    CFEF     MOVFF 0xfef, 0xfea
  2C78    FFEA     NOP
  2C7A    6EE9     MOVWF 0xfe9, ACCESS
  2C7C    50EF     MOVF 0xfef, W, ACCESS
  2C7E    6EE6     MOVWF 0xfe6, ACCESS
  2C80    50DF     MOVF 0xfdf, W, ACCESS
  2C82    6AEA     CLRF 0xfea, ACCESS
  2C84    0F40     ADDLW 0x40
  2C86    6EE9     MOVWF 0xfe9, ACCESS
  2C88    0E04     MOVLW 0x4
  2C8A    22EA     ADDWFC 0xfea, F, ACCESS
  2C8C    52E5     MOVF 0xfe5, F, ACCESS
  2C8E    50E7     MOVF 0xfe7, W, ACCESS
  2C90    6EEF     MOVWF 0xfef, ACCESS
1137:                              pBDTEntryEP0OutCurrent->ADR++;
  2C92    C063     MOVFF 0x63, 0xfe9
  2C94    FFE9     NOP
  2C96    C064     MOVFF 0x64, 0xfea
  2C98    FFEA     NOP
  2C9A    0E02     MOVLW 0x2
  2C9C    26E9     ADDWF 0xfe9, F, ACCESS
  2C9E    0E00     MOVLW 0
  2CA0    22EA     ADDWFC 0xfea, F, ACCESS
  2CA2    2AEE     INCF 0xfee, F, ACCESS
  2CA4    22EF     ADDWFC 0xfef, F, ACCESS
1138:                          }    
1139:                          pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
  2CAA    C063     MOVFF 0x63, 0xfe9
  2CAC    FFE9     NOP
  2CAE    C064     MOVFF 0x64, 0xfea
  2CB0    FFEA     NOP
  2CB2    0E02     MOVLW 0x2
  2CB4    26E9     ADDWF 0xfe9, F, ACCESS
  2CB6    0E00     MOVLW 0
  2CB8    22EA     ADDWFC 0xfea, F, ACCESS
  2CBA    0E40     MOVLW 0x40
  2CBC    6EEE     MOVWF 0xfee, ACCESS
  2CBE    0E04     MOVLW 0x4
  2CC0    6EED     MOVWF 0xfed, ACCESS
1140:              
1141:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
1142:                          USBCtrlTrfSetupHandler();
  2CC2    D80D     RCALL 0x2cde
1143:                      }
1144:                      else
  2CC4    D007     BRA 0x2cd4
1145:                      {
1146:              			//Handle the DATA transfer
1147:                          USBCtrlTrfOutHandler();
  2CC6    D83A     RCALL 0x2d3c
1148:                      }
1149:                  }
1150:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
  2CC8    D005     BRA 0x2cd4
  2CCA    0EFD     MOVLW 0xfd
  2CCC    158B     ANDWF 0x8b, W, BANKED
  2CCE    0804     SUBLW 0x4
  2CD0    E101     BNZ 0x2cd4
1151:                  {
1152:              		//Otherwise the transmission was and EP0 IN
1153:              		//  so take care of the IN transfer
1154:                      USBCtrlTrfInHandler();
  2CD2    D859     RCALL 0x2d86
1155:                  }
1156:              
1157:              }//end USBCtrlEPService
  2CD4    52E5     MOVF 0xfe5, F, ACCESS
  2CD6    52E5     MOVF 0xfe5, F, ACCESS
  2CD8    CFE7     MOVFF 0xfe7, 0xfd9
  2CDA    FFD9     NOP
  2CDC    0012     RETURN 0
1158:              
1159:              /********************************************************************
1160:               * Function:        void USBCtrlTrfSetupHandler(void)
1161:               *
1162:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
1163:               *
1164:               * Input:           None
1165:               *
1166:               * Output:          None
1167:               *
1168:               * Side Effects:    None
1169:               *
1170:               * Overview:        This routine is a task dispatcher and has 3 stages.
1171:               *                  1. It initializes the control transfer state machine.
1172:               *                  2. It calls on each of the module that may know how to
1173:               *                     service the Setup Request from the host.
1174:               *                     Module Example: USBD, HID, CDC, MSD, ...
1175:               *                     A callback function, USBCBCheckOtherReq(),
1176:               *                     is required to call other module handlers.
1177:               *                  3. Once each of the modules has had a chance to check if
1178:               *                     it is responsible for servicing the request, stage 3
1179:               *                     then checks direction of the transfer to determine how
1180:               *                     to prepare EP0 for the control transfer.
1181:               *                     Refer to USBCtrlEPServiceComplete() for more details.
1182:               *
1183:               * Note:            Microchip USB Firmware has three different states for
1184:               *                  the control transfer state machine:
1185:               *                  1. WAIT_SETUP
1186:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
1187:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
1188:               *                  Refer to firmware manual to find out how one state
1189:               *                  is transitioned to another.
1190:               *
1191:               *                  A Control Transfer is composed of many USB transactions.
1192:               *                  When transferring data over multiple transactions,
1193:               *                  it is important to keep track of data source, data
1194:               *                  destination, and data count. These three parameters are
1195:               *                  stored in pSrc,pDst, and wCount. A flag is used to
1196:               *                  note if the data source is from ROM or RAM.
1197:               *
1198:               *******************************************************************/
1199:              static void USBCtrlTrfSetupHandler(void)
1200:              {
1201:                  //--------------------------------------------------------------------------
1202:                  //1. Re-initialize state tracking variables related to control transfers.
1203:                  //--------------------------------------------------------------------------
1204:                  shortPacketStatus = SHORT_PKT_NOT_USED;  
  2CDE    0100     MOVLB 0
  2CE0    6B77     CLRF 0x77, BANKED
1205:                  USBDeferStatusStagePacket = FALSE;
  2CE2    6B97     CLRF 0x97, BANKED
1206:                  USBDeferINDataStagePackets = FALSE;
  2CE4    6B9A     CLRF 0x9a, BANKED
1207:                  USBDeferOUTDataStagePackets = FALSE;
  2CE6    6B9B     CLRF 0x9b, BANKED
1208:                  BothEP0OutUOWNsSet = FALSE;    
  2CE8    6B8D     CLRF 0x8d, BANKED
1209:                  controlTransferState = WAIT_SETUP;
  2CEA    6B78     CLRF 0x78, BANKED
1210:              
1211:                  //Abandon any previous control transfers that might have been using EP0.
1212:                  //Ordinarily, nothing actually needs abandoning, since the previous control
1213:                  //transfer would have completed successfully prior to the host sending the next
1214:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
1215:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
1216:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
1217:                  //by the class request handler that will be called next.
1218:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
  2CEC    C06F     MOVFF 0x6f, 0xfe9
  2CEE    FFE9     NOP
  2CF0    C070     MOVFF 0x70, 0xfea
  2CF2    FFEA     NOP
  2CF4    9EEF     BCF 0xfef, 0x7, ACCESS
1219:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
  2CF6    756F     BTG 0x6f, 0x2, BANKED
1220:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
  2CF8    C06F     MOVFF 0x6f, 0xfe9
  2CFA    FFE9     NOP
  2CFC    C070     MOVFF 0x70, 0xfea
  2CFE    FFEA     NOP
  2D00    9EEF     BCF 0xfef, 0x7, ACCESS
1221:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
  2D02    756F     BTG 0x6f, 0x2, BANKED
1222:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
  2D04    C065     MOVFF 0x65, 0xfe9
  2D06    FFE9     NOP
  2D08    C066     MOVFF 0x66, 0xfea
  2D0A    FFEA     NOP
  2D0C    9EEF     BCF 0xfef, 0x7, ACCESS
1223:              
1224:                  inPipes[0].info.Val = 0;
  2D0E    6B7C     CLRF 0x7c, BANKED
1225:                  inPipes[0].wCount.Val = 0;
  2D10    6B7D     CLRF 0x7d, BANKED
  2D12    6B7E     CLRF 0x7e, BANKED
1226:                  outPipes[0].info.Val = 0;
  2D14    6B81     CLRF 0x81, BANKED
1227:                  outPipes[0].wCount.Val = 0;
  2D16    6B82     CLRF 0x82, BANKED
  2D18    6B83     CLRF 0x83, BANKED
1228:                  
1229:              
1230:                  //--------------------------------------------------------------------------
1231:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
1232:                  //--------------------------------------------------------------------------
1233:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
  2D1A    D892     RCALL 0x2e40
1234:                  USB_DISABLE_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
  2D1C    0E00     MOVLW 0
  2D1E    6EE6     MOVWF 0xfe6, ACCESS
  2D20    6AE6     CLRF 0xfe6, ACCESS
  2D22    6EE6     MOVWF 0xfe6, ACCESS
  2D24    6AE6     CLRF 0xfe6, ACCESS
  2D26    0E03     MOVLW 0x3
  2D28    6EE6     MOVWF 0xfe6, ACCESS
  2D2A    6AE6     CLRF 0xfe6, ACCESS
  2D2C    ECF7     CALL 0x5bee, 0
  2D2E    F02D     NOP
  2D30    6E14     MOVWF 0x14, ACCESS
  2D32    0E06     MOVLW 0x6
  2D34    5EE1     SUBWF 0xfe1, F, ACCESS
  2D36    5014     MOVF 0x14, W, ACCESS
1235:              
1236:              
1237:                  //--------------------------------------------------------------------------
1238:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
1239:                  //   progress.  If one of the above handlers (in step 2) knew how to process
1240:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
1241:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
1242:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to 
1243:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
1244:                  //   process the request.  In this case, the default behavior will be to
1245:                  //   perform protocol STALL on EP0.
1246:                  //-------------------------------------------------------------------------- 
1247:                  USBCtrlEPServiceComplete();
  2D38    EF36     GOTO 0x346c
  2D3A    F01A     NOP
1248:              }//end USBCtrlTrfSetupHandler
1249:              
1250:              
1251:              /******************************************************************************
1252:               * Function:        void USBCtrlTrfOutHandler(void)
1253:               *
1254:               * PreCondition:    None
1255:               *
1256:               * Input:           None
1257:               *
1258:               * Output:          None
1259:               *
1260:               * Side Effects:    None
1261:               *
1262:               * Overview:        This routine handles an OUT transaction according to
1263:               *                  which control transfer state is currently active.
1264:               *
1265:               * Note:            Note that if the the control transfer was from
1266:               *                  host to device, the session owner should be notified
1267:               *                  at the end of each OUT transaction to service the
1268:               *                  received data.
1269:               *
1270:               *****************************************************************************/
1271:              static void USBCtrlTrfOutHandler(void)
1272:              {
1273:                  if(controlTransferState == CTRL_TRF_RX)
  2D3C    0E02     MOVLW 0x2
  2D3E    0100     MOVLB 0
  2D40    5D78     SUBWF 0x78, W, BANKED
  2D42    E102     BNZ 0x2d48
1274:                  {
1275:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
  2D44    EFF9     GOTO 0x35f2
  2D46    F01A     NOP
1276:                  }
1277:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
1278:                  {
1279:                      //If the status stage is complete, this means we are done with the 
1280:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
1281:                      controlTransferState = WAIT_SETUP;
  2D48    6B78     CLRF 0x78, BANKED
1282:              
1283:              	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
1284:              	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
1285:              	    //and the last control transfer was of direction: device to host, see
1286:              	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
1287:              	    //to do anything to the BDT.
1288:              		if(BothEP0OutUOWNsSet == FALSE)
  2D4A    518D     MOVF 0x8d, W, BANKED
  2D4C    E11A     BNZ 0x2d82
1289:              		{
1290:              	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  2D4E    C065     MOVFF 0x65, 0xfe9
  2D50    FFE9     NOP
  2D52    C066     MOVFF 0x66, 0xfea
  2D54    FFEA     NOP
  2D56    52EE     MOVF 0xfee, F, ACCESS
  2D58    0E08     MOVLW 0x8
  2D5A    6EEF     MOVWF 0xfef, ACCESS
1291:              	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  2D5C    C065     MOVFF 0x65, 0xfe9
  2D5E    FFE9     NOP
  2D60    C066     MOVFF 0x66, 0xfea
  2D62    FFEA     NOP
  2D64    0E02     MOVLW 0x2
  2D66    26E9     ADDWF 0xfe9, F, ACCESS
  2D68    0E00     MOVLW 0
  2D6A    22EA     ADDWFC 0xfea, F, ACCESS
  2D6C    0E40     MOVLW 0x40
  2D6E    6EEE     MOVWF 0xfee, ACCESS
  2D70    0E04     MOVLW 0x4
  2D72    6EED     MOVWF 0xfed, ACCESS
1292:              	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;			
  2D74    C065     MOVFF 0x65, 0xfe9
  2D76    FFE9     NOP
  2D78    C066     MOVFF 0x66, 0xfea
  2D7A    FFEA     NOP
  2D7C    0E8C     MOVLW 0x8c
  2D7E    6EEF     MOVWF 0xfef, ACCESS
1293:              		}
1294:              		else
  2D80    0012     RETURN 0
1295:              		{
1296:              			BothEP0OutUOWNsSet = FALSE;
  2D82    6B8D     CLRF 0x8d, BANKED
1297:              		}
1298:                  }
1299:              }
  2D84    0012     RETURN 0
1300:              
1301:              /******************************************************************************
1302:               * Function:        void USBCtrlTrfInHandler(void)
1303:               *
1304:               * PreCondition:    None
1305:               *
1306:               * Input:           None
1307:               *
1308:               * Output:          None
1309:               *
1310:               * Side Effects:    None
1311:               *
1312:               * Overview:        This routine handles an IN transaction according to
1313:               *                  which control transfer state is currently active.
1314:               *
1315:               * Note:            A Set Address Request must not change the acutal address
1316:               *                  of the device until the completion of the control
1317:               *                  transfer. The end of the control transfer for Set Address
1318:               *                  Request is an IN transaction. Therefore it is necessary
1319:               *                  to service this unique situation when the condition is
1320:               *                  right. Macro mUSBCheckAdrPendingState is defined in
1321:               *                  usb9.h and its function is to specifically service this
1322:               *                  event.
1323:               *****************************************************************************/
1324:              static void USBCtrlTrfInHandler(void)
  2D86    CFD9     MOVFF 0xfd9, 0xfe6
  2D88    FFE6     NOP
  2D8A    CFE1     MOVFF 0xfe1, 0xfd9
  2D8C    FFD9     NOP
  2D8E    52E6     MOVF 0xfe6, F, ACCESS
1325:              {
1326:                  BYTE lastDTS;
1327:              
1328:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
  2D90    C06F     MOVFF 0x6f, 0xfe9
  2D92    FFE9     NOP
  2D94    C070     MOVFF 0x70, 0xfea
  2D96    FFEA     NOP
  2D98    50EF     MOVF 0xfef, W, ACCESS
  2D9A    0B40     ANDLW 0x40
  2D9C    E001     BZ 0x2da0
  2D9E    0E01     MOVLW 0x1
  2DA0    6EDF     MOVWF 0xfdf, ACCESS
1329:              
1330:                  //switch to the next ping pong buffer
1331:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
  2DA2    0100     MOVLB 0
  2DA4    756F     BTG 0x6f, 0x2, BANKED
1332:              
1333:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
1334:                  //now, since the IN status stage of the control transfer has evidently
1335:                  //completed successfully.
1336:                  if(USBDeviceState == ADR_PENDING_STATE)
  2DA6    0E08     MOVLW 0x8
  2DA8    5D60     SUBWF 0x60, W, BANKED
  2DAA    E10B     BNZ 0x2dc2
1337:                  {
1338:                      U1ADDR = SetupPkt.bDevADR.Val;
  2DAC    C442     MOVFF 0x442, 0xf38
  2DAE    FF38     NOP
1339:                      if(U1ADDR != 0u)
  2DB0    010F     MOVLB 0xf
  2DB2    5138     MOVF 0x38, W, BANKED
  2DB4    E003     BZ 0x2dbc
1340:                      {
1341:                          USBDeviceState=ADDRESS_STATE;
  2DB6    0100     MOVLB 0
  2DB8    0E10     MOVLW 0x10
1342:                      }
1343:                      else
  2DBA    D002     BRA 0x2dc0
1344:                      {
1345:                          USBDeviceState=DEFAULT_STATE;
  2DBC    0100     MOVLB 0
  2DBE    0E04     MOVLW 0x4
  2DC0    6F60     MOVWF 0x60, BANKED
1346:                      }
1347:                  }//end if
1348:              
1349:              
1350:                  if(controlTransferState == CTRL_TRF_TX)
  2DC2    0578     DECF 0x78, W, BANKED
  2DC4    E126     BNZ 0x2e12
1351:                  {
1352:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
  2DC6    C06F     MOVFF 0x6f, 0xfe9
  2DC8    FFE9     NOP
  2DCA    C070     MOVFF 0x70, 0xfea
  2DCC    FFEA     NOP
  2DCE    0E02     MOVLW 0x2
  2DD0    26E9     ADDWF 0xfe9, F, ACCESS
  2DD2    0E00     MOVLW 0
  2DD4    22EA     ADDWFC 0xfea, F, ACCESS
  2DD6    0E48     MOVLW 0x48
  2DD8    6EEE     MOVWF 0xfee, ACCESS
  2DDA    0E04     MOVLW 0x4
  2DDC    6EED     MOVWF 0xfed, ACCESS
1353:                      USBCtrlTrfTxService();
  2DDE    DBA7     RCALL 0x352e
1354:              
1355:                      //Check if we have already sent a short packet.  If so, configure
1356:                      //the endpoint to STALL in response to any further IN tokens (in the
1357:                      //case that the host erroneously tries to receive more data than it
1358:                      //should).
1359:                      if(shortPacketStatus == SHORT_PKT_SENT)
  2DE0    0E02     MOVLW 0x2
  2DE2    0100     MOVLB 0
  2DE4    5D77     SUBWF 0x77, W, BANKED
  2DE6    E106     BNZ 0x2df4
1360:                      {
1361:                          // If a short packet has been sent, don't want to send any more,
1362:                          // stall next time if host is still trying to read.
1363:                          pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
  2DE8    C06F     MOVFF 0x6f, 0xfe9
  2DEA    FFE9     NOP
  2DEC    C070     MOVFF 0x70, 0xfea
  2DEE    FFEA     NOP
  2DF0    0E84     MOVLW 0x84
1364:                      }
1365:                      else
  2DF2    D00D     BRA 0x2e0e
1366:                      {
1367:                          if(lastDTS == 0)
  2DF4    50DF     MOVF 0xfdf, W, ACCESS
  2DF6    E106     BNZ 0x2e04
1368:                          {
1369:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
  2DF8    C06F     MOVFF 0x6f, 0xfe9
  2DFA    FFE9     NOP
  2DFC    C070     MOVFF 0x70, 0xfea
  2DFE    FFEA     NOP
  2E00    0EC8     MOVLW 0xc8
1370:                          }
1371:                          else
  2E02    D005     BRA 0x2e0e
1372:                          {
1373:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|_DTSEN;
  2E04    C06F     MOVFF 0x6f, 0xfe9
  2E06    FFE9     NOP
  2E08    C070     MOVFF 0x70, 0xfea
  2E0A    FFEA     NOP
  2E0C    0E88     MOVLW 0x88
  2E0E    6EEF     MOVWF 0xfef, ACCESS
1374:                          }
1375:                      }//end if(...)else
1376:                  }
1377:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
  2E10    D012     BRA 0x2e36
1378:              	{
1379:                      //if someone is still expecting data from the control transfer
1380:                      //  then make sure to terminate that request and let them know that
1381:                      //  they are done
1382:                      if(outPipes[0].info.bits.busy == 1)
  2E12    AF81     BTFSS 0x81, 0x7, BANKED
  2E14    D00F     BRA 0x2e34
1383:                      {
1384:                          if(outPipes[0].pFunc != NULL)
  2E16    5184     MOVF 0x84, W, BANKED
  2E18    1185     IORWF 0x85, W, BANKED
  2E1A    1186     IORWF 0x86, W, BANKED
  2E1C    E009     BZ 0x2e30
1385:                          {
1386:                              outPipes[0].pFunc();
  2E1E    D007     BRA 0x2e2e
  2E20    C086     MOVFF 0x86, 0xffb
  2E22    FFFB     NOP
  2E24    C085     MOVFF 0x85, 0xffa
  2E26    FFFA     NOP
  2E28    0100     MOVLB 0
  2E2A    5184     MOVF 0x84, W, BANKED
  2E2C    6EF9     MOVWF 0xff9, ACCESS
  2E2E    DFF8     RCALL 0x2e20
1387:                          }
1388:                          outPipes[0].info.bits.busy = 0;
  2E30    0100     MOVLB 0
  2E32    9F81     BCF 0x81, 0x7, BANKED
1389:                      }
1390:                  	
1391:                      controlTransferState = WAIT_SETUP;
  2E34    6B78     CLRF 0x78, BANKED
1392:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
1393:                      //got processed by the USBCtrlTrfRxService() handler.
1394:              	}	
1395:              
1396:              }
  2E36    52E5     MOVF 0xfe5, F, ACCESS
  2E38    52E5     MOVF 0xfe5, F, ACCESS
  2E3A    CFE7     MOVFF 0xfe7, 0xfd9
  2E3C    FFD9     NOP
  2E3E    0012     RETURN 0
1397:              
1398:              
1399:              /********************************************************************
1400:               * Function:        void USBCheckStdRequest(void)
1401:               *
1402:               * PreCondition:    None
1403:               *
1404:               * Input:           None
1405:               *
1406:               * Output:          None
1407:               *
1408:               * Side Effects:    None
1409:               *
1410:               * Overview:        This routine checks the setup data packet to see
1411:               *                  if it knows how to handle it
1412:               *
1413:               * Note:            None
1414:               *******************************************************************/
1415:              static void USBCheckStdRequest(void)
1416:              {
1417:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
  2E40    0104     MOVLB 0x4
  2E42    5140     MOVF 0x40, W, BANKED
  2E44    0B60     ANDLW 0x60
  2E46    42E8     RRNCF 0xfe8, F, ACCESS
  2E48    42E8     RRNCF 0xfe8, F, ACCESS
  2E4A    42E8     RRNCF 0xfe8, F, ACCESS
  2E4C    42E8     RRNCF 0xfe8, F, ACCESS
  2E4E    42E8     RRNCF 0xfe8, F, ACCESS
  2E50    0900     IORLW 0
  2E52    E001     BZ 0x2e56
  2E54    0012     RETURN 0
1418:              
1419:                  switch(SetupPkt.bRequest)
  2E56    5141     MOVF 0x41, W, BANKED
  2E58    0A0C     XORLW 0xc
  2E5A    E050     BZ 0x2efc
  2E5C    0A0B     XORLW 0xb
  2E5E    E03F     BZ 0x2ede
  2E60    0A0C     XORLW 0xc
  2E62    E031     BZ 0x2ec6
  2E64    0A01     XORLW 0x1
  2E66    E022     BZ 0x2eac
  2E68    0A0B     XORLW 0xb
  2E6A    E01E     BZ 0x2ea8
  2E6C    0A02     XORLW 0x2
  2E6E    E01C     BZ 0x2ea8
  2E70    0A03     XORLW 0x3
  2E72    E018     BZ 0x2ea4
  2E74    0A08     XORLW 0x8
  2E76    E010     BZ 0x2e98
  2E78    0A01     XORLW 0x1
  2E7A    E00C     BZ 0x2e94
  2E7C    0A0F     XORLW 0xf
  2E7E    E008     BZ 0x2e90
  2E80    0A03     XORLW 0x3
  2E82    E001     BZ 0x2e86
  2E84    0012     RETURN 0
1420:                  {
1421:                      case USB_REQUEST_SET_ADDRESS:
1422:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
  2E86    0100     MOVLB 0
  2E88    8F7C     BSF 0x7c, 0x7, BANKED
1423:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
  2E8A    0E08     MOVLW 0x8
  2E8C    6F60     MOVWF 0x60, BANKED
1424:                          /* See USBCtrlTrfInHandler() for the next step */
1425:                          break;
  2E8E    0012     RETURN 0
1426:                      case USB_REQUEST_GET_DESCRIPTOR:
1427:                          USBStdGetDscHandler();
  2E90    EF38     GOTO 0x3270
  2E92    F019     NOP
1428:                          break;
1429:                      case USB_REQUEST_SET_CONFIGURATION:
1430:                          USBStdSetCfgHandler();
  2E94    EF9B     GOTO 0x3736
  2E96    F01B     NOP
1431:                          break;
1432:                      case USB_REQUEST_GET_CONFIGURATION:
1433:                          inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
  2E98    0100     MOVLB 0
  2E9A    0E61     MOVLW 0x61
  2E9C    6F79     MOVWF 0x79, BANKED
  2E9E    0E00     MOVLW 0
  2EA0    6F7A     MOVWF 0x7a, BANKED
1434:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
1435:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
1436:                          inPipes[0].info.bits.busy = 1;
1437:                          break;
  2EA2    D00C     BRA 0x2ebc
1438:                      case USB_REQUEST_GET_STATUS:
1439:                          USBStdGetStatusHandler();
  2EA4    EFDC     GOTO 0x33b8
  2EA6    F019     NOP
1440:                          break;
1441:                      case USB_REQUEST_CLEAR_FEATURE:
1442:                      case USB_REQUEST_SET_FEATURE:
1443:                          USBStdFeatureReqHandler();
  2EA8    EF7F     GOTO 0x2efe
  2EAA    F017     NOP
1444:                          break;
1445:                      case USB_REQUEST_GET_INTERFACE:
1446:                          inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
  2EAC    5144     MOVF 0x44, W, BANKED
  2EAE    0100     MOVLB 0
  2EB0    6F79     MOVWF 0x79, BANKED
  2EB2    6B7A     CLRF 0x7a, BANKED
  2EB4    0E62     MOVLW 0x62
  2EB6    2779     ADDWF 0x79, F, BANKED
  2EB8    0E00     MOVLW 0
  2EBA    237A     ADDWFC 0x7a, F, BANKED
1447:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
  2EBC    817C     BSF 0x7c, 0, BANKED
1448:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
  2EBE    0E01     MOVLW 0x1
  2EC0    6F7D     MOVWF 0x7d, BANKED
1449:                          inPipes[0].info.bits.busy = 1;
  2EC2    8F7C     BSF 0x7c, 0x7, BANKED
1450:                          break;
  2EC4    0012     RETURN 0
1451:                      case USB_REQUEST_SET_INTERFACE:
1452:                          inPipes[0].info.bits.busy = 1;
  2EC6    0100     MOVLB 0
  2EC8    8F7C     BSF 0x7c, 0x7, BANKED
1453:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
  2ECA    0104     MOVLB 0x4
  2ECC    5144     MOVF 0x44, W, BANKED
  2ECE    6AEA     CLRF 0xfea, ACCESS
  2ED0    0F62     ADDLW 0x62
  2ED2    6EE9     MOVWF 0xfe9, ACCESS
  2ED4    0E00     MOVLW 0
  2ED6    22EA     ADDWFC 0xfea, F, ACCESS
  2ED8    C442     MOVFF 0x442, 0xfef
  2EDA    FFEF     NOP
1454:                          break;
  2EDC    0012     RETURN 0
1455:                      case USB_REQUEST_SET_DESCRIPTOR:
1456:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
  2EDE    0E00     MOVLW 0
  2EE0    6EE6     MOVWF 0xfe6, ACCESS
  2EE2    6AE6     CLRF 0xfe6, ACCESS
  2EE4    6EE6     MOVWF 0xfe6, ACCESS
  2EE6    6AE6     CLRF 0xfe6, ACCESS
  2EE8    0E02     MOVLW 0x2
  2EEA    6EE6     MOVWF 0xfe6, ACCESS
  2EEC    6AE6     CLRF 0xfe6, ACCESS
  2EEE    ECF7     CALL 0x5bee, 0
  2EF0    F02D     NOP
  2EF2    6E14     MOVWF 0x14, ACCESS
  2EF4    0E06     MOVLW 0x6
  2EF6    5EE1     SUBWF 0xfe1, F, ACCESS
  2EF8    5014     MOVF 0x14, W, ACCESS
1457:                          break;
  2EFA    0012     RETURN 0
1458:                      case USB_REQUEST_SYNCH_FRAME:
1459:                      default:
1460:                          break;
1461:                  }//end switch
1462:              }//end USBCheckStdRequest
  2EFC    0012     RETURN 0
1463:              
1464:              /********************************************************************
1465:               * Function:        void USBStdFeatureReqHandler(void)
1466:               *
1467:               * PreCondition:    None
1468:               *
1469:               * Input:           None
1470:               *
1471:               * Output:          None
1472:               *
1473:               * Side Effects:    None
1474:               *
1475:               * Overview:        This routine handles the standard SET & CLEAR
1476:               *                  FEATURES requests
1477:               *
1478:               * Note:            None
1479:               *******************************************************************/
1480:              static void USBStdFeatureReqHandler(void)
  2EFE    CFD9     MOVFF 0xfd9, 0xfe6
  2F00    FFE6     NOP
  2F02    CFE1     MOVFF 0xfe1, 0xfd9
  2F04    FFD9     NOP
  2F06    0E03     MOVLW 0x3
  2F08    26E1     ADDWF 0xfe1, F, ACCESS
1481:              {
1482:                  BDT_ENTRY *p;
1483:                  EP_STATUS current_ep_data;
1484:              
1485:                  #ifdef	USB_SUPPORT_OTG
1486:                  //Check for USB On-The-Go (OTG) specific requests
1487:                  if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
1488:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
1489:                  {  
1490:                      inPipes[0].info.bits.busy = 1;
1491:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
1492:                          USBOTGEnableHnp();
1493:                      else
1494:                          USBOTGDisableHnp();
1495:                  }
1496:              
1497:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
1498:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
1499:                  {
1500:                      inPipes[0].info.bits.busy = 1;
1501:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
1502:                          USBOTGEnableSupportHnp();
1503:                      else
1504:                          USBOTGDisableSupportHnp();
1505:                  }
1506:              
1507:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
1508:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
1509:                  {
1510:                      inPipes[0].info.bits.busy = 1;
1511:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
1512:                          USBOTGEnableAltHnp();
1513:                      else
1514:                          USBOTGDisableAltHnp();
1515:                  }
1516:                  #endif   //#ifdef USB_SUPPORT_OTG 
1517:              
1518:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
1519:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
  2F0A    0104     MOVLB 0x4
  2F0C    0542     DECF 0x42, W, BANKED
1520:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
  2F0E    E110     BNZ 0x2f30
  2F10    5140     MOVF 0x40, W, BANKED
  2F12    0B1F     ANDLW 0x1f
  2F14    0900     IORLW 0
  2F16    E10C     BNZ 0x2f30
1521:                  {
1522:                      inPipes[0].info.bits.busy = 1;
  2F18    0100     MOVLB 0
  2F1A    8F7C     BSF 0x7c, 0x7, BANKED
1523:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
  2F1C    0E03     MOVLW 0x3
  2F1E    0104     MOVLB 0x4
  2F20    5D41     SUBWF 0x41, W, BANKED
  2F22    E104     BNZ 0x2f2c
1524:                          RemoteWakeup = TRUE;
  2F24    0100     MOVLB 0
  2F26    0E01     MOVLW 0x1
  2F28    6F89     MOVWF 0x89, BANKED
1525:                      else
  2F2A    D002     BRA 0x2f30
1526:                          RemoteWakeup = FALSE;
  2F2C    0100     MOVLB 0
  2F2E    6B89     CLRF 0x89, BANKED
1527:                  }//end if
1528:              
1529:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
1530:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
  2F30    0104     MOVLB 0x4
  2F32    5142     MOVF 0x42, W, BANKED
1531:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
  2F34    E001     BZ 0x2f38
  2F36    D103     BRA 0x313e
  2F38    5140     MOVF 0x40, W, BANKED
  2F3A    0B1F     ANDLW 0x1f
  2F3C    0802     SUBLW 0x2
  2F3E    E001     BZ 0x2f42
  2F40    D0FE     BRA 0x313e
1532:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
  2F42    5144     MOVF 0x44, W, BANKED
  2F44    0B0F     ANDLW 0xf
  2F46    0900     IORLW 0
  2F48    E101     BNZ 0x2f4c
  2F4A    D0F9     BRA 0x313e
  2F4C    5144     MOVF 0x44, W, BANKED
  2F4E    0B0F     ANDLW 0xf
  2F50    0803     SUBLW 0x3
  2F52    E201     BC 0x2f56
  2F54    D0F4     BRA 0x313e
1533:                     (USBDeviceState == CONFIGURED_STATE))
  2F56    0E20     MOVLW 0x20
  2F58    0100     MOVLB 0
  2F5A    5D60     SUBWF 0x60, W, BANKED
  2F5C    E001     BZ 0x2f60
  2F5E    D0EF     BRA 0x313e
1534:                  {
1535:              		//The request was valid.  Take control of the control transfer and
1536:              		//perform the host requested action.
1537:              		inPipes[0].info.bits.busy = 1;
  2F60    8F7C     BSF 0x7c, 0x7, BANKED
1538:              
1539:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
1540:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
  2F62    0104     MOVLB 0x4
  2F64    BF44     BTFSC 0x44, 0x7, BANKED
  2F66    D016     BRA 0x2f94
1541:                      {
1542:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
  2F68    5144     MOVF 0x44, W, BANKED
  2F6A    0B0F     ANDLW 0xf
  2F6C    6EE9     MOVWF 0xfe9, ACCESS
  2F6E    6AEA     CLRF 0xfea, ACCESS
  2F70    90D8     BCF 0xfd8, 0, ACCESS
  2F72    36E9     RLCF 0xfe9, F, ACCESS
  2F74    36EA     RLCF 0xfea, F, ACCESS
  2F76    0E67     MOVLW 0x67
  2F78    26E9     ADDWF 0xfe9, F, ACCESS
  2F7A    0E00     MOVLW 0
  2F7C    22EA     ADDWFC 0xfea, F, ACCESS
  2F7E    CFEE     MOVFF 0xfee, 0xfde
  2F80    FFDE     NOP
  2F82    CFED     MOVFF 0xfed, 0xfdd
  2F84    FFDD     NOP
1543:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
  2F86    5144     MOVF 0x44, W, BANKED
  2F88    0B0F     ANDLW 0xf
  2F8A    6AEA     CLRF 0xfea, ACCESS
  2F8C    0F92     ADDLW 0x92
  2F8E    6EE9     MOVWF 0xfe9, ACCESS
  2F90    0E00     MOVLW 0
1544:                      }
1545:                      else
  2F92    D015     BRA 0x2fbe
1546:                      {
1547:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
  2F94    5144     MOVF 0x44, W, BANKED
  2F96    0B0F     ANDLW 0xf
  2F98    6EE9     MOVWF 0xfe9, ACCESS
  2F9A    6AEA     CLRF 0xfea, ACCESS
  2F9C    90D8     BCF 0xfd8, 0, ACCESS
  2F9E    36E9     RLCF 0xfe9, F, ACCESS
  2FA0    36EA     RLCF 0xfea, F, ACCESS
  2FA2    0E6F     MOVLW 0x6f
  2FA4    26E9     ADDWF 0xfe9, F, ACCESS
  2FA6    0E00     MOVLW 0
  2FA8    22EA     ADDWFC 0xfea, F, ACCESS
  2FAA    CFEE     MOVFF 0xfee, 0xfde
  2FAC    FFDE     NOP
  2FAE    CFED     MOVFF 0xfed, 0xfdd
  2FB0    FFDD     NOP
1548:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
  2FB2    5144     MOVF 0x44, W, BANKED
  2FB4    0B0F     ANDLW 0xf
  2FB6    6AEA     CLRF 0xfea, ACCESS
  2FB8    0F8E     ADDLW 0x8e
  2FBA    6EE9     MOVWF 0xfe9, ACCESS
  2FBC    0E00     MOVLW 0
  2FBE    22EA     ADDWFC 0xfea, F, ACCESS
  2FC0    0E02     MOVLW 0x2
  2FC2    CFEF     MOVFF 0xfef, 0xfdb
  2FC4    FFDB     NOP
1549:                      }
1550:              
1551:                      //If ping pong buffering is enabled on the requested endpoint, need 
1552:                      //to point to the one that is the active BDT entry which the SIE will 
1553:                      //use for the next attempted transaction on that EP number.
1554:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
1555:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
  2FC6    50D9     MOVF 0xfd9, W, ACCESS
  2FC8    0F02     ADDLW 0x2
  2FCA    6EE9     MOVWF 0xfe9, ACCESS
  2FCC    CFDA     MOVFF 0xfda, 0xfea
  2FCE    FFEA     NOP
  2FD0    50EF     MOVF 0xfef, W, ACCESS
  2FD2    0B01     ANDLW 0x1
  2FD4    E103     BNZ 0x2fdc
1556:                          {
1557:                              USBHALPingPongSetToEven(&p);
  2FD6    0E00     MOVLW 0
  2FD8    94DF     BCF 0xfdf, 0x2, ACCESS
1558:                          }
1559:                          else //else must have been odd
  2FDA    D001     BRA 0x2fde
1560:                          {
1561:                              USBHALPingPongSetToOdd(&p);
  2FDC    84DF     BSF 0xfdf, 0x2, ACCESS
1562:                          }
1563:                      #endif
1564:                      
1565:                      //Update the BDT pointers with the new, next entry based on the feature
1566:                      //  request
1567:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
  2FDE    BF44     BTFSC 0x44, 0x7, BANKED
  2FE0    D00B     BRA 0x2ff8
1568:                      {
1569:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
  2FE2    5144     MOVF 0x44, W, BANKED
  2FE4    0B0F     ANDLW 0xf
  2FE6    6EE9     MOVWF 0xfe9, ACCESS
  2FE8    6AEA     CLRF 0xfea, ACCESS
  2FEA    90D8     BCF 0xfd8, 0, ACCESS
  2FEC    36E9     RLCF 0xfe9, F, ACCESS
  2FEE    36EA     RLCF 0xfea, F, ACCESS
  2FF0    0E67     MOVLW 0x67
  2FF2    26E9     ADDWF 0xfe9, F, ACCESS
  2FF4    0E00     MOVLW 0
1570:                      }
1571:                      else
  2FF6    D00A     BRA 0x300c
1572:                      {
1573:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
  2FF8    5144     MOVF 0x44, W, BANKED
  2FFA    0B0F     ANDLW 0xf
  2FFC    6EE9     MOVWF 0xfe9, ACCESS
  2FFE    6AEA     CLRF 0xfea, ACCESS
  3000    90D8     BCF 0xfd8, 0, ACCESS
  3002    36E9     RLCF 0xfe9, F, ACCESS
  3004    36EA     RLCF 0xfea, F, ACCESS
  3006    0E6F     MOVLW 0x6f
  3008    26E9     ADDWF 0xfe9, F, ACCESS
  300A    0E00     MOVLW 0
  300C    22EA     ADDWFC 0xfea, F, ACCESS
  300E    CFDE     MOVFF 0xfde, 0xfee
  3010    FFEE     NOP
  3012    CFDD     MOVFF 0xfdd, 0xfed
  3014    FFED     NOP
1574:                      }
1575:              
1576:              		//Check if it was a SET_FEATURE endpoint halt request
1577:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
  3016    0E03     MOVLW 0x3
  3018    5D41     SUBWF 0x41, W, BANKED
  301A    E120     BNZ 0x305c
1578:                      {
1579:                          if(p->STAT.UOWN == 1)
  301C    CFDE     MOVFF 0xfde, 0xfe9
  301E    FFE9     NOP
  3020    CFDD     MOVFF 0xfdd, 0xfea
  3022    FFEA     NOP
  3024    50EF     MOVF 0xfef, W, ACCESS
  3026    0B80     ANDLW 0x80
  3028    E011     BZ 0x304c
1580:                          {
1581:                              //Mark that we are terminating this transfer and that the user
1582:                              //  needs to be notified later
1583:                              if(SetupPkt.EPDir == 0)
  302A    BF44     BTFSC 0x44, 0x7, BANKED
  302C    D007     BRA 0x303c
1584:                              {
1585:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
  302E    5144     MOVF 0x44, W, BANKED
  3030    0B0F     ANDLW 0xf
  3032    6AEA     CLRF 0xfea, ACCESS
  3034    0F92     ADDLW 0x92
  3036    6EE9     MOVWF 0xfe9, ACCESS
  3038    0E00     MOVLW 0
1586:                              }
1587:                              else
  303A    D006     BRA 0x3048
1588:                              {
1589:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
  303C    5144     MOVF 0x44, W, BANKED
  303E    0B0F     ANDLW 0xf
  3040    6AEA     CLRF 0xfea, ACCESS
  3042    0F8E     ADDLW 0x8e
  3044    6EE9     MOVWF 0xfe9, ACCESS
  3046    0E00     MOVLW 0
  3048    22EA     ADDWFC 0xfea, F, ACCESS
  304A    82EF     BSF 0xfef, 0x1, ACCESS
1590:                              }
1591:                          }
1592:              
1593:              			//Then STALL the endpoint
1594:                          p->STAT.Val |= _USIE|_BSTALL;
  304C    0E84     MOVLW 0x84
  304E    CFDE     MOVFF 0xfde, 0xfe9
  3050    FFE9     NOP
  3052    CFDD     MOVFF 0xfdd, 0xfea
  3054    FFEA     NOP
  3056    50E8     MOVF 0xfe8, W, ACCESS
  3058    12EF     IORWF 0xfef, F, ACCESS
1595:                      }
1596:                      else
  305A    D071     BRA 0x313e
1597:                      {
1598:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
1599:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
1600:                              //toggle over the to the non-active BDT
1601:                              USBAdvancePingPongBuffer(&p);  
  305C    74DF     BTG 0xfdf, 0x2, ACCESS
1602:              
1603:                              if(p->STAT.UOWN == 1)
  305E    CFDE     MOVFF 0xfde, 0xfe9
  3060    FFE9     NOP
  3062    CFDD     MOVFF 0xfdd, 0xfea
  3064    FFEA     NOP
  3066    50EF     MOVF 0xfef, W, ACCESS
  3068    0B80     ANDLW 0x80
  306A    E01B     BZ 0x30a2
1604:                              {
1605:                                  //Clear UOWN and set DTS state so it will be correct the next time
1606:                                  //the application firmware uses USBTransferOnePacket() on the EP.
1607:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
  306C    CFDE     MOVFF 0xfde, 0xfe9
  306E    FFE9     NOP
  3070    CFDD     MOVFF 0xfdd, 0xfea
  3072    FFEA     NOP
  3074    9EEF     BCF 0xfef, 0x7, ACCESS
1608:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
  3076    CFDE     MOVFF 0xfde, 0xfe9
  3078    FFE9     NOP
  307A    CFDD     MOVFF 0xfdd, 0xfea
  307C    FFEA     NOP
  307E    8CEF     BSF 0xfef, 0x6, ACCESS
1609:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
  3080    0E02     MOVLW 0x2
  3082    6EE6     MOVWF 0xfe6, ACCESS
  3084    6AE6     CLRF 0xfe6, ACCESS
  3086    CFDE     MOVFF 0xfde, 0xfe6
  3088    FFE6     NOP
  308A    CFDD     MOVFF 0xfdd, 0xfe6
  308C    FFE6     NOP
  308E    0E05     MOVLW 0x5
  3090    6EE6     MOVWF 0xfe6, ACCESS
  3092    6AE6     CLRF 0xfe6, ACCESS
  3094    ECF7     CALL 0x5bee, 0
  3096    F02D     NOP
  3098    6E14     MOVWF 0x14, ACCESS
  309A    0E06     MOVLW 0x6
  309C    5EE1     SUBWF 0xfe1, F, ACCESS
  309E    5014     MOVF 0x14, W, ACCESS
1610:                              }
1611:                              else
  30A0    D005     BRA 0x30ac
1612:                              {
1613:                                  //UOWN already clear, but still need to set DTS to DATA1     
1614:              					p->STAT.Val |= _DAT1;
  30A2    CFDE     MOVFF 0xfde, 0xfe9
  30A4    FFE9     NOP
  30A6    CFDD     MOVFF 0xfdd, 0xfea
  30A8    FFEA     NOP
  30AA    8CEF     BSF 0xfef, 0x6, ACCESS
1615:                              }
1616:              
1617:                              //toggle back to the active BDT (the one the SIE is currently looking at
1618:                              //and will use for the next successful transaction to take place on the EP
1619:                              USBAdvancePingPongBuffer(&p);    
  30AC    74DF     BTG 0xfdf, 0x2, ACCESS
1620:                              
1621:                              //Check if we are currently terminating, or have previously terminated
1622:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
1623:                              //set DTS to the proper state, and call the application callback
1624:                              //function.
1625:                              if((current_ep_data.bits.transfer_terminated != 0) || ((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 0)))
  30AE    50D9     MOVF 0xfd9, W, ACCESS
  30B0    0F02     ADDLW 0x2
  30B2    6EE9     MOVWF 0xfe9, ACCESS
  30B4    CFDA     MOVFF 0xfda, 0xfea
  30B6    FFEA     NOP
  30B8    50EF     MOVF 0xfef, W, ACCESS
  30BA    0B02     ANDLW 0x2
  30BC    E10E     BNZ 0x30da
  30BE    CFDE     MOVFF 0xfde, 0xfe9
  30C0    FFE9     NOP
  30C2    CFDD     MOVFF 0xfdd, 0xfea
  30C4    FFEA     NOP
  30C6    50EF     MOVF 0xfef, W, ACCESS
  30C8    0B80     ANDLW 0x80
  30CA    E032     BZ 0x3130
  30CC    CFDE     MOVFF 0xfde, 0xfe9
  30CE    FFE9     NOP
  30D0    CFDD     MOVFF 0xfdd, 0xfea
  30D2    FFEA     NOP
  30D4    50EF     MOVF 0xfef, W, ACCESS
  30D6    0B04     ANDLW 0x4
  30D8    E12B     BNZ 0x3130
1626:                              {
1627:                                  if(SetupPkt.EPDir == 0)
  30DA    0104     MOVLB 0x4
  30DC    BF44     BTFSC 0x44, 0x7, BANKED
  30DE    D007     BRA 0x30ee
1628:                                  {
1629:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
  30E0    5144     MOVF 0x44, W, BANKED
  30E2    0B0F     ANDLW 0xf
  30E4    6AEA     CLRF 0xfea, ACCESS
  30E6    0F92     ADDLW 0x92
  30E8    6EE9     MOVWF 0xfe9, ACCESS
  30EA    0E00     MOVLW 0
1630:                                  }
1631:                                  else
  30EC    D006     BRA 0x30fa
1632:                                  {
1633:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
  30EE    5144     MOVF 0x44, W, BANKED
  30F0    0B0F     ANDLW 0xf
  30F2    6AEA     CLRF 0xfea, ACCESS
  30F4    0F8E     ADDLW 0x8e
  30F6    6EE9     MOVWF 0xfe9, ACCESS
  30F8    0E00     MOVLW 0
  30FA    22EA     ADDWFC 0xfea, F, ACCESS
  30FC    92EF     BCF 0xfef, 0x1, ACCESS
1634:                                  }
1635:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
1636:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
  30FE    0E3B     MOVLW 0x3b
  3100    6E14     MOVWF 0x14, ACCESS
  3102    CFDE     MOVFF 0xfde, 0xfe9
  3104    FFE9     NOP
  3106    CFDD     MOVFF 0xfdd, 0xfea
  3108    FFEA     NOP
  310A    50E8     MOVF 0xfe8, W, ACCESS
  310C    16EF     ANDWF 0xfef, F, ACCESS
1637:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
  310E    0E02     MOVLW 0x2
  3110    6EE6     MOVWF 0xfe6, ACCESS
  3112    6AE6     CLRF 0xfe6, ACCESS
  3114    CFDE     MOVFF 0xfde, 0xfe6
  3116    FFE6     NOP
  3118    CFDD     MOVFF 0xfdd, 0xfe6
  311A    FFE6     NOP
  311C    0E05     MOVLW 0x5
  311E    6EE6     MOVWF 0xfe6, ACCESS
  3120    6AE6     CLRF 0xfe6, ACCESS
  3122    ECF7     CALL 0x5bee, 0
  3124    F02D     NOP
  3126    6E14     MOVWF 0x14, ACCESS
  3128    0E06     MOVLW 0x6
  312A    5EE1     SUBWF 0xfe1, F, ACCESS
  312C    5014     MOVF 0x14, W, ACCESS
1638:                              }
1639:                              else
  312E    D007     BRA 0x313e
1640:                              {
1641:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
1642:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
  3130    0E3B     MOVLW 0x3b
  3132    CFDE     MOVFF 0xfde, 0xfe9
  3134    FFE9     NOP
  3136    CFDD     MOVFF 0xfdd, 0xfea
  3138    FFEA     NOP
  313A    50E8     MOVF 0xfe8, W, ACCESS
  313C    16EF     ANDWF 0xfef, F, ACCESS
1643:                              } 
1644:                          #else //else we must not be using ping-pong buffering on the requested endpoint
1645:                              if((current_ep_data.bits.transfer_terminated != 0) || ((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 0)))
1646:                              {
1647:                                  if(SetupPkt.EPDir == 0)
1648:                                  {
1649:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
1650:                                  }
1651:                                  else
1652:                                  {
1653:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
1654:                                  }
1655:               
1656:                                  //Clear UOWN and remove the STALL condition.   
1657:                                  //  In this case we also need to set the DTS bit to 1 so that
1658:                                  //  it toggles to DATA0 the next time the application firmware
1659:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
1660:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
1661:                                  p->STAT.Val |= _DAT1;
1662:                                  //Let the application firmware know a transaction just
1663:                                  //got terminated by the host, and that it is now free to
1664:                                  //re-arm the endpoint or do other tasks if desired.                                        
1665:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
1666:                              }
1667:                              else
1668:                              {
1669:                                  //Clear UOWN and remove the STALL condition.   
1670:                                  //  In this case we also need to set the DTS bit to 1 so that
1671:                                  //  it toggles to DATA0 the next time the application firmware
1672:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
1673:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
1674:                                  p->STAT.Val |= _DAT1;
1675:                              } 
1676:                          #endif
1677:                      }//end if
1678:                  }//end if
1679:              }//end USBStdFeatureReqHandler
  313E    0E03     MOVLW 0x3
  3140    5CE1     SUBWF 0xfe1, W, ACCESS
  3142    E202     BC 0x3148
  3144    6AE1     CLRF 0xfe1, ACCESS
  3146    52E5     MOVF 0xfe5, F, ACCESS
  3148    6EE1     MOVWF 0xfe1, ACCESS
  314A    52E5     MOVF 0xfe5, F, ACCESS
  314C    CFE7     MOVFF 0xfe7, 0xfd9
  314E    FFD9     NOP
  3150    0012     RETURN 0
1680:              
1681:              
1682:              /********************************************************************
1683:               * Function:        void USBCtrlEPAllowStatusStage(void)
1684:               *
1685:               * PreCondition:    Before USBCtrlEPAllowStatusStage() is called, the USBDeviceInit()
1686:               *                  function must have been called at least once, since the last 
1687:               *                  microcontroller reset or power up cycle.
1688:               *
1689:               * Input:           None
1690:               *
1691:               * Output:          None
1692:               *
1693:               * Side Effects:    None
1694:               *
1695:               * Overview:        This function can be called to prepare the appropriate
1696:               *					EP0 endpoint (IN or OUT) to be ready to allow the status
1697:               *					stage of the currently pending control transfer to complete.
1698:               *					This function will be called automatically by the
1699:               *					USB stack, while processing a control transfer, unless an
1700:               *					application specific/device class specific handler sets
1701:               *					the USBDeferStatusStagePacket boolean to TRUE, while processing
1702:               *					the SETUP packet that initiated the control transfer.  If
1703:               *					application specific code sets USBDeferStatusStagePacket to TRUE,
1704:               *					it is then responsible for calling USBCtrlEPAllowStatusStage(),
1705:               *					once the control transfer data has been satisfactorily processed.
1706:               *
1707:               * Note:            This function is re-entrant, and is safe to call from multiple
1708:               *                  contexts in the application (either higher, same, or lower
1709:               *                  priority than the context that the USBDeviceTasks() function
1710:               *                  executes at.
1711:               *******************************************************************/
1712:              void USBCtrlEPAllowStatusStage(void)
1713:              {
1714:                  //Check and set two flags, prior to actually modifying any BDT entries.
1715:                  //This double checking is necessary to make certain that 
1716:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1717:                  //in main loop context, while simultaneously getting an interrupt which 
1718:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1719:                  if(USBStatusStageEnabledFlag1 == FALSE)
  3152    0100     MOVLB 0
  3154    5198     MOVF 0x98, W, BANKED
  3156    E14D     BNZ 0x31f2
1720:                  {
1721:                      USBStatusStageEnabledFlag1 = TRUE;  
  3158    0E01     MOVLW 0x1
  315A    6F98     MOVWF 0x98, BANKED
1722:                      if(USBStatusStageEnabledFlag2 == FALSE)
  315C    5199     MOVF 0x99, W, BANKED
  315E    E149     BNZ 0x31f2
1723:                      {
1724:                          USBStatusStageEnabledFlag2 = TRUE;
  3160    0E01     MOVLW 0x1
  3162    6F99     MOVWF 0x99, BANKED
1725:                      
1726:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1727:                          //stage), based on the type of control transfer currently pending.
1728:                          if(controlTransferState == CTRL_TRF_RX)
  3164    0E02     MOVLW 0x2
  3166    5D78     SUBWF 0x78, W, BANKED
  3168    E10D     BNZ 0x3184
1729:                          {
1730:                              pBDTEntryIn[0]->CNT = 0;
  316A    C06F     MOVFF 0x6f, 0xfe9
  316C    FFE9     NOP
  316E    C070     MOVFF 0x70, 0xfea
  3170    FFEA     NOP
  3172    52EE     MOVF 0xfee, F, ACCESS
  3174    6AEF     CLRF 0xfef, ACCESS
1731:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;        
  3176    C06F     MOVFF 0x6f, 0xfe9
  3178    FFE9     NOP
  317A    C070     MOVFF 0x70, 0xfea
  317C    FFEA     NOP
  317E    0EC8     MOVLW 0xc8
  3180    6EEF     MOVWF 0xfef, ACCESS
1732:                          }
1733:                          else if(controlTransferState == CTRL_TRF_TX)
  3182    0012     RETURN 0
  3184    0578     DECF 0x78, W, BANKED
  3186    E135     BNZ 0x31f2
1734:                          {
1735:                      		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
  3188    6B8D     CLRF 0x8d, BANKED
1736:                      
1737:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1738:                              //next SETUP packet.
1739:                      		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1740:                      		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
  318A    C063     MOVFF 0x63, 0xfe9
  318C    FFE9     NOP
  318E    C064     MOVFF 0x64, 0xfea
  3190    FFEA     NOP
  3192    52EE     MOVF 0xfee, F, ACCESS
  3194    0E08     MOVLW 0x8
  3196    6EEF     MOVWF 0xfef, ACCESS
1741:                      		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
  3198    C063     MOVFF 0x63, 0xfe9
  319A    FFE9     NOP
  319C    C064     MOVFF 0x64, 0xfea
  319E    FFEA     NOP
  31A0    0E02     MOVLW 0x2
  31A2    26E9     ADDWF 0xfe9, F, ACCESS
  31A4    0E00     MOVLW 0
  31A6    22EA     ADDWFC 0xfea, F, ACCESS
  31A8    0E40     MOVLW 0x40
  31AA    6EEE     MOVWF 0xfee, ACCESS
  31AC    0E04     MOVLW 0x4
  31AE    6EED     MOVWF 0xfed, ACCESS
1742:                      		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
  31B0    C063     MOVFF 0x63, 0xfe9
  31B2    FFE9     NOP
  31B4    C064     MOVFF 0x64, 0xfea
  31B6    FFEA     NOP
  31B8    0E84     MOVLW 0x84
  31BA    6EEF     MOVWF 0xfef, ACCESS
1743:                      		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
  31BC    0E01     MOVLW 0x1
  31BE    6F8D     MOVWF 0x8d, BANKED
1744:                      		#endif
1745:                      
1746:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1747:                      		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  31C0    C065     MOVFF 0x65, 0xfe9
  31C2    FFE9     NOP
  31C4    C066     MOVFF 0x66, 0xfea
  31C6    FFEA     NOP
  31C8    52EE     MOVF 0xfee, F, ACCESS
  31CA    0E08     MOVLW 0x8
  31CC    6EEF     MOVWF 0xfef, ACCESS
1748:                      		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  31CE    C065     MOVFF 0x65, 0xfe9
  31D0    FFE9     NOP
  31D2    C066     MOVFF 0x66, 0xfea
  31D4    FFEA     NOP
  31D6    0E02     MOVLW 0x2
  31D8    26E9     ADDWF 0xfe9, F, ACCESS
  31DA    0E00     MOVLW 0
  31DC    22EA     ADDWFC 0xfea, F, ACCESS
  31DE    0E40     MOVLW 0x40
  31E0    6EEE     MOVWF 0xfee, ACCESS
  31E2    0E04     MOVLW 0x4
  31E4    6EED     MOVWF 0xfed, ACCESS
1749:                      		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
  31E6    C065     MOVFF 0x65, 0xfe9
  31E8    FFE9     NOP
  31EA    C066     MOVFF 0x66, 0xfea
  31EC    FFEA     NOP
  31EE    0E80     MOVLW 0x80
  31F0    6EEF     MOVWF 0xfef, ACCESS
1750:                          }
1751:                      }    
1752:                  }
1753:              }   
  31F2    0012     RETURN 0
1754:              
1755:              
1756:              /*******************************************************************************
1757:                Function: void USBCtrlEPAllowDataStage(void);
1758:                  
1759:                Summary: This function allows the data stage of either a host-to-device or
1760:                          device-to-host control transfer (with data stage) to complete.
1761:                          This function is meant to be used in conjunction with either the
1762:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1763:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1764:                          then the firmware does not need to manually call 
1765:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1766:                          instead.
1767:                   
1768:                Description:
1769:                  
1770:                Conditions: A control transfer (with data stage) should already be pending, 
1771:                              if the firmware calls this function.  Additionally, the firmware
1772:                              should have called either USBDeferOUTDataStage() or 
1773:                              USBDeferINDataStage() at the start of the control transfer, if
1774:                              the firmware will be calling this function manually.
1775:              
1776:                Input:
1777:              
1778:                Return:
1779:              
1780:                Remarks: 
1781:                *****************************************************************************/
1782:              void USBCtrlEPAllowDataStage(void)
1783:              {
1784:                  USBDeferINDataStagePackets = FALSE;
  31F4    0100     MOVLB 0
  31F6    6B9A     CLRF 0x9a, BANKED
1785:                  USBDeferOUTDataStagePackets = FALSE;
  31F8    6B9B     CLRF 0x9b, BANKED
1786:              
1787:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
  31FA    0E02     MOVLW 0x2
  31FC    5D78     SUBWF 0x78, W, BANKED
  31FE    E118     BNZ 0x3230
1788:                  {
1789:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1790:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  3200    C065     MOVFF 0x65, 0xfe9
  3202    FFE9     NOP
  3204    C066     MOVFF 0x66, 0xfea
  3206    FFEA     NOP
  3208    52EE     MOVF 0xfee, F, ACCESS
  320A    0E08     MOVLW 0x8
  320C    6EEF     MOVWF 0xfef, ACCESS
1791:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
  320E    C065     MOVFF 0x65, 0xfe9
  3210    FFE9     NOP
  3212    C066     MOVFF 0x66, 0xfea
  3214    FFEA     NOP
  3216    0E02     MOVLW 0x2
  3218    26E9     ADDWF 0xfe9, F, ACCESS
  321A    0E00     MOVLW 0
  321C    22EA     ADDWFC 0xfea, F, ACCESS
  321E    0E48     MOVLW 0x48
  3220    6EEE     MOVWF 0xfee, ACCESS
  3222    0E04     MOVLW 0x4
  3224    6EED     MOVWF 0xfed, ACCESS
1792:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
  3226    C065     MOVFF 0x65, 0xfe9
  3228    FFE9     NOP
  322A    C066     MOVFF 0x66, 0xfea
  322C    FFEA     NOP
1793:                  }   
1794:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
  322E    D01D     BRA 0x326a
1795:                  {
1796:                      //Error check the data stage byte count.  Make sure the user specified
1797:                      //value was no greater than the number of bytes the host requested.
1798:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
  3230    517D     MOVF 0x7d, W, BANKED
  3232    0104     MOVLB 0x4
  3234    5D46     SUBWF 0x46, W, BANKED
  3236    0100     MOVLB 0
  3238    517E     MOVF 0x7e, W, BANKED
  323A    0104     MOVLB 0x4
  323C    5947     SUBWFB 0x47, W, BANKED
  323E    E204     BC 0x3248
1799:              		{
1800:              			inPipes[0].wCount.Val = SetupPkt.wLength;
  3240    C446     MOVFF 0x446, 0x7d
  3242    F07D     NOP
  3244    C447     MOVFF 0x447, 0x7e
  3246    F07E     NOP
1801:              		}
1802:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
  3248    D972     RCALL 0x352e
1803:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1804:              
1805:              	    //Cnt should have been initialized by responsible request owner (ex: by
1806:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1807:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
  324A    C06F     MOVFF 0x6f, 0xfe9
  324C    FFE9     NOP
  324E    C070     MOVFF 0x70, 0xfea
  3250    FFEA     NOP
  3252    0E02     MOVLW 0x2
  3254    26E9     ADDWF 0xfe9, F, ACCESS
  3256    0E00     MOVLW 0
  3258    22EA     ADDWFC 0xfea, F, ACCESS
  325A    0E48     MOVLW 0x48
  325C    6EEE     MOVWF 0xfee, ACCESS
  325E    0E04     MOVLW 0x4
  3260    6EED     MOVWF 0xfed, ACCESS
1808:              		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
  3262    C06F     MOVFF 0x6f, 0xfe9
  3264    FFE9     NOP
  3266    C070     MOVFF 0x70, 0xfea
  3268    FFEA     NOP
  326A    0EC8     MOVLW 0xc8
  326C    6EEF     MOVWF 0xfef, ACCESS
1809:                  }     
1810:              }    
  326E    0012     RETURN 0
1811:              
1812:              /********************************************************************
1813:               * Function:        void USBStdGetDscHandler(void)
1814:               *
1815:               * PreCondition:    None
1816:               *
1817:               * Input:           None
1818:               *
1819:               * Output:          None
1820:               *
1821:               * Side Effects:    None
1822:               *
1823:               * Overview:        This routine handles the standard GET_DESCRIPTOR
1824:               *                  request.
1825:               *
1826:               * Note:            None
1827:               *******************************************************************/
1828:              static void USBStdGetDscHandler(void)
1829:              {
1830:                  if(SetupPkt.bmRequestType == 0x80)
  3270    0E80     MOVLW 0x80
  3272    0104     MOVLB 0x4
  3274    5D40     SUBWF 0x40, W, BANKED
  3276    E001     BZ 0x327a
  3278    D09E     BRA 0x33b6
1831:                  {
1832:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
  327A    0100     MOVLB 0
  327C    0EC0     MOVLW 0xc0
  327E    6F7C     MOVWF 0x7c, BANKED
1833:              
1834:                      switch(SetupPkt.bDescriptorType)
  3280    0104     MOVLB 0x4
  3282    5143     MOVF 0x43, W, BANKED
  3284    0A03     XORLW 0x3
  3286    E057     BZ 0x3336
  3288    0A01     XORLW 0x1
  328A    E00C     BZ 0x32a4
  328C    0A03     XORLW 0x3
  328E    E001     BZ 0x3292
  3290    D090     BRA 0x33b2
1835:                      {
1836:                          case USB_DESCRIPTOR_DEVICE:
1837:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
1838:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
1839:                              #else
1840:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
  3292    0100     MOVLB 0
  3294    0EE0     MOVLW 0xe0
  3296    6F79     MOVWF 0x79, BANKED
  3298    0E61     MOVLW 0x61
  329A    6F7A     MOVWF 0x7a, BANKED
  329C    0E00     MOVLW 0
  329E    6F7B     MOVWF 0x7b, BANKED
1841:                              #endif
1842:                              inPipes[0].wCount.Val = sizeof(device_dsc);
  32A0    0E12     MOVLW 0x12
1843:                              break;
  32A2    D081     BRA 0x33a6
1844:                          case USB_DESCRIPTOR_CONFIGURATION:
1845:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
1846:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
1847:                              #else
1848:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
  32A4    0EBD     MOVLW 0xbd
  32A6    6E14     MOVWF 0x14, ACCESS
  32A8    0E62     MOVLW 0x62
  32AA    6E15     MOVWF 0x15, ACCESS
  32AC    0E00     MOVLW 0
  32AE    6E16     MOVWF 0x16, ACCESS
  32B0    C442     MOVFF 0x442, 0x17
  32B2    F017     NOP
  32B4    6A18     CLRF 0x18, ACCESS
  32B6    6A19     CLRF 0x19, ACCESS
  32B8    0E03     MOVLW 0x3
  32BA    6E0C     MOVWF 0xc, ACCESS
  32BC    6A0D     CLRF 0xd, ACCESS
  32BE    6A0E     CLRF 0xe, ACCESS
  32C0    C017     MOVFF 0x17, 0x7
  32C2    F007     NOP
  32C4    C018     MOVFF 0x18, 0x8
  32C6    F008     NOP
  32C8    C019     MOVFF 0x19, 0x9
  32CA    F009     NOP
  32CC    EC7A     CALL 0x60f4, 0
  32CE    F030     NOP
  32D0    5014     MOVF 0x14, W, ACCESS
  32D2    2404     ADDWF 0x4, W, ACCESS
  32D4    6EF3     MOVWF 0xff3, ACCESS
  32D6    5015     MOVF 0x15, W, ACCESS
  32D8    2005     ADDWFC 0x5, W, ACCESS
  32DA    6EF4     MOVWF 0xff4, ACCESS
  32DC    5016     MOVF 0x16, W, ACCESS
  32DE    2006     ADDWFC 0x6, W, ACCESS
  32E0    6EF8     MOVWF 0xff8, ACCESS
  32E2    CFF4     MOVFF 0xff4, 0xff7
  32E4    FFF7     NOP
  32E6    CFF3     MOVFF 0xff3, 0xff6
  32E8    FFF6     NOP
  32EA    0009     TBLRD*+
  32EC    CFF5     MOVFF 0xff5, 0x79
  32EE    F079     NOP
  32F0    0009     TBLRD*+
  32F2    CFF5     MOVFF 0xff5, 0x7a
  32F4    F07A     NOP
  32F6    0008     TBLRD*
  32F8    CFF5     MOVFF 0xff5, 0x7b
  32FA    F07B     NOP
1849:                              #endif
1850:              
1851:                              //This must be loaded using byte addressing.  The source pointer
1852:                              //  may not be word aligned for the 16 or 32 bit machines resulting
1853:                              //  in an address error on the dereference.
1854:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
  32FC    C079     MOVFF 0x79, 0xff6
  32FE    FFF6     NOP
  3300    C07A     MOVFF 0x7a, 0xff7
  3302    FFF7     NOP
  3304    C07B     MOVFF 0x7b, 0xff8
  3306    FFF8     NOP
  3308    0E02     MOVLW 0x2
  330A    26F6     ADDWF 0xff6, F, ACCESS
  330C    0E00     MOVLW 0
  330E    22F7     ADDWFC 0xff7, F, ACCESS
  3310    22F8     ADDWFC 0xff8, F, ACCESS
  3312    0008     TBLRD*
  3314    CFF5     MOVFF 0xff5, 0x7d
  3316    F07D     NOP
1855:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
  3318    C079     MOVFF 0x79, 0xff6
  331A    FFF6     NOP
  331C    C07A     MOVFF 0x7a, 0xff7
  331E    FFF7     NOP
  3320    C07B     MOVFF 0x7b, 0xff8
  3322    FFF8     NOP
  3324    0E03     MOVLW 0x3
  3326    26F6     ADDWF 0xff6, F, ACCESS
  3328    0E00     MOVLW 0
  332A    22F7     ADDWFC 0xff7, F, ACCESS
  332C    22F8     ADDWFC 0xff8, F, ACCESS
  332E    0008     TBLRD*
  3330    CFF5     MOVFF 0xff5, 0x7e
  3332    F07E     NOP
1856:                              break;
  3334    0012     RETURN 0
1857:                          case USB_DESCRIPTOR_STRING:
1858:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
1859:                              //  later it is now manditory.  This should be defined in usb_config.h and should
1860:                              //  indicate the number of string descriptors.
1861:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
  3336    0E03     MOVLW 0x3
  3338    5D42     SUBWF 0x42, W, BANKED
  333A    E238     BC 0x33ac
1862:                              {
1863:                                  //Get a pointer to the String descriptor requested
1864:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
  333C    0EC0     MOVLW 0xc0
  333E    6E14     MOVWF 0x14, ACCESS
  3340    0E62     MOVLW 0x62
  3342    6E15     MOVWF 0x15, ACCESS
  3344    0E00     MOVLW 0
  3346    6E16     MOVWF 0x16, ACCESS
  3348    C442     MOVFF 0x442, 0x17
  334A    F017     NOP
  334C    6A18     CLRF 0x18, ACCESS
  334E    6A19     CLRF 0x19, ACCESS
  3350    0E03     MOVLW 0x3
  3352    6E0C     MOVWF 0xc, ACCESS
  3354    6A0D     CLRF 0xd, ACCESS
  3356    6A0E     CLRF 0xe, ACCESS
  3358    C017     MOVFF 0x17, 0x7
  335A    F007     NOP
  335C    C018     MOVFF 0x18, 0x8
  335E    F008     NOP
  3360    C019     MOVFF 0x19, 0x9
  3362    F009     NOP
  3364    EC7A     CALL 0x60f4, 0
  3366    F030     NOP
  3368    5014     MOVF 0x14, W, ACCESS
  336A    2404     ADDWF 0x4, W, ACCESS
  336C    6EF3     MOVWF 0xff3, ACCESS
  336E    5015     MOVF 0x15, W, ACCESS
  3370    2005     ADDWFC 0x5, W, ACCESS
  3372    6EF4     MOVWF 0xff4, ACCESS
  3374    5016     MOVF 0x16, W, ACCESS
  3376    2006     ADDWFC 0x6, W, ACCESS
  3378    6EF8     MOVWF 0xff8, ACCESS
  337A    CFF4     MOVFF 0xff4, 0xff7
  337C    FFF7     NOP
  337E    CFF3     MOVFF 0xff3, 0xff6
  3380    FFF6     NOP
  3382    0009     TBLRD*+
  3384    CFF5     MOVFF 0xff5, 0x79
  3386    F079     NOP
  3388    0009     TBLRD*+
  338A    CFF5     MOVFF 0xff5, 0x7a
  338C    F07A     NOP
  338E    0008     TBLRD*
  3390    CFF5     MOVFF 0xff5, 0x7b
  3392    F07B     NOP
1865:                                  // Set data count
1866:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
  3394    C079     MOVFF 0x79, 0xff6
  3396    FFF6     NOP
  3398    C07A     MOVFF 0x7a, 0xff7
  339A    FFF7     NOP
  339C    C07B     MOVFF 0x7b, 0xff8
  339E    FFF8     NOP
  33A0    0008     TBLRD*
  33A2    50F5     MOVF 0xff5, W, ACCESS
  33A4    0100     MOVLB 0
  33A6    6F7D     MOVWF 0x7d, BANKED
  33A8    6B7E     CLRF 0x7e, BANKED
1867:                              }
1868:                              else
  33AA    0012     RETURN 0
1869:                              {
1870:                                  inPipes[0].info.Val = 0;
  33AC    0100     MOVLB 0
  33AE    6B7C     CLRF 0x7c, BANKED
1871:                              }
1872:                              break;
  33B0    0012     RETURN 0
1873:                          default:
1874:                              inPipes[0].info.Val = 0;
  33B2    0100     MOVLB 0
  33B4    6B7C     CLRF 0x7c, BANKED
1875:                              break;
1876:                      }//end switch
1877:                  }//end if
1878:              }//end USBStdGetDscHandler
  33B6    0012     RETURN 0
1879:              
1880:              /********************************************************************
1881:               * Function:        void USBStdGetStatusHandler(void)
1882:               *
1883:               * PreCondition:    None
1884:               *
1885:               * Input:           None
1886:               *
1887:               * Output:          None
1888:               *
1889:               * Side Effects:    None
1890:               *
1891:               * Overview:        This routine handles the standard GET_STATUS request
1892:               *
1893:               * Note:            None
1894:               *******************************************************************/
1895:              void USBStdGetStatusHandler(void)
  33B8    CFD9     MOVFF 0xfd9, 0xfe6
  33BA    FFE6     NOP
  33BC    CFE1     MOVFF 0xfe1, 0xfd9
  33BE    FFD9     NOP
  33C0    0E02     MOVLW 0x2
  33C2    26E1     ADDWF 0xfe1, F, ACCESS
1896:              {
1897:                  CtrlTrfData[0] = 0;                 // Initialize content
  33C4    0104     MOVLB 0x4
  33C6    6B48     CLRF 0x48, BANKED
1898:                  CtrlTrfData[1] = 0;
  33C8    6B49     CLRF 0x49, BANKED
1899:              
1900:                  switch(SetupPkt.Recipient)
  33CA    5140     MOVF 0x40, W, BANKED
  33CC    0B1F     ANDLW 0x1f
  33CE    0A02     XORLW 0x2
  33D0    E011     BZ 0x33f4
  33D2    0A03     XORLW 0x3
  33D4    E00C     BZ 0x33ee
  33D6    0A01     XORLW 0x1
  33D8    E135     BNZ 0x3444
1901:                  {
1902:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
1903:                          inPipes[0].info.bits.busy = 1;
  33DA    0100     MOVLB 0
  33DC    8F7C     BSF 0x7c, 0x7, BANKED
1904:                          /*
1905:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
1906:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
1907:                           */
1908:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
1909:                          {
1910:                              CtrlTrfData[0]|=0x01;
  33DE    0104     MOVLB 0x4
  33E0    8148     BSF 0x48, 0, BANKED
1911:                          }
1912:              
1913:                          if(RemoteWakeup == TRUE)
  33E2    0100     MOVLB 0
  33E4    0589     DECF 0x89, W, BANKED
  33E6    E12E     BNZ 0x3444
1914:                          {
1915:                              CtrlTrfData[0]|=0x02;
  33E8    0104     MOVLB 0x4
  33EA    8348     BSF 0x48, 0x1, BANKED
1916:                          }
1917:                          break;
  33EC    D02B     BRA 0x3444
1918:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
1919:                          inPipes[0].info.bits.busy = 1;     // No data to update
  33EE    0100     MOVLB 0
  33F0    8F7C     BSF 0x7c, 0x7, BANKED
1920:                          break;
  33F2    D028     BRA 0x3444
1921:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
1922:                          inPipes[0].info.bits.busy = 1;
  33F4    0100     MOVLB 0
  33F6    8F7C     BSF 0x7c, 0x7, BANKED
1923:                          /*
1924:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
1925:                           */
1926:                          {
1927:                              BDT_ENTRY *p;
1928:              
1929:                              if(SetupPkt.EPDir == 0)
  33F8    0104     MOVLB 0x4
  33FA    BF44     BTFSC 0x44, 0x7, BANKED
  33FC    D00B     BRA 0x3414
1930:                              {
1931:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
  33FE    5144     MOVF 0x44, W, BANKED
  3400    0B0F     ANDLW 0xf
  3402    6EE9     MOVWF 0xfe9, ACCESS
  3404    6AEA     CLRF 0xfea, ACCESS
  3406    90D8     BCF 0xfd8, 0, ACCESS
  3408    36E9     RLCF 0xfe9, F, ACCESS
  340A    36EA     RLCF 0xfea, F, ACCESS
  340C    0E67     MOVLW 0x67
  340E    26E9     ADDWF 0xfe9, F, ACCESS
  3410    0E00     MOVLW 0
1932:                              }
1933:                              else
  3412    D00A     BRA 0x3428
1934:                              {
1935:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
  3414    5144     MOVF 0x44, W, BANKED
  3416    0B0F     ANDLW 0xf
  3418    6EE9     MOVWF 0xfe9, ACCESS
  341A    6AEA     CLRF 0xfea, ACCESS
  341C    90D8     BCF 0xfd8, 0, ACCESS
  341E    36E9     RLCF 0xfe9, F, ACCESS
  3420    36EA     RLCF 0xfea, F, ACCESS
  3422    0E6F     MOVLW 0x6f
  3424    26E9     ADDWF 0xfe9, F, ACCESS
  3426    0E00     MOVLW 0
  3428    22EA     ADDWFC 0xfea, F, ACCESS
  342A    CFEE     MOVFF 0xfee, 0xfde
  342C    FFDE     NOP
  342E    CFED     MOVFF 0xfed, 0xfdd
  3430    FFDD     NOP
1936:                              }
1937:              
1938:                              if(p->STAT.Val & _BSTALL)    // Use _BSTALL as a bit mask
  3432    CFDE     MOVFF 0xfde, 0xfe9
  3434    FFE9     NOP
  3436    CFDD     MOVFF 0xfdd, 0xfea
  3438    FFEA     NOP
  343A    50EF     MOVF 0xfef, W, ACCESS
  343C    0B04     ANDLW 0x4
  343E    E002     BZ 0x3444
1939:                                  CtrlTrfData[0]=0x01;    // Set bit0
  3440    0E01     MOVLW 0x1
  3442    6F48     MOVWF 0x48, BANKED
1940:                              break;
1941:                          }
1942:                  }//end switch
1943:              
1944:                  if(inPipes[0].info.bits.busy == 1)
  3444    0100     MOVLB 0
  3446    AF7C     BTFSS 0x7c, 0x7, BANKED
  3448    D007     BRA 0x3458
1945:                  {
1946:                      inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
  344A    0E48     MOVLW 0x48
  344C    6F79     MOVWF 0x79, BANKED
  344E    0E04     MOVLW 0x4
  3450    6F7A     MOVWF 0x7a, BANKED
1947:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
  3452    817C     BSF 0x7c, 0, BANKED
1948:                      inPipes[0].wCount.v[0] = 2;                         // Set data count
  3454    0E02     MOVLW 0x2
  3456    6F7D     MOVWF 0x7d, BANKED
1949:                  }//end if(...)
1950:              }//end USBStdGetStatusHandler
  3458    0E02     MOVLW 0x2
  345A    5CE1     SUBWF 0xfe1, W, ACCESS
  345C    E202     BC 0x3462
  345E    6AE1     CLRF 0xfe1, ACCESS
  3460    52E5     MOVF 0xfe5, F, ACCESS
  3462    6EE1     MOVWF 0xfe1, ACCESS
  3464    52E5     MOVF 0xfe5, F, ACCESS
  3466    CFE7     MOVFF 0xfe7, 0xfd9
  3468    FFD9     NOP
  346A    0012     RETURN 0
1951:              
1952:              /******************************************************************************
1953:               * Function:        void USBCtrlEPServiceComplete(void)
1954:               *
1955:               * PreCondition:    None
1956:               *
1957:               * Input:           None
1958:               *
1959:               * Output:          None
1960:               *
1961:               * Side Effects:    None
1962:               *
1963:               * Overview:        This routine wrap up the remaining tasks in servicing
1964:               *                  a Setup Request. Its main task is to set the endpoint
1965:               *                  controls appropriately for a given situation. See code
1966:               *                  below.
1967:               *                  There are three main scenarios:
1968:               *                  a) There was no handler for the Request, in this case
1969:               *                     a STALL should be sent out.
1970:               *                  b) The host has requested a read control transfer,
1971:               *                     endpoints are required to be setup in a specific way.
1972:               *                  c) The host has requested a write control transfer, or
1973:               *                     a control data stage is not required, endpoints are
1974:               *                     required to be setup in a specific way.
1975:               *
1976:               *                  Packet processing is resumed by clearing PKTDIS bit.
1977:               *
1978:               * Note:            None
1979:               *****************************************************************************/
1980:              static void USBCtrlEPServiceComplete(void)
1981:              {
1982:                  /*
1983:                   * PKTDIS bit is set when a Setup Transaction is received.
1984:                   * Clear to resume packet processing.
1985:                   */
1986:                  USBPacketDisable = 0;
  346C    9865     BCF 0xf65, 0x4, ACCESS
1987:              
1988:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1989:              	//control transfer is currently in progress.  We need to know the type of control
1990:              	//transfer that is currently pending, in order to know how to properly arm the 
1991:              	//EP0 IN and EP0 OUT endpoints.
1992:                  if(inPipes[0].info.bits.busy == 0)
  346E    0100     MOVLB 0
  3470    BF7C     BTFSC 0x7c, 0x7, BANKED
  3472    D02B     BRA 0x34ca
1993:                  {
1994:                      if(outPipes[0].info.bits.busy == 1)
  3474    AF81     BTFSS 0x81, 0x7, BANKED
  3476    D009     BRA 0x348a
1995:                      {
1996:                          controlTransferState = CTRL_TRF_RX;
  3478    0E02     MOVLW 0x2
  347A    6F78     MOVWF 0x78, BANKED
1997:                          /*
1998:                           * Control Write:
1999:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
2000:                           */
2001:              
2002:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
2003:                          //   function decided to defer the data stage (ex: because the intended
2004:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
2005:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
2006:                          //   once it is ready to begin receiving the data.
2007:                          if(USBDeferOUTDataStagePackets == FALSE)
  347C    519B     MOVF 0x9b, W, BANKED
  347E    E101     BNZ 0x3482
2008:                          {
2009:                              USBCtrlEPAllowDataStage();
  3480    DEB9     RCALL 0x31f4
2010:                          }
2011:                          
2012:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
2013:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
2014:                          USBStatusStageEnabledFlag2 = FALSE;
  3482    0100     MOVLB 0
  3484    6B99     CLRF 0x99, BANKED
2015:                          USBStatusStageEnabledFlag1 = FALSE;
  3486    6B98     CLRF 0x98, BANKED
2016:                      }
2017:                      else
  3488    0012     RETURN 0
2018:                      {
2019:                          /*
2020:                           * If no one knows how to service this request then stall.
2021:                           * Must also prepare EP0 to receive the next SETUP transaction.
2022:                           */
2023:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  348A    C065     MOVFF 0x65, 0xfe9
  348C    FFE9     NOP
  348E    C066     MOVFF 0x66, 0xfea
  3490    FFEA     NOP
  3492    52EE     MOVF 0xfee, F, ACCESS
  3494    0E08     MOVLW 0x8
  3496    6EEF     MOVWF 0xfef, ACCESS
2024:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  3498    C065     MOVFF 0x65, 0xfe9
  349A    FFE9     NOP
  349C    C066     MOVFF 0x66, 0xfea
  349E    FFEA     NOP
  34A0    0E02     MOVLW 0x2
  34A2    26E9     ADDWF 0xfe9, F, ACCESS
  34A4    0E00     MOVLW 0
  34A6    22EA     ADDWFC 0xfea, F, ACCESS
  34A8    0E40     MOVLW 0x40
  34AA    6EEE     MOVWF 0xfee, ACCESS
  34AC    0E04     MOVLW 0x4
  34AE    6EED     MOVWF 0xfed, ACCESS
2025:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
  34B0    C065     MOVFF 0x65, 0xfe9
  34B2    FFE9     NOP
  34B4    C066     MOVFF 0x66, 0xfea
  34B6    FFEA     NOP
  34B8    0E8C     MOVLW 0x8c
  34BA    6EEF     MOVWF 0xfef, ACCESS
2026:                          pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
  34BC    C06F     MOVFF 0x6f, 0xfe9
  34BE    FFE9     NOP
  34C0    C070     MOVFF 0x70, 0xfea
  34C2    FFEA     NOP
  34C4    0E84     MOVLW 0x84
  34C6    6EEF     MOVWF 0xfef, ACCESS
2027:                      }
2028:                  }
2029:                  else    // A module has claimed ownership of the control transfer session.
  34C8    0012     RETURN 0
2030:                  {
2031:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
  34CA    0104     MOVLB 0x4
  34CC    AF40     BTFSS 0x40, 0x7, BANKED
  34CE    D00D     BRA 0x34ea
2032:              		{
2033:              			controlTransferState = CTRL_TRF_TX;
  34D0    0100     MOVLB 0
  34D2    0E01     MOVLW 0x1
  34D4    6F78     MOVWF 0x78, BANKED
2034:              			/*
2035:              			 * Control Read:
2036:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
2037:              			 *
2038:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
2039:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
2040:              			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
2041:              			 *    Then the class request handler reponsible should call the USBDeferDataStage()
2042:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
2043:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
2044:              			 *    is ready to begin sending the data, it should then call the 
2045:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
2046:              			 */
2047:              			if(USBDeferINDataStagePackets == FALSE)
  34D6    519A     MOVF 0x9a, W, BANKED
  34D8    E101     BNZ 0x34dc
2048:                          {
2049:                              USBCtrlEPAllowDataStage();
  34DA    DE8C     RCALL 0x31f4
2050:              			}
2051:              
2052:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
2053:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
2054:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
2055:                          //    is ready.  If the class request handler does this, it needs to be careful to
2056:                          //    be written so that it can handle the early termination scenario.
2057:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
2058:                          //    1.  The desired total number of bytes were sent to the host.
2059:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
2060:                          //        started the control transfer) has been reached.
2061:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
2062:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
2063:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
2064:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
2065:                          //        option can take care of this for you.
2066:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
2067:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
2068:                          //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
2069:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
2070:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
2071:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
2072:                          USBStatusStageEnabledFlag2 = FALSE;
  34DC    0100     MOVLB 0
  34DE    6B99     CLRF 0x99, BANKED
2073:                          USBStatusStageEnabledFlag1 = FALSE;
  34E0    6B98     CLRF 0x98, BANKED
2074:                          if(USBDeferStatusStagePacket == FALSE)
  34E2    5197     MOVF 0x97, W, BANKED
  34E4    E123     BNZ 0x352c
2075:                          {
2076:                              USBCtrlEPAllowStatusStage();
  34E6    EFA9     GOTO 0x3152
  34E8    F018     NOP
2077:                          } 
2078:              		}
2079:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
2080:              		{
2081:              			//This situation occurs for special types of control transfers,
2082:              			//such as that which occurs when the host sends a SET_ADDRESS
2083:              			//control transfer.  Ex:
2084:              			//
2085:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
2086:              				
2087:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
2088:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
2089:              			//an IN status stage.
2090:              
2091:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
  34EA    0100     MOVLB 0
  34EC    0E02     MOVLW 0x2
  34EE    6F78     MOVWF 0x78, BANKED
2092:              			
2093:              			//1. Prepare OUT EP to receive the next SETUP packet.
2094:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  34F0    C065     MOVFF 0x65, 0xfe9
  34F2    FFE9     NOP
  34F4    C066     MOVFF 0x66, 0xfea
  34F6    FFEA     NOP
  34F8    52EE     MOVF 0xfee, F, ACCESS
  34FA    0E08     MOVLW 0x8
  34FC    6EEF     MOVWF 0xfef, ACCESS
2095:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  34FE    C065     MOVFF 0x65, 0xfe9
  3500    FFE9     NOP
  3502    C066     MOVFF 0x66, 0xfea
  3504    FFEA     NOP
  3506    0E02     MOVLW 0x2
  3508    26E9     ADDWF 0xfe9, F, ACCESS
  350A    0E00     MOVLW 0
  350C    22EA     ADDWFC 0xfea, F, ACCESS
  350E    0E40     MOVLW 0x40
  3510    6EEE     MOVWF 0xfee, ACCESS
  3512    0E04     MOVLW 0x4
  3514    6EED     MOVWF 0xfed, ACCESS
2096:              			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
  3516    C065     MOVFF 0x65, 0xfe9
  3518    FFE9     NOP
  351A    C066     MOVFF 0x66, 0xfea
  351C    FFEA     NOP
  351E    0E84     MOVLW 0x84
  3520    6EEF     MOVWF 0xfef, ACCESS
2097:              				
2098:              			//2. Prepare for IN status stage of the control transfer
2099:                          USBStatusStageEnabledFlag2 = FALSE;
  3522    6B99     CLRF 0x99, BANKED
2100:                          USBStatusStageEnabledFlag1 = FALSE;
  3524    6B98     CLRF 0x98, BANKED
2101:              			if(USBDeferStatusStagePacket == FALSE)
  3526    5197     MOVF 0x97, W, BANKED
  3528    E101     BNZ 0x352c
2102:                          {
2103:                              USBCtrlEPAllowStatusStage();
  352A    DE13     RCALL 0x3152
2104:                          } 
2105:              		}
2106:              
2107:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
2108:              
2109:              }//end USBCtrlEPServiceComplete
  352C    0012     RETURN 0
2110:              
2111:              
2112:              /******************************************************************************
2113:               * Function:        void USBCtrlTrfTxService(void)
2114:               *
2115:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
2116:               *
2117:               * Input:           None
2118:               *
2119:               * Output:          None
2120:               *
2121:               * Side Effects:    None
2122:               *
2123:               * Overview:        This routine is used for device to host control transfers 
2124:               *					(IN transactions).  This function takes care of managing a
2125:               *                  transfer over multiple USB transactions.
2126:               *					This routine should be called from only two places.
2127:               *                  One from USBCtrlEPServiceComplete() and one from
2128:               *                  USBCtrlTrfInHandler().
2129:               *
2130:               * Note:            
2131:               *****************************************************************************/
2132:              static void USBCtrlTrfTxService(void)
  352E    CFD9     MOVFF 0xfd9, 0xfe6
  3530    FFE6     NOP
  3532    CFE1     MOVFF 0xfe1, 0xfd9
  3534    FFD9     NOP
  3536    52E6     MOVF 0xfe6, F, ACCESS
2133:              {
2134:                  BYTE byteToSend;
2135:              
2136:                  //Figure out how many bytes of data to send in the next IN transaction.
2137:                  //Assume a full size packet, unless otherwise determined below.
2138:                  byteToSend = USB_EP0_BUFF_SIZE;         
  3538    0E08     MOVLW 0x8
  353A    6EDF     MOVWF 0xfdf, ACCESS
2139:                  if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
  353C    0100     MOVLB 0
  353E    5D7D     SUBWF 0x7d, W, BANKED
  3540    0E00     MOVLW 0
  3542    597E     SUBWFB 0x7e, W, BANKED
  3544    E20A     BC 0x355a
2140:                  {
2141:                      byteToSend = inPipes[0].wCount.Val;
  3546    C07D     MOVFF 0x7d, 0xfdf
  3548    FFDF     NOP
2142:              
2143:                      //Keep track of whether or not we have sent a "short packet" yet.
2144:                      //This is useful so that later on, we can configure EP0 IN to STALL,
2145:                      //after we have sent all of the intended data.  This makes sure the
2146:                      //hardware STALLs if the host erroneously tries to send more IN token 
2147:                      //packets, requesting more data than intended in the control transfer.
2148:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
  354A    5177     MOVF 0x77, W, BANKED
  354C    E102     BNZ 0x3552
2149:                      {
2150:                          shortPacketStatus = SHORT_PKT_PENDING;
  354E    0E01     MOVLW 0x1
2151:                      }
2152:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
  3550    D003     BRA 0x3558
  3552    0577     DECF 0x77, W, BANKED
  3554    E102     BNZ 0x355a
2153:                      {
2154:                          shortPacketStatus = SHORT_PKT_SENT;
  3556    0E02     MOVLW 0x2
  3558    6F77     MOVWF 0x77, BANKED
2155:                      }
2156:                  }
2157:              
2158:                  //Keep track of how many bytes remain to be sent in the transfer, by
2159:                  //subtracting the number of bytes about to be sent from the total.
2160:                  inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
  355A    50DF     MOVF 0xfdf, W, ACCESS
  355C    6A15     CLRF 0x15, ACCESS
  355E    50E8     MOVF 0xfe8, W, ACCESS
  3560    5D7D     SUBWF 0x7d, W, BANKED
  3562    6F7D     MOVWF 0x7d, BANKED
  3564    5015     MOVF 0x15, W, ACCESS
  3566    597E     SUBWFB 0x7e, W, BANKED
  3568    6F7E     MOVWF 0x7e, BANKED
2161:                  
2162:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
2163:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
2164:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
2165:                  pBDTEntryIn[0]->CNT = byteToSend;
  356A    C06F     MOVFF 0x6f, 0xfe9
  356C    FFE9     NOP
  356E    C070     MOVFF 0x70, 0xfea
  3570    FFEA     NOP
  3572    52EE     MOVF 0xfee, F, ACCESS
  3574    CFDF     MOVFF 0xfdf, 0xfef
  3576    FFEF     NOP
2166:              
2167:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
2168:                  //which we will send to the host.
2169:                  pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
  3578    0E48     MOVLW 0x48
  357A    6F87     MOVWF 0x87, BANKED
  357C    0E04     MOVLW 0x4
  357E    6F88     MOVWF 0x88, BANKED
2170:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
  3580    B17C     BTFSC 0x7c, 0, BANKED
  3582    D01B     BRA 0x35ba
2171:                  {
2172:                      while(byteToSend)
  3584    50DF     MOVF 0xfdf, W, ACCESS
  3586    E030     BZ 0x35e8
  35B8    D7E5     BRA 0x3584
2173:                      {
2174:                          *pDst++ = *inPipes[0].pSrc.bRom++;
  3588    C079     MOVFF 0x79, 0xff6
  358A    FFF6     NOP
  358C    2B79     INCF 0x79, F, BANKED
  358E    C07A     MOVFF 0x7a, 0xff7
  3590    FFF7     NOP
  3592    0E00     MOVLW 0
  3594    237A     ADDWFC 0x7a, F, BANKED
  3596    C07B     MOVFF 0x7b, 0xff8
  3598    FFF8     NOP
  359A    237B     ADDWFC 0x7b, F, BANKED
  359C    0008     TBLRD*
  359E    50F5     MOVF 0xff5, W, ACCESS
  35A0    6EE6     MOVWF 0xfe6, ACCESS
  35A2    C087     MOVFF 0x87, 0xfe9
  35A4    FFE9     NOP
  35A6    C088     MOVFF 0x88, 0xfea
  35A8    FFEA     NOP
  35AA    2B87     INCF 0x87, F, BANKED
  35AC    0E00     MOVLW 0
  35AE    2388     ADDWFC 0x88, F, BANKED
  35B0    52E5     MOVF 0xfe5, F, ACCESS
  35B2    50E7     MOVF 0xfe7, W, ACCESS
  35B4    6EEF     MOVWF 0xfef, ACCESS
2175:                          byteToSend--;
  35B6    06DF     DECF 0xfdf, F, ACCESS
2176:                      }//end while(byte_to_send.Val)
2177:                  }
2178:                  else  // RAM
2179:                  {
2180:                      while(byteToSend)
  35BA    50DF     MOVF 0xfdf, W, ACCESS
  35BC    E015     BZ 0x35e8
  35E6    D7E9     BRA 0x35ba
2181:                      {
2182:                          *pDst++ = *inPipes[0].pSrc.bRam++;
  35BE    C079     MOVFF 0x79, 0xfe9
  35C0    FFE9     NOP
  35C2    C07A     MOVFF 0x7a, 0xfea
  35C4    FFEA     NOP
  35C6    2B79     INCF 0x79, F, BANKED
  35C8    0E00     MOVLW 0
  35CA    237A     ADDWFC 0x7a, F, BANKED
  35CC    50EF     MOVF 0xfef, W, ACCESS
  35CE    6EE6     MOVWF 0xfe6, ACCESS
  35D0    C087     MOVFF 0x87, 0xfe9
  35D2    FFE9     NOP
  35D4    C088     MOVFF 0x88, 0xfea
  35D6    FFEA     NOP
  35D8    2B87     INCF 0x87, F, BANKED
  35DA    0E00     MOVLW 0
  35DC    2388     ADDWFC 0x88, F, BANKED
  35DE    52E5     MOVF 0xfe5, F, ACCESS
  35E0    50E7     MOVF 0xfe7, W, ACCESS
  35E2    6EEF     MOVWF 0xfef, ACCESS
2183:                          byteToSend--;
  35E4    06DF     DECF 0xfdf, F, ACCESS
2184:                      }//end while(byte_to_send.Val)
2185:                  }//end if(usb_stat.ctrl_trf_mem == _ROM)
2186:              }//end USBCtrlTrfTxService
  35E8    52E5     MOVF 0xfe5, F, ACCESS
  35EA    52E5     MOVF 0xfe5, F, ACCESS
  35EC    CFE7     MOVFF 0xfe7, 0xfd9
  35EE    FFD9     NOP
  35F0    0012     RETURN 0
2187:              
2188:              /******************************************************************************
2189:               * Function:        void USBCtrlTrfRxService(void)
2190:               *
2191:               * PreCondition:    pDst and wCount are setup properly.
2192:               *                  pSrc is always &CtrlTrfData
2193:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
2194:               *                  wCount should be set to 0 at the start of each control
2195:               *                  transfer.
2196:               *
2197:               * Input:           None
2198:               *
2199:               * Output:          None
2200:               *
2201:               * Side Effects:    None
2202:               *
2203:               * Overview:        This routine is used for host to device control transfers
2204:               *					(uses OUT transactions).  This function receives the data that arrives
2205:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2206:               *					buffer.  Once the host has sent all the data it was intending
2207:               *					to send, this function will call the appropriate outPipes[0].pFunc()
2208:               *					handler (unless it is NULL), so that it can be used by the
2209:               *					intended target firmware.
2210:               *
2211:               * Note:            None
2212:               *****************************************************************************/
2213:              static void USBCtrlTrfRxService(void)
  35F2    CFD9     MOVFF 0xfd9, 0xfe6
  35F4    FFE6     NOP
  35F6    CFE1     MOVFF 0xfe1, 0xfd9
  35F8    FFD9     NOP
  35FA    0E02     MOVLW 0x2
  35FC    26E1     ADDWF 0xfe1, F, ACCESS
2214:              {
2215:                  BYTE byteToRead;
2216:                  BYTE i;
2217:              
2218:                  //Load byteToRead with the number of bytes the host just sent us in the 
2219:                  //last OUT transaction.
2220:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;   
  35FE    C063     MOVFF 0x63, 0xfe9
  3600    FFE9     NOP
  3602    C064     MOVFF 0x64, 0xfea
  3604    FFEA     NOP
  3606    52EE     MOVF 0xfee, F, ACCESS
  3608    CFEF     MOVFF 0xfef, 0xfdf
  360A    FFDF     NOP
2221:              
2222:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2223:                  //of remaining bytes expected to be received from the host, in the control
2224:                  //transfer.  First check to see if the host sent us more bytes than the
2225:                  //application firmware was expecting to receive.
2226:                  if(byteToRead > outPipes[0].wCount.Val)
  360C    CFDF     MOVFF 0xfdf, 0x14
  360E    F014     NOP
  3610    5014     MOVF 0x14, W, ACCESS
  3612    0100     MOVLB 0
  3614    5D82     SUBWF 0x82, W, BANKED
  3616    0E00     MOVLW 0
  3618    5983     SUBWFB 0x83, W, BANKED
  361A    E202     BC 0x3620
2227:                  {
2228:                      byteToRead = outPipes[0].wCount.Val;
  361C    C082     MOVFF 0x82, 0xfdf
  361E    FFDF     NOP
2229:                  }	
2230:                  //Reduce the number of remaining bytes by the number we just received.
2231:              	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
  3620    50DF     MOVF 0xfdf, W, ACCESS
  3622    6E14     MOVWF 0x14, ACCESS
  3624    6A15     CLRF 0x15, ACCESS
  3626    50E8     MOVF 0xfe8, W, ACCESS
  3628    5D82     SUBWF 0x82, W, BANKED
  362A    6F82     MOVWF 0x82, BANKED
  362C    5015     MOVF 0x15, W, ACCESS
  362E    5983     SUBWFB 0x83, W, BANKED
  3630    6F83     MOVWF 0x83, BANKED
2232:              
2233:                  //Copy the OUT DATAx packet bytes that we just received from the host,
2234:                  //into the user application buffer space.
2235:                  for(i=0;i<byteToRead;i++)
  3632    0E01     MOVLW 0x1
  3634    6ADB     CLRF 0xfdb, ACCESS
  3636    50DF     MOVF 0xfdf, W, ACCESS
  3638    6EF3     MOVWF 0xff3, ACCESS
  363A    0E01     MOVLW 0x1
  363C    CFDB     MOVFF 0xfdb, 0xff4
  363E    FFF4     NOP
  3640    50F3     MOVF 0xff3, W, ACCESS
  3642    5CF4     SUBWF 0xff4, W, ACCESS
  3644    E216     BC 0x3672
  366C    0E01     MOVLW 0x1
  366E    2ADB     INCF 0xfdb, F, ACCESS
  3670    D7E2     BRA 0x3636
2236:                  {
2237:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
  3646    0E01     MOVLW 0x1
  3648    50DB     MOVF 0xfdb, W, ACCESS
  364A    6AEA     CLRF 0xfea, ACCESS
  364C    0F48     ADDLW 0x48
  364E    6EE9     MOVWF 0xfe9, ACCESS
  3650    0E04     MOVLW 0x4
  3652    22EA     ADDWFC 0xfea, F, ACCESS
  3654    50EF     MOVF 0xfef, W, ACCESS
  3656    6EE6     MOVWF 0xfe6, ACCESS
  3658    C07F     MOVFF 0x7f, 0xfe9
  365A    FFE9     NOP
  365C    C080     MOVFF 0x80, 0xfea
  365E    FFEA     NOP
  3660    2B7F     INCF 0x7f, F, BANKED
  3662    0E00     MOVLW 0
  3664    2380     ADDWFC 0x80, F, BANKED
  3666    52E5     MOVF 0xfe5, F, ACCESS
  3668    50E7     MOVF 0xfe7, W, ACCESS
  366A    6EEF     MOVWF 0xfef, ACCESS
2238:                  }//end while(byteToRead.Val)
2239:              
2240:                  //If there is more data to receive, prepare EP0 OUT so that it can receive 
2241:              	//the next packet in the sequence.
2242:                  if(outPipes[0].wCount.Val > 0)
  3672    0E00     MOVLW 0
  3674    80D8     BSF 0xfd8, 0, ACCESS
  3676    5582     SUBFWB 0x82, W, BANKED
  3678    0E00     MOVLW 0
  367A    5583     SUBFWB 0x83, W, BANKED
  367C    E227     BC 0x36cc
2243:                  {
2244:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  367E    C065     MOVFF 0x65, 0xfe9
  3680    FFE9     NOP
  3682    C066     MOVFF 0x66, 0xfea
  3684    FFEA     NOP
  3686    52EE     MOVF 0xfee, F, ACCESS
  3688    0E08     MOVLW 0x8
  368A    6EEF     MOVWF 0xfef, ACCESS
2245:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
  368C    C065     MOVFF 0x65, 0xfe9
  368E    FFE9     NOP
  3690    C066     MOVFF 0x66, 0xfea
  3692    FFEA     NOP
  3694    0E02     MOVLW 0x2
  3696    26E9     ADDWF 0xfe9, F, ACCESS
  3698    0E00     MOVLW 0
  369A    22EA     ADDWFC 0xfea, F, ACCESS
  369C    0E48     MOVLW 0x48
  369E    6EEE     MOVWF 0xfee, ACCESS
  36A0    0E04     MOVLW 0x4
  36A2    6EED     MOVWF 0xfed, ACCESS
2246:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
  36A4    C063     MOVFF 0x63, 0xfe9
  36A6    FFE9     NOP
  36A8    C064     MOVFF 0x64, 0xfea
  36AA    FFEA     NOP
  36AC    50EF     MOVF 0xfef, W, ACCESS
  36AE    0B40     ANDLW 0x40
  36B0    E106     BNZ 0x36be
2247:                      {
2248:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
  36B2    C065     MOVFF 0x65, 0xfe9
  36B4    FFE9     NOP
  36B6    C066     MOVFF 0x66, 0xfea
  36B8    FFEA     NOP
  36BA    0EC8     MOVLW 0xc8
2249:                      }
2250:                      else
  36BC    D005     BRA 0x36c8
2251:                      {
2252:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN;
  36BE    C065     MOVFF 0x65, 0xfe9
  36C0    FFE9     NOP
  36C2    C066     MOVFF 0x66, 0xfea
  36C4    FFEA     NOP
  36C6    0E88     MOVLW 0x88
  36C8    6EEF     MOVWF 0xfef, ACCESS
2253:                      }
2254:                  }
2255:                  else
  36CA    D02B     BRA 0x3722
2256:                  {
2257:              	    //We have received all OUT packets that we were expecting to
2258:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
2259:              		//the next SETUP transaction that may arrive.
2260:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  36CC    C065     MOVFF 0x65, 0xfe9
  36CE    FFE9     NOP
  36D0    C066     MOVFF 0x66, 0xfea
  36D2    FFEA     NOP
  36D4    52EE     MOVF 0xfee, F, ACCESS
  36D6    0E08     MOVLW 0x8
  36D8    6EEF     MOVWF 0xfef, ACCESS
2261:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  36DA    C065     MOVFF 0x65, 0xfe9
  36DC    FFE9     NOP
  36DE    C066     MOVFF 0x66, 0xfea
  36E0    FFEA     NOP
  36E2    0E02     MOVLW 0x2
  36E4    26E9     ADDWF 0xfe9, F, ACCESS
  36E6    0E00     MOVLW 0
  36E8    22EA     ADDWFC 0xfea, F, ACCESS
  36EA    0E40     MOVLW 0x40
  36EC    6EEE     MOVWF 0xfee, ACCESS
  36EE    0E04     MOVLW 0x4
  36F0    6EED     MOVWF 0xfed, ACCESS
2262:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
2263:                      //control transfers.  However, set BSTALL in case the host tries to send
2264:                      //more data than it claims it was going to send.
2265:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
  36F2    C065     MOVFF 0x65, 0xfe9
  36F4    FFE9     NOP
  36F6    C066     MOVFF 0x66, 0xfea
  36F8    FFEA     NOP
  36FA    0E84     MOVLW 0x84
  36FC    6EEF     MOVWF 0xfef, ACCESS
2266:              
2267:              		//All data bytes for the host to device control write (OUT) have now been
2268:              		//received successfully.
2269:              		//Go ahead and call the user specified callback function, to use/consume
2270:              		//the control transfer data (ex: if the "void (*function)" parameter 
2271:              		//was non-NULL when USBEP0Receive() was called).
2272:                      if(outPipes[0].pFunc != NULL)
  36FE    5184     MOVF 0x84, W, BANKED
  3700    1185     IORWF 0x85, W, BANKED
  3702    1186     IORWF 0x86, W, BANKED
  3704    E009     BZ 0x3718
2273:                      {
2274:                          outPipes[0].pFunc();
  3706    D007     BRA 0x3716
  3708    C086     MOVFF 0x86, 0xffb
  370A    FFFB     NOP
  370C    C085     MOVFF 0x85, 0xffa
  370E    FFFA     NOP
  3710    0100     MOVLB 0
  3712    5184     MOVF 0x84, W, BANKED
  3714    6EF9     MOVWF 0xff9, ACCESS
  3716    DFF8     RCALL 0x3708
2275:                      }
2276:                      outPipes[0].info.bits.busy = 0;    
  3718    0100     MOVLB 0
  371A    9F81     BCF 0x81, 0x7, BANKED
2277:              
2278:                      //Ready to arm status stage IN transaction now, if the application
2279:                      //firmware has completed processing the request.  If it is still busy
2280:                      //and needs more time to finish handling the request, then the user
2281:                      //callback (the one called by the outPipes[0].pFunc();) should set the
2282:                      //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2283:                      //this case, it is the application's firmware responsibility to call 
2284:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2285:                      //Note: The application firmware must process the request and call
2286:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2287:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
2288:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
2289:                      //more details.
2290:                      if(USBDeferStatusStagePacket == FALSE)
  371C    5197     MOVF 0x97, W, BANKED
  371E    E101     BNZ 0x3722
2291:                      {
2292:                          USBCtrlEPAllowStatusStage();
  3720    DD18     RCALL 0x3152
2293:                      }            
2294:                  }    
2295:              
2296:              }//end USBCtrlTrfRxService
  3722    0E02     MOVLW 0x2
  3724    5CE1     SUBWF 0xfe1, W, ACCESS
  3726    E202     BC 0x372c
  3728    6AE1     CLRF 0xfe1, ACCESS
  372A    52E5     MOVF 0xfe5, F, ACCESS
  372C    6EE1     MOVWF 0xfe1, ACCESS
  372E    52E5     MOVF 0xfe5, F, ACCESS
  3730    CFE7     MOVFF 0xfe7, 0xfd9
  3732    FFD9     NOP
  3734    0012     RETURN 0
2297:              
2298:              
2299:              /********************************************************************
2300:               * Function:        void USBStdSetCfgHandler(void)
2301:               *
2302:               * PreCondition:    None
2303:               *
2304:               * Input:           None
2305:               *
2306:               * Output:          None
2307:               *
2308:               * Side Effects:    None
2309:               *
2310:               * Overview:        This routine first disables all endpoints by
2311:               *                  clearing UEP registers. It then configures
2312:               *                  (initializes) endpoints by calling the callback
2313:               *                  function USBCBInitEP().
2314:               *
2315:               * Note:            None
2316:               *******************************************************************/
2317:              void USBStdSetCfgHandler(void)
  3736    CFD9     MOVFF 0xfd9, 0xfe6
  3738    FFE6     NOP
  373A    CFE1     MOVFF 0xfe1, 0xfd9
  373C    FFD9     NOP
  373E    52E6     MOVF 0xfe6, F, ACCESS
2318:              {
2319:                  BYTE i;
2320:              
2321:                  // This will generate a zero length packet
2322:                  inPipes[0].info.bits.busy = 1;            
  3740    0100     MOVLB 0
  3742    8F7C     BSF 0x7c, 0x7, BANKED
2323:              
2324:                  //Clear all of the endpoint control registers
2325:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
  3744    0E03     MOVLW 0x3
  3746    6EE6     MOVWF 0xfe6, ACCESS
  3748    6AE6     CLRF 0xfe6, ACCESS
  374A    6AE6     CLRF 0xfe6, ACCESS
  374C    0E27     MOVLW 0x27
  374E    6EE6     MOVWF 0xfe6, ACCESS
  3750    0E0F     MOVLW 0xf
  3752    6EE6     MOVWF 0xfe6, ACCESS
  3754    EC88     CALL 0x6310, 0
  3756    F031     NOP
  3758    6E14     MOVWF 0x14, ACCESS
  375A    0E05     MOVLW 0x5
  375C    5EE1     SUBWF 0xfe1, F, ACCESS
  375E    5014     MOVF 0x14, W, ACCESS
2326:              
2327:                  //Clear all of the BDT entries
2328:                  for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
  3760    6ADF     CLRF 0xfdf, ACCESS
  3762    50DF     MOVF 0xfdf, W, ACCESS
  3764    6E14     MOVWF 0x14, ACCESS
  3766    6A15     CLRF 0x15, ACCESS
  3768    0E10     MOVLW 0x10
  376A    5C14     SUBWF 0x14, W, ACCESS
  376C    0E00     MOVLW 0
  376E    5815     SUBWFB 0x15, W, ACCESS
  3770    E210     BC 0x3792
  378E    2ADF     INCF 0xfdf, F, ACCESS
  3790    D7E8     BRA 0x3762
2329:                  {
2330:                      BDT[i].Val = 0x00;
  3772    50DF     MOVF 0xfdf, W, ACCESS
  3774    0D04     MULLW 0x4
  3776    CFF3     MOVFF 0xff3, 0xfe9
  3778    FFE9     NOP
  377A    CFF4     MOVFF 0xff4, 0xfea
  377C    FFEA     NOP
  377E    0E00     MOVLW 0
  3780    26E9     ADDWF 0xfe9, F, ACCESS
  3782    0E04     MOVLW 0x4
  3784    22EA     ADDWFC 0xfea, F, ACCESS
  3786    6AEE     CLRF 0xfee, ACCESS
  3788    6AEE     CLRF 0xfee, ACCESS
  378A    6AEE     CLRF 0xfee, ACCESS
  378C    6AEE     CLRF 0xfee, ACCESS
2331:                  }
2332:              
2333:                  // Assert reset request to all of the Ping Pong buffer pointers
2334:                  USBPingPongBufferReset = 1;                                   
  3792    8C65     BSF 0xf65, 0x6, ACCESS
2335:              
2336:                  //clear the alternate interface settings
2337:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
  3794    0E01     MOVLW 0x1
  3796    6EE6     MOVWF 0xfe6, ACCESS
  3798    6AE6     CLRF 0xfe6, ACCESS
  379A    6AE6     CLRF 0xfe6, ACCESS
  379C    0E62     MOVLW 0x62
  379E    6EE6     MOVWF 0xfe6, ACCESS
  37A0    0E00     MOVLW 0
  37A2    6EE6     MOVWF 0xfe6, ACCESS
  37A4    EC88     CALL 0x6310, 0
  37A6    F031     NOP
  37A8    6E14     MOVWF 0x14, ACCESS
  37AA    0E05     MOVLW 0x5
  37AC    5EE1     SUBWF 0xfe1, F, ACCESS
  37AE    5014     MOVF 0x14, W, ACCESS
2338:              
2339:                  //Stop trying to reset ping pong buffer pointers
2340:                  USBPingPongBufferReset = 0;
  37B0    9C65     BCF 0xf65, 0x6, ACCESS
2341:              
2342:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
  37B2    0100     MOVLB 0
  37B4    0E08     MOVLW 0x8
  37B6    6F6F     MOVWF 0x6f, BANKED
  37B8    0E04     MOVLW 0x4
  37BA    6F70     MOVWF 0x70, BANKED
2343:              
2344:              	//Set the next out to the current out packet
2345:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
  37BC    0E00     MOVLW 0
  37BE    6F63     MOVWF 0x63, BANKED
  37C0    0E04     MOVLW 0x4
  37C2    6F64     MOVWF 0x64, BANKED
2346:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
  37C4    C063     MOVFF 0x63, 0x65
  37C6    F065     NOP
  37C8    6F66     MOVWF 0x66, BANKED
2347:              
2348:                  //set the current configuration
2349:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
  37CA    C442     MOVFF 0x442, 0x61
  37CC    F061     NOP
2350:              
2351:                  //if the configuration value == 0
2352:                  if(USBActiveConfiguration == 0)
  37CE    5161     MOVF 0x61, W, BANKED
  37D0    E102     BNZ 0x37d6
2353:                  {
2354:                      //Go back to the addressed state
2355:                      USBDeviceState = ADDRESS_STATE;
  37D2    0E10     MOVLW 0x10
2356:                  }
2357:                  else
  37D4    D012     BRA 0x37fa
2358:                  {
2359:                      //initialize the required endpoints
2360:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
  37D6    0E01     MOVLW 0x1
  37D8    6EE6     MOVWF 0xfe6, ACCESS
  37DA    6AE6     CLRF 0xfe6, ACCESS
  37DC    0E61     MOVLW 0x61
  37DE    6EE6     MOVWF 0xfe6, ACCESS
  37E0    0E00     MOVLW 0
  37E2    6EE6     MOVWF 0xfe6, ACCESS
  37E4    0E01     MOVLW 0x1
  37E6    6EE6     MOVWF 0xfe6, ACCESS
  37E8    6AE6     CLRF 0xfe6, ACCESS
  37EA    ECF7     CALL 0x5bee, 0
  37EC    F02D     NOP
  37EE    6E14     MOVWF 0x14, ACCESS
  37F0    0E06     MOVLW 0x6
  37F2    5EE1     SUBWF 0xfe1, F, ACCESS
  37F4    5014     MOVF 0x14, W, ACCESS
2361:              
2362:                      //Otherwise go to the configured state.  Update the state variable last,
2363:                      //after performing all of the set configuration related initialization
2364:                      //tasks.
2365:                      USBDeviceState = CONFIGURED_STATE;		
  37F6    0100     MOVLB 0
  37F8    0E20     MOVLW 0x20
  37FA    6F60     MOVWF 0x60, BANKED
2366:                  }//end if(SetupPkt.bConfigurationValue == 0)
2367:              }//end USBStdSetCfgHandler
  37FC    52E5     MOVF 0xfe5, F, ACCESS
  37FE    52E5     MOVF 0xfe5, F, ACCESS
  3800    CFE7     MOVFF 0xfe7, 0xfd9
  3802    FFD9     NOP
  3804    0012     RETURN 0
2368:              
2369:              /********************************************************************
2370:               * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
2371:               *
2372:               * PreCondition:    None
2373:               *
2374:               * Input:           BYTE EPNum - the endpoint to be configured
2375:               *                  BYTE direction - the direction to be configured
2376:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
2377:               *
2378:               * Output:          None
2379:               *
2380:               * Side Effects:    None
2381:               *
2382:               * Overview:        This function will configure the specified 
2383:               *                  endpoint
2384:               *
2385:               * Note:            None
2386:               *******************************************************************/
2387:              static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
  3806    CFD9     MOVFF 0xfd9, 0xfe6
  3808    FFE6     NOP
  380A    CFE1     MOVFF 0xfe1, 0xfd9
  380C    FFD9     NOP
  380E    0E02     MOVLW 0x2
  3810    26E1     ADDWF 0xfe1, F, ACCESS
2388:              {
2389:                  volatile BDT_ENTRY* handle;
2390:              
2391:                  //Compute a pointer to the even BDT entry corresponding to the
2392:                  //EPNum and direction values passed to this function.
2393:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
  3812    0E00     MOVLW 0
  3814    6EDE     MOVWF 0xfde, ACCESS
  3816    0E04     MOVLW 0x4
  3818    6EDD     MOVWF 0xfdd, ACCESS
2394:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
  381A    0EFD     MOVLW 0xfd
  381C    50DB     MOVF 0xfdb, W, ACCESS
  381E    24E8     ADDWF 0xfe8, W, ACCESS
  3820    6E16     MOVWF 0x16, ACCESS
  3822    0EFE     MOVLW 0xfe
  3824    50DB     MOVF 0xfdb, W, ACCESS
  3826    0D04     MULLW 0x4
  3828    50F3     MOVF 0xff3, W, ACCESS
  382A    2416     ADDWF 0x16, W, ACCESS
  382C    0D04     MULLW 0x4
  382E    CFF4     MOVFF 0xff4, 0x15
  3830    F015     NOP
  3832    CFD9     MOVFF 0xfd9, 0xfe9
  3834    FFE9     NOP
  3836    CFDA     MOVFF 0xfda, 0xfea
  3838    FFEA     NOP
  383A    50F3     MOVF 0xff3, W, ACCESS
  383C    26EE     ADDWF 0xfee, F, ACCESS
  383E    5015     MOVF 0x15, W, ACCESS
  3840    22ED     ADDWFC 0xfed, F, ACCESS
2395:                  
2396:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
  3842    CFDE     MOVFF 0xfde, 0xfe9
  3844    FFE9     NOP
  3846    CFDD     MOVFF 0xfdd, 0xfea
  3848    FFEA     NOP
  384A    9EEF     BCF 0xfef, 0x7, ACCESS
2397:                  //already cleared the entire BDT table
2398:              
2399:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
2400:                  //for USBTransferOnePacket() API calls.
2401:                  if(direction == OUT_FROM_HOST)
  384C    0EFD     MOVLW 0xfd
  384E    50DB     MOVF 0xfdb, W, ACCESS
  3850    E10A     BNZ 0x3866
2402:                  {
2403:                      pBDTEntryOut[EPNum] = handle;
  3852    0EFE     MOVLW 0xfe
  3854    6AEA     CLRF 0xfea, ACCESS
  3856    34DB     RLCF 0xfdb, W, ACCESS
  3858    0BFE     ANDLW 0xfe
  385A    36EA     RLCF 0xfea, F, ACCESS
  385C    6EE9     MOVWF 0xfe9, ACCESS
  385E    0E67     MOVLW 0x67
  3860    26E9     ADDWF 0xfe9, F, ACCESS
  3862    0E00     MOVLW 0
2404:                  }
2405:                  else
  3864    D009     BRA 0x3878
2406:                  {
2407:                      pBDTEntryIn[EPNum] = handle;
  3866    0EFE     MOVLW 0xfe
  3868    6AEA     CLRF 0xfea, ACCESS
  386A    34DB     RLCF 0xfdb, W, ACCESS
  386C    0BFE     ANDLW 0xfe
  386E    36EA     RLCF 0xfea, F, ACCESS
  3870    6EE9     MOVWF 0xfe9, ACCESS
  3872    0E6F     MOVLW 0x6f
  3874    26E9     ADDWF 0xfe9, F, ACCESS
  3876    0E00     MOVLW 0
  3878    22EA     ADDWFC 0xfea, F, ACCESS
  387A    CFDE     MOVFF 0xfde, 0xfee
  387C    FFEE     NOP
  387E    CFDD     MOVFF 0xfdd, 0xfed
  3880    FFED     NOP
2408:                  }
2409:              
2410:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2411:                      handle->STAT.DTS = 0;
  3882    CFDE     MOVFF 0xfde, 0xfe9
  3884    FFE9     NOP
  3886    CFDD     MOVFF 0xfdd, 0xfea
  3888    FFEA     NOP
  388A    9CEF     BCF 0xfef, 0x6, ACCESS
2412:                      (handle+1)->STAT.DTS = 1;
  388C    CFDE     MOVFF 0xfde, 0xfe9
  388E    FFE9     NOP
  3890    CFDD     MOVFF 0xfdd, 0xfea
  3892    FFEA     NOP
  3894    0E04     MOVLW 0x4
  3896    26E9     ADDWF 0xfe9, F, ACCESS
  3898    0E00     MOVLW 0
  389A    22EA     ADDWFC 0xfea, F, ACCESS
  389C    8CEF     BSF 0xfef, 0x6, ACCESS
2413:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
2414:                      //Set DTS to one because the first thing we will do
2415:                      //when transmitting is toggle the bit
2416:                      handle->STAT.DTS = 1;
2417:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
2418:                      if(EPNum != 0)
2419:                      {
2420:                          handle->STAT.DTS = 1;
2421:                      }
2422:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
2423:                      if(EPNum != 0)
2424:                      {
2425:                          handle->STAT.DTS = 0;
2426:                          (handle+1)->STAT.DTS = 1;
2427:                      }
2428:                  #endif
2429:              }
  389E    0E02     MOVLW 0x2
  38A0    5CE1     SUBWF 0xfe1, W, ACCESS
  38A2    E202     BC 0x38a8
  38A4    6AE1     CLRF 0xfe1, ACCESS
  38A6    52E5     MOVF 0xfe5, F, ACCESS
  38A8    6EE1     MOVWF 0xfe1, ACCESS
  38AA    52E5     MOVF 0xfe5, F, ACCESS
  38AC    CFE7     MOVFF 0xfe7, 0xfd9
  38AE    FFD9     NOP
  38B0    0012     RETURN 0
2430:              
2431:              /*****************************************************************************************************************
2432:                Function:
2433:                      void USBEnableEndpoint(BYTE ep, BYTE options)
2434:                  
2435:                Summary:
2436:                  This function will enable the specified endpoint with the specified
2437:                  options
2438:                Description:
2439:                  This function will enable the specified endpoint with the specified
2440:                  options.
2441:                  
2442:                  Typical Usage:
2443:                  <code>
2444:                  void USBCBInitEP(void)
2445:                  {
2446:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
2447:                      USBMSDInit();
2448:                  }
2449:                  </code>
2450:                  
2451:                  In the above example endpoint number MSD_DATA_IN_EP is being configured
2452:                  for both IN and OUT traffic with handshaking enabled. Also since
2453:                  MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
2454:                  explicitly disable SETUP packets on this endpoint.
2455:                Conditions:
2456:                  None
2457:                Input:
2458:                  BYTE ep -       the endpoint to be configured
2459:                  BYTE options -  optional settings for the endpoint. The options should
2460:                                  be ORed together to form a single options string. The
2461:                                  available optional settings for the endpoint. The
2462:                                  options should be ORed together to form a single options
2463:                                  string. The available options are the following\:
2464:                                  * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
2465:                                    NAK)
2466:                                  * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
2467:                                    NAK)
2468:                                  * USB_OUT_ENABLED enables the out direction
2469:                                  * USB_OUT_DISABLED disables the out direction
2470:                                  * USB_IN_ENABLED enables the in direction
2471:                                  * USB_IN_DISABLED disables the in direction
2472:                                  * USB_ALLOW_SETUP enables control transfers
2473:                                  * USB_DISALLOW_SETUP disables control transfers
2474:                Return:
2475:                  None
2476:                Remarks:
2477:                  None                                                                                                          
2478:                *****************************************************************************************************************/
2479:              void USBEnableEndpoint(BYTE ep, BYTE options)
  38B2    CFD9     MOVFF 0xfd9, 0xfe6
  38B4    FFE6     NOP
  38B6    CFE1     MOVFF 0xfe1, 0xfd9
  38B8    FFD9     NOP
  38BA    0E02     MOVLW 0x2
  38BC    26E1     ADDWF 0xfe1, F, ACCESS
2480:              {
2481:                  unsigned char* p;
2482:                      
2483:                  //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
2484:                  //starting DTS state in the BDT entry.
2485:                  if(options & USB_OUT_ENABLED)
  38BE    0EFD     MOVLW 0xfd
  38C0    A4DB     BTFSS 0xfdb, 0x2, ACCESS
  38C2    D007     BRA 0x38d2
2486:                  {
2487:                      USBConfigureEndpoint(ep, OUT_FROM_HOST);
  38C4    6AE6     CLRF 0xfe6, ACCESS
  38C6    0EFE     MOVLW 0xfe
  38C8    CFDB     MOVFF 0xfdb, 0xfe6
  38CA    FFE6     NOP
  38CC    DF9C     RCALL 0x3806
  38CE    52E5     MOVF 0xfe5, F, ACCESS
  38D0    52E5     MOVF 0xfe5, F, ACCESS
2488:                  }
2489:                  if(options & USB_IN_ENABLED)
  38D2    0EFD     MOVLW 0xfd
  38D4    A2DB     BTFSS 0xfdb, 0x1, ACCESS
  38D6    D008     BRA 0x38e8
2490:                  {
2491:                      USBConfigureEndpoint(ep, IN_TO_HOST);
  38D8    0E01     MOVLW 0x1
  38DA    6EE6     MOVWF 0xfe6, ACCESS
  38DC    0EFE     MOVLW 0xfe
  38DE    CFDB     MOVFF 0xfdb, 0xfe6
  38E0    FFE6     NOP
  38E2    DF91     RCALL 0x3806
  38E4    52E5     MOVF 0xfe5, F, ACCESS
  38E6    52E5     MOVF 0xfe5, F, ACCESS
2492:                  }
2493:              
2494:                  //Update the relevant UEPx register to actually enable the endpoint with
2495:                  //the specified options (ex: handshaking enabled, control transfers allowed,
2496:                  //etc.)
2497:                  #if defined(__C32__)
2498:                      p = (unsigned char*)(&U1EP0+(4*ep));
2499:                  #else
2500:                      p = (unsigned char*)(&U1EP0+ep);
  38E8    0EFE     MOVLW 0xfe
  38EA    50DB     MOVF 0xfdb, W, ACCESS
  38EC    6A15     CLRF 0x15, ACCESS
  38EE    0F26     ADDLW 0x26
  38F0    6E14     MOVWF 0x14, ACCESS
  38F2    0E0F     MOVLW 0xf
  38F4    2215     ADDWFC 0x15, F, ACCESS
  38F6    C014     MOVFF 0x14, 0xfde
  38F8    FFDE     NOP
  38FA    C015     MOVFF 0x15, 0xfdd
  38FC    FFDD     NOP
2501:                  #endif
2502:                  *p = options;
  38FE    CFDE     MOVFF 0xfde, 0xfe9
  3900    FFE9     NOP
  3902    CFDD     MOVFF 0xfdd, 0xfea
  3904    FFEA     NOP
  3906    0EFD     MOVLW 0xfd
  3908    CFDB     MOVFF 0xfdb, 0xfef
  390A    FFEF     NOP
2503:              }
  390C    0E02     MOVLW 0x2
  390E    5CE1     SUBWF 0xfe1, W, ACCESS
  3910    E202     BC 0x3916
  3912    6AE1     CLRF 0xfe1, ACCESS
  3914    52E5     MOVF 0xfe5, F, ACCESS
  3916    6EE1     MOVWF 0xfe1, ACCESS
  3918    52E5     MOVF 0xfe5, F, ACCESS
  391A    CFE7     MOVFF 0xfe7, 0xfd9
  391C    FFD9     NOP
  391E    0012     RETURN 0
2504:              
2505:              /********************************************************************
2506:               * Function:        void USBStallEndpoint(BYTE ep, BYTE dir)
2507:               *
2508:               * PreCondition:    None
2509:               *
2510:               * Input:
2511:               *   BYTE ep - the endpoint the data will be transmitted on
2512:               *   BYTE dir - the direction of the transfer
2513:               *
2514:               * Output:          None
2515:               *
2516:               * Side Effects:    Endpoint is STALLed
2517:               *
2518:               * Overview:        STALLs the specified endpoint
2519:               *
2520:               * Note:            None
2521:               *******************************************************************/
2522:              void USBStallEndpoint(BYTE ep, BYTE dir)
  3920    CFD9     MOVFF 0xfd9, 0xfe6
  3922    FFE6     NOP
  3924    CFE1     MOVFF 0xfe1, 0xfd9
  3926    FFD9     NOP
  3928    0E02     MOVLW 0x2
  392A    26E1     ADDWF 0xfe1, F, ACCESS
2523:              {
2524:                  BDT_ENTRY *p;
2525:              
2526:                  if(ep == 0)
  392C    0EFE     MOVLW 0xfe
  392E    50DB     MOVF 0xfdb, W, ACCESS
  3930    E120     BNZ 0x3972
2527:                  {
2528:                      /*
2529:                       * If no one knows how to service this request then stall.
2530:                       * Must also prepare EP0 to receive the next SETUP transaction.
2531:                       */
2532:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  3932    C065     MOVFF 0x65, 0xfe9
  3934    FFE9     NOP
  3936    C066     MOVFF 0x66, 0xfea
  3938    FFEA     NOP
  393A    52EE     MOVF 0xfee, F, ACCESS
  393C    0E08     MOVLW 0x8
  393E    6EEF     MOVWF 0xfef, ACCESS
2533:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  3940    C065     MOVFF 0x65, 0xfe9
  3942    FFE9     NOP
  3944    C066     MOVFF 0x66, 0xfea
  3946    FFEA     NOP
  3948    0E02     MOVLW 0x2
  394A    26E9     ADDWF 0xfe9, F, ACCESS
  394C    0E00     MOVLW 0
  394E    22EA     ADDWFC 0xfea, F, ACCESS
  3950    0E40     MOVLW 0x40
  3952    6EEE     MOVWF 0xfee, ACCESS
  3954    0E04     MOVLW 0x4
  3956    6EED     MOVWF 0xfed, ACCESS
2534:              
2535:                      /* v2b fix */
2536:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
  3958    C065     MOVFF 0x65, 0xfe9
  395A    FFE9     NOP
  395C    C066     MOVFF 0x66, 0xfea
  395E    FFEA     NOP
  3960    0E8C     MOVLW 0x8c
  3962    6EEF     MOVWF 0xfef, ACCESS
2537:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
  3964    C06F     MOVFF 0x6f, 0xfe9
  3966    FFE9     NOP
  3968    C070     MOVFF 0x70, 0xfea
  396A    FFEA     NOP
  396C    0E84     MOVLW 0x84
  396E    6EEF     MOVWF 0xfef, ACCESS
2538:                  }
2539:                  else
  3970    D03B     BRA 0x39e8
2540:                  {
2541:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
  3972    0EFD     MOVLW 0xfd
  3974    50DB     MOVF 0xfdb, W, ACCESS
  3976    24E8     ADDWF 0xfe8, W, ACCESS
  3978    6E16     MOVWF 0x16, ACCESS
  397A    0EFE     MOVLW 0xfe
  397C    50DB     MOVF 0xfdb, W, ACCESS
  397E    0D04     MULLW 0x4
  3980    50F3     MOVF 0xff3, W, ACCESS
  3982    2416     ADDWF 0x16, W, ACCESS
  3984    0D04     MULLW 0x4
  3986    CFF3     MOVFF 0xff3, 0x14
  3988    F014     NOP
  398A    CFF4     MOVFF 0xff4, 0x15
  398C    F015     NOP
  398E    0E00     MOVLW 0
  3990    2614     ADDWF 0x14, F, ACCESS
  3992    0E04     MOVLW 0x4
  3994    2215     ADDWFC 0x15, F, ACCESS
  3996    C014     MOVFF 0x14, 0xfde
  3998    FFDE     NOP
  399A    C015     MOVFF 0x15, 0xfdd
  399C    FFDD     NOP
2542:                      p->STAT.Val |= _BSTALL | _USIE;
  399E    0E84     MOVLW 0x84
  39A0    CFDE     MOVFF 0xfde, 0xfe9
  39A2    FFE9     NOP
  39A4    CFDD     MOVFF 0xfdd, 0xfea
  39A6    FFEA     NOP
  39A8    50E8     MOVF 0xfe8, W, ACCESS
  39AA    12EF     IORWF 0xfef, F, ACCESS
2543:                  
2544:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
2545:                      //then stall that entry as well
2546:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || \
2547:                          (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
2548:                  
2549:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
  39AC    0EFD     MOVLW 0xfd
  39AE    50DB     MOVF 0xfdb, W, ACCESS
  39B0    24E8     ADDWF 0xfe8, W, ACCESS
  39B2    6E16     MOVWF 0x16, ACCESS
  39B4    0EFE     MOVLW 0xfe
  39B6    50DB     MOVF 0xfdb, W, ACCESS
  39B8    0D04     MULLW 0x4
  39BA    50F3     MOVF 0xff3, W, ACCESS
  39BC    2416     ADDWF 0x16, W, ACCESS
  39BE    0F01     ADDLW 0x1
  39C0    0D04     MULLW 0x4
  39C2    CFF3     MOVFF 0xff3, 0x14
  39C4    F014     NOP
  39C6    CFF4     MOVFF 0xff4, 0x15
  39C8    F015     NOP
  39CA    0E00     MOVLW 0
  39CC    2614     ADDWF 0x14, F, ACCESS
  39CE    0E04     MOVLW 0x4
  39D0    2215     ADDWFC 0x15, F, ACCESS
  39D2    C014     MOVFF 0x14, 0xfde
  39D4    FFDE     NOP
  39D6    C015     MOVFF 0x15, 0xfdd
  39D8    FFDD     NOP
2550:                      p->STAT.Val |= _BSTALL | _USIE;
  39DA    0E84     MOVLW 0x84
  39DC    CFDE     MOVFF 0xfde, 0xfe9
  39DE    FFE9     NOP
  39E0    CFDD     MOVFF 0xfdd, 0xfea
  39E2    FFEA     NOP
  39E4    50E8     MOVF 0xfe8, W, ACCESS
  39E6    12EF     IORWF 0xfef, F, ACCESS
2551:                      #endif
2552:                  }
2553:              }
  39E8    0E02     MOVLW 0x2
  39EA    5CE1     SUBWF 0xfe1, W, ACCESS
  39EC    E202     BC 0x39f2
  39EE    6AE1     CLRF 0xfe1, ACCESS
  39F0    52E5     MOVF 0xfe5, F, ACCESS
  39F2    6EE1     MOVWF 0xfe1, ACCESS
  39F4    52E5     MOVF 0xfe5, F, ACCESS
  39F6    CFE7     MOVFF 0xfe7, 0xfd9
  39F8    FFD9     NOP
  39FA    0012     RETURN 0
2554:              
2555:              /********************************************************************
2556:               * Function:        USB_HANDLE USBTransferOnePacket(
2557:               *                      BYTE ep, 
2558:               *                      BYTE dir, 
2559:               *                      BYTE* data, 
2560:               *                      BYTE len)
2561:               *
2562:               * PreCondition:    The pBDTEntryIn[] or pBDTEntryOut[] pointer to 
2563:               *					the endpoint that will be used must have been 
2564:               *					initialized, prior to calling USBTransferOnePacket().
2565:               *					Therefore, the application firmware should not call
2566:               *					USBTransferOnePacket() until after the USB stack has been
2567:               					initialized (by USBDeviceInit()), and the host has sent a 
2568:               *					set configuration request.  This can be checked by
2569:               *					verifying that the USBGetDeviceState() == CONFIGURED_STATE,
2570:               *					prior to calling USBTransferOnePacket().
2571:               *					
2572:               *					Note: If calling the USBTransferOnePacket() 
2573:               *					function from within the USBCBInitEP() callback function, 
2574:               *					the set configuration is still being processed and the 
2575:               *					USBDeviceState may not be == CONFIGURED_STATE yet.  In this
2576:               *					special case, the USBTransferOnePacket() may still be 
2577:               *					called, but make sure that the endpoint has been enabled 
2578:               *					and initialized by the USBEnableEndpoint() function first.
2579:               *
2580:               * Input:
2581:               *   BYTE ep - the endpoint number that the data will be transmitted or 
2582:               *				received on
2583:               *   BYTE dir - the direction of the transfer
2584:               *              This value is either OUT_FROM_HOST or IN_TO_HOST
2585:               *   BYTE* data - For IN transactions: pointer to the RAM buffer containing 
2586:               *				  the data to be sent to the host.
2587:               *				  For OUT transactions: pointer to the RAM buffer that the
2588:               *				  received data should get written to.
2589:               *   BYTE len - length of the data needing to be sent (for IN transactions).
2590:               *				For OUT transactions, the len parameter should normally be set
2591:               *				to the endpoint size specified in the endpoint descriptor.
2592:               *
2593:               * Output:          
2594:               *   USB_HANDLE - handle to the transfer.  The handle is a pointer to
2595:               *					the BDT entry associated with this transaction.  The 
2596:               *					status of the transaction (ex: if it is complete or still
2597:               *					pending) can be checked using the USBHandleBusy() macro
2598:               *					and supplying the USB_HANDLE provided by 
2599:               *					USBTransferOnePacket().
2600:               *
2601:               *
2602:               * Side Effects:    None
2603:               *
2604:               * Overview:        The USBTransferOnePacket() function prepares a USB endpoint
2605:               *					so that it may send data to the host (an IN transaction),
2606:               *					or receive data from the host (an OUT transaction).  The
2607:               *					USBTransferOnePacket() function can be used both to receive
2608:               *					and send data to the host.  The USBTransferOnePacket()
2609:               *					function is the primary API function provided by the USB
2610:               *					stack firmware for sending or receiving application data
2611:               *					over the USB port.  The USBTransferOnePacket() is intended
2612:               *					for use with all application endpoints.  It is not used for
2613:               *					sending or receiving applicaiton data through endpoint 0
2614:               *					by using control transfers.  Separate API functions,
2615:               *					such as USBEP0Receive(), USBEP0SendRAMPtr(), and
2616:               *					USBEP0SendROMPtr() are provided for this purpose.
2617:               *					
2618:               *					The	USBTransferOnePacket() writes to the Buffer Descriptor
2619:               *					Table (BDT) entry associated with an endpoint buffer, and
2620:               *					sets the UOWN bit, which prepares the USB hardware to 
2621:               *					allow the transaction to complete.  The application firmware
2622:               *					can use the USBHandleBusy() macro to check the status of the
2623:               *					transaction, to see if the data has been successfully 
2624:               *					transmitted yet.
2625:               *
2626:               * Note:            None
2627:               *******************************************************************/
2628:              USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
  39FC    CFD9     MOVFF 0xfd9, 0xfe6
  39FE    FFE6     NOP
  3A00    CFE1     MOVFF 0xfe1, 0xfd9
  3A02    FFD9     NOP
  3A04    0E02     MOVLW 0x2
  3A06    26E1     ADDWF 0xfe1, F, ACCESS
2629:              {
2630:                  volatile BDT_ENTRY* handle;
2631:              
2632:                  //If the direction is IN
2633:                  if(dir != 0)
  3A08    0EFD     MOVLW 0xfd
  3A0A    50DB     MOVF 0xfdb, W, ACCESS
  3A0C    E00A     BZ 0x3a22
2634:                  {
2635:                      //point to the IN BDT of the specified endpoint
2636:                      handle = pBDTEntryIn[ep];
  3A0E    0EFE     MOVLW 0xfe
  3A10    6AEA     CLRF 0xfea, ACCESS
  3A12    34DB     RLCF 0xfdb, W, ACCESS
  3A14    0BFE     ANDLW 0xfe
  3A16    36EA     RLCF 0xfea, F, ACCESS
  3A18    6EE9     MOVWF 0xfe9, ACCESS
  3A1A    0E6F     MOVLW 0x6f
  3A1C    26E9     ADDWF 0xfe9, F, ACCESS
  3A1E    0E00     MOVLW 0
2637:                  }
2638:                  else
  3A20    D009     BRA 0x3a34
2639:                  {
2640:                      //else point to the OUT BDT of the specified endpoint
2641:                      handle = pBDTEntryOut[ep];
  3A22    0EFE     MOVLW 0xfe
  3A24    6AEA     CLRF 0xfea, ACCESS
  3A26    34DB     RLCF 0xfdb, W, ACCESS
  3A28    0BFE     ANDLW 0xfe
  3A2A    36EA     RLCF 0xfea, F, ACCESS
  3A2C    6EE9     MOVWF 0xfe9, ACCESS
  3A2E    0E67     MOVLW 0x67
  3A30    26E9     ADDWF 0xfe9, F, ACCESS
  3A32    0E00     MOVLW 0
  3A34    22EA     ADDWFC 0xfea, F, ACCESS
  3A36    CFEE     MOVFF 0xfee, 0xfde
  3A38    FFDE     NOP
  3A3A    CFED     MOVFF 0xfed, 0xfdd
  3A3C    FFDD     NOP
2642:                  }
2643:                  
2644:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
2645:                  //pBDTEntryOut[ep]) is initialized before using it.
2646:                  if(handle == 0)
  3A3E    CFD9     MOVFF 0xfd9, 0xfe9
  3A40    FFE9     NOP
  3A42    CFDA     MOVFF 0xfda, 0xfea
  3A44    FFEA     NOP
  3A46    50EE     MOVF 0xfee, W, ACCESS
  3A48    10ED     IORWF 0xfed, W, ACCESS
  3A4A    E103     BNZ 0x3a52
2647:                  {
2648:              	    return 0;
  3A4C    6AF3     CLRF 0xff3, ACCESS
  3A4E    6AF4     CLRF 0xff4, ACCESS
  3A50    D044     BRA 0x3ada
2649:              	}
2650:              
2651:                  //Toggle the DTS bit if required
2652:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
2653:                      handle->STAT.Val ^= _DTSMASK;
2654:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
2655:                      if(ep != 0)
2656:                      {
2657:                          handle->STAT.Val ^= _DTSMASK;
2658:                      }
2659:                  #endif
2660:              
2661:                  //Set the data pointer, data length, and enable the endpoint
2662:                  handle->ADR = ConvertToPhysicalAddress(data);
  3A52    CFDE     MOVFF 0xfde, 0xfe9
  3A54    FFE9     NOP
  3A56    CFDD     MOVFF 0xfdd, 0xfea
  3A58    FFEA     NOP
  3A5A    0E02     MOVLW 0x2
  3A5C    26E9     ADDWF 0xfe9, F, ACCESS
  3A5E    0E00     MOVLW 0
  3A60    22EA     ADDWFC 0xfea, F, ACCESS
  3A62    0EFB     MOVLW 0xfb
  3A64    CFDB     MOVFF 0xfdb, 0xfee
  3A66    FFEE     NOP
  3A68    0EFC     MOVLW 0xfc
  3A6A    CFDB     MOVFF 0xfdb, 0xfed
  3A6C    FFED     NOP
2663:                  handle->CNT = len;
  3A6E    CFDE     MOVFF 0xfde, 0xfe9
  3A70    FFE9     NOP
  3A72    CFDD     MOVFF 0xfdd, 0xfea
  3A74    FFEA     NOP
  3A76    52EE     MOVF 0xfee, F, ACCESS
  3A78    0EFA     MOVLW 0xfa
  3A7A    CFDB     MOVFF 0xfdb, 0xfef
  3A7C    FFEF     NOP
2664:                  handle->STAT.Val &= _DTSMASK;
  3A7E    0E40     MOVLW 0x40
  3A80    CFDE     MOVFF 0xfde, 0xfe9
  3A82    FFE9     NOP
  3A84    CFDD     MOVFF 0xfdd, 0xfea
  3A86    FFEA     NOP
  3A88    50E8     MOVF 0xfe8, W, ACCESS
  3A8A    16EF     ANDWF 0xfef, F, ACCESS
2665:                  handle->STAT.Val |= _USIE | _DTSEN;
  3A8C    0E88     MOVLW 0x88
  3A8E    CFDE     MOVFF 0xfde, 0xfe9
  3A90    FFE9     NOP
  3A92    CFDD     MOVFF 0xfdd, 0xfea
  3A94    FFEA     NOP
  3A96    50E8     MOVF 0xfe8, W, ACCESS
  3A98    12EF     IORWF 0xfef, F, ACCESS
2666:              
2667:                  //Point to the next buffer for ping pong purposes.
2668:                  if(dir != 0)
  3A9A    0EFD     MOVLW 0xfd
  3A9C    50DB     MOVF 0xfdb, W, ACCESS
  3A9E    E00A     BZ 0x3ab4
2669:                  {
2670:                      //toggle over the to the next buffer for an IN endpoint
2671:                      USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
  3AA0    0EFE     MOVLW 0xfe
  3AA2    6AEA     CLRF 0xfea, ACCESS
  3AA4    34DB     RLCF 0xfdb, W, ACCESS
  3AA6    0BFE     ANDLW 0xfe
  3AA8    36EA     RLCF 0xfea, F, ACCESS
  3AAA    6EE9     MOVWF 0xfe9, ACCESS
  3AAC    0E6F     MOVLW 0x6f
  3AAE    26E9     ADDWF 0xfe9, F, ACCESS
  3AB0    0E00     MOVLW 0
2672:                  }
2673:                  else
  3AB2    D009     BRA 0x3ac6
2674:                  {
2675:                      //toggle over the to the next buffer for an OUT endpoint
2676:                      USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
  3AB4    0EFE     MOVLW 0xfe
  3AB6    6AEA     CLRF 0xfea, ACCESS
  3AB8    34DB     RLCF 0xfdb, W, ACCESS
  3ABA    0BFE     ANDLW 0xfe
  3ABC    36EA     RLCF 0xfea, F, ACCESS
  3ABE    6EE9     MOVWF 0xfe9, ACCESS
  3AC0    0E67     MOVLW 0x67
  3AC2    26E9     ADDWF 0xfe9, F, ACCESS
  3AC4    0E00     MOVLW 0
  3AC6    22EA     ADDWFC 0xfea, F, ACCESS
  3AC8    74EF     BTG 0xfef, 0x2, ACCESS
2677:                  }
2678:                  return (USB_HANDLE)handle;
  3ACA    CFDE     MOVFF 0xfde, 0x14
  3ACC    F014     NOP
  3ACE    CFDD     MOVFF 0xfdd, 0x15
  3AD0    F015     NOP
  3AD2    C014     MOVFF 0x14, 0xff3
  3AD4    FFF3     NOP
  3AD6    C015     MOVFF 0x15, 0xff4
  3AD8    FFF4     NOP
2679:              }
  3ADA    0E02     MOVLW 0x2
  3ADC    5CE1     SUBWF 0xfe1, W, ACCESS
  3ADE    E202     BC 0x3ae4
  3AE0    6AE1     CLRF 0xfe1, ACCESS
  3AE2    52E5     MOVF 0xfe5, F, ACCESS
  3AE4    6EE1     MOVWF 0xfe1, ACCESS
  3AE6    52E5     MOVF 0xfe5, F, ACCESS
  3AE8    CFE7     MOVFF 0xfe7, 0xfd9
  3AEA    FFD9     NOP
  3AEC    0012     RETURN 0
2680:              
2681:              /**************************************************************************
2682:                  Function:
2683:                      void USBCancelIO(BYTE endpoint)
2684:                  
2685:                  Description:
2686:                      This function cancels the transfers pending on the specified endpoint.
2687:                      This function can only be used after a SETUP packet is received and 
2688:                      before that setup packet is handled.  This is the time period in which
2689:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
2690:                      returns to the stack.
2691:              
2692:                  Precondition:
2693:                
2694:                  Parameters:
2695:                      BYTE endpoint - the endpoint number you wish to cancel the transfers for
2696:                   
2697:                  Return Values:
2698:                      None
2699:                      
2700:                  Remarks:
2701:                      None
2702:                                                                        
2703:                **************************************************************************/
2704:              void USBCancelIO(BYTE endpoint)
  3AEE    CFD9     MOVFF 0xfd9, 0xfe6
  3AF0    FFE6     NOP
  3AF2    CFE1     MOVFF 0xfe1, 0xfd9
  3AF4    FFD9     NOP
2705:              {
2706:                  if(USBPacketDisable == 1)
  3AF6    A865     BTFSS 0xf65, 0x4, ACCESS
  3AF8    D04E     BRA 0x3b96
2707:                  {
2708:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
2709:                  	//to mess with the BDT right now.
2710:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
  3AFA    0EFE     MOVLW 0xfe
  3AFC    6AEA     CLRF 0xfea, ACCESS
  3AFE    34DB     RLCF 0xfdb, W, ACCESS
  3B00    0BFE     ANDLW 0xfe
  3B02    36EA     RLCF 0xfea, F, ACCESS
  3B04    6EE9     MOVWF 0xfe9, ACCESS
  3B06    0E6F     MOVLW 0x6f
  3B08    26E9     ADDWF 0xfe9, F, ACCESS
  3B0A    0E00     MOVLW 0
  3B0C    22EA     ADDWFC 0xfea, F, ACCESS
  3B0E    50EE     MOVF 0xfee, W, ACCESS
  3B10    CFEF     MOVFF 0xfef, 0xfea
  3B12    FFEA     NOP
  3B14    6EE9     MOVWF 0xfe9, ACCESS
  3B16    0E40     MOVLW 0x40
  3B18    16EE     ANDWF 0xfee, F, ACCESS
  3B1A    6AEE     CLRF 0xfee, ACCESS
  3B1C    6AEE     CLRF 0xfee, ACCESS
  3B1E    6AEE     CLRF 0xfee, ACCESS
2711:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
  3B20    0EFE     MOVLW 0xfe
  3B22    6AEA     CLRF 0xfea, ACCESS
  3B24    34DB     RLCF 0xfdb, W, ACCESS
  3B26    0BFE     ANDLW 0xfe
  3B28    36EA     RLCF 0xfea, F, ACCESS
  3B2A    6EE9     MOVWF 0xfe9, ACCESS
  3B2C    0E6F     MOVLW 0x6f
  3B2E    26E9     ADDWF 0xfe9, F, ACCESS
  3B30    0E00     MOVLW 0
  3B32    22EA     ADDWFC 0xfea, F, ACCESS
  3B34    50EE     MOVF 0xfee, W, ACCESS
  3B36    CFEF     MOVFF 0xfef, 0xfea
  3B38    FFEA     NOP
  3B3A    6EE9     MOVWF 0xfe9, ACCESS
  3B3C    7CEE     BTG 0xfee, 0x6, ACCESS
2712:                  	
2713:                  	//Need to do additional handling if ping-pong buffering is being used
2714:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
2715:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
2716:                      //(either due to SIE clearing it after a transaction, or the firmware
2717:                      //clearing it) makes hardware ping pong pointer advance.
2718:                      USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
  3B3E    0EFE     MOVLW 0xfe
  3B40    6AEA     CLRF 0xfea, ACCESS
  3B42    34DB     RLCF 0xfdb, W, ACCESS
  3B44    0BFE     ANDLW 0xfe
  3B46    36EA     RLCF 0xfea, F, ACCESS
  3B48    6EE9     MOVWF 0xfe9, ACCESS
  3B4A    0E6F     MOVLW 0x6f
  3B4C    26E9     ADDWF 0xfe9, F, ACCESS
  3B4E    0E00     MOVLW 0
  3B50    22EA     ADDWFC 0xfea, F, ACCESS
  3B52    74EF     BTG 0xfef, 0x2, ACCESS
2719:                  
2720:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
  3B54    0E40     MOVLW 0x40
  3B56    6E14     MOVWF 0x14, ACCESS
  3B58    0EFE     MOVLW 0xfe
  3B5A    6AEA     CLRF 0xfea, ACCESS
  3B5C    34DB     RLCF 0xfdb, W, ACCESS
  3B5E    0BFE     ANDLW 0xfe
  3B60    36EA     RLCF 0xfea, F, ACCESS
  3B62    6EE9     MOVWF 0xfe9, ACCESS
  3B64    0E6F     MOVLW 0x6f
  3B66    26E9     ADDWF 0xfe9, F, ACCESS
  3B68    0E00     MOVLW 0
  3B6A    22EA     ADDWFC 0xfea, F, ACCESS
  3B6C    50EE     MOVF 0xfee, W, ACCESS
  3B6E    CFEF     MOVFF 0xfef, 0xfea
  3B70    FFEA     NOP
  3B72    6EE9     MOVWF 0xfe9, ACCESS
  3B74    5014     MOVF 0x14, W, ACCESS
  3B76    16EF     ANDWF 0xfef, F, ACCESS
2721:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
  3B78    0EFE     MOVLW 0xfe
  3B7A    6AEA     CLRF 0xfea, ACCESS
  3B7C    34DB     RLCF 0xfdb, W, ACCESS
  3B7E    0BFE     ANDLW 0xfe
  3B80    36EA     RLCF 0xfea, F, ACCESS
  3B82    6EE9     MOVWF 0xfe9, ACCESS
  3B84    0E6F     MOVLW 0x6f
  3B86    26E9     ADDWF 0xfe9, F, ACCESS
  3B88    0E00     MOVLW 0
  3B8A    22EA     ADDWFC 0xfea, F, ACCESS
  3B8C    50EE     MOVF 0xfee, W, ACCESS
  3B8E    CFEF     MOVFF 0xfef, 0xfea
  3B90    FFEA     NOP
  3B92    6EE9     MOVWF 0xfe9, ACCESS
  3B94    7CEF     BTG 0xfef, 0x6, ACCESS
2722:                      #endif
2723:                  }
2724:              }
  3B96    52E5     MOVF 0xfe5, F, ACCESS
  3B98    CFE7     MOVFF 0xfe7, 0xfd9
  3B9A    FFD9     NOP
  3B9C    0012     RETURN 0
2725:              
2726:              /**************************************************************************
2727:                  Function:
2728:                      void USBDeviceDetach(void)
2729:                  
2730:                  Description:
2731:                              
2732:                  Precondition:
2733:                      
2734:                  Parameters:
2735:                      None
2736:                   
2737:                  Return Values:
2738:                      None
2739:                      
2740:                  Remarks:
2741:                      None
2742:                                                                        
2743:                **************************************************************************/
2744:              #if defined(USB_INTERRUPT)
2745:              void USBDeviceDetach(void)
2746:              {
2747:                  //If the interrupt option is selected then the customer is required
2748:                  //  to notify the stack when the device is attached or removed from the
2749:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
2750:              #ifdef USB_SUPPORT_OTG
2751:                  if (USB_BUS_SENSE != 1)
2752:              #endif
2753:                  {
2754:                       // Disable module & detach from bus
2755:                       U1CON = 0;             
  3B9E    6A65     CLRF 0xf65, ACCESS
2756:              
2757:                       // Mask all USB interrupts              
2758:                       U1IE = 0;          
  3BA0    010F     MOVLB 0xf
  3BA2    6B36     CLRF 0x36, BANKED
2759:              
2760:                       //Move to the detached state                  
2761:                       USBDeviceState = DETACHED_STATE;
  3BA4    0100     MOVLB 0
  3BA6    6B60     CLRF 0x60, BANKED
2762:              
2763:                       #ifdef  USB_SUPPORT_OTG    
2764:                           //Disable D+ Pullup
2765:                           U1OTGCONbits.DPPULUP = 0;
2766:              
2767:                           //Disable HNP
2768:                           USBOTGDisableHnp();
2769:              
2770:                           //Deactivate HNP
2771:                           USBOTGDeactivateHnp();
2772:                           
2773:                           //If ID Pin Changed State
2774:                           if (USBIDIF && USBIDIE)
2775:                           {  
2776:                               //Re-detect & Initialize
2777:                                USBOTGInitialize();
2778:              
2779:                                //Clear ID Interrupt Flag
2780:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
2781:                           }
2782:                       #endif
2783:              
2784:                       #ifdef __C30__
2785:                           //USBClearInterruptFlag(U1OTGIR, 3); 
2786:                       #endif
2787:                          //return so that we don't go through the rest of 
2788:                          //the state machine
2789:                        return;
2790:                  }
2791:              
2792:              #ifdef USB_SUPPORT_OTG
2793:                  //If Session Is Started Then
2794:                 else
2795:                 {
2796:                      //If SRP Is Ready
2797:                      if (USBOTGSRPIsReady())
2798:                      {   
2799:                          //Clear SRPReady
2800:                          USBOTGClearSRPReady();
2801:              
2802:                          //Clear SRP Timeout Flag
2803:                          USBOTGClearSRPTimeOutFlag();
2804:              
2805:                          //Indicate Session Started
2806:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
2807:                      }
2808:                  }
2809:              #endif
2810:              }
  3BA8    0012     RETURN 0
2811:              #endif  //#if defined(USB_INTERRUPT)
2812:              /**************************************************************************
2813:                  Function:
2814:                      void USBDeviceAttach(void)
2815:                  
2816:                  Summary:
2817:                      Checks if VBUS is present, and that the USB module is not already 
2818:                      initalized, and if so, enables the USB module so as to signal device 
2819:                      attachment to the USB host.   
2820:              
2821:                  Description:
2822:                      This function indicates to the USB host that the USB device has been
2823:                      attached to the bus.  This function needs to be called in order for the
2824:                      device to start to enumerate on the bus.
2825:                              
2826:                  Precondition:
2827:                      Should only be called when USB_INTERRUPT is defined.  Also, should only 
2828:                      be called from the main() loop context.  Do not call USBDeviceAttach()
2829:                      from within an interrupt handler, as the USBDeviceAttach() function
2830:                      may modify global interrupt enable bits and settings.
2831:              
2832:                      For normal USB devices:
2833:                      Make sure that if the module was previously on, that it has been turned off 
2834:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
2835:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
2836:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
2837:                      reject this event, since no human could ever unplug and reattach a USB device in a 
2838:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
2839:                      of glitch and ignore the event altogether.  
2840:                  
2841:                  Parameters:
2842:                      None
2843:                      
2844:                  Remarks:
2845:                      None
2846:                                                                        
2847:                **************************************************************************/
2848:              #if defined(USB_INTERRUPT)
2849:              void USBDeviceAttach(void)
2850:              {
2851:                  //if we are in the detached state
2852:                  if(USBDeviceState == DETACHED_STATE)
  3BAA    0100     MOVLB 0
  3BAC    5160     MOVF 0x60, W, BANKED
  3BAE    E114     BNZ 0x3bd8
2853:                  {
2854:                      if(USB_BUS_SENSE == 1)
2855:                      {
2856:                  	    //Initialize registers to known states.
2857:                          U1CON = 0;          
  3BB0    6A65     CLRF 0xf65, ACCESS
2858:                  
2859:                          // Mask all USB interrupts
2860:                          U1IE = 0;                                
  3BB2    010F     MOVLB 0xf
  3BB4    6B36     CLRF 0x36, BANKED
2861:                  
2862:                          //Configure things like: pull ups, full/low-speed mode, 
2863:                          //set the ping pong mode, and set internal transceiver
2864:                          SetConfigurationOptions();
  3BB6    0E16     MOVLW 0x16
  3BB8    6F39     MOVWF 0x39, BANKED
  3BBA    0E9F     MOVLW 0x9f
  3BBC    6F37     MOVWF 0x37, BANKED
  3BBE    0E7B     MOVLW 0x7b
  3BC0    6F36     MOVWF 0x36, BANKED
2865:                  
2866:                          USBEnableInterrupts();  //Modifies global interrupt settings
  3BC2    8ED0     BSF 0xfd0, 0x7, ACCESS
  3BC4    88A2     BSF 0xfa2, 0x4, ACCESS
  3BC6    88A0     BSF 0xfa0, 0x4, ACCESS
  3BC8    8EF2     BSF 0xff2, 0x7, ACCESS
2867:                  
2868:                          // Enable module & attach to bus
2869:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
  3BCA    B665     BTFSC 0xf65, 0x3, ACCESS
  3BCC    D002     BRA 0x3bd2
  3BCE    8665     BSF 0xf65, 0x3, ACCESS
  3BD0    D7FC     BRA 0x3bca
2870:                  
2871:                          //moved to the attached state
2872:                          USBDeviceState = ATTACHED_STATE;
  3BD2    0100     MOVLB 0
  3BD4    0E01     MOVLW 0x1
  3BD6    6F60     MOVWF 0x60, BANKED
2873:                  
2874:                          #ifdef  USB_SUPPORT_OTG
2875:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
2876:                          #endif
2877:                      }
2878:                  }
2879:              }
  3BD8    0012     RETURN 0
---  E:\Projects\DevPFG\Prog10\SD CDC Prog\main.c  -----------------------------------------------
1:                 /********************************************************************
2:                  FileName:		main.c
3:                  Dependencies:	See INCLUDES section
4:                  Processor:		PIC18, PIC24, and PIC32 USB Microcontrollers
5:                  Hardware:		This demo is natively intended to be used on Microchip USB demo
6:                  				boards supported by the MCHPFSUSB stack.  See release notes for
7:                  				support matrix.  This demo can be modified for use on other hardware
8:                  				platforms.
9:                  Complier:  	Microchip C18 (for PIC18), C30 (for PIC24), C32 (for PIC32)
10:                 Company:		Microchip Technology, Inc.
11:                
12:                 Software License Agreement:
13:                
14:                 The software supplied herewith by Microchip Technology Incorporated
15:                 (the "Company") for its PICr Microcontroller is intended and
16:                 supplied to you, the Company's customer, for use solely and
17:                 exclusively on Microchip PIC Microcontroller products. The
18:                 software is owned by the Company and/or its supplier, and is
19:                 protected under applicable copyright laws. All rights are reserved.
20:                 Any use in violation of the foregoing restrictions may subject the
21:                 user to criminal sanctions under applicable laws, as well as to
22:                 civil liability for the breach of the terms and conditions of this
23:                 license.
24:                
25:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
26:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:                
32:                ********************************************************************
33:                 File Description:
34:                
35:                 Change History:
36:                  Rev   Description
37:                  ----  -----------------------------------------
38:                  1.0   Initial release
39:                  2.1   Updated for simplicity and to use common
40:                                     coding style
41:                  2.8  Improvements to USBCBSendResume(), to make it easier to use.
42:                	Added runtime check to avoid buffer overflow possibility if
43:                	the USB IN data rate is somehow slower than the UART RX rate.
44:                ********************************************************************/
45:                
46:                /** INCLUDES *******************************************************/
47:                
48:                #include "./USB/USB.h"
49:                #include "HardwareProfile.h"
50:                #include "FSconfig.h"
51:                #if defined(USE_INTERNAL_FLASH)
52:                #include "MDD File System/internal flash.h"
53:                #elif defined(USE_SD_INTERFACE_WITH_SPI)
54:                #include "MDD File System/SD-SPI.h"
55:                #endif
56:                
57:                #include "./USB/usb_function_msd.h"
58:                #include "./USB/usb_function_cdc.h"
59:                
60:                /** CONFIGURATION **************************************************/
61:                #if defined(PICDEM_FS_USB)      // Configuration bits for PICDEM FS USB Demo Board (based on PIC18F4550)
62:                #elif defined(PIC18F46J50_PIM) || defined(PIC18F47J53_PIM) || defined(CUSTOM_PIM)
63:                     #pragma config WDTEN = OFF          //WDT disabled (enabled by SWDTEN bit)
64:                     #pragma config PLLDIV = 3           //Divide by 3 (12 MHz oscillator input)
65:                     #pragma config STVREN = ON          //stack overflow/underflow reset enabled
66:                     #pragma config XINST = OFF          //Extended instruction set disabled
67:                     #pragma config CPUDIV = OSC1        //No CPU system clock divide
68:                     #pragma config CP0 = OFF            //Program memory is not code-protected
69:                     #pragma config OSC = HSPLL          //HS oscillator, PLL enabled, HSPLL used by USB
70:                     #pragma config FCMEN = OFF          //Fail-Safe Clock Monitor disabled
71:                     #pragma config IESO = OFF           //Two-Speed Start-up disabled
72:                     #pragma config WDTPS = 32768        //1:32768
73:                     #pragma config DSWDTOSC = INTOSCREF //DSWDT uses INTOSC/INTRC as clock
74:                     #pragma config RTCOSC = T1OSCREF    //RTCC uses T1OSC/T1CKI as clock
75:                     #pragma config DSBOREN = OFF        //Zero-Power BOR disabled in Deep Sleep
76:                     #pragma config DSWDTEN = OFF        //Disabled
77:                     #pragma config DSWDTPS = 8192       //1:8,192 (8.5 seconds)
78:                     #pragma config IOL1WAY = OFF        //IOLOCK bit can be set and cleared
79:                     #pragma config MSSP7B_EN = MSK7     //7 Bit address masking
80:                     #pragma config WPFP = PAGE_1        //Write Protect Program Flash Page 0
81:                     #pragma config WPEND = PAGE_0       //Start protection at page 0
82:                     #pragma config WPCFG = OFF          //Write/Erase last page protect Disabled
83:                     #pragma config WPDIS = OFF          //WPFP[5:0], WPEND, and WPCFG bits ignored 
84:                     #if defined(PIC18F47J53_PIM)
85:                        #pragma config CFGPLLEN = OFF
86:                     #else
87:                        #pragma config T1DIG = ON           //Sec Osc clock source may be selected
88:                        #pragma config LPT1OSC = OFF        //high power Timer1 mode
89:                     #endif
90:                #elif defined(LOW_PIN_COUNT_USB_DEVELOPMENT_KIT)
91:                        //14K50
92:                        #pragma config CPUDIV = NOCLKDIV
93:                        #pragma config USBDIV = OFF
94:                        #pragma config FOSC   = HS
95:                        #pragma config PLLEN  = ON
96:                        #pragma config FCMEN  = OFF
97:                        #pragma config IESO   = OFF
98:                        #pragma config PWRTEN = OFF
99:                        #pragma config BOREN  = OFF
100:                       #pragma config BORV   = 30
101:               //        #pragma config VREGEN = ON
102:                       #pragma config WDTEN  = OFF
103:                       #pragma config WDTPS  = 32768
104:                       #pragma config MCLRE  = OFF
105:                       #pragma config HFOFST = OFF
106:                       #pragma config STVREN = ON
107:                       #pragma config LVP    = OFF
108:                       #pragma config XINST  = OFF
109:                       #pragma config BBSIZ  = OFF
110:                       #pragma config CP0    = OFF
111:                       #pragma config CP1    = OFF
112:                       #pragma config CPB    = OFF
113:                       #pragma config WRT0   = OFF
114:                       #pragma config WRT1   = OFF
115:                       #pragma config WRTB   = OFF
116:                       #pragma config WRTC   = OFF
117:                       #pragma config EBTR0  = OFF
118:                       #pragma config EBTR1  = OFF
119:                       #pragma config EBTRB  = OFF       
120:               
121:               #elif defined(EXPLORER_16)
122:                   #if defined(__PIC24FJ256GB110__)
123:                       _CONFIG1( JTAGEN_OFF & GCP_OFF & GWRP_OFF & FWDTEN_OFF & ICS_PGx2) 
124:                       _CONFIG2( 0xF7FF & IESO_OFF & FCKSM_CSDCMD & OSCIOFNC_ON & POSCMOD_HS & FNOSC_PRIPLL & PLLDIV_DIV2 & IOL1WAY_ON)
125:                   #elif defined(__PIC24FJ256GB210__)
126:                       _CONFIG1(FWDTEN_OFF & ICS_PGx2 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
127:                       _CONFIG2(POSCMOD_HS & IOL1WAY_ON & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRIPLL & PLL96MHZ_ON & PLLDIV_DIV2 & IESO_OFF)
128:                   #elif defined(__PIC24FJ64GB004__)
129:                       _CONFIG1(WDTPS_PS1 & FWPSA_PR32 & WINDIS_OFF & FWDTEN_OFF & ICS_PGx1 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
130:                       _CONFIG2(POSCMOD_HS & I2C1SEL_PRI & IOL1WAY_OFF & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRIPLL & PLL96MHZ_ON & PLLDIV_DIV2 & IESO_ON)
131:                       _CONFIG3(WPFP_WPFP0 & SOSCSEL_SOSC & WUTSEL_LEG & WPDIS_WPDIS & WPCFG_WPCFGDIS & WPEND_WPENDMEM)
132:                       _CONFIG4(DSWDTPS_DSWDTPS3 & DSWDTOSC_LPRC & RTCOSC_SOSC & DSBOREN_OFF & DSWDTEN_OFF)
133:                   #elif defined(__32MX460F512L__) || defined(__32MX795F512L__)
134:                       #pragma config UPLLEN   = ON        // USB PLL Enabled
135:                       #pragma config FPLLMUL  = MUL_15        // PLL Multiplier
136:                       #pragma config UPLLIDIV = DIV_2         // USB PLL Input Divider
137:                       #pragma config FPLLIDIV = DIV_2         // PLL Input Divider
138:                       #pragma config FPLLODIV = DIV_1         // PLL Output Divider
139:                       #pragma config FPBDIV   = DIV_1         // Peripheral Clock divisor
140:                       #pragma config FWDTEN   = OFF           // Watchdog Timer
141:                       #pragma config WDTPS    = PS1           // Watchdog Timer Postscale
142:                       #pragma config FCKSM    = CSDCMD        // Clock Switching & Fail Safe Clock Monitor
143:                       #pragma config OSCIOFNC = OFF           // CLKO Enable
144:                       #pragma config POSCMOD  = HS            // Primary Oscillator
145:                       #pragma config IESO     = OFF           // Internal/External Switch-over
146:                       #pragma config FSOSCEN  = OFF           // Secondary Oscillator Enable (KLO was off)
147:                       #pragma config FNOSC    = PRIPLL        // Oscillator Selection
148:                       #pragma config CP       = OFF           // Code Protect
149:                       #pragma config BWP      = OFF           // Boot Flash Write Protect
150:                       #pragma config PWP      = OFF           // Program Flash Write Protect
151:                       #pragma config ICESEL   = ICS_PGx2      // ICE/ICD Comm Channel Select
152:                       #pragma config DEBUG    = ON            // Background Debugger Enable
153:                   #else
154:                       #error No hardware board defined, see "HardwareProfile.h" and __FILE__
155:                   #endif
156:               #elif defined(PIC24F_STARTER_KIT)
157:                   _CONFIG1( JTAGEN_OFF & GCP_OFF & GWRP_OFF & COE_OFF & FWDTEN_OFF & ICS_PGx2) 
158:                   _CONFIG2( 0xF7FF & IESO_OFF & FCKSM_CSDCMD & OSCIOFNC_ON & POSCMOD_HS & FNOSC_PRIPLL & PLLDIV_DIV3 & IOL1WAY_ON)
159:               #elif defined(PIC24FJ256DA210_DEV_BOARD)
160:                   _CONFIG1(FWDTEN_OFF & ICS_PGx2 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
161:                   _CONFIG2(POSCMOD_HS & IOL1WAY_ON & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRIPLL & PLL96MHZ_ON & PLLDIV_DIV2 & IESO_OFF)
162:               #elif defined(PIC32_USB_STARTER_KIT)
163:                   #pragma config UPLLEN   = ON        // USB PLL Enabled
164:                   #pragma config FPLLMUL  = MUL_15        // PLL Multiplier
165:                   #pragma config UPLLIDIV = DIV_2         // USB PLL Input Divider
166:                   #pragma config FPLLIDIV = DIV_2         // PLL Input Divider
167:                   #pragma config FPLLODIV = DIV_1         // PLL Output Divider
168:                   #pragma config FPBDIV   = DIV_1         // Peripheral Clock divisor
169:                   #pragma config FWDTEN   = OFF           // Watchdog Timer
170:                   #pragma config WDTPS    = PS1           // Watchdog Timer Postscale
171:                   #pragma config FCKSM    = CSDCMD        // Clock Switching & Fail Safe Clock Monitor
172:                   #pragma config OSCIOFNC = OFF           // CLKO Enable
173:                   #pragma config POSCMOD  = HS            // Primary Oscillator
174:                   #pragma config IESO     = OFF           // Internal/External Switch-over
175:                   #pragma config FSOSCEN  = OFF           // Secondary Oscillator Enable (KLO was off)
176:                   #pragma config FNOSC    = PRIPLL        // Oscillator Selection
177:                   #pragma config CP       = OFF           // Code Protect
178:                   #pragma config BWP      = OFF           // Boot Flash Write Protect
179:                   #pragma config PWP      = OFF           // Program Flash Write Protect
180:                   #pragma config ICESEL   = ICS_PGx2      // ICE/ICD Comm Channel Select
181:                   #pragma config DEBUG    = ON            // Background Debugger Enable
182:               #else
183:                   #error No hardware board defined, see "HardwareProfile.h" and __FILE__
184:               #endif
185:               
186:               
187:               
188:               /** VARIABLES ******************************************************/
189:               #pragma udata
190:               // char USB_Out_Buffer[CDC_DATA_OUT_EP_SIZE+1];	// bad Microchip code
191:               char RS232_Out_Data[CDC_DATA_IN_EP_SIZE+1];		// bad Microchip code
192:               
193:               #define RS232_IntRec_Buf 16
194:               #if defined(__18CXX)
195:               	#pragma udata myCDC=CDC_BUFFER_ADDRESS
196:               #endif
197:               unsigned char RS232_In_Buffer[RS232_IntRec_Buf];
198:               unsigned char RS232_In_Head = 0, RS232_In_Tail = 0;	// interrupt driven circular buffer
199:               unsigned char ucInt;
200:               
201:               char cPrintBuf[CDC_DATA_OUT_EP_SIZE];
202:               
203:               #if defined(__18CXX)
204:               #pragma udata
205:               #endif
206:               int iPrintBufFull;
207:               
208:               unsigned char  NextUSBOut;
209:               //unsigned char  NextUSBOut; // the ways they fail is amasing
210:               
211:               unsigned char    LastRS232Out;  // Number of characters in the buffer
212:               unsigned char    RS232cp;       // current position within the buffer
213:               unsigned char RS232_Out_Data_Rdy = 0;
214:               USB_HANDLE  lastTransmission;
215:               
216:               USB_HANDLE USBOutHandle = 0;
217:               USB_HANDLE USBInHandle = 0;
218:               BOOL blinkStatusValid = TRUE;
219:               
220:               #pragma udata
221:               char USB_In_Buffer[64+1];
222:               char USB_Out_Buffer[64+1];
223:               BOOL stringPrinted;
224:               volatile BOOL buttonPressed;
225:               volatile BYTE buttonCount;
226:               
227:               
228:               #if defined(__C30__) || defined(__C32__)
229:               //The LUN variable definition is critical to the MSD function driver.  This
230:               //  array is a structure of function pointers that are the functions that 
231:               //  will take care of each of the physical media.  For each additional LUN
232:               //  that is added to the system, an entry into this array needs to be added
233:               //  so that the stack can know where to find the physical layer functions.
234:               //  In this example the media initialization function is named 
235:               //  "MediaInitialize", the read capacity function is named "ReadCapacity",
236:               //  etc.  
237:               LUN_FUNCTIONS LUN[MAX_LUN + 1] = 
238:               {
239:                   {
240:                       &MDD_IntFlash_MediaInitialize,
241:                       &MDD_IntFlash_ReadCapacity,
242:                       &MDD_IntFlash_ReadSectorSize,
243:                       &MDD_IntFlash_MediaDetect,
244:                       &MDD_IntFlash_SectorRead,
245:                       &MDD_IntFlash_WriteProtectState,
246:                       &MDD_IntFlash_SectorWrite
247:                   }
248:               };
249:               #endif
250:               
251:               /* Standard Response to INQUIRY command stored in ROM 	*/
252:               const ROM InquiryResponse inq_resp = {
253:               	0x00,		// peripheral device is connected, direct access block device
254:               	0x80,           // removable
255:               	0x04,	 	// version = 00=> does not conform to any standard, 4=> SPC-2
256:               	0x02,		// response is in format specified by SPC-2
257:               	0x20,		// n-4 = 36-4=32= 0x20
258:               	0x00,		// sccs etc.
259:               	0x00,		// bque=1 and cmdque=0,indicates simple queueing 00 is obsolete,
260:               			// but as in case of other device, we are just using 00
261:               	0x00,		// 00 obsolete, 0x80 for basic task queueing
262:               	{'M','i','c','r','o','c','h','p'
263:                   },
264:               	// this is the T10 assigned Vendor ID
265:               	{'M','a','s','s',' ','S','t','o','r','a','g','e',' ',' ',' ',' '
266:                   },
267:               	{'0','0','0','1'
268:                   }
269:               };
270:               
271:               /** PRIVATE PROTOTYPES *********************************************/
272:               static void InitializeSystem(void);
273:               void USBDeviceTasks(void);
274:               void ProcessIO(void);
275:               void YourHighPriorityISRCode(void);
276:               void YourLowPriorityISRCode(void);
277:               void USBCBSendResume(void);
278:               void BlinkUSBStatus(void);
279:               void UserInit(void);
280:               void InitializeUSART(void);
281:               void putcUSART(char c);
282:               unsigned char getcUSART ();
283:               
284:               
285:               #if defined(__18CXX)
286:                   #define mDataRdyUSART() PIR1bits.RCIF
287:               //    #define mTxRdyUSART()   TXSTAbits.TRMT
288:                   #define mTxRdyUSART()   PIR1bits.TXIF
289:               #elif defined(__C30__) || defined(__C32__)
290:                   #define mDataRdyUSART() UART2IsPressed()
291:                   #define mTxRdyUSART()   U2STAbits.TRMT
292:               #endif
293:               
294:               /** VECTOR REMAPPING ***********************************************/
295:               #if defined(__18CXX)
296:               	//On PIC18 devices, addresses 0x00, 0x08, and 0x18 are used for
297:               	//the reset, high priority interrupt, and low priority interrupt
298:               	//vectors.  However, the current Microchip USB bootloader 
299:               	//examples are intended to occupy addresses 0x00-0x7FF or
300:               	//0x00-0xFFF depending on which bootloader is used.  Therefore,
301:               	//the bootloader code remaps these vectors to new locations
302:               	//as indicated below.  This remapping is only necessary if you
303:               	//wish to program the hex file generated from this project with
304:               	//the USB bootloader.  If no bootloader is used, edit the
305:               	//usb_config.h file and comment out the following defines:
306:               	//#define PROGRAMMABLE_WITH_USB_HID_BOOTLOADER
307:               	//#define PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER
308:               	
309:               	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)
310:               		#define REMAPPED_RESET_VECTOR_ADDRESS			0x1000
311:               		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x1008
312:               		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x1018
313:               	#elif defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)	
314:               		#define REMAPPED_RESET_VECTOR_ADDRESS			0x800
315:               		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x808
316:               		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x818
317:               	#else	
318:               		#define REMAPPED_RESET_VECTOR_ADDRESS			0x00
319:               		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x08
320:               		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x18
321:               	#endif
322:               	
323:               	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
324:               	extern void _startup (void);        // See c018i.c in your C18 compiler dir
325:               	#pragma code REMAPPED_RESET_VECTOR = REMAPPED_RESET_VECTOR_ADDRESS
326:               	void _reset (void)
327:               	{
328:               	    _asm goto _startup _endasm
  1000    EF8E     GOTO 0x671c
  1002    F033     NOP
329:               	}
  1004    0012     RETURN 0
330:               	#endif
331:               	#pragma code REMAPPED_HIGH_INTERRUPT_VECTOR = REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS
332:               	void Remapped_High_ISR (void)
333:               	{
334:               	     _asm goto YourHighPriorityISRCode _endasm
  1008    EF5A     GOTO 0x52b4
  100A    F029     NOP
335:               	}
  100C    0012     RETURN 0
336:               	#pragma code REMAPPED_LOW_INTERRUPT_VECTOR = REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS
337:               	void Remapped_Low_ISR (void)
338:               	{
339:               	     _asm goto YourLowPriorityISRCode _endasm
  1018    EFAD     GOTO 0x535a
  101A    F029     NOP
340:               	}
  101C    0012     RETURN 0
341:               	
342:               	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
343:               	//Note: If this project is built while one of the bootloaders has
344:               	//been defined, but then the output hex file is not programmed with
345:               	//the bootloader, addresses 0x08 and 0x18 would end up programmed with 0xFFFF.
346:               	//As a result, if an actual interrupt was enabled and occured, the PC would jump
347:               	//to 0x08 (or 0x18) and would begin executing "0xFFFF" (unprogrammed space).  This
348:               	//executes as nop instructions, but the PC would eventually reach the REMAPPED_RESET_VECTOR_ADDRESS
349:               	//(0x1000 or 0x800, depending upon bootloader), and would execute the "goto _startup".  This
350:               	//would effective reset the application.
351:               	
352:               	//To fix this situation, we should always deliberately place a 
353:               	//"goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS" at address 0x08, and a
354:               	//"goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS" at address 0x18.  When the output
355:               	//hex file of this project is programmed with the bootloader, these sections do not
356:               	//get bootloaded (as they overlap the bootloader space).  If the output hex file is not
357:               	//programmed using the bootloader, then the below goto instructions do get programmed,
358:               	//and the hex file still works like normal.  The below section is only required to fix this
359:               	//scenario.
360:               	#pragma code HIGH_INTERRUPT_VECTOR = 0x08
361:               	void High_ISR (void)
362:               	{
363:               	     _asm goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS _endasm
  0008    EF04     GOTO 0x1008
  000A    F008     NOP
364:               	}
  000C    0012     RETURN 0
365:               	#pragma code LOW_INTERRUPT_VECTOR = 0x18
366:               	void Low_ISR (void)
367:               	{
368:               	     _asm goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS _endasm
  0018    EF0C     GOTO 0x1018
  001A    F008     NOP
369:               	}
  001C    0012     RETURN 0
370:               	#endif	//end of "#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER)"
371:               
372:               	#pragma code
373:               	
374:               	
375:               	//These are your actual interrupt handling routines.
376:               	#pragma interrupt YourHighPriorityISRCode
377:               	void YourHighPriorityISRCode()
  52B4    CFDA     MOVFF 0xfda, 0xfe4
  52B6    FFE4     NOP
  52B8    CFE2     MOVFF 0xfe2, 0xfda
  52BA    FFDA     NOP
  52BC    CFE9     MOVFF 0xfe9, 0xfe4
  52BE    FFE4     NOP
  52C0    CFEA     MOVFF 0xfea, 0xfe4
  52C2    FFE4     NOP
  52C4    CFF6     MOVFF 0xff6, 0xfe4
  52C6    FFE4     NOP
  52C8    CFF7     MOVFF 0xff7, 0xfe4
  52CA    FFE4     NOP
  52CC    CFF8     MOVFF 0xff8, 0xfe4
  52CE    FFE4     NOP
  52D0    CFF5     MOVFF 0xff5, 0xfe4
  52D2    FFE4     NOP
  52D4    CFF3     MOVFF 0xff3, 0xfe4
  52D6    FFE4     NOP
  52D8    CFF4     MOVFF 0xff4, 0xfe4
  52DA    FFE4     NOP
  52DC    CFFA     MOVFF 0xffa, 0xfe4
  52DE    FFE4     NOP
  52E0    CFFB     MOVFF 0xffb, 0xfe4
  52E2    FFE4     NOP
  52E4    EE00     LFSR 0, 0
  52E6    F000     NOP
  52E8    0E14     MOVLW 0x14
  52EA    04E8     DECF 0xfe8, W, ACCESS
  52EC    E303     BNC 0x52f4
  52EE    CFEE     MOVFF 0xfee, 0xfe4
  52F0    FFE4     NOP
  52F2    D7FB     BRA 0x52ea
  52F4    EE00     LFSR 0, 0x14
  52F6    F014     NOP
  52F8    0E12     MOVLW 0x12
  52FA    04E8     DECF 0xfe8, W, ACCESS
  52FC    E303     BNC 0x5304
  52FE    CFEE     MOVFF 0xfee, 0xfe4
  5300    FFE4     NOP
  5302    D7FB     BRA 0x52fa
  5304    52E6     MOVF 0xfe6, F, ACCESS
378:               	{
379:               		//Check which interrupt flag caused the interrupt.
380:               		//Service the interrupt
381:               		//Clear the interrupt flag
382:               		//Etc.
383:                       #if defined(USB_INTERRUPT)
384:               	        USBDeviceTasks();
  5306    EC07     CALL 0x2a0e, 0
  5308    F015     NOP
385:                       #endif
386:               	
387:               	}	//This return will be a "retfie fast", since this is in a #pragma interrupt section 
  530A    52E5     MOVF 0xfe5, F, ACCESS
  530C    EE00     LFSR 0, 0x25
  530E    F025     NOP
  5310    0E12     MOVLW 0x12
  5312    04E8     DECF 0xfe8, W, ACCESS
  5314    E303     BNC 0x531c
  5316    CFE5     MOVFF 0xfe5, 0xfed
  5318    FFED     NOP
  531A    D7FB     BRA 0x5312
  531C    EE00     LFSR 0, 0x13
  531E    F013     NOP
  5320    0E14     MOVLW 0x14
  5322    04E8     DECF 0xfe8, W, ACCESS
  5324    E303     BNC 0x532c
  5326    CFE5     MOVFF 0xfe5, 0xfed
  5328    FFED     NOP
  532A    D7FB     BRA 0x5322
  532C    CFE5     MOVFF 0xfe5, 0xffb
  532E    FFFB     NOP
  5330    CFE5     MOVFF 0xfe5, 0xffa
  5332    FFFA     NOP
  5334    CFE5     MOVFF 0xfe5, 0xff4
  5336    FFF4     NOP
  5338    CFE5     MOVFF 0xfe5, 0xff3
  533A    FFF3     NOP
  533C    CFE5     MOVFF 0xfe5, 0xff5
  533E    FFF5     NOP
  5340    CFE5     MOVFF 0xfe5, 0xff8
  5342    FFF8     NOP
  5344    CFE5     MOVFF 0xfe5, 0xff7
  5346    FFF7     NOP
  5348    CFE5     MOVFF 0xfe5, 0xff6
  534A    FFF6     NOP
  534C    CFE5     MOVFF 0xfe5, 0xfea
  534E    FFEA     NOP
  5350    CFE5     MOVFF 0xfe5, 0xfe9
  5352    FFE9     NOP
  5354    CFE5     MOVFF 0xfe5, 0xfda
  5356    FFDA     NOP
  5358    0011     RETFIE 0x1
388:               	#pragma interruptlow YourLowPriorityISRCode
389:               	void YourLowPriorityISRCode()
  535A    CFD8     MOVFF 0xfd8, 0xfe4
  535C    FFE4     NOP
  535E    CFE0     MOVFF 0xfe0, 0xfe4
  5360    FFE4     NOP
  5362    6EE4     MOVWF 0xfe4, ACCESS
  5364    CFDA     MOVFF 0xfda, 0xfe4
  5366    FFE4     NOP
  5368    CFE9     MOVFF 0xfe9, 0xfe4
  536A    FFE4     NOP
  536C    CFEA     MOVFF 0xfea, 0xfe4
  536E    FFE4     NOP
  5370    52E6     MOVF 0xfe6, F, ACCESS
390:               	{
391:               		//Check which interrupt flag caused the interrupt.
392:               		//Service the interrupt
393:               		//Clear the interrupt flag
394:               		//Etc.
395:               
396:               		//Check if we received a character over the physical UART, and we need
397:               		//to buffer it up for eventual transmission to the USB host.
398:                   #if defined(__18CXX)
399:               		if(mDataRdyUSART())
  5372    AA9E     BTFSS 0xf9e, 0x5, ACCESS
  5374    D017     BRA 0x53a4
400:               		{
401:               			if (RCSTAbits.OERR)  // in case of overrun error
  5376    A2AC     BTFSS 0xfac, 0x1, ACCESS
  5378    D005     BRA 0x5384
402:               			{                    // we should never see an overrun error, but if we do, 
403:               				RCSTAbits.CREN = 0;  // reset the port
  537A    98AC     BCF 0xfac, 0x4, ACCESS
404:               				ucInt = RCREG;
  537C    CFAF     MOVFF 0xfaf, 0x510
  537E    F510     NOP
405:               				RCSTAbits.CREN = 1;  // and keep going.
  5380    88AC     BSF 0xfac, 0x4, ACCESS
406:               			}
407:               			else
  5382    D002     BRA 0x5388
408:               				ucInt = RCREG;
  5384    CFAF     MOVFF 0xfaf, 0x510
  5386    F510     NOP
409:               		// not necessary.  EUSART auto clears the flag when RCREG is cleared
410:               		//	PIR1bits.RCIF = 0;    // clear Flag
411:               			RS232_In_Buffer[RS232_In_Head] = ucInt;
  5388    0101     MOVLB 0x1
  538A    51E5     MOVF 0xe5, W, BANKED
  538C    6AEA     CLRF 0xfea, ACCESS
  538E    0F00     ADDLW 0
  5390    6EE9     MOVWF 0xfe9, ACCESS
  5392    0E05     MOVLW 0x5
  5394    22EA     ADDWFC 0xfea, F, ACCESS
  5396    C510     MOVFF 0x510, 0xfef
  5398    FFEF     NOP
412:               			RS232_In_Head++;
  539A    2BE5     INCF 0xe5, F, BANKED
413:               			if ( RS232_In_Head > (RS232_IntRec_Buf - 1) )
  539C    51E5     MOVF 0xe5, W, BANKED
  539E    080F     SUBLW 0xf
  53A0    E201     BC 0x53a4
414:               				RS232_In_Head = 0;
  53A2    6BE5     CLRF 0xe5, BANKED
415:               		}
416:               	#endif
417:               	
418:               	}	//This return will be a "retfie", since this is in a #pragma interruptlow section 
  53A4    52E5     MOVF 0xfe5, F, ACCESS
  53A6    CFE5     MOVFF 0xfe5, 0xfea
  53A8    FFEA     NOP
  53AA    CFE5     MOVFF 0xfe5, 0xfe9
  53AC    FFE9     NOP
  53AE    CFE5     MOVFF 0xfe5, 0xfda
  53B0    FFDA     NOP
  53B2    50E5     MOVF 0xfe5, W, ACCESS
  53B4    CFE5     MOVFF 0xfe5, 0xfe0
  53B6    FFE0     NOP
  53B8    CFE5     MOVFF 0xfe5, 0xfd8
  53BA    FFD8     NOP
  53BC    0010     RETFIE 0
419:               
420:               #elif defined(__C30__)
421:                   #if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)
422:                       /*
423:                        *	ISR JUMP TABLE
424:                        *
425:                        *	It is necessary to define jump table as a function because C30 will
426:                        *	not store 24-bit wide values in program memory as variables.
427:                        *
428:                        *	This function should be stored at an address where the goto instructions 
429:                        *	line up with the remapped vectors from the bootloader's linker script.
430:                        *  
431:                        *  For more information about how to remap the interrupt vectors,
432:                        *  please refer to AN1157.  An example is provided below for the T2
433:                        *  interrupt with a bootloader ending at address 0x1400
434:                        */
435:               //        void __attribute__ ((address(0x1404))) ISRTable(){
436:               //        
437:               //        	asm("reset"); //reset instruction to prevent runaway code
438:               //        	asm("goto %0"::"i"(&_T2Interrupt));  //T2Interrupt's address
439:               //        }
440:                   #endif
441:               #endif
442:               
443:               
444:               
445:               
446:               /** DECLARATIONS ***************************************************/
447:               #pragma code
448:               
449:               /********************************************************************
450:                * Function:        void main(void)
451:                *
452:                * PreCondition:    None
453:                *
454:                * Input:           None
455:                *
456:                * Output:          None
457:                *
458:                * Side Effects:    None
459:                *
460:                * Overview:        Main program entry point.
461:                *
462:                * Note:            None
463:                *****************************************************************************/
464:               
465:                #if defined(__18CXX)
466:               void main(void)
  53BE    CFD9     MOVFF 0xfd9, 0xfe6
  53C0    FFE6     NOP
  53C2    CFE1     MOVFF 0xfe1, 0xfd9
  53C4    FFD9     NOP
  53C6    0E02     MOVLW 0x2
  53C8    26E1     ADDWF 0xfe1, F, ACCESS
467:               #else 
468:               int main(void)
469:               #endif
470:               {
471:               	MEDIA_INFORMATION * ucMediaResp = 0;
  53CA    6ADE     CLRF 0xfde, ACCESS
  53CC    6ADD     CLRF 0xfdd, ACCESS
472:               
473:                   InitializeSystem();
  53CE    D8CE     RCALL 0x556c
474:               //	ucMediaResp = MDD_SDSPI_MediaInitialize();
475:               
476:                   #if defined(USB_INTERRUPT)
477:                       USBDeviceAttach();
  53D0    ECD5     CALL 0x3baa, 0
  53D2    F01D     NOP
478:                   #endif
479:               
480:                   while(1)
  53D6    D7FE     BRA 0x53d4
481:                   {
482:                       #if defined(USB_POLLING)
483:               		// Check bus status and service USB interrupts.
484:                       USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
485:                       				  // this function periodically.  This function will take care
486:                       				  // of processing and responding to SETUP transactions 
487:                       				  // (such as during the enumeration process when you first
488:                       				  // plug in).  USB hosts require that USB devices should accept
489:                       				  // and process SETUP packets in a timely fashion.  Therefore,
490:                       				  // when using polling, this function should be called 
491:                       				  // regularly (such as once every 1.8ms or faster** [see 
492:                       				  // inline code comments in usb_device.c for explanation when
493:                       				  // "or faster" applies])  In most cases, the USBDeviceTasks() 
494:                       				  // function does not take very long to execute (ex: <100 
495:                       				  // instruction cycles) before it returns.
496:                       #endif
497:                   				  
498:               
499:               		// Application-specific tasks.
500:               		// Application related code may be added here, or in the ProcessIO() function.
501:                       ProcessIO();        
  53D4    D801     RCALL 0x53d8
502:               //		if ( ucMediaResp->errorCode )
503:               //			ucMediaResp = MDD_SDSPI_MediaInitialize();
504:                   }//end while
505:               }//end main
506:               
507:               /********************************************************************
508:                * Function:        void ProcessIO(void)
509:                *
510:                * PreCondition:    None
511:                *
512:                * Input:           None
513:                *
514:                * Output:          None
515:                *
516:                * Side Effects:    None
517:                *
518:                * Overview:        This function is a place holder for other user
519:                *                  routines. It is a mixture of both USB and
520:                *                  non-USB tasks.
521:                *
522:                * Note:            None
523:                *******************************************************************/
524:               void ProcessIO(void)
  53D8    CFD9     MOVFF 0xfd9, 0xfe6
  53DA    FFE6     NOP
  53DC    CFE1     MOVFF 0xfe1, 0xfd9
  53DE    FFD9     NOP
  53E0    0E03     MOVLW 0x3
  53E2    26E1     ADDWF 0xfe1, F, ACCESS
525:               {   
526:                   BYTE numBytesRead;
527:               	int iIdx;
528:                   //Blink the LEDs according to the USB device status
529:                   BlinkUSBStatus();
  53E4    DBBC     RCALL 0x5b5e
530:                   // User Application USB tasks
531:                   if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) return;
  53E6    0E20     MOVLW 0x20
  53E8    0100     MOVLB 0
  53EA    6EE7     MOVWF 0xfe7, ACCESS
  53EC    1960     XORWF 0x60, W, BANKED
  53EE    AEE8     BTFSS 0xfe8, 0x7, ACCESS
  53F0    D002     BRA 0x53f6
  53F2    34E7     RLCF 0xfe7, W, ACCESS
  53F4    D002     BRA 0x53fa
  53F6    50E7     MOVF 0xfe7, W, ACCESS
  53F8    5D60     SUBWF 0x60, W, BANKED
  53FA    E201     BC 0x53fe
  53FC    D0AD     BRA 0x5558
  53FE    5065     MOVF 0xf65, W, ACCESS
  5400    0B02     ANDLW 0x2
  5402    E001     BZ 0x5406
  5404    D0A9     BRA 0x5558
532:               
533:               #if !defined(CUSTOM_PIM)
534:                   if(buttonPressed)
535:                   {
536:                       if(stringPrinted == FALSE)
537:                       {
538:                           if(mUSBUSARTIsTxTrfReady())
539:                           {
540:                               putrsUSBUSART("Button Pressed -- \r\n");
541:                               stringPrinted = TRUE;
542:                           }
543:                       }
544:                   }
545:                   else
546:                   {
547:                       stringPrinted = FALSE;
548:                   }
549:               #endif
550:               
551:               	if (RS232_Out_Data_Rdy == 0)  // only check for new USB buffer if the old RS232 buffer is
  5406    0101     MOVLB 0x1
  5408    51E7     MOVF 0xe7, W, BANKED
  540A    E115     BNZ 0x5436
552:               	{						  // empty.  This will cause additional USB packets to be NAK'd
553:               		LastRS232Out = getsUSBUSART(RS232_Out_Data,64); //until the buffer is free.
  540C    0E40     MOVLW 0x40
  540E    6EE6     MOVWF 0xfe6, ACCESS
  5410    0E00     MOVLW 0
  5412    6EE6     MOVWF 0xfe6, ACCESS
  5414    0E01     MOVLW 0x1
  5416    6EE6     MOVWF 0xfe6, ACCESS
  5418    ECC6     CALL 0x5d8c, 0
  541A    F02E     NOP
  541C    52E5     MOVF 0xfe5, F, ACCESS
  541E    52E5     MOVF 0xfe5, F, ACCESS
  5420    52E5     MOVF 0xfe5, F, ACCESS
  5422    0101     MOVLB 0x1
  5424    6F44     MOVWF 0x44, BANKED
554:               		if(LastRS232Out > 0)
  5426    50E8     MOVF 0xfe8, W, ACCESS
  5428    0800     SUBLW 0
  542A    E205     BC 0x5436
555:               		{	
556:               			RS232_Out_Data_Rdy = 1;  // signal buffer full
  542C    0101     MOVLB 0x1
  542E    0E01     MOVLW 0x1
  5430    6FE7     MOVWF 0xe7, BANKED
557:               			RS232cp = 0;  // Reset the current position
  5432    0101     MOVLB 0x1
  5434    6B45     CLRF 0x45, BANKED
558:               		}
559:               	}
560:               
561:                   //Check if one or more bytes are waiting in the physical UART transmit
562:                   //queue.  If so, send it out the UART TX pin.
563:               	if(RS232_Out_Data_Rdy && mTxRdyUSART())
  5436    0101     MOVLB 0x1
  5438    51E7     MOVF 0xe7, W, BANKED
  543A    E015     BZ 0x5466
  543C    509E     MOVF 0xf9e, W, ACCESS
  543E    0B10     ANDLW 0x10
  5440    E012     BZ 0x5466
564:               	{
565:               		putcUSART(RS232_Out_Data[RS232cp]);
  5442    0101     MOVLB 0x1
  5444    5145     MOVF 0x45, W, BANKED
  5446    6AEA     CLRF 0xfea, ACCESS
  5448    0F00     ADDLW 0
  544A    6EE9     MOVWF 0xfe9, ACCESS
  544C    0E01     MOVLW 0x1
  544E    22EA     ADDWFC 0xfea, F, ACCESS
  5450    50EF     MOVF 0xfef, W, ACCESS
  5452    6EE6     MOVWF 0xfe6, ACCESS
  5454    D8FB     RCALL 0x564c
  5456    52E5     MOVF 0xfe5, F, ACCESS
566:               		++RS232cp;
  5458    0101     MOVLB 0x1
  545A    2B45     INCF 0x45, F, BANKED
567:               		if (RS232cp == LastRS232Out)
  545C    5144     MOVF 0x44, W, BANKED
  545E    5D45     SUBWF 0x45, W, BANKED
  5460    E102     BNZ 0x5466
568:               			RS232_Out_Data_Rdy = 0;
  5462    0101     MOVLB 0x1
  5464    6BE7     CLRF 0xe7, BANKED
569:               	}
570:               
571:               //    //Check if we received a character over the physical UART, and we need
572:               //    //to buffer it up for eventual transmission to the USB host.
573:               //	if(mDataRdyUSART() && (NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)))
574:               //	{
575:               //		USB_Out_Buffer[NextUSBOut] = getcUSART();
576:               //		++NextUSBOut;
577:               //		USB_Out_Buffer[NextUSBOut] = 0;
578:               //	}
579:               	while ((RS232_In_Head != RS232_In_Tail) && (NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)))
  5466    0101     MOVLB 0x1
  5468    51E6     MOVF 0xe6, W, BANKED
  546A    5DE5     SUBWF 0xe5, W, BANKED
  546C    E027     BZ 0x54bc
  546E    0E3F     MOVLW 0x3f
  5470    0101     MOVLB 0x1
  5472    5D43     SUBWF 0x43, W, BANKED
  5474    E223     BC 0x54bc
  54BA    D7D5     BRA 0x5466
580:               	{
581:               		USB_Out_Buffer[NextUSBOut] = RS232_In_Buffer[RS232_In_Tail];
  5476    0101     MOVLB 0x1
  5478    51E6     MOVF 0xe6, W, BANKED
  547A    6AEA     CLRF 0xfea, ACCESS
  547C    0F00     ADDLW 0
  547E    6EE9     MOVWF 0xfe9, ACCESS
  5480    0E05     MOVLW 0x5
  5482    22EA     ADDWFC 0xfea, F, ACCESS
  5484    50EF     MOVF 0xfef, W, ACCESS
  5486    6EE6     MOVWF 0xfe6, ACCESS
  5488    0101     MOVLB 0x1
  548A    5143     MOVF 0x43, W, BANKED
  548C    6AEA     CLRF 0xfea, ACCESS
  548E    0F89     ADDLW 0x89
  5490    6EE9     MOVWF 0xfe9, ACCESS
  5492    0E01     MOVLW 0x1
  5494    22EA     ADDWFC 0xfea, F, ACCESS
  5496    52E5     MOVF 0xfe5, F, ACCESS
  5498    50E7     MOVF 0xfe7, W, ACCESS
  549A    6EEF     MOVWF 0xfef, ACCESS
582:               		++NextUSBOut, RS232_In_Tail++;	// interrupt driven circular buffer
  549C    2B43     INCF 0x43, F, BANKED
  549E    0101     MOVLB 0x1
  54A0    2BE6     INCF 0xe6, F, BANKED
583:               		if ( RS232_In_Tail > (RS232_IntRec_Buf - 1) )
  54A2    51E6     MOVF 0xe6, W, BANKED
  54A4    080F     SUBLW 0xf
  54A6    E201     BC 0x54aa
584:               			RS232_In_Tail = 0;
  54A8    6BE6     CLRF 0xe6, BANKED
585:               		USB_Out_Buffer[NextUSBOut] = 0;
  54AA    0101     MOVLB 0x1
  54AC    5143     MOVF 0x43, W, BANKED
  54AE    6AEA     CLRF 0xfea, ACCESS
  54B0    0F89     ADDLW 0x89
  54B2    6EE9     MOVWF 0xfe9, ACCESS
  54B4    0E01     MOVLW 0x1
  54B6    22EA     ADDWFC 0xfea, F, ACCESS
  54B8    6AEF     CLRF 0xfef, ACCESS
586:               	};
587:               
588:                   //Check if the print buffer needs to be sent - one time only so may lose
589:                   //some buffer. Only used in debug mode.
590:               	if(iPrintBufFull)
  54BC    0101     MOVLB 0x1
  54BE    5141     MOVF 0x41, W, BANKED
  54C0    1142     IORWF 0x42, W, BANKED
  54C2    E032     BZ 0x5528
591:               	{	iIdx = 0;
  54C4    0E01     MOVLW 0x1
  54C6    6ADB     CLRF 0xfdb, ACCESS
  54C8    0E02     MOVLW 0x2
  54CA    6ADB     CLRF 0xfdb, ACCESS
592:               		while ((NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)) && iPrintBufFull)
  54CC    0E3F     MOVLW 0x3f
  54CE    5D43     SUBWF 0x43, W, BANKED
  54D0    E229     BC 0x5524
  54D2    5141     MOVF 0x41, W, BANKED
  54D4    1142     IORWF 0x42, W, BANKED
  54D6    E026     BZ 0x5524
  5522    D7D4     BRA 0x54cc
593:               		{
594:               			USB_Out_Buffer[NextUSBOut] = cPrintBuf[iIdx];
  54D8    0E01     MOVLW 0x1
  54DA    CFDB     MOVFF 0xfdb, 0xfe9
  54DC    FFE9     NOP
  54DE    0E02     MOVLW 0x2
  54E0    CFDB     MOVFF 0xfdb, 0xfea
  54E2    FFEA     NOP
  54E4    0E11     MOVLW 0x11
  54E6    26E9     ADDWF 0xfe9, F, ACCESS
  54E8    0E05     MOVLW 0x5
  54EA    22EA     ADDWFC 0xfea, F, ACCESS
  54EC    50EF     MOVF 0xfef, W, ACCESS
  54EE    6EE6     MOVWF 0xfe6, ACCESS
  54F0    5143     MOVF 0x43, W, BANKED
  54F2    6AEA     CLRF 0xfea, ACCESS
  54F4    0F89     ADDLW 0x89
  54F6    6EE9     MOVWF 0xfe9, ACCESS
  54F8    0E01     MOVLW 0x1
  54FA    22EA     ADDWFC 0xfea, F, ACCESS
  54FC    52E5     MOVF 0xfe5, F, ACCESS
  54FE    50E7     MOVF 0xfe7, W, ACCESS
  5500    6EEF     MOVWF 0xfef, ACCESS
595:               			++NextUSBOut, iIdx++, iPrintBufFull--;
  5502    2B43     INCF 0x43, F, BANKED
  5504    0E01     MOVLW 0x1
  5506    2ADB     INCF 0xfdb, F, ACCESS
  5508    0E02     MOVLW 0x2
  550A    E301     BNC 0x550e
  550C    2ADB     INCF 0xfdb, F, ACCESS
  550E    0741     DECF 0x41, F, BANKED
  5510    0E00     MOVLW 0
  5512    5B42     SUBWFB 0x42, F, BANKED
596:               			USB_Out_Buffer[NextUSBOut] = 0;
  5514    5143     MOVF 0x43, W, BANKED
  5516    6AEA     CLRF 0xfea, ACCESS
  5518    0F89     ADDLW 0x89
  551A    6EE9     MOVWF 0xfe9, ACCESS
  551C    0E01     MOVLW 0x1
  551E    22EA     ADDWFC 0xfea, F, ACCESS
  5520    6AEF     CLRF 0xfef, ACCESS
597:               		};
598:               		iPrintBufFull = 0;
  5524    6B41     CLRF 0x41, BANKED
  5526    6B42     CLRF 0x42, BANKED
599:               	}
600:               
601:                   //Check if any bytes are waiting in the queue to send to the USB host.
602:                   //If any bytes are waiting, and the endpoint is available, prepare to
603:                   //send the USB packet to the host.
604:               	if((USBUSARTIsTxTrfReady()) && (NextUSBOut > 0))
  5528    0105     MOVLB 0x5
  552A    51E1     MOVF 0xe1, W, BANKED
  552C    E111     BNZ 0x5550
  552E    0101     MOVLB 0x1
  5530    5143     MOVF 0x43, W, BANKED
  5532    0800     SUBLW 0
  5534    E20D     BC 0x5550
605:               	{
606:               		putUSBUSART(&USB_Out_Buffer[0], NextUSBOut);
  5536    C143     MOVFF 0x143, 0xfe6
  5538    FFE6     NOP
  553A    0E89     MOVLW 0x89
  553C    6EE6     MOVWF 0xfe6, ACCESS
  553E    0E01     MOVLW 0x1
  5540    6EE6     MOVWF 0xfe6, ACCESS
  5542    EC26     CALL 0x5e4c, 0
  5544    F02F     NOP
  5546    52E5     MOVF 0xfe5, F, ACCESS
  5548    52E5     MOVF 0xfe5, F, ACCESS
  554A    52E5     MOVF 0xfe5, F, ACCESS
607:               		NextUSBOut = 0;
  554C    0101     MOVLB 0x1
  554E    6B43     CLRF 0x43, BANKED
608:               	}
609:               
610:                   CDCTxService();
  5550    ECD0     CALL 0x5fa0, 0
  5552    F02F     NOP
611:                   MSDTasks();    
  5554    EC70     CALL 0x48e0, 0
  5556    F024     NOP
612:               }//end ProcessIO
  5558    0E03     MOVLW 0x3
  555A    5CE1     SUBWF 0xfe1, W, ACCESS
  555C    E202     BC 0x5562
  555E    6AE1     CLRF 0xfe1, ACCESS
  5560    52E5     MOVF 0xfe5, F, ACCESS
  5562    6EE1     MOVWF 0xfe1, ACCESS
  5564    52E5     MOVF 0xfe5, F, ACCESS
  5566    CFE7     MOVFF 0xfe7, 0xfd9
  5568    FFD9     NOP
  556A    0012     RETURN 0
613:               
614:               /********************************************************************
615:                * Function:        static void InitializeSystem(void)
616:                *
617:                * PreCondition:    None
618:                *
619:                * Input:           None
620:                *
621:                * Output:          None
622:                *
623:                * Side Effects:    None
624:                *
625:                * Overview:        InitializeSystem is a centralize initialization
626:                *                  routine. All required USB initialization routines
627:                *                  are called from here.
628:                *
629:                *                  User application initialization routine should
630:                *                  also be called from here.                  
631:                *
632:                * Note:            None
633:                *******************************************************************/
634:               static void InitializeSystem(void)
  556C    CFD9     MOVFF 0xfd9, 0xfe6
  556E    FFE6     NOP
  5570    CFE1     MOVFF 0xfe1, 0xfd9
  5572    FFD9     NOP
  5574    0E02     MOVLW 0x2
  5576    26E1     ADDWF 0xfe1, F, ACCESS
635:               {
636:                   #if (defined(__18CXX) & !defined(PIC18F87J50_PIM))
637:                       ADCON1 |= 0x0F;                 // Default all pins to digital
  5578    0E0F     MOVLW 0xf
  557A    12C1     IORWF 0xfc1, F, ACCESS
638:                   #elif defined(__C30__)
639:                       #if defined(PIC24FJ256GB110_PIM) || defined(PIC24F_STARTER_KIT) || defined(PIC24FJ64GB004_PIM)
640:                           AD1PCFGL = 0xFFFF;
641:                       #endif
642:                   #elif defined(__C32__)
643:                       AD1PCFG = 0xFFFF;
644:                   #endif
645:               
646:                   #if defined(PIC18F87J50_PIM) || defined(PIC18F46J50_PIM) || defined(PIC18F_STARTER_KIT_1) || defined(PIC18F47J53_PIM) || defined(CUSTOM_PIM)
647:               	//On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
648:               	//by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
649:               	//This allows the device to power up at a lower initial operating frequency, which can be
650:               	//advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
651:               	//operation.  On these devices, user firmware needs to manually set the OSCTUNE<PLLEN> bit to
652:               	//power up the PLL.
653:                   {
654:                       unsigned int pll_startup_counter = 600;
  557C    0E58     MOVLW 0x58
  557E    6EDE     MOVWF 0xfde, ACCESS
  5580    0E02     MOVLW 0x2
  5582    6EDD     MOVWF 0xfdd, ACCESS
655:                       OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
  5584    8C9B     BSF 0xf9b, 0x6, ACCESS
656:                       while(pll_startup_counter--);
  5586    CFDF     MOVFF 0xfdf, 0x14
  5588    F014     NOP
  558A    06DF     DECF 0xfdf, F, ACCESS
  558C    0E01     MOVLW 0x1
  558E    CFDB     MOVFF 0xfdb, 0x15
  5590    F015     NOP
  5592    E201     BC 0x5596
  5594    06DB     DECF 0xfdb, F, ACCESS
  5596    5014     MOVF 0x14, W, ACCESS
  5598    1015     IORWF 0x15, W, ACCESS
  559A    E1F5     BNZ 0x5586
657:                   }
658:                   //Device switches over automatically to PLL output after PLL is locked and ready.
659:                   #endif
660:               
661:                   #if defined(PIC18F87J50_PIM)
662:               	//Configure all I/O pins to use digital input buffers.  The PIC18F87J50 Family devices
663:               	//use the ANCONx registers to control this, which is different from other devices which
664:               	//use the ADCON1 register for this purpose.
665:                   WDTCONbits.ADSHR = 1;			// Select alternate SFR location to access ANCONx registers
666:                   ANCON0 = 0xFF;                  // Default all pins to digital
667:                   ANCON1 = 0xFF;                  // Default all pins to digital
668:                   WDTCONbits.ADSHR = 0;			// Select normal SFR locations
669:                   #endif
670:               
671:                   #if defined(PIC18F46J50_PIM) || defined(PIC18F_STARTER_KIT_1) || defined(PIC18F47J53_PIM)
672:               	//Configure all I/O pins to use digital input buffers.  The PIC18F87J50 Family devices
673:               	//use the ANCONx registers to control this, which is different from other devices which
674:               	//use the ADCON1 register for this purpose.
675:                   ANCON0 = 0xFC;                  // Default all pins to digital, low 2 are analog on power board
676:                   ANCON1 = 0x7F;                  // Default all pins to digital
677:                   #endif
678:                   
679:                  #if defined(PIC24FJ64GB004_PIM) || defined(PIC24FJ256DA210_DEV_BOARD)
680:               	//On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
681:               	//by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
682:               	//This allows the device to power up at a lower initial operating frequency, which can be
683:               	//advantageous when powered from a source which is not gauranteed to be adequate for 32MHz
684:               	//operation.  On these devices, user firmware needs to manually set the CLKDIV<PLLEN> bit to
685:               	//power up the PLL.
686:                   {
687:                       unsigned int pll_startup_counter = 600;
688:                       CLKDIVbits.PLLEN = 1;
689:                       while(pll_startup_counter--);
690:                   }
691:               
692:                   //Device switches over automatically to PLL output after PLL is locked and ready.
693:                   #endif
694:               
695:                  #if defined(DSPIC33EP512MU810_PIM)
696:               
697:                   // Configure the device PLL to obtain 60 MIPS operation. The crystal
698:                   // frequency is 8MHz. Divide 8MHz by 2, multiply by 60 and divide by
699:                   // 2. This results in Fosc of 120MHz. The CPU clock frequency is
700:                   // Fcy = Fosc/2 = 60MHz. Wait for the Primary PLL to lock and then
701:                   // configure the auxilliary PLL to provide 48MHz needed for USB 
702:                   // Operation.
703:               
704:               	PLLFBD = 58;				/* M  = 60	*/
705:               	CLKDIVbits.PLLPOST = 0;		/* N1 = 2	*/
706:               	CLKDIVbits.PLLPRE = 0;		/* N2 = 2	*/
707:               	OSCTUN = 0;			
708:               
709:                   /*	Initiate Clock Switch to Primary
710:                    *	Oscillator with PLL (NOSC= 0x3)*/
711:               	
712:                   __builtin_write_OSCCONH(0x03);		
713:               	__builtin_write_OSCCONL(0x01);
714:               	while (OSCCONbits.COSC != 0x3);       
715:               
716:                   // Configuring the auxiliary PLL, since the primary
717:                   // oscillator provides the source clock to the auxiliary
718:                   // PLL, the auxiliary oscillator is disabled. Note that
719:                   // the AUX PLL is enabled. The input 8MHz clock is divided
720:                   // by 2, multiplied by 24 and then divided by 2. Wait till 
721:                   // the AUX PLL locks.
722:               
723:                   ACLKCON3 = 0x24C1;   
724:                   ACLKDIV3 = 0x7;
725:                   ACLKCON3bits.ENAPLL = 1;
726:                   while(ACLKCON3bits.APLLCK != 1); 
727:               
728:                   #endif
729:               
730:               
731:               //	The USB specifications require that USB peripheral devices must never source
732:               //	current onto the Vbus pin.  Additionally, USB peripherals should not source
733:               //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
734:               //	When designing a self powered (as opposed to bus powered) USB peripheral
735:               //	device, the firmware should make sure not to turn on the USB module and D+
736:               //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
737:               //	firmware needs some means to detect when Vbus is being powered by the host.
738:               //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
739:               // 	can be used to detect when Vbus is high (host actively powering), or low
740:               //	(host is shut down or otherwise not supplying power).  The USB firmware
741:               // 	can then periodically poll this I/O pin to know when it is okay to turn on
742:               //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
743:               //	peripheral device, it is not possible to source current on D+ or D- when the
744:               //	host is not actively providing power on Vbus. Therefore, implementing this
745:               //	bus sense feature is optional.  This firmware can be made to use this bus
746:               //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
747:               //	HardwareProfile.h file.    
748:                   #if defined(USE_USB_BUS_SENSE_IO)
749:                   tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
750:                   #endif
751:                   
752:               //	If the host PC sends a GetStatus (device) request, the firmware must respond
753:               //	and let the host know if the USB peripheral device is currently bus powered
754:               //	or self powered.  See chapter 9 in the official USB specifications for details
755:               //	regarding this request.  If the peripheral device is capable of being both
756:               //	self and bus powered, it should not return a hard coded value for this request.
757:               //	Instead, firmware should check if it is currently self or bus powered, and
758:               //	respond accordingly.  If the hardware has been configured like demonstrated
759:               //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
760:               //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
761:               //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
762:               //	has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped
763:               //	to it in HardwareProfile.h.
764:                   #if defined(USE_SELF_POWER_SENSE_IO)
765:                   tris_self_power = INPUT_PIN;	// See HardwareProfile.h
766:                   #endif
767:                   
768:                   UserInit();
  559C    D817     RCALL 0x55cc
769:               
770:                   //********* Initialize Peripheral Pin Select (PPS) *************************
771:                   //  This section only pertains to devices that have the PPS capabilities.
772:                   //    When migrating code into an application, please verify that the PPS
773:                   //    setting is correct for the port pins that are used in the application.
774:                   #if defined(PIC24FJ256GB110_PIM)
775:                   //Initialize the SPI
776:                   RPINR20bits.SDI1R = 23;
777:                   RPOR7bits.RP15R = 7;
778:                   RPOR0bits.RP0R = 8;    
779:               
780:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
781:                   //  then lets have a pull-up to make sure we don't think it is there.
782:                   CNPU5bits.CN68PUE = 1; 
783:               
784:                   #elif defined(PIC24FJ64GB004_PIM)
785:                   //Initialize the SPI
786:                   RPINR20bits.SDI1R = 17;     //MSDI
787:                   RPOR8bits.RP16R = 7;        //MSDO
788:                   RPOR7bits.RP15R = 8;        //SCK
789:               
790:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
791:                   //  then lets have a pull-up to make sure we don't think it is there.
792:                   CNPU1bits.CN6PUE = 1; 
793:               
794:                   #elif defined(PIC18F46J50_PIM)
795:                   //Initialize the SPI
796:                   //RPINR21bits.SDI2R = 1;
797:                   //RPOR4bits.RP4R = 10;    //RP4 = SCK
798:                   //RPOR2bits.RP2R = 9;     //RP2 = SDO   
799:                   RPINR21 = 6;   //SDI = RP1
800:                   RPOR4 = 10;    //RP4 = SCK
801:                   RPOR2 = 9;     //RP2 = SDO
802:                   RPINR22 = 5;   //SCK = RP4
803:               
804:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
805:                   //  then lets have a pull-up to make sure we don't think it is there.
806:                   INTCON2bits.RBPU = 0; 
807:               
808:                   #elif defined(CUSTOM_PIM)
809:                   //Initialize the SPI
810:                   //RPINR21bits.SDI2R = 1;
811:                   //RPOR4bits.RP4R = 10;    //RP4 = SCK
812:                   //RPOR2bits.RP2R = 9;     //RP2 = SDO   
813:                   RPINR21 = 6;   //PICSDI = RP6 = SD CARD DO
  559E    010E     MOVLB 0xe
  55A0    0E06     MOVLW 0x6
  55A2    6FFB     MOVWF 0xfb, BANKED
814:                   RPOR5 = 10;    //RP5 = SCK
  55A4    0E0A     MOVLW 0xa
  55A6    6FCB     MOVWF 0xcb, BANKED
815:                   RPOR4 = 9;     //PICSDO = RP4 = SD CARD DI
  55A8    0E09     MOVLW 0x9
  55AA    6FCA     MOVWF 0xca, BANKED
816:                   RPINR22 = 5;   //SCK = RP10
  55AC    0E05     MOVLW 0x5
  55AE    6FFC     MOVWF 0xfc, BANKED
817:               
818:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
819:                   //  then lets have a pull-up to make sure we don't think it is there.
820:               //    INTCON2bits.RBPU = 0; // all signals have hardware pullups
821:               
822:                   #endif
823:               
824:               #if defined(USE_SD_INTERFACE_WITH_SPI)
825:                   MDD_SDSPI_InitIO();
  55B0    EC7A     CALL 0x10f4, 0
  55B2    F008     NOP
826:               #endif
827:               
828:                   USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
  55B4    EC77     CALL 0x28ee, 0
  55B6    F014     NOP
829:                   					//variables to known states.
830:               }//end InitializeSystem
  55B8    0E02     MOVLW 0x2
  55BA    5CE1     SUBWF 0xfe1, W, ACCESS
  55BC    E202     BC 0x55c2
  55BE    6AE1     CLRF 0xfe1, ACCESS
  55C0    52E5     MOVF 0xfe5, F, ACCESS
  55C2    6EE1     MOVWF 0xfe1, ACCESS
  55C4    52E5     MOVF 0xfe5, F, ACCESS
  55C6    CFE7     MOVFF 0xfe7, 0xfd9
  55C8    FFD9     NOP
  55CA    0012     RETURN 0
831:               
832:               
833:               
834:               /******************************************************************************
835:                * Function:        void UserInit(void)
836:                *
837:                * PreCondition:    None
838:                *
839:                * Input:           None
840:                *
841:                * Output:          None
842:                *
843:                * Side Effects:    None
844:                *
845:                * Overview:        This routine should take care of all of the demo code
846:                *                  initialization that is required.
847:                *
848:                * Note:            
849:                *
850:                *****************************************************************************/
851:               void UserInit(void)
  55CC    CFD9     MOVFF 0xfd9, 0xfe6
  55CE    FFE6     NOP
  55D0    CFE1     MOVFF 0xfe1, 0xfd9
  55D2    FFD9     NOP
  55D4    52E6     MOVF 0xfe6, F, ACCESS
852:               {
853:               	unsigned char i;
854:                   InitializeUSART();
  55D6    D81F     RCALL 0x5616
855:               
856:               // 	 Initialize the arrays
857:               	for (i=0; i<sizeof(USB_Out_Buffer); i++)
  55D8    6ADF     CLRF 0xfdf, ACCESS
  55DA    50DF     MOVF 0xfdf, W, ACCESS
  55DC    6E14     MOVWF 0x14, ACCESS
  55DE    6A15     CLRF 0x15, ACCESS
  55E0    0E41     MOVLW 0x41
  55E2    5C14     SUBWF 0x14, W, ACCESS
  55E4    0E00     MOVLW 0
  55E6    5815     SUBWFB 0x15, W, ACCESS
  55E8    E209     BC 0x55fc
  55F8    2ADF     INCF 0xfdf, F, ACCESS
  55FA    D7EF     BRA 0x55da
858:                   {
859:               		USB_Out_Buffer[i] = 0;
  55EA    50DF     MOVF 0xfdf, W, ACCESS
  55EC    6AEA     CLRF 0xfea, ACCESS
  55EE    0F89     ADDLW 0x89
  55F0    6EE9     MOVWF 0xfe9, ACCESS
  55F2    0E01     MOVLW 0x1
  55F4    22EA     ADDWFC 0xfea, F, ACCESS
  55F6    6AEF     CLRF 0xfef, ACCESS
860:                   }
861:               	NextUSBOut = 0;
  55FC    0101     MOVLB 0x1
  55FE    6B43     CLRF 0x43, BANKED
862:               	LastRS232Out = 0;
  5600    6B44     CLRF 0x44, BANKED
863:               	lastTransmission = 0;
  5602    6B46     CLRF 0x46, BANKED
  5604    6B47     CLRF 0x47, BANKED
864:               
865:                   //Initialize all of the debouncing variables
866:                   buttonCount = 0;
  5606    6BCC     CLRF 0xcc, BANKED
867:                   buttonPressed = FALSE;
  5608    6BCB     CLRF 0xcb, BANKED
868:               	stringPrinted = FALSE;
  560A    6BCA     CLRF 0xca, BANKED
869:               
870:               	mInitAllLEDs();
871:                   mInitAllSwitches();
872:               }//end UserInit
  560C    52E5     MOVF 0xfe5, F, ACCESS
  560E    52E5     MOVF 0xfe5, F, ACCESS
  5610    CFE7     MOVFF 0xfe7, 0xfd9
  5612    FFD9     NOP
  5614    0012     RETURN 0
873:               
874:               /******************************************************************************
875:                * Function:        void InitializeUSART(void)
876:                *
877:                * PreCondition:    None
878:                *
879:                * Input:           None
880:                *
881:                * Output:          None
882:                *
883:                * Side Effects:    None
884:                *
885:                * Overview:        This routine initializes the UART to 19200
886:                *
887:                * Note:            
888:                *
889:                *****************************************************************************/
890:               void InitializeUSART(void)
  5616    CFD9     MOVFF 0xfd9, 0xfe6
  5618    FFE6     NOP
  561A    CFE1     MOVFF 0xfe1, 0xfd9
  561C    FFD9     NOP
  561E    52E6     MOVF 0xfe6, F, ACCESS
891:               {
892:                   #if defined(__18CXX)
893:               	    unsigned char c;
894:                       #if defined(__18F14K50)
895:                   	    //ANSELHbits.ANS11 = 0;	// Make RB5 digital so USART can use pin for Rx
896:                           ANSELH = 0;
897:                           #ifndef BAUDCON
898:                               #define BAUDCON BAUDCTL
899:                           #endif
900:                       #endif
901:                       UART_TRISRx=1;			// RX
  5620    8E94     BSF 0xf94, 0x7, ACCESS
902:                       UART_TRISTx=0;			// TX
  5622    9C94     BCF 0xf94, 0x6, ACCESS
903:                       TXSTA = 0x24;       	// TX enable BRGH=1
  5624    0E24     MOVLW 0x24
  5626    6EAD     MOVWF 0xfad, ACCESS
904:                       RCSTA = 0x90;       	// Single Character RX
  5628    0E90     MOVLW 0x90
  562A    6EAC     MOVWF 0xfac, ACCESS
905:                       SPBRG = 0x71;
  562C    0E71     MOVLW 0x71
  562E    6EB0     MOVWF 0xfb0, ACCESS
906:                       SPBRGH = 0x02;      	// 0x0271 for 48MHz -> 19200 baud
  5630    0E02     MOVLW 0x2
  5632    6E7F     MOVWF 0xf7f, ACCESS
907:                  		PIE1bits.RC1IE = 1, IPR1bits.RC1IP = 0;	// RX enable low priority
  5634    8A9D     BSF 0xf9d, 0x5, ACCESS
  5636    9A9F     BCF 0xf9f, 0x5, ACCESS
908:               		INTCONbits.PEIE = 1;	// enable interrupt
  5638    8CF2     BSF 0xff2, 0x6, ACCESS
909:               // ABDOVF RCIDL RXDTP TXCKP BRG16 - WUE ABDEN
910:               //        BAUDCON = 0x08;     	// BRG16 = 1
911:                       BAUDCON = 0x38;     	// BRG16 = 1, TX and RX idle low
  563A    0E38     MOVLW 0x38
  563C    6E7E     MOVWF 0xf7e, ACCESS
912:                       c = RCREG;				// read 
  563E    50AF     MOVF 0xfaf, W, ACCESS
  5640    6EDF     MOVWF 0xfdf, ACCESS
913:                   #endif
914:               
915:                   #if defined(__C30__)
916:                       #if defined( __PIC24FJ256GB110__ ) || defined( PIC24FJ256GB210_PIM )
917:                           // PPS - Configure U2RX - put on pin 49 (RP10)
918:                           RPINR19bits.U2RXR = 10;
919:               
920:                           // PPS - Configure U2TX - put on pin 50 (RP17)
921:                           RPOR8bits.RP17R = 5;
922:                       #elif defined(__PIC24FJ64GB004__)
923:                           // PPS - Configure U2RX - put on RC3/pin 36 (RP19)
924:                           RPINR19bits.U2RXR = 19;
925:               
926:                           // PPS - Configure U2TX - put on RC9/pin 5 (RP25)
927:                           RPOR12bits.RP25R = 5;
928:                       #elif defined(__PIC24FJ256DA210__)
929:                           // PPS - Configure U2RX - put on RC14/pin 74 (RPI37)
930:                           RPINR19bits.U2RXR = 37;
931:                   
932:                           // PPS - Configure U2TX - put on RF3/pin 51 (RP16)
933:                           RPOR8bits.RP16R = 5;
934:               
935:                           TRISFbits.TRISF3 = 0;
936:                       #elif defined(__dsPIC33EP512MU810__)
937:                           // The dsPIC33EP512MU810 features Peripheral Pin
938:                           // select. The following statements map UART2 to 
939:                           // device pins which would connect to the the 
940:                           // RX232 transciever on the Explorer 16 board.
941:               
942:                            RPINR19 = 0;
943:                            RPINR19 = 0x64;
944:                            RPOR9bits.RP101R = 0x3;
945:               
946:                       #else
947:                           #error Verify that any required PPS is done here.
948:                       #endif
949:               
950:                       UART2Init();
951:                   #endif
952:               
953:                   #if defined(__C32__)
954:                       UART2Init();
955:                   #endif
956:               
957:               }//end InitializeUSART
  5642    52E5     MOVF 0xfe5, F, ACCESS
  5644    52E5     MOVF 0xfe5, F, ACCESS
  5646    CFE7     MOVFF 0xfe7, 0xfd9
  5648    FFD9     NOP
  564A    0012     RETURN 0
958:               
959:               /******************************************************************************
960:                * Function:        void putcUSART(char c)
961:                *
962:                * PreCondition:    None
963:                *
964:                * Input:           char c - character to print to the UART
965:                *
966:                * Output:          None
967:                *
968:                * Side Effects:    None
969:                *
970:                * Overview:        Print the input character to the UART
971:                *
972:                * Note:            
973:                *
974:                *****************************************************************************/
975:               void putcUSART(char c)  
  564C    CFD9     MOVFF 0xfd9, 0xfe6
  564E    FFE6     NOP
  5650    CFE1     MOVFF 0xfe1, 0xfd9
  5652    FFD9     NOP
976:               {
977:                   #if defined(__18CXX)
978:               	    TXREG = c;
  5654    0EFE     MOVLW 0xfe
  5656    50DB     MOVF 0xfdb, W, ACCESS
  5658    6EAE     MOVWF 0xfae, ACCESS
979:                   #else
980:                       UART2PutChar(c);
981:                   #endif
982:               }
  565A    52E5     MOVF 0xfe5, F, ACCESS
  565C    CFE7     MOVFF 0xfe7, 0xfd9
  565E    FFD9     NOP
  5660    0012     RETURN 0
983:               
984:               
985:               /******************************************************************************
986:                * Function:        void mySetLineCodingHandler(void)
987:                *
988:                * PreCondition:    USB_CDC_SET_LINE_CODING_HANDLER is defined
989:                *
990:                * Input:           None
991:                *
992:                * Output:          None
993:                *
994:                * Side Effects:    None
995:                *
996:                * Overview:        This function gets called when a SetLineCoding command
997:                *                  is sent on the bus.  This function will evaluate the request
998:                *                  and determine if the application should update the baudrate
999:                *                  or not.
1000:               *
1001:               * Note:            
1002:               *
1003:               *****************************************************************************/
1004:              #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
1005:              void mySetLineCodingHandler(void)
  5662    CFD9     MOVFF 0xfd9, 0xfe6
  5664    FFE6     NOP
  5666    CFE1     MOVFF 0xfe1, 0xfd9
  5668    FFD9     NOP
  566A    0E22     MOVLW 0x22
  566C    26E1     ADDWF 0xfe1, F, ACCESS
1006:              {
1007:                  //If the request is not in a valid range
1008:                  if(cdc_notice.GetLineCoding.dwDTERate.Val > 2000000)
  566E    80D8     BSF 0xfd8, 0, ACCESS
  5670    0E80     MOVLW 0x80
  5672    0105     MOVLB 0x5
  5674    5551     SUBFWB 0x51, W, BANKED
  5676    0E84     MOVLW 0x84
  5678    5552     SUBFWB 0x52, W, BANKED
  567A    0E1E     MOVLW 0x1e
  567C    5553     SUBFWB 0x53, W, BANKED
  567E    0E00     MOVLW 0
  5680    5554     SUBFWB 0x54, W, BANKED
  5682    E201     BC 0x5686
  5684    D24E     BRA 0x5b22
1009:                  {
1010:                      //NOTE: There are two ways that an unsupported baud rate could be
1011:                      //handled.  The first is just to ignore the request and don't change
1012:                      //the values.  That is what is currently implemented in this function.
1013:                      //The second possible method is to stall the STATUS stage of the request.
1014:                      //STALLing the STATUS stage will cause an exception to be thrown in the 
1015:                      //requesting application.  Some programs, like HyperTerminal, handle the
1016:                      //exception properly and give a pop-up box indicating that the request
1017:                      //settings are not valid.  Any application that does not handle the
1018:                      //exception correctly will likely crash when this requiest fails.  For
1019:                      //the sake of example the code required to STALL the status stage of the
1020:                      //request is provided below.  It has been left out so that this demo
1021:                      //does not cause applications without the required exception handling
1022:                      //to crash.
1023:                      //---------------------------------------
1024:                      //USBStallEndpoint(0,1);
1025:                  }
1026:                  else
1027:                  {
1028:                      DWORD_VAL dwBaud, dwBaud1, dwError, dwError1, dwRate, dwRate1;
1029:              		char cPercent[10];
1030:              
1031:                      //Update the baudrate info in the CDC driver
1032:                      CDCSetBaudRate(cdc_notice.GetLineCoding.dwDTERate.Val);
  5686    C551     MOVFF 0x551, 0x5d9
  5688    F5D9     NOP
  568A    C552     MOVFF 0x552, 0x5da
  568C    F5DA     NOP
  568E    C553     MOVFF 0x553, 0x5db
  5690    F5DB     NOP
  5692    C554     MOVFF 0x554, 0x5dc
  5694    F5DC     NOP
1033:                      
1034:                      //Update the baudrate of the UART
1035:                      #if defined(__18CXX)
1036:                          dwBaud.Val = (DWORD)(GetSystemClock()/4)/line_coding.dwDTERate.Val-1;
  5696    6A18     CLRF 0x18, ACCESS
  5698    0E1B     MOVLW 0x1b
  569A    6E19     MOVWF 0x19, ACCESS
  569C    0EB7     MOVLW 0xb7
  569E    6E1A     MOVWF 0x1a, ACCESS
  56A0    6A1B     CLRF 0x1b, ACCESS
  56A2    C018     MOVFF 0x18, 0x6
  56A4    F006     NOP
  56A6    C019     MOVFF 0x19, 0x7
  56A8    F007     NOP
  56AA    6E08     MOVWF 0x8, ACCESS
  56AC    C01B     MOVFF 0x1b, 0x9
  56AE    F009     NOP
  56B0    C5D9     MOVFF 0x5d9, 0xb
  56B2    F00B     NOP
  56B4    C5DA     MOVFF 0x5da, 0xc
  56B6    F00C     NOP
  56B8    C5DB     MOVFF 0x5db, 0xd
  56BA    F00D     NOP
  56BC    C5DC     MOVFF 0x5dc, 0xe
  56BE    F00E     NOP
  56C0    EC18     CALL 0x6630, 0
  56C2    F033     NOP
  56C4    C006     MOVFF 0x6, 0x14
  56C6    F014     NOP
  56C8    C007     MOVFF 0x7, 0x15
  56CA    F015     NOP
  56CC    C008     MOVFF 0x8, 0x16
  56CE    F016     NOP
  56D0    C009     MOVFF 0x9, 0x17
  56D2    F017     NOP
  56D4    0614     DECF 0x14, F, ACCESS
  56D6    0E00     MOVLW 0
  56D8    5A15     SUBWFB 0x15, F, ACCESS
  56DA    5A16     SUBWFB 0x16, F, ACCESS
  56DC    5A17     SUBWFB 0x17, F, ACCESS
  56DE    C014     MOVFF 0x14, 0xfdf
  56E0    FFDF     NOP
  56E2    0E01     MOVLW 0x1
  56E4    C015     MOVFF 0x15, 0xfdb
  56E6    FFDB     NOP
  56E8    0E02     MOVLW 0x2
  56EA    C016     MOVFF 0x16, 0xfdb
  56EC    FFDB     NOP
  56EE    0E03     MOVLW 0x3
  56F0    C017     MOVFF 0x17, 0xfdb
  56F2    FFDB     NOP
1037:              			dwRate.Val = ((DWORD)(GetSystemClock()/4)/(dwBaud.Val+1));
  56F4    0E01     MOVLW 0x1
  56F6    6E18     MOVWF 0x18, ACCESS
  56F8    6A19     CLRF 0x19, ACCESS
  56FA    6A1A     CLRF 0x1a, ACCESS
  56FC    6A1B     CLRF 0x1b, ACCESS
  56FE    CFD9     MOVFF 0xfd9, 0xfe9
  5700    FFE9     NOP
  5702    CFDA     MOVFF 0xfda, 0xfea
  5704    FFEA     NOP
  5706    50EE     MOVF 0xfee, W, ACCESS
  5708    2618     ADDWF 0x18, F, ACCESS
  570A    50EE     MOVF 0xfee, W, ACCESS
  570C    2219     ADDWFC 0x19, F, ACCESS
  570E    50EE     MOVF 0xfee, W, ACCESS
  5710    221A     ADDWFC 0x1a, F, ACCESS
  5712    50EE     MOVF 0xfee, W, ACCESS
  5714    221B     ADDWFC 0x1b, F, ACCESS
  5716    6A14     CLRF 0x14, ACCESS
  5718    0E1B     MOVLW 0x1b
  571A    6E15     MOVWF 0x15, ACCESS
  571C    0EB7     MOVLW 0xb7
  571E    6E16     MOVWF 0x16, ACCESS
  5720    6A17     CLRF 0x17, ACCESS
  5722    C014     MOVFF 0x14, 0x6
  5724    F006     NOP
  5726    C015     MOVFF 0x15, 0x7
  5728    F007     NOP
  572A    6E08     MOVWF 0x8, ACCESS
  572C    C017     MOVFF 0x17, 0x9
  572E    F009     NOP
  5730    C018     MOVFF 0x18, 0xb
  5732    F00B     NOP
  5734    C019     MOVFF 0x19, 0xc
  5736    F00C     NOP
  5738    C01A     MOVFF 0x1a, 0xd
  573A    F00D     NOP
  573C    C01B     MOVFF 0x1b, 0xe
  573E    F00E     NOP
  5740    EC18     CALL 0x6630, 0
  5742    F033     NOP
  5744    0E10     MOVLW 0x10
  5746    C006     MOVFF 0x6, 0xfdb
  5748    FFDB     NOP
  574A    0E11     MOVLW 0x11
  574C    C007     MOVFF 0x7, 0xfdb
  574E    FFDB     NOP
  5750    0E12     MOVLW 0x12
  5752    C008     MOVFF 0x8, 0xfdb
  5754    FFDB     NOP
  5756    0E13     MOVLW 0x13
  5758    C009     MOVFF 0x9, 0xfdb
  575A    FFDB     NOP
1038:              			dwError.Val = dwRate.Val - line_coding.dwDTERate.Val;
  575C    50D9     MOVF 0xfd9, W, ACCESS
  575E    0F10     ADDLW 0x10
  5760    6EE9     MOVWF 0xfe9, ACCESS
  5762    CFDA     MOVFF 0xfda, 0xfea
  5764    FFEA     NOP
  5766    0105     MOVLB 0x5
  5768    51D9     MOVF 0xd9, W, BANKED
  576A    5CEE     SUBWF 0xfee, W, ACCESS
  576C    6E14     MOVWF 0x14, ACCESS
  576E    51DA     MOVF 0xda, W, BANKED
  5770    58EE     SUBWFB 0xfee, W, ACCESS
  5772    6E15     MOVWF 0x15, ACCESS
  5774    51DB     MOVF 0xdb, W, BANKED
  5776    58EE     SUBWFB 0xfee, W, ACCESS
  5778    6E16     MOVWF 0x16, ACCESS
  577A    51DC     MOVF 0xdc, W, BANKED
  577C    58EE     SUBWFB 0xfee, W, ACCESS
  577E    6E17     MOVWF 0x17, ACCESS
  5780    0E08     MOVLW 0x8
  5782    C014     MOVFF 0x14, 0xfdb
  5784    FFDB     NOP
  5786    0E09     MOVLW 0x9
  5788    C015     MOVFF 0x15, 0xfdb
  578A    FFDB     NOP
  578C    0E0A     MOVLW 0xa
  578E    C016     MOVFF 0x16, 0xfdb
  5790    FFDB     NOP
  5792    0E0B     MOVLW 0xb
  5794    C017     MOVFF 0x17, 0xfdb
  5796    FFDB     NOP
1039:              			dwBaud1.Val = ((DWORD)(GetSystemClock()/4)/line_coding.dwDTERate.Val);	// pick next larger to slow more
  5798    6A14     CLRF 0x14, ACCESS
  579A    0E1B     MOVLW 0x1b
  579C    6E15     MOVWF 0x15, ACCESS
  579E    0EB7     MOVLW 0xb7
  57A0    6E16     MOVWF 0x16, ACCESS
  57A2    6A17     CLRF 0x17, ACCESS
  57A4    C014     MOVFF 0x14, 0x6
  57A6    F006     NOP
  57A8    C015     MOVFF 0x15, 0x7
  57AA    F007     NOP
  57AC    6E08     MOVWF 0x8, ACCESS
  57AE    C017     MOVFF 0x17, 0x9
  57B0    F009     NOP
  57B2    C5D9     MOVFF 0x5d9, 0xb
  57B4    F00B     NOP
  57B6    C5DA     MOVFF 0x5da, 0xc
  57B8    F00C     NOP
  57BA    C5DB     MOVFF 0x5db, 0xd
  57BC    F00D     NOP
  57BE    C5DC     MOVFF 0x5dc, 0xe
  57C0    F00E     NOP
  57C2    EC18     CALL 0x6630, 0
  57C4    F033     NOP
  57C6    0E04     MOVLW 0x4
  57C8    C006     MOVFF 0x6, 0xfdb
  57CA    FFDB     NOP
  57CC    0E05     MOVLW 0x5
  57CE    C007     MOVFF 0x7, 0xfdb
  57D0    FFDB     NOP
  57D2    0E06     MOVLW 0x6
  57D4    C008     MOVFF 0x8, 0xfdb
  57D6    FFDB     NOP
  57D8    0E07     MOVLW 0x7
  57DA    C009     MOVFF 0x9, 0xfdb
  57DC    FFDB     NOP
1040:              			dwRate1.Val = ((DWORD)(GetSystemClock()/4)/(dwBaud1.Val+1));
  57DE    0E01     MOVLW 0x1
  57E0    6E18     MOVWF 0x18, ACCESS
  57E2    6A19     CLRF 0x19, ACCESS
  57E4    6A1A     CLRF 0x1a, ACCESS
  57E6    6A1B     CLRF 0x1b, ACCESS
  57E8    50D9     MOVF 0xfd9, W, ACCESS
  57EA    0F04     ADDLW 0x4
  57EC    6EE9     MOVWF 0xfe9, ACCESS
  57EE    CFDA     MOVFF 0xfda, 0xfea
  57F0    FFEA     NOP
  57F2    50EE     MOVF 0xfee, W, ACCESS
  57F4    2618     ADDWF 0x18, F, ACCESS
  57F6    50EE     MOVF 0xfee, W, ACCESS
  57F8    2219     ADDWFC 0x19, F, ACCESS
  57FA    50EE     MOVF 0xfee, W, ACCESS
  57FC    221A     ADDWFC 0x1a, F, ACCESS
  57FE    50EE     MOVF 0xfee, W, ACCESS
  5800    221B     ADDWFC 0x1b, F, ACCESS
  5802    6A14     CLRF 0x14, ACCESS
  5804    0E1B     MOVLW 0x1b
  5806    6E15     MOVWF 0x15, ACCESS
  5808    0EB7     MOVLW 0xb7
  580A    6E16     MOVWF 0x16, ACCESS
  580C    6A17     CLRF 0x17, ACCESS
  580E    C014     MOVFF 0x14, 0x6
  5810    F006     NOP
  5812    C015     MOVFF 0x15, 0x7
  5814    F007     NOP
  5816    6E08     MOVWF 0x8, ACCESS
  5818    C017     MOVFF 0x17, 0x9
  581A    F009     NOP
  581C    C018     MOVFF 0x18, 0xb
  581E    F00B     NOP
  5820    C019     MOVFF 0x19, 0xc
  5822    F00C     NOP
  5824    C01A     MOVFF 0x1a, 0xd
  5826    F00D     NOP
  5828    C01B     MOVFF 0x1b, 0xe
  582A    F00E     NOP
  582C    EC18     CALL 0x6630, 0
  582E    F033     NOP
  5830    0E14     MOVLW 0x14
  5832    C006     MOVFF 0x6, 0xfdb
  5834    FFDB     NOP
  5836    0E15     MOVLW 0x15
  5838    C007     MOVFF 0x7, 0xfdb
  583A    FFDB     NOP
  583C    0E16     MOVLW 0x16
  583E    C008     MOVFF 0x8, 0xfdb
  5840    FFDB     NOP
  5842    0E17     MOVLW 0x17
  5844    C009     MOVFF 0x9, 0xfdb
  5846    FFDB     NOP
1041:              			dwError1.Val = line_coding.dwDTERate.Val - dwRate1.Val;		// make both positive
  5848    50D9     MOVF 0xfd9, W, ACCESS
  584A    0F14     ADDLW 0x14
  584C    6EE9     MOVWF 0xfe9, ACCESS
  584E    CFDA     MOVFF 0xfda, 0xfea
  5850    FFEA     NOP
  5852    50EE     MOVF 0xfee, W, ACCESS
  5854    0105     MOVLB 0x5
  5856    5DD9     SUBWF 0xd9, W, BANKED
  5858    6E14     MOVWF 0x14, ACCESS
  585A    50EE     MOVF 0xfee, W, ACCESS
  585C    59DA     SUBWFB 0xda, W, BANKED
  585E    6E15     MOVWF 0x15, ACCESS
  5860    50EE     MOVF 0xfee, W, ACCESS
  5862    59DB     SUBWFB 0xdb, W, BANKED
  5864    6E16     MOVWF 0x16, ACCESS
  5866    50EE     MOVF 0xfee, W, ACCESS
  5868    59DC     SUBWFB 0xdc, W, BANKED
  586A    6E17     MOVWF 0x17, ACCESS
  586C    0E0C     MOVLW 0xc
  586E    C014     MOVFF 0x14, 0xfdb
  5870    FFDB     NOP
  5872    0E0D     MOVLW 0xd
  5874    C015     MOVFF 0x15, 0xfdb
  5876    FFDB     NOP
  5878    0E0E     MOVLW 0xe
  587A    C016     MOVFF 0x16, 0xfdb
  587C    FFDB     NOP
  587E    0E0F     MOVLW 0xf
  5880    C017     MOVFF 0x17, 0xfdb
  5882    FFDB     NOP
1042:              			if ( dwError.Val > dwError1.Val )	// if error > error1 then use rate1
  5884    0E0C     MOVLW 0xc
  5886    CFDB     MOVFF 0xfdb, 0x14
  5888    F014     NOP
  588A    0E0D     MOVLW 0xd
  588C    CFDB     MOVFF 0xfdb, 0x15
  588E    F015     NOP
  5890    0E0E     MOVLW 0xe
  5892    CFDB     MOVFF 0xfdb, 0x16
  5894    F016     NOP
  5896    0E0F     MOVLW 0xf
  5898    CFDB     MOVFF 0xfdb, 0x17
  589A    F017     NOP
  589C    50D9     MOVF 0xfd9, W, ACCESS
  589E    0F08     ADDLW 0x8
  58A0    6EE9     MOVWF 0xfe9, ACCESS
  58A2    CFDA     MOVFF 0xfda, 0xfea
  58A4    FFEA     NOP
  58A6    50EE     MOVF 0xfee, W, ACCESS
  58A8    5C14     SUBWF 0x14, W, ACCESS
  58AA    50EE     MOVF 0xfee, W, ACCESS
  58AC    5815     SUBWFB 0x15, W, ACCESS
  58AE    50EE     MOVF 0xfee, W, ACCESS
  58B0    5816     SUBWFB 0x16, W, ACCESS
  58B2    50EE     MOVF 0xfee, W, ACCESS
  58B4    5817     SUBWFB 0x17, W, ACCESS
  58B6    E236     BC 0x5924
1043:              			{
1044:              	            dwBaud.Val = dwBaud1.Val;
  58B8    CFD9     MOVFF 0xfd9, 0xfe9
  58BA    FFE9     NOP
  58BC    CFDA     MOVFF 0xfda, 0xfea
  58BE    FFEA     NOP
  58C0    0E04     MOVLW 0x4
  58C2    CFDB     MOVFF 0xfdb, 0xfee
  58C4    FFEE     NOP
  58C6    0E05     MOVLW 0x5
  58C8    CFDB     MOVFF 0xfdb, 0xfee
  58CA    FFEE     NOP
  58CC    0E06     MOVLW 0x6
  58CE    CFDB     MOVFF 0xfdb, 0xfee
  58D0    FFEE     NOP
  58D2    0E07     MOVLW 0x7
  58D4    CFDB     MOVFF 0xfdb, 0xfee
  58D6    FFEE     NOP
1045:              				dwRate.Val = dwRate1.Val;
  58D8    50D9     MOVF 0xfd9, W, ACCESS
  58DA    0F14     ADDLW 0x14
  58DC    6EE9     MOVWF 0xfe9, ACCESS
  58DE    CFDA     MOVFF 0xfda, 0xfea
  58E0    FFEA     NOP
  58E2    0E10     MOVLW 0x10
  58E4    CFEE     MOVFF 0xfee, 0xfdb
  58E6    FFDB     NOP
  58E8    0E11     MOVLW 0x11
  58EA    CFEE     MOVFF 0xfee, 0xfdb
  58EC    FFDB     NOP
  58EE    0E12     MOVLW 0x12
  58F0    CFEE     MOVFF 0xfee, 0xfdb
  58F2    FFDB     NOP
  58F4    0E13     MOVLW 0x13
  58F6    CFEE     MOVFF 0xfee, 0xfdb
  58F8    FFDB     NOP
1046:              				dwError.Val = dwError1.Val;
  58FA    50D9     MOVF 0xfd9, W, ACCESS
  58FC    0F0C     ADDLW 0xc
  58FE    6EE9     MOVWF 0xfe9, ACCESS
  5900    CFDA     MOVFF 0xfda, 0xfea
  5902    FFEA     NOP
  5904    0E08     MOVLW 0x8
  5906    CFEE     MOVFF 0xfee, 0xfdb
  5908    FFDB     NOP
  590A    0E09     MOVLW 0x9
  590C    CFEE     MOVFF 0xfee, 0xfdb
  590E    FFDB     NOP
  5910    0E0A     MOVLW 0xa
  5912    CFEE     MOVFF 0xfee, 0xfdb
  5914    FFDB     NOP
  5916    0E0B     MOVLW 0xb
  5918    CFEE     MOVFF 0xfee, 0xfdb
  591A    FFDB     NOP
1047:              				cPercent[9] = '-';
  591C    0E2D     MOVLW 0x2d
  591E    6EF3     MOVWF 0xff3, ACCESS
  5920    0E21     MOVLW 0x21
1048:              			} else cPercent[0] = ' ';
  5922    D003     BRA 0x592a
  5924    0E20     MOVLW 0x20
  5926    6EF3     MOVWF 0xff3, ACCESS
  5928    0E18     MOVLW 0x18
  592A    CFF3     MOVFF 0xff3, 0xfdb
  592C    FFDB     NOP
1049:                          SPBRG = dwBaud.v[0];
  592E    50DF     MOVF 0xfdf, W, ACCESS
  5930    6EB0     MOVWF 0xfb0, ACCESS
1050:                          SPBRGH = dwBaud.v[1];
  5932    0E01     MOVLW 0x1
  5934    50DB     MOVF 0xfdb, W, ACCESS
  5936    6E7F     MOVWF 0xf7f, ACCESS
1051:              #if defined(__DEBUG)
1052:              			if ( !iPrintBufFull )
  5938    0101     MOVLB 0x1
  593A    5141     MOVF 0x41, W, BANKED
  593C    1142     IORWF 0x42, W, BANKED
  593E    E001     BZ 0x5942
  5940    D0F0     BRA 0x5b22
1053:              			{	
1054:              				dwError.Val *= 10000; // for %
  5942    50D9     MOVF 0xfd9, W, ACCESS
  5944    0F08     ADDLW 0x8
  5946    6EE9     MOVWF 0xfe9, ACCESS
  5948    CFDA     MOVFF 0xfda, 0xfea
  594A    FFEA     NOP
  594C    0E10     MOVLW 0x10
  594E    6E0B     MOVWF 0xb, ACCESS
  5950    0E27     MOVLW 0x27
  5952    6E0C     MOVWF 0xc, ACCESS
  5954    6A0D     CLRF 0xd, ACCESS
  5956    6A0E     CLRF 0xe, ACCESS
  5958    CFEE     MOVFF 0xfee, 0x6
  595A    F006     NOP
  595C    CFEE     MOVFF 0xfee, 0x7
  595E    F007     NOP
  5960    CFEE     MOVFF 0xfee, 0x8
  5962    F008     NOP
  5964    CFEF     MOVFF 0xfef, 0x9
  5966    F009     NOP
  5968    ECBC     CALL 0x6578, 0
  596A    F032     NOP
  596C    C005     MOVFF 0x5, 0xfed
  596E    FFED     NOP
  5970    C004     MOVFF 0x4, 0xfed
  5972    FFED     NOP
  5974    C003     MOVFF 0x3, 0xfed
  5976    FFED     NOP
  5978    C002     MOVFF 0x2, 0xfef
  597A    FFEF     NOP
1055:              				dwError.Val /= line_coding.dwDTERate.Val; // for %
  597C    50D9     MOVF 0xfd9, W, ACCESS
  597E    0F08     ADDLW 0x8
  5980    6EE9     MOVWF 0xfe9, ACCESS
  5982    CFDA     MOVFF 0xfda, 0xfea
  5984    FFEA     NOP
  5986    C5D9     MOVFF 0x5d9, 0xb
  5988    F00B     NOP
  598A    C5DA     MOVFF 0x5da, 0xc
  598C    F00C     NOP
  598E    C5DB     MOVFF 0x5db, 0xd
  5990    F00D     NOP
  5992    C5DC     MOVFF 0x5dc, 0xe
  5994    F00E     NOP
  5996    CFEE     MOVFF 0xfee, 0x6
  5998    F006     NOP
  599A    CFEE     MOVFF 0xfee, 0x7
  599C    F007     NOP
  599E    CFEE     MOVFF 0xfee, 0x8
  59A0    F008     NOP
  59A2    CFEF     MOVFF 0xfef, 0x9
  59A4    F009     NOP
  59A6    EC18     CALL 0x6630, 0
  59A8    F033     NOP
  59AA    C009     MOVFF 0x9, 0xfed
  59AC    FFED     NOP
  59AE    C008     MOVFF 0x8, 0xfed
  59B0    FFED     NOP
  59B2    C007     MOVFF 0x7, 0xfed
  59B4    FFED     NOP
  59B6    C006     MOVFF 0x6, 0xfef
  59B8    FFEF     NOP
1056:              				sprintf( &cPercent[0], "%04ld", dwError.Val );
  59BA    50D9     MOVF 0xfd9, W, ACCESS
  59BC    0F08     ADDLW 0x8
  59BE    6EE9     MOVWF 0xfe9, ACCESS
  59C0    CFDA     MOVFF 0xfda, 0xfea
  59C2    FFEA     NOP
  59C4    CFEE     MOVFF 0xfee, 0xfe6
  59C6    FFE6     NOP
  59C8    CFEE     MOVFF 0xfee, 0xfe6
  59CA    FFE6     NOP
  59CC    CFEE     MOVFF 0xfee, 0xfe6
  59CE    FFE6     NOP
  59D0    CFEF     MOVFF 0xfef, 0xfe6
  59D2    FFE6     NOP
  59D4    0EAD     MOVLW 0xad
  59D6    6EE6     MOVWF 0xfe6, ACCESS
  59D8    0E66     MOVLW 0x66
  59DA    6EE6     MOVWF 0xfe6, ACCESS
  59DC    0E00     MOVLW 0
  59DE    6EE6     MOVWF 0xfe6, ACCESS
  59E0    50D9     MOVF 0xfd9, W, ACCESS
  59E2    0F18     ADDLW 0x18
  59E4    6EE6     MOVWF 0xfe6, ACCESS
  59E6    0E00     MOVLW 0
  59E8    20DA     ADDWFC 0xfda, W, ACCESS
  59EA    6EE6     MOVWF 0xfe6, ACCESS
  59EC    ECD5     CALL 0x63aa, 0
  59EE    F031     NOP
  59F0    6E14     MOVWF 0x14, ACCESS
  59F2    0E09     MOVLW 0x9
  59F4    5EE1     SUBWF 0xfe1, F, ACCESS
  59F6    5014     MOVF 0x14, W, ACCESS
1057:              				cPercent[4] = cPercent[3], cPercent[3] = cPercent[2], cPercent[2] = '.', cPercent[5] = 0;
  59F8    0E1B     MOVLW 0x1b
  59FA    50DB     MOVF 0xfdb, W, ACCESS
  59FC    6EE7     MOVWF 0xfe7, ACCESS
  59FE    0E1C     MOVLW 0x1c
  5A00    CFE7     MOVFF 0xfe7, 0xfdb
  5A02    FFDB     NOP
  5A04    0E1A     MOVLW 0x1a
  5A06    50DB     MOVF 0xfdb, W, ACCESS
  5A08    6EE7     MOVWF 0xfe7, ACCESS
  5A0A    0E1B     MOVLW 0x1b
  5A0C    CFE7     MOVFF 0xfe7, 0xfdb
  5A0E    FFDB     NOP
  5A10    0E2E     MOVLW 0x2e
  5A12    6EF3     MOVWF 0xff3, ACCESS
  5A14    0E1A     MOVLW 0x1a
  5A16    CFF3     MOVFF 0xff3, 0xfdb
  5A18    FFDB     NOP
  5A1A    0E1D     MOVLW 0x1d
  5A1C    6ADB     CLRF 0xfdb, ACCESS
1058:              				if ( cPercent[0] == '0' )
  5A1E    0E18     MOVLW 0x18
  5A20    50DB     MOVF 0xfdb, W, ACCESS
  5A22    0830     SUBLW 0x30
  5A24    E11A     BNZ 0x5a5a
1059:              				{	cPercent[0] = cPercent[1], cPercent[1] = cPercent[2];
  5A26    0E19     MOVLW 0x19
  5A28    50DB     MOVF 0xfdb, W, ACCESS
  5A2A    6EE7     MOVWF 0xfe7, ACCESS
  5A2C    0E18     MOVLW 0x18
  5A2E    CFE7     MOVFF 0xfe7, 0xfdb
  5A30    FFDB     NOP
  5A32    0E1A     MOVLW 0x1a
  5A34    50DB     MOVF 0xfdb, W, ACCESS
  5A36    6EE7     MOVWF 0xfe7, ACCESS
  5A38    0E19     MOVLW 0x19
  5A3A    CFE7     MOVFF 0xfe7, 0xfdb
  5A3C    FFDB     NOP
1060:              					cPercent[2] = cPercent[3], cPercent[3] = cPercent[4], cPercent[4] = 0;
  5A3E    0E1B     MOVLW 0x1b
  5A40    50DB     MOVF 0xfdb, W, ACCESS
  5A42    6EE7     MOVWF 0xfe7, ACCESS
  5A44    0E1A     MOVLW 0x1a
  5A46    CFE7     MOVFF 0xfe7, 0xfdb
  5A48    FFDB     NOP
  5A4A    0E1C     MOVLW 0x1c
  5A4C    50DB     MOVF 0xfdb, W, ACCESS
  5A4E    6EE7     MOVWF 0xfe7, ACCESS
  5A50    0E1B     MOVLW 0x1b
  5A52    CFE7     MOVFF 0xfe7, 0xfdb
  5A54    FFDB     NOP
  5A56    0E1C     MOVLW 0x1c
  5A58    6ADB     CLRF 0xfdb, ACCESS
1061:              				};
1062:              				if ( cPercent[9] == '-' )
  5A5A    0E21     MOVLW 0x21
  5A5C    50DB     MOVF 0xfdb, W, ACCESS
  5A5E    082D     SUBLW 0x2d
  5A60    E125     BNZ 0x5aac
1063:              				{	cPercent[5] = cPercent[4], cPercent[4] = cPercent[3], cPercent[3] = cPercent[2];
  5A62    0E1C     MOVLW 0x1c
  5A64    50DB     MOVF 0xfdb, W, ACCESS
  5A66    6EE7     MOVWF 0xfe7, ACCESS
  5A68    0E1D     MOVLW 0x1d
  5A6A    CFE7     MOVFF 0xfe7, 0xfdb
  5A6C    FFDB     NOP
  5A6E    0E1B     MOVLW 0x1b
  5A70    50DB     MOVF 0xfdb, W, ACCESS
  5A72    6EE7     MOVWF 0xfe7, ACCESS
  5A74    0E1C     MOVLW 0x1c
  5A76    CFE7     MOVFF 0xfe7, 0xfdb
  5A78    FFDB     NOP
  5A7A    0E1A     MOVLW 0x1a
  5A7C    50DB     MOVF 0xfdb, W, ACCESS
  5A7E    6EE7     MOVWF 0xfe7, ACCESS
  5A80    0E1B     MOVLW 0x1b
  5A82    CFE7     MOVFF 0xfe7, 0xfdb
  5A84    FFDB     NOP
1064:              					cPercent[2] = cPercent[1], cPercent[1] = cPercent[0];
  5A86    0E19     MOVLW 0x19
  5A88    50DB     MOVF 0xfdb, W, ACCESS
  5A8A    6EE7     MOVWF 0xfe7, ACCESS
  5A8C    0E1A     MOVLW 0x1a
  5A8E    CFE7     MOVFF 0xfe7, 0xfdb
  5A90    FFDB     NOP
  5A92    0E18     MOVLW 0x18
  5A94    50DB     MOVF 0xfdb, W, ACCESS
  5A96    6EE7     MOVWF 0xfe7, ACCESS
  5A98    0E19     MOVLW 0x19
  5A9A    CFE7     MOVFF 0xfe7, 0xfdb
  5A9C    FFDB     NOP
1065:              					cPercent[0] = '-', cPercent[6] = 0;
  5A9E    0E2D     MOVLW 0x2d
  5AA0    6EF3     MOVWF 0xff3, ACCESS
  5AA2    0E18     MOVLW 0x18
  5AA4    CFF3     MOVFF 0xff3, 0xfdb
  5AA6    FFDB     NOP
  5AA8    0E1E     MOVLW 0x1e
  5AAA    6ADB     CLRF 0xfdb, ACCESS
1066:              				};
1067:              				iPrintBufFull = sprintf( &cPrintBuf[0], "\r\nRequest %ld, divisor %ld = %ld baud, %s%% error.\r\n", 
  5AFA    0E78     MOVLW 0x78
  5AFC    6EE6     MOVWF 0xfe6, ACCESS
  5AFE    0E66     MOVLW 0x66
  5B00    6EE6     MOVWF 0xfe6, ACCESS
  5B02    0E00     MOVLW 0
  5B04    6EE6     MOVWF 0xfe6, ACCESS
  5B06    0E11     MOVLW 0x11
  5B08    6EE6     MOVWF 0xfe6, ACCESS
  5B0A    0E05     MOVLW 0x5
  5B0C    6EE6     MOVWF 0xfe6, ACCESS
1068:              					line_coding.dwDTERate.Val, dwBaud.Val, dwRate.Val, &cPercent[0] );
  5AAC    50D9     MOVF 0xfd9, W, ACCESS
  5AAE    0F18     ADDLW 0x18
  5AB0    6EE6     MOVWF 0xfe6, ACCESS
  5AB2    0E00     MOVLW 0
  5AB4    20DA     ADDWFC 0xfda, W, ACCESS
  5AB6    6EE6     MOVWF 0xfe6, ACCESS
  5AB8    50D9     MOVF 0xfd9, W, ACCESS
  5ABA    0F10     ADDLW 0x10
  5ABC    6EE9     MOVWF 0xfe9, ACCESS
  5ABE    CFDA     MOVFF 0xfda, 0xfea
  5AC0    FFEA     NOP
  5AC2    CFEE     MOVFF 0xfee, 0xfe6
  5AC4    FFE6     NOP
  5AC6    CFEE     MOVFF 0xfee, 0xfe6
  5AC8    FFE6     NOP
  5ACA    CFEE     MOVFF 0xfee, 0xfe6
  5ACC    FFE6     NOP
  5ACE    CFEF     MOVFF 0xfef, 0xfe6
  5AD0    FFE6     NOP
  5AD2    CFD9     MOVFF 0xfd9, 0xfe9
  5AD4    FFE9     NOP
  5AD6    CFDA     MOVFF 0xfda, 0xfea
  5AD8    FFEA     NOP
  5ADA    CFEE     MOVFF 0xfee, 0xfe6
  5ADC    FFE6     NOP
  5ADE    CFEE     MOVFF 0xfee, 0xfe6
  5AE0    FFE6     NOP
  5AE2    CFEE     MOVFF 0xfee, 0xfe6
  5AE4    FFE6     NOP
  5AE6    CFEF     MOVFF 0xfef, 0xfe6
  5AE8    FFE6     NOP
  5AEA    C5D9     MOVFF 0x5d9, 0xfe6
  5AEC    FFE6     NOP
  5AEE    C5DA     MOVFF 0x5da, 0xfe6
  5AF0    FFE6     NOP
  5AF2    C5DB     MOVFF 0x5db, 0xfe6
  5AF4    FFE6     NOP
  5AF6    C5DC     MOVFF 0x5dc, 0xfe6
  5AF8    FFE6     NOP
  5B0E    ECD5     CALL 0x63aa, 0
  5B10    F031     NOP
  5B12    6E14     MOVWF 0x14, ACCESS
  5B14    0E13     MOVLW 0x13
  5B16    5EE1     SUBWF 0xfe1, F, ACCESS
  5B18    5014     MOVF 0x14, W, ACCESS
  5B1A    CFF3     MOVFF 0xff3, 0x141
  5B1C    F141     NOP
  5B1E    CFF4     MOVFF 0xff4, 0x142
  5B20    F142     NOP
1069:              			};
1070:              #endif
1071:                      #elif defined(__C30__)
1072:                          #if defined(__dsPIC33EP512MU810__)
1073:                          dwBaud.Val = ((GetPeripheralClock()+(BRG_DIV2/2*line_coding.dwDTERate.Val))/BRG_DIV2/line_coding.dwDTERate.Val-1);
1074:                          #else
1075:                          dwBaud.Val = (((GetPeripheralClock()/2)+(BRG_DIV2/2*line_coding.dwDTERate.Val))/BRG_DIV2/line_coding.dwDTERate.Val-1);
1076:                          #endif
1077:                          U2BRG = dwBaud.Val;
1078:                      #elif defined(__C32__)
1079:                          U2BRG = ((GetPeripheralClock()+(BRG_DIV2/2*line_coding.dwDTERate.Val))/BRG_DIV2/line_coding.dwDTERate.Val-1);
1080:                          //U2MODE = 0;
1081:                          U2MODEbits.BRGH = BRGH2;
1082:                          //U2STA = 0;
1083:                      #endif
1084:                  }
1085:              }
  5B22    0E22     MOVLW 0x22
  5B24    5CE1     SUBWF 0xfe1, W, ACCESS
  5B26    E202     BC 0x5b2c
  5B28    6AE1     CLRF 0xfe1, ACCESS
  5B2A    52E5     MOVF 0xfe5, F, ACCESS
  5B2C    6EE1     MOVWF 0xfe1, ACCESS
  5B2E    52E5     MOVF 0xfe5, F, ACCESS
  5B30    CFE7     MOVFF 0xfe7, 0xfd9
  5B32    FFD9     NOP
  5B34    0012     RETURN 0
1086:              #endif
1087:              
1088:              /******************************************************************************
1089:               * Function:        unsigned char getcUSART ()
1090:               *
1091:               * PreCondition:    None
1092:               *
1093:               * Input:           None
1094:               *
1095:               * Output:          unsigned char c - character received on the UART
1096:               *
1097:               * Side Effects:    None
1098:               *
1099:               * Overview:        get a character from the UART
1100:               *
1101:               * Note:            
1102:               *
1103:               *****************************************************************************/
1104:              unsigned char getcUSART ()
  5B36    CFD9     MOVFF 0xfd9, 0xfe6
  5B38    FFE6     NOP
  5B3A    CFE1     MOVFF 0xfe1, 0xfd9
  5B3C    FFD9     NOP
  5B3E    52E6     MOVF 0xfe6, F, ACCESS
1105:              {
1106:              	char  c;
1107:              
1108:                  #if defined(__18CXX)
1109:              
1110:              	if (RCSTAbits.OERR)  // in case of overrun error
  5B40    A2AC     BTFSS 0xfac, 0x1, ACCESS
  5B42    D005     BRA 0x5b4e
1111:              	{                    // we should never see an overrun error, but if we do, 
1112:              		RCSTAbits.CREN = 0;  // reset the port
  5B44    98AC     BCF 0xfac, 0x4, ACCESS
1113:              		c = RCREG;
  5B46    50AF     MOVF 0xfaf, W, ACCESS
  5B48    6EDF     MOVWF 0xfdf, ACCESS
1114:              		RCSTAbits.CREN = 1;  // and keep going.
  5B4A    88AC     BSF 0xfac, 0x4, ACCESS
1115:              	}
1116:              	else
  5B4C    D002     BRA 0x5b52
1117:              		c = RCREG;
  5B4E    50AF     MOVF 0xfaf, W, ACCESS
  5B50    6EDF     MOVWF 0xfdf, ACCESS
1118:              // not necessary.  EUSART auto clears the flag when RCREG is cleared
1119:              //	PIR1bits.RCIF = 0;    // clear Flag
1120:              
1121:                  #endif
1122:              
1123:                  #if defined(__C30__) || defined(__C32__)
1124:                      c = UART2GetChar();
1125:                  #endif
1126:              
1127:              	return c;
  5B52    50DF     MOVF 0xfdf, W, ACCESS
1128:              }
  5B54    52E5     MOVF 0xfe5, F, ACCESS
  5B56    52E5     MOVF 0xfe5, F, ACCESS
  5B58    CFE7     MOVFF 0xfe7, 0xfd9
  5B5A    FFD9     NOP
  5B5C    0012     RETURN 0
1129:              
1130:              /********************************************************************
1131:               * Function:        void BlinkUSBStatus(void)
1132:               *
1133:               * PreCondition:    None
1134:               *
1135:               * Input:           None
1136:               *
1137:               * Output:          None
1138:               *
1139:               * Side Effects:    None
1140:               *
1141:               * Overview:        BlinkUSBStatus turns on and off LEDs 
1142:               *                  corresponding to the USB device state.
1143:               *
1144:               * Note:            mLED macros can be found in HardwareProfile.h
1145:               *                  USBDeviceState is declared and updated in
1146:               *                  usb_device.c.
1147:               *******************************************************************/
1148:              void BlinkUSBStatus(void)
1149:              {
1150:              #if !defined(HARDWARE_PROFILE_CUSTOM_PIM_H)
1151:                  static WORD led_count=0;
1152:                  
1153:                  if(led_count == 0)led_count = 10000U;
1154:                  led_count--;
1155:              
1156:                  #define mLED_Both_Off()         {mLED_1_Off();mLED_2_Off();}
1157:                  #define mLED_Both_On()          {mLED_1_On();mLED_2_On();}
1158:                  #define mLED_Only_1_On()        {mLED_1_On();mLED_2_Off();}
1159:                  #define mLED_Only_2_On()        {mLED_1_Off();mLED_2_On();}
1160:              
1161:                  if(USBSuspendControl == 1)
1162:                  {
1163:                      if(led_count==0)
1164:                      {
1165:                          mLED_1_Toggle();
1166:                          if(mGetLED_1())
1167:                          {
1168:                              mLED_2_On();
1169:                          }
1170:                          else
1171:                          {
1172:                              mLED_2_Off();
1173:                          }
1174:                      }//end if
1175:                  }
1176:                  else
1177:                  {
1178:                      if(USBDeviceState == DETACHED_STATE)
1179:                      {
1180:                          mLED_Both_Off();
1181:                      }
1182:                      else if(USBDeviceState == ATTACHED_STATE)
1183:                      {
1184:                          mLED_Both_On();
1185:                      }
1186:                      else if(USBDeviceState == POWERED_STATE)
1187:                      {
1188:                          mLED_Only_1_On();
1189:                      }
1190:                      else if(USBDeviceState == DEFAULT_STATE)
1191:                      {
1192:                          mLED_Only_2_On();
1193:                      }
1194:                      else if(USBDeviceState == ADDRESS_STATE)
1195:                      {
1196:                          if(led_count == 0)
1197:                          {
1198:                              mLED_1_Toggle();
1199:                              mLED_2_Off();
1200:                          }//end if
1201:                      }
1202:                      else if(USBDeviceState == CONFIGURED_STATE)
1203:                      {
1204:                          if(led_count==0)
1205:                          {
1206:                              mLED_1_Toggle();
1207:                              if(mGetLED_1())
1208:                              {
1209:                                  mLED_2_Off();
1210:                              }
1211:                              else
1212:                              {
1213:                                  mLED_2_On();
1214:                              }
1215:                          }//end if
1216:                      }//end if(...)
1217:                  }//end if(UCONbits.SUSPND...)
1218:              #endif //#if !defined(HARDWARE_PROFILE_CUSTOM_PIM_H)
1219:              }//end BlinkUSBStatus
  5B5E    0012     RETURN 0
1220:              
1221:              
1222:              
1223:              
1224:              // ******************************************************************************************************
1225:              // ************** USB Callback Functions ****************************************************************
1226:              // ******************************************************************************************************
1227:              // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
1228:              // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
1229:              // packets to your device.  In response to this, all USB devices are supposed to decrease their power
1230:              // consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
1231:              // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
1232:              // function.  You should modify these callback functions to take appropriate actions for each of these
1233:              // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
1234:              // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
1235:              // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
1236:              // add code that undoes the power saving things done in the USBCBSuspend() function.
1237:              
1238:              // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
1239:              // function.  This function is meant to be called from the application firmware instead.  See the
1240:              // additional comments near the function.
1241:              
1242:              /******************************************************************************
1243:               * Function:        void USBCBSuspend(void)
1244:               *
1245:               * PreCondition:    None
1246:               *
1247:               * Input:           None
1248:               *
1249:               * Output:          None
1250:               *
1251:               * Side Effects:    None
1252:               *
1253:               * Overview:        Call back that is invoked when a USB suspend is detected
1254:               *
1255:               * Note:            None
1256:               *****************************************************************************/
1257:              void USBCBSuspend(void)
1258:              {
1259:              	//Example power saving code.  Insert appropriate code here for the desired
1260:              	//application behavior.  If the microcontroller will be put to sleep, a
1261:              	//process similar to that shown below may be used:
1262:              	
1263:              	//ConfigureIOPinsForLowPower();
1264:              	//SaveStateOfAllInterruptEnableBits();
1265:              	//DisableAllInterruptEnableBits();
1266:              	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
1267:              	//Sleep();
1268:              	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
1269:              	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
1270:              
1271:              	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
1272:              	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
1273:              	//things to not work as intended.	
1274:              	
1275:              
1276:                  #if defined(__C30__)
1277:                  #if 0
1278:                      U1EIR = 0xFFFF;
1279:                      U1IR = 0xFFFF;
1280:                      U1OTGIR = 0xFFFF;
1281:                      IFS5bits.USB1IF = 0;
1282:                      IEC5bits.USB1IE = 1;
1283:                      U1OTGIEbits.ACTVIE = 1;
1284:                      U1OTGIRbits.ACTVIF = 1;
1285:                      Sleep();
1286:                  #endif
1287:                  #endif
1288:              }
  5B60    0012     RETURN 0
1289:              
1290:              
1291:              /******************************************************************************
1292:               * Function:        void _USB1Interrupt(void)
1293:               *
1294:               * PreCondition:    None
1295:               *
1296:               * Input:           None
1297:               *
1298:               * Output:          None
1299:               *
1300:               * Side Effects:    None
1301:               *
1302:               * Overview:        This function is called when the USB interrupt bit is set
1303:               *					In this example the interrupt is only used when the device
1304:               *					goes to sleep when it receives a USB suspend command
1305:               *
1306:               * Note:            None
1307:               *****************************************************************************/
1308:              #if 0
1309:              void __attribute__ ((interrupt)) _USB1Interrupt(void)
1310:              {
1311:                  #if !defined(self_powered)
1312:                      if(U1OTGIRbits.ACTVIF)
1313:                      {
1314:                          IEC5bits.USB1IE = 0;
1315:                          U1OTGIEbits.ACTVIE = 0;
1316:                          IFS5bits.USB1IF = 0;
1317:                      
1318:                          //USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
1319:                          USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1320:                          //USBSuspendControl = 0;
1321:                      }
1322:                  #endif
1323:              }
1324:              #endif
1325:              
1326:              /******************************************************************************
1327:               * Function:        void USBCBWakeFromSuspend(void)
1328:               *
1329:               * PreCondition:    None
1330:               *
1331:               * Input:           None
1332:               *
1333:               * Output:          None
1334:               *
1335:               * Side Effects:    None
1336:               *
1337:               * Overview:        The host may put USB peripheral devices in low power
1338:               *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
1339:               *					mode, the host may wake the device back up by sending non-
1340:               *					idle state signalling.
1341:               *					
1342:               *					This call back is invoked when a wakeup from USB suspend 
1343:               *					is detected.
1344:               *
1345:               * Note:            None
1346:               *****************************************************************************/
1347:              void USBCBWakeFromSuspend(void)
1348:              {
1349:              	// If clock switching or other power savings measures were taken when
1350:              	// executing the USBCBSuspend() function, now would be a good time to
1351:              	// switch back to normal full power run mode conditions.  The host allows
1352:              	// a few milliseconds of wakeup time, after which the device must be 
1353:              	// fully back to normal, and capable of receiving and processing USB
1354:              	// packets.  In order to do this, the USB module must receive proper
1355:              	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
1356:              	// operation).
1357:              }
  5B62    0012     RETURN 0
1358:              
1359:              /********************************************************************
1360:               * Function:        void USBCB_SOF_Handler(void)
1361:               *
1362:               * PreCondition:    None
1363:               *
1364:               * Input:           None
1365:               *
1366:               * Output:          None
1367:               *
1368:               * Side Effects:    None
1369:               *
1370:               * Overview:        The USB host sends out a SOF packet to full-speed
1371:               *                  devices every 1 ms. This interrupt may be useful
1372:               *                  for isochronous pipes. End designers should
1373:               *                  implement callback routine as necessary.
1374:               *
1375:               * Note:            None
1376:               *******************************************************************/
1377:              void USBCB_SOF_Handler(void)
1378:              {
1379:                  // No need to clear UIRbits.SOFIF to 0 here.
1380:                  // Callback caller is already doing that.
1381:              
1382:                  //This is reverse logic since the pushbutton is active low
1383:                  if(buttonPressed == sw2)
  5B64    0101     MOVLB 0x1
  5B66    05CB     DECF 0xcb, W, BANKED
  5B68    E108     BNZ 0x5b7a
1384:                  {
1385:                      if(buttonCount != 0)
  5B6A    51CC     MOVF 0xcc, W, BANKED
  5B6C    E002     BZ 0x5b72
1386:                      {
1387:                          buttonCount--;
  5B6E    07CC     DECF 0xcc, F, BANKED
1388:                      }
1389:                      else
  5B70    0012     RETURN 0
1390:                      {
1391:                          //This is reverse logic since the pushbutton is active low
1392:                          buttonPressed = !sw2;
  5B72    6BCB     CLRF 0xcb, BANKED
1393:              
1394:                          //Wait 100ms before the next press can be generated
1395:                          buttonCount = 100;
  5B74    0E64     MOVLW 0x64
  5B76    6FCC     MOVWF 0xcc, BANKED
1396:                      }
1397:                  }
1398:                  else
  5B78    0012     RETURN 0
1399:                  {
1400:                      if(buttonCount != 0)
  5B7A    51CC     MOVF 0xcc, W, BANKED
  5B7C    E001     BZ 0x5b80
1401:                      {
1402:                          buttonCount--;
  5B7E    07CC     DECF 0xcc, F, BANKED
1403:                      }
1404:                  }
1405:              }
  5B80    0012     RETURN 0
1406:              
1407:              /*******************************************************************
1408:               * Function:        void USBCBErrorHandler(void)
1409:               *
1410:               * PreCondition:    None
1411:               *
1412:               * Input:           None
1413:               *
1414:               * Output:          None
1415:               *
1416:               * Side Effects:    None
1417:               *
1418:               * Overview:        The purpose of this callback is mainly for
1419:               *                  debugging during development. Check UEIR to see
1420:               *                  which error causes the interrupt.
1421:               *
1422:               * Note:            None
1423:               *******************************************************************/
1424:              void USBCBErrorHandler(void)
1425:              {
1426:                  // No need to clear UEIR to 0 here.
1427:                  // Callback caller is already doing that.
1428:              
1429:              	// Typically, user firmware does not need to do anything special
1430:              	// if a USB error occurs.  For example, if the host sends an OUT
1431:              	// packet to your device, but the packet gets corrupted (ex:
1432:              	// because of a bad connection, or the user unplugs the
1433:              	// USB cable during the transmission) this will typically set
1434:              	// one or more USB error interrupt flags.  Nothing specific
1435:              	// needs to be done however, since the SIE will automatically
1436:              	// send a "NAK" packet to the host.  In response to this, the
1437:              	// host will normally retry to send the packet again, and no
1438:              	// data loss occurs.  The system will typically recover
1439:              	// automatically, without the need for application firmware
1440:              	// intervention.
1441:              	
1442:              	// Nevertheless, this callback function is provided, such as
1443:              	// for debugging purposes.
1444:              }
  5B82    0012     RETURN 0
1445:              
1446:              
1447:              /*******************************************************************
1448:               * Function:        void USBCBCheckOtherReq(void)
1449:               *
1450:               * PreCondition:    None
1451:               *
1452:               * Input:           None
1453:               *
1454:               * Output:          None
1455:               *
1456:               * Side Effects:    None
1457:               *
1458:               * Overview:        When SETUP packets arrive from the host, some
1459:               * 					firmware must process the request and respond
1460:               *					appropriately to fulfill the request.  Some of
1461:               *					the SETUP packets will be for standard
1462:               *					USB "chapter 9" (as in, fulfilling chapter 9 of
1463:               *					the official USB specifications) requests, while
1464:               *					others may be specific to the USB device class
1465:               *					that is being implemented.  For example, a HID
1466:               *					class device needs to be able to respond to
1467:               *					"GET REPORT" type of requests.  This
1468:               *					is not a standard USB chapter 9 request, and 
1469:               *					therefore not handled by usb_device.c.  Instead
1470:               *					this request should be handled by class specific 
1471:               *					firmware, such as that contained in usb_function_hid.c.
1472:               *
1473:               * Note:            None
1474:               *******************************************************************/
1475:              void USBCBCheckOtherReq(void)
1476:              {
1477:                  USBCheckMSDRequest();
  5B84    EC4C     CALL 0x4898, 0
  5B86    F024     NOP
1478:                  USBCheckCDCRequest();
  5B88    EF41     GOTO 0x5c82
  5B8A    F02E     NOP
1479:              }//end
1480:              
1481:              
1482:              /*******************************************************************
1483:               * Function:        void USBCBStdSetDscHandler(void)
1484:               *
1485:               * PreCondition:    None
1486:               *
1487:               * Input:           None
1488:               *
1489:               * Output:          None
1490:               *
1491:               * Side Effects:    None
1492:               *
1493:               * Overview:        The USBCBStdSetDscHandler() callback function is
1494:               *					called when a SETUP, bRequest: SET_DESCRIPTOR request
1495:               *					arrives.  Typically SET_DESCRIPTOR requests are
1496:               *					not used in most applications, and it is
1497:               *					optional to support this type of request.
1498:               *
1499:               * Note:            None
1500:               *******************************************************************/
1501:              void USBCBStdSetDscHandler(void)
1502:              {
1503:                  // Must claim session ownership if supporting this request
1504:              }//end
  5B8C    0012     RETURN 0
1505:              
1506:              
1507:              /*******************************************************************
1508:               * Function:        void USBCBInitEP(void)
1509:               *
1510:               * PreCondition:    None
1511:               *
1512:               * Input:           None
1513:               *
1514:               * Output:          None
1515:               *
1516:               * Side Effects:    None
1517:               *
1518:               * Overview:        This function is called when the device becomes
1519:               *                  initialized, which occurs after the host sends a
1520:               * 					SET_CONFIGURATION (wValue not = 0) request.  This 
1521:               *					callback function should initialize the endpoints 
1522:               *					for the device's usage according to the current 
1523:               *					configuration.
1524:               *
1525:               * Note:            None
1526:               *******************************************************************/
1527:              void USBCBInitEP(void)
1528:              {
1529:                  #if (MSD_DATA_IN_EP == MSD_DATA_OUT_EP)
1530:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
  5B8E    0E1E     MOVLW 0x1e
  5B90    6EE6     MOVWF 0xfe6, ACCESS
  5B92    0E01     MOVLW 0x1
  5B94    6EE6     MOVWF 0xfe6, ACCESS
  5B96    EC59     CALL 0x38b2, 0
  5B98    F01C     NOP
  5B9A    52E5     MOVF 0xfe5, F, ACCESS
  5B9C    52E5     MOVF 0xfe5, F, ACCESS
1531:                  #else
1532:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1533:                      USBEnableEndpoint(MSD_DATA_OUT_EP,USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1534:                  #endif
1535:              
1536:                  USBMSDInit();
  5B9E    ECFE     CALL 0x47fc, 0
  5BA0    F023     NOP
1537:                  CDCInitEP();
  5BA2    EF93     GOTO 0x5d26
  5BA4    F02E     NOP
1538:              }
1539:              
1540:              /********************************************************************
1541:               * Function:        void USBCBSendResume(void)
1542:               *
1543:               * PreCondition:    None
1544:               *
1545:               * Input:           None
1546:               *
1547:               * Output:          None
1548:               *
1549:               * Side Effects:    None
1550:               *
1551:               * Overview:        The USB specifications allow some types of USB
1552:               * 					peripheral devices to wake up a host PC (such
1553:               *					as if it is in a low power suspend to RAM state).
1554:               *					This can be a very useful feature in some
1555:               *					USB applications, such as an Infrared remote
1556:               *					control	receiver.  If a user presses the "power"
1557:               *					button on a remote control, it is nice that the
1558:               *					IR receiver can detect this signalling, and then
1559:               *					send a USB "command" to the PC to wake up.
1560:               *					
1561:               *					The USBCBSendResume() "callback" function is used
1562:               *					to send this special USB signalling which wakes 
1563:               *					up the PC.  This function may be called by
1564:               *					application firmware to wake up the PC.  This
1565:               *					function will only be able to wake up the host if
1566:               *                  all of the below are true:
1567:               *					
1568:               *					1.  The USB driver used on the host PC supports
1569:               *						the remote wakeup capability.
1570:               *					2.  The USB configuration descriptor indicates
1571:               *						the device is remote wakeup capable in the
1572:               *						bmAttributes field.
1573:               *					3.  The USB host PC is currently sleeping,
1574:               *						and has previously sent your device a SET 
1575:               *						FEATURE setup packet which "armed" the
1576:               *						remote wakeup capability.   
1577:               *
1578:               *                  If the host has not armed the device to perform remote wakeup,
1579:               *                  then this function will return without actually performing a
1580:               *                  remote wakeup sequence.  This is the required behavior, 
1581:               *                  as a USB device that has not been armed to perform remote 
1582:               *                  wakeup must not drive remote wakeup signalling onto the bus;
1583:               *                  doing so will cause USB compliance testing failure.
1584:               *                  
1585:               *					This callback should send a RESUME signal that
1586:               *                  has the period of 1-15ms.
1587:               *
1588:               * Note:            This function does nothing and returns quickly, if the USB
1589:               *                  bus and host are not in a suspended condition, or are 
1590:               *                  otherwise not in a remote wakeup ready state.  Therefore, it
1591:               *                  is safe to optionally call this function regularly, ex: 
1592:               *                  anytime application stimulus occurs, as the function will
1593:               *                  have no effect, until the bus really is in a state ready
1594:               *                  to accept remote wakeup. 
1595:               *
1596:               *                  When this function executes, it may perform clock switching,
1597:               *                  depending upon the application specific code in 
1598:               *                  USBCBWakeFromSuspend().  This is needed, since the USB
1599:               *                  bus will no longer be suspended by the time this function
1600:               *                  returns.  Therefore, the USB module will need to be ready
1601:               *                  to receive traffic from the host.
1602:               *
1603:               *                  The modifiable section in this routine may be changed
1604:               *                  to meet the application needs. Current implementation
1605:               *                  temporary blocks other functions from executing for a
1606:               *                  period of ~3-15 ms depending on the core frequency.
1607:               *
1608:               *                  According to USB 2.0 specification section 7.1.7.7,
1609:               *                  "The remote wakeup device must hold the resume signaling
1610:               *                  for at least 1 ms but for no more than 15 ms."
1611:               *                  The idea here is to use a delay counter loop, using a
1612:               *                  common value that would work over a wide range of core
1613:               *                  frequencies.
1614:               *                  That value selected is 1800. See table below:
1615:               *                  ==========================================================
1616:               *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
1617:               *                  ==========================================================
1618:               *                      48              12          1.05
1619:               *                       4              1           12.6
1620:               *                  ==========================================================
1621:               *                  * These timing could be incorrect when using code
1622:               *                    optimization or extended instruction mode,
1623:               *                    or when having other interrupts enabled.
1624:               *                    Make sure to verify using the MPLAB SIM's Stopwatch
1625:               *                    and verify the actual signal on an oscilloscope.
1626:               *******************************************************************/
1627:              void USBCBSendResume(void)
1628:              {
1629:                  static WORD delay_count;
1630:                  
1631:                  //First verify that the host has armed us to perform remote wakeup.
1632:                  //It does this by sending a SET_FEATURE request to enable remote wakeup,
1633:                  //usually just before the host goes to standby mode (note: it will only
1634:                  //send this SET_FEATURE request if the configuration descriptor declares
1635:                  //the device as remote wakeup capable, AND, if the feature is enabled
1636:                  //on the host (ex: on Windows based hosts, in the device manager 
1637:                  //properties page for the USB device, power management tab, the 
1638:                  //"Allow this device to bring the computer out of standby." checkbox 
1639:                  //should be checked).
1640:                  if(USBGetRemoteWakeupStatus() == TRUE) 
  5BA6    0100     MOVLB 0
  5BA8    0589     DECF 0x89, W, BANKED
  5BAA    E120     BNZ 0x5bec
1641:                  {
1642:                      //Verify that the USB bus is in fact suspended, before we send
1643:                      //remote wakeup signalling.
1644:                      if(USBIsBusSuspended() == TRUE)
  5BAC    0100     MOVLB 0
  5BAE    058A     DECF 0x8a, W, BANKED
  5BB0    E11D     BNZ 0x5bec
1645:                      {
1646:                          USBMaskInterrupts();
  5BB2    98A0     BCF 0xfa0, 0x4, ACCESS
1647:                          
1648:                          //Clock switch to settings consistent with normal USB operation.
1649:                          USBCBWakeFromSuspend();
  5BB4    DFD6     RCALL 0x5b62
1650:                          USBSuspendControl = 0; 
  5BB6    9265     BCF 0xf65, 0x1, ACCESS
1651:                          USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
  5BB8    0100     MOVLB 0
  5BBA    6B8A     CLRF 0x8a, BANKED
1652:                                                      //until a new suspend condition is detected.
1653:              
1654:                          //Section 7.1.7.7 of the USB 2.0 specifications indicates a USB
1655:                          //device must continuously see 5ms+ of idle on the bus, before it sends
1656:                          //remote wakeup signalling.  One way to be certain that this parameter
1657:                          //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
1658:                          //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yeilds
1659:                          //5ms+ total delay since start of idle).
1660:                          delay_count = 3600U;        
  5BBC    0101     MOVLB 0x1
  5BBE    0E10     MOVLW 0x10
  5BC0    6FCD     MOVWF 0xcd, BANKED
  5BC2    0E0E     MOVLW 0xe
  5BC4    6FCE     MOVWF 0xce, BANKED
1661:                          do
1662:                          {
1663:                              delay_count--;
  5BC6    07CD     DECF 0xcd, F, BANKED
  5BC8    0E00     MOVLW 0
  5BCA    5BCE     SUBWFB 0xce, F, BANKED
1664:                          }while(delay_count);
  5BCC    51CD     MOVF 0xcd, W, BANKED
  5BCE    11CE     IORWF 0xce, W, BANKED
  5BD0    E1FA     BNZ 0x5bc6
1665:                          
1666:                          //Now drive the resume K-state signalling onto the USB bus.
1667:                          USBResumeControl = 1;       // Start RESUME signaling
  5BD2    8465     BSF 0xf65, 0x2, ACCESS
1668:                          delay_count = 1800U;        // Set RESUME line for 1-13 ms
  5BD4    0E08     MOVLW 0x8
  5BD6    6FCD     MOVWF 0xcd, BANKED
  5BD8    0E07     MOVLW 0x7
  5BDA    6FCE     MOVWF 0xce, BANKED
1669:                          do
1670:                          {
1671:                              delay_count--;
  5BDC    07CD     DECF 0xcd, F, BANKED
  5BDE    0E00     MOVLW 0
  5BE0    5BCE     SUBWFB 0xce, F, BANKED
1672:                          }while(delay_count);
  5BE2    51CD     MOVF 0xcd, W, BANKED
  5BE4    11CE     IORWF 0xce, W, BANKED
  5BE6    E1FA     BNZ 0x5bdc
1673:                          USBResumeControl = 0;       //Finished driving resume signalling
  5BE8    9465     BCF 0xf65, 0x2, ACCESS
1674:              
1675:                          USBUnmaskInterrupts();
  5BEA    88A0     BSF 0xfa0, 0x4, ACCESS
1676:                      }
1677:                  }
1678:              }
  5BEC    0012     RETURN 0
1679:              
1680:              
1681:              /*******************************************************************
1682:               * Function:        void USBCBEP0DataReceived(void)
1683:               *
1684:               * PreCondition:    ENABLE_EP0_DATA_RECEIVED_CALLBACK must be
1685:               *                  defined already (in usb_config.h)
1686:               *
1687:               * Input:           None
1688:               *
1689:               * Output:          None
1690:               *
1691:               * Side Effects:    None
1692:               *
1693:               * Overview:        This function is called whenever a EP0 data
1694:               *                  packet is received.  This gives the user (and
1695:               *                  thus the various class examples a way to get
1696:               *                  data that is received via the control endpoint.
1697:               *                  This function needs to be used in conjunction
1698:               *                  with the USBCBCheckOtherReq() function since 
1699:               *                  the USBCBCheckOtherReq() function is the apps
1700:               *                  method for getting the initial control transfer
1701:               *                  before the data arrives.
1702:               *
1703:               * Note:            None
1704:               *******************************************************************/
1705:              #if defined(ENABLE_EP0_DATA_RECEIVED_CALLBACK)
1706:              void USBCBEP0DataReceived(void)
1707:              {
1708:              }
1709:              #endif
1710:              
1711:              /*******************************************************************
1712:               * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
1713:               *                        USB_EVENT event, void *pdata, WORD size)
1714:               *
1715:               * PreCondition:    None
1716:               *
1717:               * Input:           USB_EVENT event - the type of event
1718:               *                  void *pdata - pointer to the event data
1719:               *                  WORD size - size of the event data
1720:               *
1721:               * Output:          None
1722:               *
1723:               * Side Effects:    None
1724:               *
1725:               * Overview:        This function is called from the USB stack to
1726:               *                  notify a user application that a USB event
1727:               *                  occured.  This callback is in interrupt context
1728:               *                  when the USB_INTERRUPT option is selected.
1729:               *
1730:               * Note:            None
1731:               *******************************************************************/
1732:              BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size)
  5BEE    CFD9     MOVFF 0xfd9, 0xfe6
  5BF0    FFE6     NOP
  5BF2    CFE1     MOVFF 0xfe1, 0xfd9
  5BF4    FFD9     NOP
1733:              {
1734:                  switch(event)
  5BF6    0EFD     MOVLW 0xfd
  5BF8    CFDB     MOVFF 0xfdb, 0x8
  5BFA    F008     NOP
  5BFC    0EFE     MOVLW 0xfe
  5BFE    CFDB     MOVFF 0xfdb, 0x9
  5C00    F009     NOP
  5C02    0E05     MOVLW 0x5
  5C04    1808     XORWF 0x8, W, ACCESS
  5C06    E101     BNZ 0x5c0a
  5C08    5009     MOVF 0x9, W, ACCESS
  5C0A    E036     BZ 0x5c78
  5C0C    68E8     SETF 0xfe8, ACCESS
  5C0E    1808     XORWF 0x8, W, ACCESS
  5C10    E102     BNZ 0x5c16
  5C12    0E7F     MOVLW 0x7f
  5C14    1809     XORWF 0x9, W, ACCESS
  5C16    E02F     BZ 0x5c76
  5C18    0E03     MOVLW 0x3
  5C1A    1808     XORWF 0x8, W, ACCESS
  5C1C    E101     BNZ 0x5c20
  5C1E    5009     MOVF 0x9, W, ACCESS
  5C20    E028     BZ 0x5c72
  5C22    0E02     MOVLW 0x2
  5C24    1808     XORWF 0x8, W, ACCESS
  5C26    E101     BNZ 0x5c2a
  5C28    5009     MOVF 0x9, W, ACCESS
  5C2A    E021     BZ 0x5c6e
  5C2C    0E01     MOVLW 0x1
  5C2E    1808     XORWF 0x8, W, ACCESS
  5C30    E101     BNZ 0x5c34
  5C32    5009     MOVF 0x9, W, ACCESS
  5C34    E01A     BZ 0x5c6a
  5C36    0E74     MOVLW 0x74
  5C38    1808     XORWF 0x8, W, ACCESS
  5C3A    E101     BNZ 0x5c3e
  5C3C    5009     MOVF 0x9, W, ACCESS
  5C3E    E013     BZ 0x5c66
  5C40    0E75     MOVLW 0x75
  5C42    1808     XORWF 0x8, W, ACCESS
  5C44    E101     BNZ 0x5c48
  5C46    5009     MOVF 0x9, W, ACCESS
  5C48    E00C     BZ 0x5c62
  5C4A    0E73     MOVLW 0x73
  5C4C    1808     XORWF 0x8, W, ACCESS
  5C4E    E101     BNZ 0x5c52
  5C50    5009     MOVF 0x9, W, ACCESS
  5C52    E005     BZ 0x5c5e
  5C54    0E72     MOVLW 0x72
  5C56    1808     XORWF 0x8, W, ACCESS
  5C58    E10F     BNZ 0x5c78
  5C5A    5009     MOVF 0x9, W, ACCESS
  5C5C    D00D     BRA 0x5c78
1735:                  {
1736:                      case EVENT_TRANSFER:
1737:                          //Add application specific callback task or callback function here if desired.
1738:                          break;
1739:                      case EVENT_SOF:
1740:                          USBCB_SOF_Handler();
  5C5E    DF82     RCALL 0x5b64
1741:                          break;
  5C60    D00B     BRA 0x5c78
1742:                      case EVENT_SUSPEND:
1743:                          USBCBSuspend();
  5C62    DF7E     RCALL 0x5b60
1744:                          break;
  5C64    D009     BRA 0x5c78
1745:                      case EVENT_RESUME:
1746:                          USBCBWakeFromSuspend();
  5C66    DF7D     RCALL 0x5b62
1747:                          break;
  5C68    D007     BRA 0x5c78
1748:                      case EVENT_CONFIGURED: 
1749:                          USBCBInitEP();
  5C6A    DF91     RCALL 0x5b8e
1750:                          break;
  5C6C    D005     BRA 0x5c78
1751:                      case EVENT_SET_DESCRIPTOR:
1752:                          USBCBStdSetDscHandler();
  5C6E    DF8E     RCALL 0x5b8c
1753:                          break;
  5C70    D003     BRA 0x5c78
1754:                      case EVENT_EP0_REQUEST:
1755:                          USBCBCheckOtherReq();
  5C72    DF88     RCALL 0x5b84
1756:                          break;
  5C74    D001     BRA 0x5c78
1757:                      case EVENT_BUS_ERROR:
1758:                          USBCBErrorHandler();
  5C76    DF85     RCALL 0x5b82
1759:                          break;
1760:                      case EVENT_TRANSFER_TERMINATED:
1761:                          //Add application specific callback task or callback function here if desired.
1762:                          //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
1763:                          //FEATURE (endpoint halt) request on an application endpoint which was 
1764:                          //previously armed (UOWN was = 1).  Here would be a good place to:
1765:                          //1.  Determine which endpoint the transaction that just got terminated was 
1766:                          //      on, by checking the handle value in the *pdata.
1767:                          //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
1768:                          //      endpoints).
1769:                          break;
1770:                      default:
1771:                          break;
1772:                  }      
1773:                  return TRUE; 
  5C78    0E01     MOVLW 0x1
1774:              }
  5C7A    52E5     MOVF 0xfe5, F, ACCESS
  5C7C    CFE7     MOVFF 0xfe7, 0xfd9
  5C7E    FFD9     NOP
  5C80    0012     RETURN 0