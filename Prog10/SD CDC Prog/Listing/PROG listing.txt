---  C:\MCC18\src\pmc_common\USART\_usartpc.asm  -------------------------------------------------
                                                  1:     #include <P18CXXX.INC>
                                                  2:     
                                                  3:     
                                                  4:     #ifdef __18F1220
                                                  5:     #define __USE_PORTB 1
                                                  6:     #endif
                                                  7:     #ifdef __18F1230
                                                  8:     #define __USE_PORTB 1
                                                  9:     #endif
                                                  10:    #ifdef __18F1231
                                                  11:    #define __USE_PORTB 1
                                                  12:    #endif
                                                  13:    #ifdef __18F1320
                                                  14:    #define __USE_PORTB 1
                                                  15:    #endif
                                                  16:    #ifdef __18F1330
                                                  17:    #define __USE_PORTB 1
                                                  18:    #endif
                                                  19:    #ifdef __18F1331
                                                  20:    #define __USE_PORTB 1
                                                  21:    #endif
                                                  22:    
                                                  23:      GLOBAL _usart_putc
                                                  24:    
                                                  25:    STDIO CODE
                                                  26:      
                                                  27:    _usart_putc  
  52F2    0EFF     MOVLW 0xff                     28:                  MOVLW     0xff
  52F4    50E3     MOVF 0xfe3, W, ACCESS          29:                  MOVF      PLUSW1, w
  52F6    BAAD     BTFSC 0xfad, 0x5, ACCESS       30:                  BTFSC     TXSTA, 0x5
  52F8    D004     BRA 0x5302                     31:                  BRA       loop
  52FA    6AB0     CLRF 0xfb0, ACCESS             32:                  CLRF      SPBRG
  52FC    8EAC     BSF 0xfac, 0x7, ACCESS         33:                  BSF       RCSTA, 0x7
  52FE    8AAD     BSF 0xfad, 0x5, ACCESS         34:                  BSF       TXSTA, 0x5
                                                  35:    #ifdef __USE_PORTB
                                                  36:                  BCF       TRISB, 0x1
                                                  37:    #else
  5300    9C94     BCF 0xf94, 0x6, ACCESS         38:                  BCF       TRISC, 0x6
                                                  39:    #endif
  5302    A2AD     BTFSS 0xfad, 0x1, ACCESS       40:    loop:         BTFSS     TXSTA, 0x1
  5304    D7FE     BRA 0x5302                     41:                  BRA       loop
  5306    6EAE     MOVWF 0xfae, ACCESS            42:                  MOVWF     TXREG
  5308    6EF3     MOVWF 0xff3, ACCESS            43:                  MOVWF     PRODL
  530A    6AF4     CLRF 0xff4, ACCESS             44:                  CLRF      PRODL + 1
                                                  45:                 
  530C    0012     RETURN 0                       46:                  RETURN
---  C:\MCC18\src\traditional\math\fxd3232u.c  ---------------------------------------------------
1:                 /*** Unsigned Integer Division: 32-bit by 32-bit
2:                  *** 
3:                  *** Optimized: Dec. 21, 2000
4:                  ***        by: Daniel R. Madill, Quanser Consulting Inc.
5:                  ***       for: Saved (for the worst case) at least 8*32 = 256 instruction cycles
6:                  ***            over the code supplied with MCC18 v1.00.12
7:                  ***/
8:                 
9:                 void  FXD3232U(void/* ulong aarg, ulong barg */)
10:                {
11:                  // use INDF1 for the counter...
12:                
13:                    _asm
14:                
15:                    // REM = 0
16:                    clrf __REMB0, 0
  51EA    6A05     CLRF 0x5, ACCESS
17:                    clrf __REMB1, 0
  51EC    6A04     CLRF 0x4, ACCESS
18:                    clrf __REMB2, 0
  51EE    6A03     CLRF 0x3, ACCESS
19:                    clrf __REMB3, 0
  51F0    6A02     CLRF 0x2, ACCESS
20:                
21:                    // INDF1 = 32
22:                    movlw 32
  51F2    0E20     MOVLW 0x20
23:                    movwf INDF1, 0
  51F4    6EE7     MOVWF 0xfe7, ACCESS
24:                
25:                    // Clear the carry
26:                    bcf STATUS, 0, 0
  51F6    90D8     BCF 0xfd8, 0, ACCESS
27:                
28:                loop:
29:                
30:                	//AARG32 <<= 1; The carry is always clear at the top of the loop.
31:                	rlcf __AARGB3, 1, 0
  51F8    3606     RLCF 0x6, F, ACCESS
32:                	rlcf __AARGB2, 1, 0
  51FA    3607     RLCF 0x7, F, ACCESS
33:                	rlcf __AARGB1, 1, 0
  51FC    3608     RLCF 0x8, F, ACCESS
34:                	rlcf __AARGB0, 1, 0
  51FE    3609     RLCF 0x9, F, ACCESS
35:                
36:                	//REM32 = (REM32 << 1) | (AARG32 >> 32)
37:                	rlcf __REMB3, 1, 0
  5200    3602     RLCF 0x2, F, ACCESS
38:                	rlcf __REMB2, 1, 0
  5202    3603     RLCF 0x3, F, ACCESS
39:                	rlcf __REMB1, 1, 0
  5204    3604     RLCF 0x4, F, ACCESS
40:                	rlcf __REMB0, 1, 0
  5206    3605     RLCF 0x5, F, ACCESS
41:                	
42:                	//if (PROD >= BARG32)
43:                	movf __BARGB3, 0, 0
  5208    500B     MOVF 0xb, W, ACCESS
44:                	subwf __REMB3, 0, 0
  520A    5C02     SUBWF 0x2, W, ACCESS
45:                	movf __BARGB2, 0, 0
  520C    500C     MOVF 0xc, W, ACCESS
46:                	subwfb __REMB2, 0, 0
  520E    5803     SUBWFB 0x3, W, ACCESS
47:                	movf __BARGB1, 0, 0
  5210    500D     MOVF 0xd, W, ACCESS
48:                	subwfb __REMB1, 0, 0
  5212    5804     SUBWFB 0x4, W, ACCESS
49:                	movf __BARGB0, 0, 0
  5214    500E     MOVF 0xe, W, ACCESS
50:                	subwfb __REMB0, 0, 0
  5216    5805     SUBWFB 0x5, W, ACCESS
51:                	bnc _false
  5218    E309     BNC 0x522c
52:                    //{
53:                	    //REM32-= BARG32;
54:                	    movf __BARGB3, 0, 0
  521A    500B     MOVF 0xb, W, ACCESS
55:                	    subwf __REMB3, 1, 0
  521C    5E02     SUBWF 0x2, F, ACCESS
56:                	    movf __BARGB2, 0, 0
  521E    500C     MOVF 0xc, W, ACCESS
57:                	    subwfb __REMB2, 1, 0
  5220    5A03     SUBWFB 0x3, F, ACCESS
58:                	    movf __BARGB1, 0, 0
  5222    500D     MOVF 0xd, W, ACCESS
59:                	    subwfb __REMB1, 1, 0
  5224    5A04     SUBWFB 0x4, F, ACCESS
60:                	    movf __BARGB0, 0, 0
  5226    500E     MOVF 0xe, W, ACCESS
61:                	    subwfb __REMB0, 1, 0
  5228    5A05     SUBWFB 0x5, F, ACCESS
62:                
63:                	    //++AARG32; Since AARG32 was shift to the left above, we only need to set
64:                        //          the lowest bit. Use incf so that the carry flag will also be cleared.
65:                        //          Thus, the carry will always be clear at the top of the loop.
66:                	    incf __AARGB3, 1, 0
  522A    2A06     INCF 0x6, F, ACCESS
67:                    //}
68:                _false:
69:                
70:                    decfsz INDF1, 1, 0    // does not affect the carry bit
  522C    2EE7     DECFSZ 0xfe7, F, ACCESS
71:                    bra loop
  522E    D7E4     BRA 0x51f8
72:                
73:                  /* result in AARG already... */
74:                  _endasm
75:                }
  5230    0012     RETURN 0
---  C:\MCC18\src\traditional\math\fxm1616s.asm  -------------------------------------------------
                                                  1:     ;	RCS Header $Id: fxm1616s.asm,v 1.3 2006/01/12 23:16:38 rhinec Exp $
                                                  2:     
                                                  3:     ;	$Revision: 1.3 $
                                                  4:     
                                                  5:     	include <P18CXXX.INC>		; general Golden Gate definitions
                                                  6:     
                                                  7:     	include <CMATH18.INC>		; Math library definitions
                                                  8:     
                                                  9:     	include <AARG.INC>		; AARG declarations
                                                  10:    	
                                                  11:    	include <BARG.INC>		; BARG declarations
                                                  12:    
                                                  13:    	include <TEMPARG.INC>		; TEMPARG declarations
                                                  14:    
                                                  15:    ;**********************************************************************************************
                                                  16:    ;**********************************************************************************************
                                                  17:    
                                                  18:    ;       16x16 Bit Signed Fixed Point Multiply 16 x 16 -> 32
                                                  19:    
                                                  20:    ;       Input:  16 bit signed fixed point multiplicand in AARGB0, AARGB1
                                                  21:    ;               16 bit signed fixed point multiplier in BARGB0, BARGB1
                                                  22:    
                                                  23:    ;       Use:    CALL    FXM1616S
                                                  24:    
                                                  25:    ;       Output: 32 bit signed fixed point product in AARGB0, AARGB1,
                                                  26:    ;               AARGB2, AARGB3
                                                  27:    
                                                  28:    ;       Result: AARG  <--  AARG * BARG
                                                  29:    
                                                  30:    ;       Max Timing:     39 clks
                                                  31:    
                                                  32:    ;       Min Timing:     31 clks
                                                  33:    
                                                  34:    ;       PM: 38              DM: 8
                                                  35:    
                                                  36:    PROG	CODE
                                                  37:    
                                                  38:    FXM1616S
                                                  39:    		GLOBAL	FXM1616S
                                                  40:    
  4E68    C009     MOVFF 0x9, 0x13                41:    		MOVFF	__AARGB0,__TEMPB0
  4E6A    F013     NOP
  4E6C    C008     MOVFF 0x8, 0x12                42:    		MOVFF	__AARGB1,__TEMPB1	
  4E6E    F012     NOP
                                                  43:    
  4E70    5008     MOVF 0x8, W, ACCESS            44:    		MOVF	__AARGB1,W
  4E72    020D     MULWF 0xd, ACCESS              45:    		MULWF	__BARGB1
  4E74    CFF4     MOVFF 0xff4, 0x7               46:    		MOVFF	PRODH,__AARGB2
  4E76    F007     NOP
  4E78    CFF3     MOVFF 0xff3, 0x6               47:    		MOVFF	PRODL,__AARGB3
  4E7A    F006     NOP
                                                  48:    		
  4E7C    5009     MOVF 0x9, W, ACCESS            49:    		MOVF	__AARGB0,W
  4E7E    020E     MULWF 0xe, ACCESS              50:    		MULWF	__BARGB0
  4E80    CFF4     MOVFF 0xff4, 0x9               51:    		MOVFF	PRODH,__AARGB0
  4E82    F009     NOP
  4E84    CFF3     MOVFF 0xff3, 0x8               52:    		MOVFF	PRODL,__AARGB1
  4E86    F008     NOP
                                                  53:    
  4E88    020D     MULWF 0xd, ACCESS              54:    		MULWF	__BARGB1
  4E8A    50F3     MOVF 0xff3, W, ACCESS          55:    		MOVF	PRODL,W
  4E8C    2607     ADDWF 0x7, F, ACCESS           56:    		ADDWF	__AARGB2,F
  4E8E    50F4     MOVF 0xff4, W, ACCESS          57:    		MOVF	PRODH,W
  4E90    2208     ADDWFC 0x8, F, ACCESS          58:    		ADDWFC	__AARGB1,F
  4E92    6AE8     CLRF 0xfe8, ACCESS             59:    		CLRF	WREG
  4E94    2209     ADDWFC 0x9, F, ACCESS          60:    		ADDWFC	__AARGB0,F
                                                  61:    
  4E96    5012     MOVF 0x12, W, ACCESS           62:    		MOVF	__TEMPB1,W
  4E98    020E     MULWF 0xe, ACCESS              63:    		MULWF	__BARGB0
  4E9A    50F3     MOVF 0xff3, W, ACCESS          64:    		MOVF	PRODL,W
  4E9C    2607     ADDWF 0x7, F, ACCESS           65:    		ADDWF	__AARGB2,F
  4E9E    50F4     MOVF 0xff4, W, ACCESS          66:    		MOVF	PRODH,W
  4EA0    2208     ADDWFC 0x8, F, ACCESS          67:    		ADDWFC	__AARGB1,F
  4EA2    6AE8     CLRF 0xfe8, ACCESS             68:    		CLRF	WREG
  4EA4    2209     ADDWFC 0x9, F, ACCESS          69:    		ADDWFC	__AARGB0,F
                                                  70:    
  4EA6    AE0E     BTFSS 0xe, 0x7, ACCESS         71:    		BTFSS	__BARGB0,MSB
  4EA8    EF5A     GOTO 0x4eb4                    72:    		GOTO	TSIGN1616A
  4EAA    F027     NOP
  4EAC    5012     MOVF 0x12, W, ACCESS           73:    		MOVF	__TEMPB1,W
  4EAE    5E08     SUBWF 0x8, F, ACCESS           74:    		SUBWF	__AARGB1,F
  4EB0    5013     MOVF 0x13, W, ACCESS           75:    		MOVF	__TEMPB0,W
  4EB2    5A09     SUBWFB 0x9, F, ACCESS          76:    		SUBWFB	__AARGB0,F
                                                  77:    
                                                  78:    TSIGN1616A
  4EB4    AE13     BTFSS 0x13, 0x7, ACCESS        79:    		BTFSS	__TEMPB0,MSB
  4EB6    0C00     RETLW 0                        80:    		RETLW	0x00
  4EB8    500D     MOVF 0xd, W, ACCESS            81:    		MOVF	__BARGB1,W
  4EBA    5E08     SUBWF 0x8, F, ACCESS           82:    		SUBWF	__AARGB1,F
  4EBC    500E     MOVF 0xe, W, ACCESS            83:    		MOVF	__BARGB0,W
  4EBE    5A09     SUBWFB 0x9, F, ACCESS          84:    		SUBWFB	__AARGB0,F
                                                  85:    		
  4EC0    0C00     RETLW 0                        86:    		RETLW	0x00
---  C:\MCC18\src\traditional\math\fxm2424u.asm  -------------------------------------------------
                                                  1:     ;	RCS Header $Id: fxm2424u.asm,v 1.3 2006/01/12 23:16:38 rhinec Exp $
                                                  2:     
                                                  3:     ;	$Revision: 1.3 $
                                                  4:     
                                                  5:     	include <P18CXXX.INC>		; general Golden Gate definitions
                                                  6:     
                                                  7:     	include <CMATH18.INC>		; Math library definitions
                                                  8:     
                                                  9:     	include <AARG.INC>		; AARG declarations
                                                  10:    	
                                                  11:    	include <BARG.INC>		; BARG declarations
                                                  12:    
                                                  13:    	include <TEMPARG.INC>		; TEMPARG declarations
                                                  14:    
                                                  15:    ;**********************************************************************************************
                                                  16:    ;**********************************************************************************************
                                                  17:    
                                                  18:    ;       24x24 Bit Unsigned Fixed Point Multiply 24 x 24 -> 48
                                                  19:    
                                                  20:    ;       Input:  24 bit unsigned fixed point multiplicand in AARGB0, AARGB1,
                                                  21:    ;               AARGB2
                                                  22:    ;               24 bit unsigned fixed point multiplier in BARGB0, BARGB1,
                                                  23:    ;               BARGB2
                                                  24:    
                                                  25:    ;       Use:    CALL    FXM2424U
                                                  26:    
                                                  27:    ;       Output: 48 bit unsigned fixed point product in AARGB0, AARGB1, 
                                                  28:    ;               AARGB2, AARGB3, AARGB4, AARGB5
                                                  29:    
                                                  30:    ;       Result: AARG  <--  AARG * BARG
                                                  31:    
                                                  32:    ;       Max Timing:     65 clks
                                                  33:    
                                                  34:    ;       Min Timing:     65 clks
                                                  35:    
                                                  36:    ;       PM: 64              DM: 12
                                                  37:    
                                                  38:    PROG	CODE
                                                  39:    
                                                  40:    FXM2424U
                                                  41:    		GLOBAL	FXM2424U
                                                  42:    
  4DD6    C009     MOVFF 0x9, 0x13                43:    		MOVFF	__AARGB0,__TEMPB0	
  4DD8    F013     NOP
  4DDA    C008     MOVFF 0x8, 0x12                44:    		MOVFF	__AARGB1,__TEMPB1	
  4DDC    F012     NOP
  4DDE    C007     MOVFF 0x7, 0x11                45:    		MOVFF	__AARGB2,__TEMPB2	
  4DE0    F011     NOP
                                                  46:    
  4DE2    5007     MOVF 0x7, W, ACCESS            47:    		MOVF	__AARGB2,W
  4DE4    020C     MULWF 0xc, ACCESS              48:    		MULWF	__BARGB2
  4DE6    CFF4     MOVFF 0xff4, 0x5               49:    		MOVFF	PRODH,__AARGB4
  4DE8    F005     NOP
  4DEA    CFF3     MOVFF 0xff3, 0x4               50:    		MOVFF	PRODL,__AARGB5
  4DEC    F004     NOP
                                                  51:    		
  4DEE    5008     MOVF 0x8, W, ACCESS            52:    		MOVF	__AARGB1,W
  4DF0    020D     MULWF 0xd, ACCESS              53:    		MULWF	__BARGB1
  4DF2    CFF4     MOVFF 0xff4, 0x7               54:    		MOVFF	PRODH,__AARGB2
  4DF4    F007     NOP
  4DF6    CFF3     MOVFF 0xff3, 0x6               55:    		MOVFF	PRODL,__AARGB3
  4DF8    F006     NOP
                                                  56:    
  4DFA    020C     MULWF 0xc, ACCESS              57:    		MULWF	__BARGB2
  4DFC    50F3     MOVF 0xff3, W, ACCESS          58:    		MOVF	PRODL,W
  4DFE    2605     ADDWF 0x5, F, ACCESS           59:    		ADDWF	__AARGB4,F
  4E00    50F4     MOVF 0xff4, W, ACCESS          60:    		MOVF	PRODH,W
  4E02    2206     ADDWFC 0x6, F, ACCESS          61:    		ADDWFC	__AARGB3,F
  4E04    6AE8     CLRF 0xfe8, ACCESS             62:    		CLRF	WREG
  4E06    2207     ADDWFC 0x7, F, ACCESS          63:    		ADDWFC	__AARGB2,F
                                                  64:    
  4E08    5011     MOVF 0x11, W, ACCESS           65:    		MOVF	__TEMPB2,W
  4E0A    020D     MULWF 0xd, ACCESS              66:    		MULWF	__BARGB1
  4E0C    50F3     MOVF 0xff3, W, ACCESS          67:    		MOVF	PRODL,W
  4E0E    2605     ADDWF 0x5, F, ACCESS           68:    		ADDWF	__AARGB4,F
  4E10    50F4     MOVF 0xff4, W, ACCESS          69:    		MOVF	PRODH,W
  4E12    2206     ADDWFC 0x6, F, ACCESS          70:    		ADDWFC	__AARGB3,F
  4E14    6AE8     CLRF 0xfe8, ACCESS             71:    		CLRF	WREG
  4E16    2207     ADDWFC 0x7, F, ACCESS          72:    		ADDWFC	__AARGB2,F
                                                  73:    	
  4E18    5009     MOVF 0x9, W, ACCESS            74:    		MOVF	__AARGB0,W
  4E1A    020C     MULWF 0xc, ACCESS              75:    		MULWF	__BARGB2
  4E1C    50F3     MOVF 0xff3, W, ACCESS          76:    		MOVF	PRODL,W
  4E1E    2606     ADDWF 0x6, F, ACCESS           77:    		ADDWF	__AARGB3,F
  4E20    50F4     MOVF 0xff4, W, ACCESS          78:    		MOVF	PRODH,W
  4E22    2207     ADDWFC 0x7, F, ACCESS          79:    		ADDWFC	__AARGB2,F
  4E24    5009     MOVF 0x9, W, ACCESS            80:    		MOVF	__AARGB0,W
  4E26    020D     MULWF 0xd, ACCESS              81:    		MULWF	__BARGB1
  4E28    6A08     CLRF 0x8, ACCESS               82:    		CLRF	__AARGB1
  4E2A    6AE8     CLRF 0xfe8, ACCESS             83:    		CLRF	WREG
  4E2C    2208     ADDWFC 0x8, F, ACCESS          84:    		ADDWFC	__AARGB1,F
  4E2E    50F3     MOVF 0xff3, W, ACCESS          85:    		MOVF	PRODL,W
  4E30    2607     ADDWF 0x7, F, ACCESS           86:    		ADDWF	__AARGB2,F
  4E32    50F4     MOVF 0xff4, W, ACCESS          87:    		MOVF	PRODH,W
  4E34    2208     ADDWFC 0x8, F, ACCESS          88:    		ADDWFC	__AARGB1,F
                                                  89:    
  4E36    5011     MOVF 0x11, W, ACCESS           90:    		MOVF	__TEMPB2,W
  4E38    020E     MULWF 0xe, ACCESS              91:    		MULWF	__BARGB0
  4E3A    50F3     MOVF 0xff3, W, ACCESS          92:    		MOVF	PRODL,W
  4E3C    2606     ADDWF 0x6, F, ACCESS           93:    		ADDWF	__AARGB3,F
  4E3E    50F4     MOVF 0xff4, W, ACCESS          94:    		MOVF	PRODH,W
  4E40    2207     ADDWFC 0x7, F, ACCESS          95:    		ADDWFC	__AARGB2,F
  4E42    6A09     CLRF 0x9, ACCESS               96:    		CLRF	__AARGB0
  4E44    6AE8     CLRF 0xfe8, ACCESS             97:    		CLRF	WREG
  4E46    2208     ADDWFC 0x8, F, ACCESS          98:    		ADDWFC	__AARGB1,F
  4E48    2209     ADDWFC 0x9, F, ACCESS          99:    		ADDWFC	__AARGB0,F
                                                  100:   
  4E4A    5012     MOVF 0x12, W, ACCESS           101:   		MOVF	__TEMPB1,W
  4E4C    020E     MULWF 0xe, ACCESS              102:   		MULWF	__BARGB0
  4E4E    50F3     MOVF 0xff3, W, ACCESS          103:   		MOVF	PRODL,W
  4E50    2607     ADDWF 0x7, F, ACCESS           104:   		ADDWF	__AARGB2,F
  4E52    50F4     MOVF 0xff4, W, ACCESS          105:   		MOVF	PRODH,W
  4E54    2208     ADDWFC 0x8, F, ACCESS          106:   		ADDWFC	__AARGB1,F
  4E56    6AE8     CLRF 0xfe8, ACCESS             107:   		CLRF	WREG
  4E58    2209     ADDWFC 0x9, F, ACCESS          108:   		ADDWFC	__AARGB0,F
                                                  109:   
  4E5A    5013     MOVF 0x13, W, ACCESS           110:   		MOVF	__TEMPB0,W
  4E5C    020E     MULWF 0xe, ACCESS              111:   		MULWF	__BARGB0
  4E5E    50F3     MOVF 0xff3, W, ACCESS          112:   		MOVF	PRODL,W
  4E60    2608     ADDWF 0x8, F, ACCESS           113:   		ADDWF	__AARGB1,F
  4E62    50F4     MOVF 0xff4, W, ACCESS          114:   		MOVF	PRODH,W
  4E64    2209     ADDWFC 0x9, F, ACCESS          115:   		ADDWFC	__AARGB0,F
                                                  116:   
  4E66    0C00     RETLW 0                        117:   		RETLW	0x00
---  C:\MCC18\src\traditional\math\fxm3232.c  ----------------------------------------------------
1:                 /* a signed multiply is only different from an unsigned multiply
2:                  * if the upper bytes of the result matter, which for us they
3:                  * don't.
4:                  */
5:                 
6:                 #define PRODH	(PRODL + 1)
7:                 
8:                 extern near unsigned char __AARGB3, __BARGB3;
9:                 extern near unsigned char __AARGB7;
10:                void FXM3232 (void)
11:                {
12:                  _asm
13:                    movf __AARGB3, 0, 0
  517A    5006     MOVF 0x6, W, ACCESS
14:                    mulwf __BARGB3, 0
  517C    020B     MULWF 0xb, ACCESS
15:                    // low byte of both operands, so result adds into the low order
16:                    // result bytes
17:                    movff PRODL, __AARGB7
  517E    CFF3     MOVFF 0xff3, 0x2
  5180    F002     NOP
18:                    movff PRODH, __AARGB7 + 1
  5182    CFF4     MOVFF 0xff4, 0x3
  5184    F003     NOP
19:                    // W still contains AARGB3
20:                    mulwf __BARGB3 + 1, 0
  5186    020C     MULWF 0xc, ACCESS
21:                    // BARGB3[1], so result adds into AARGB7[1,2]
22:                    movf PRODL, 0, 0
  5188    50F3     MOVF 0xff3, W, ACCESS
23:                    addwf __AARGB7 + 1, 1, 0
  518A    2603     ADDWF 0x3, F, ACCESS
24:                    movlw 0
  518C    0E00     MOVLW 0
25:                    addwfc PRODH, 0, 0
  518E    20F4     ADDWFC 0xff4, W, ACCESS
26:                    movwf __AARGB7 + 2, 0
  5190    6E04     MOVWF 0x4, ACCESS
27:                    // reload AARGB3 to continue
28:                    movf __AARGB3, 0, 0
  5192    5006     MOVF 0x6, W, ACCESS
29:                    mulwf __BARGB3 + 2, 0
  5194    020D     MULWF 0xd, ACCESS
30:                    // BARGB3[2], so result adds into AARGB7[2,3]
31:                    movf PRODL, 0, 0
  5196    50F3     MOVF 0xff3, W, ACCESS
32:                    addwf __AARGB7 + 2, 1, 0
  5198    2604     ADDWF 0x4, F, ACCESS
33:                    movlw 0
  519A    0E00     MOVLW 0
34:                    addwfc PRODH, 0, 0
  519C    20F4     ADDWFC 0xff4, W, ACCESS
35:                    movwf __AARGB7 + 3, 0
  519E    6E05     MOVWF 0x5, ACCESS
36:                    // reload AARGB3 to continue
37:                    movf __AARGB3, 0, 0
  51A0    5006     MOVF 0x6, W, ACCESS
38:                    mulwf __BARGB3 + 3, 0
  51A2    020E     MULWF 0xe, ACCESS
39:                    // BARGB3[3], so result adds into AARGB7[3]. 
40:                    // we don't care about result bytes above AARGB7[3], ignore prodh here.
41:                    movf PRODL, 0, 0
  51A4    50F3     MOVF 0xff3, W, ACCESS
42:                    addwf __AARGB7 + 3, 1, 0
  51A6    2605     ADDWF 0x5, F, ACCESS
43:                    // that's the end of all terms involving AARGB3[0].
44:                    // load AARGB3[1] to continue
45:                    movf __AARGB3 + 1, 0, 0
  51A8    5007     MOVF 0x7, W, ACCESS
46:                    mulwf __BARGB3, 0
  51AA    020B     MULWF 0xb, ACCESS
47:                    // AARGB3[1], so result adds into AARGB7[1,2]
48:                    movf PRODL, 0, 0
  51AC    50F3     MOVF 0xff3, W, ACCESS
49:                    addwf __AARGB7 + 1, 1, 0
  51AE    2603     ADDWF 0x3, F, ACCESS
50:                    movf PRODH, 0, 0
  51B0    50F4     MOVF 0xff4, W, ACCESS
51:                    addwfc __AARGB7 + 2, 1, 0
  51B2    2204     ADDWFC 0x4, F, ACCESS
52:                    movlw 0
  51B4    0E00     MOVLW 0
53:                    addwfc __AARGB7 + 3, 1, 0
  51B6    2205     ADDWFC 0x5, F, ACCESS
54:                    // reload AARGB3[1] to continue
55:                    movf __AARGB3 + 1, 0, 0
  51B8    5007     MOVF 0x7, W, ACCESS
56:                    mulwf __BARGB3 + 1, 0
  51BA    020C     MULWF 0xc, ACCESS
57:                    // AARGB3[1] and BARGB3[1], so result adds into AARGB7[2,3]
58:                    movf PRODL, 0, 0
  51BC    50F3     MOVF 0xff3, W, ACCESS
59:                    addwf __AARGB7 + 2, 1, 0
  51BE    2604     ADDWF 0x4, F, ACCESS
60:                    movf PRODH, 0, 0
  51C0    50F4     MOVF 0xff4, W, ACCESS
61:                    addwfc __AARGB7 + 3, 1, 0
  51C2    2205     ADDWFC 0x5, F, ACCESS
62:                    // reload AARGB3[1] to continue
63:                    movf __AARGB3 + 1, 0, 0
  51C4    5007     MOVF 0x7, W, ACCESS
64:                    mulwf __BARGB3 + 2, 0
  51C6    020D     MULWF 0xd, ACCESS
65:                    // AARGB3[1] and BARGB3[2], so result adds into AARGB7[3]
66:                    // we don't care about result bytes above AARGB7[3], ignore prodh here.
67:                    movf PRODL, 0, 0
  51C8    50F3     MOVF 0xff3, W, ACCESS
68:                    addwf __AARGB7 + 3, 1, 0
  51CA    2605     ADDWF 0x5, F, ACCESS
69:                    // all bytes of the term from the product of AARGB3[1] and BARGB3[3] are
70:                    // above our 32-bit result, don't even need to bother calculating
71:                    // that term.
72:                    // load AARGB3[2] to continue
73:                    movf __AARGB3 + 2, 0, 0
  51CC    5008     MOVF 0x8, W, ACCESS
74:                    mulwf __BARGB3, 0
  51CE    020B     MULWF 0xb, ACCESS
75:                    // AARGB3[2] and BARGB3[0], so result adds into AARGB7[2,3]
76:                    movf PRODL, 0, 0
  51D0    50F3     MOVF 0xff3, W, ACCESS
77:                    addwf __AARGB7 + 2, 1, 0
  51D2    2604     ADDWF 0x4, F, ACCESS
78:                    movf PRODH, 0, 0
  51D4    50F4     MOVF 0xff4, W, ACCESS
79:                    addwfc __AARGB7 + 3, 1, 0
  51D6    2205     ADDWFC 0x5, F, ACCESS
80:                    // reload AARGB3[2] to continue
81:                    movf __AARGB3 + 2, 0, 0
  51D8    5008     MOVF 0x8, W, ACCESS
82:                    mulwf __BARGB3 + 1, 0
  51DA    020C     MULWF 0xc, ACCESS
83:                    // AARGB3[2] and BARGB3[1], so result adds into AARGB7[3]
84:                    // we don't care about result bytes above AARGB7[3], ignore prodh here.
85:                    movf PRODL, 0, 0
  51DC    50F3     MOVF 0xff3, W, ACCESS
86:                    addwf __AARGB7 + 3, 1, 0
  51DE    2605     ADDWF 0x5, F, ACCESS
87:                    // all bytes of the termsfrom the products of AARGB3[2] and BARGB3[2,3] are
88:                    // above our 32-bit result, don't even need to bother calculating
89:                    // those terms.
90:                    // load AARGB3[3] to continue
91:                    movf __AARGB3 + 3, 0, 0
  51E0    5009     MOVF 0x9, W, ACCESS
92:                    mulwf __BARGB3, 0
  51E2    020B     MULWF 0xb, ACCESS
93:                    // AARGB3[3] and BARGB3[0], so result adds into AARGB7[3]
94:                    movf PRODL, 0, 0
  51E4    50F3     MOVF 0xff3, W, ACCESS
95:                    addwf __AARGB7 + 3, 1, 0
  51E6    2605     ADDWF 0x5, F, ACCESS
96:                
97:                    _endasm;
98:                }
  51E8    0012     RETURN 0
---  C:\MCC18\src\traditional\math\pow2x16.c  ----------------------------------------------------
1:                 void pow2x16 (void)
2:                 {
3:                   /* exponent in wreg, leave result in PROD */
4:                   _asm
5:                     clrf PRODL, 0
  530E    6AF3     CLRF 0xff3, ACCESS
6:                     clrf PRODL+1, 0
  5310    6AF4     CLRF 0xff4, ACCESS
7:                     incf PRODL, 1, 0
  5312    2AF3     INCF 0xff3, F, ACCESS
8:                     andlw 0x0f
  5314    0B0F     ANDLW 0xf
9:                     bz 5
  5316    E005     BZ 0x5322
10:                    bcf STATUS, 0, 0
  5318    90D8     BCF 0xfd8, 0, ACCESS
11:                    rlcf PRODL, 1, 0
  531A    36F3     RLCF 0xff3, F, ACCESS
12:                    rlcf PRODL+1, 1, 0
  531C    36F4     RLCF 0xff4, F, ACCESS
13:                    decf WREG, 0, 0
  531E    04E8     DECF 0xfe8, W, ACCESS
14:                    bnz -5
  5320    E1FB     BNZ 0x5318
15:                  _endasm
16:                }
  5322    0012     RETURN 0
---  C:\MCC18\src\traditional\proc\p18F26J50.asm  ------------------------------------------------
                                                  1:             LIST P=18F26J50
                                                  2:             NOLIST
                                                  3:     ;-------------------------------------------------------------------------
                                                  4:     ; MPLAB-Cxx  PIC18F26J50 processor definition module
                                                  5:     ; 
                                                  6:     ; (c) Copyright 1999-2009 Microchip Technology, All rights reserved
                                                  7:     ;-------------------------------------------------------------------------
                                                  8:     
                                                  9:     SFR_UNBANKED0       UDATA_ACS H'F60'
                                                  10:    
                                                  11:    UFRM                
                                                  12:    UFRML               
                                                  13:    UFRMLbits           RES 1     ; 0xF60
                                                  14:    UFRMH               
                                                  15:    UFRMHbits           RES 1     ; 0xF61
                                                  16:    UIR                 
                                                  17:    UIRbits             RES 1     ; 0xF62
                                                  18:    UEIR                
                                                  19:    UEIRbits            RES 1     ; 0xF63
                                                  20:    USTAT               
                                                  21:    USTATbits           RES 1     ; 0xF64
                                                  22:    UCON                
                                                  23:    UCONbits            RES 1     ; 0xF65
                                                  24:    DMABCH              
                                                  25:    DMABCHbits          RES 1     ; 0xF66
                                                  26:    DMABCL              RES 1     ; 0xF67
                                                  27:    RXADDRH             
                                                  28:    RXADDRHbits         RES 1     ; 0xF68
                                                  29:    RXADDRL             RES 1     ; 0xF69
                                                  30:    TXADDRH             
                                                  31:    TXADDRHbits         RES 1     ; 0xF6A
                                                  32:    TXADDRL             RES 1     ; 0xF6B
                                                  33:                        RES 4
                                                  34:    CMSTAT              
                                                  35:    CMSTATbits          
                                                  36:    CMSTATUS            
                                                  37:    CMSTATUSbits        RES 1     ; 0xF70
                                                  38:    SSP2CON2            
                                                  39:    SSP2CON2bits        RES 1     ; 0xF71
                                                  40:    SSP2CON1            
                                                  41:    SSP2CON1bits        RES 1     ; 0xF72
                                                  42:    SSP2STAT            
                                                  43:    SSP2STATbits        RES 1     ; 0xF73
                                                  44:    SSP2ADD             
                                                  45:    SSP2ADDbits         RES 1     ; 0xF74
                                                  46:    SSP2BUF             RES 1     ; 0xF75
                                                  47:    T4CON               
                                                  48:    T4CONbits           RES 1     ; 0xF76
                                                  49:    PR4                 RES 1     ; 0xF77
                                                  50:    TMR4                RES 1     ; 0xF78
                                                  51:    T3CON               
                                                  52:    T3CONbits           RES 1     ; 0xF79
                                                  53:    TMR3L               RES 1     ; 0xF7A
                                                  54:    TMR3H               RES 1     ; 0xF7B
                                                  55:    BAUDCON2            
                                                  56:    BAUDCON2bits        RES 1     ; 0xF7C
                                                  57:    SPBRGH2             RES 1     ; 0xF7D
                                                  58:    BAUDCON             
                                                  59:    BAUDCONbits         
                                                  60:    BAUDCON1            
                                                  61:    BAUDCON1bits        
                                                  62:    BAUDCTL             
                                                  63:    BAUDCTLbits         RES 1     ; 0xF7E
                                                  64:    SPBRGH              
                                                  65:    SPBRGH1             RES 1     ; 0xF7F
                                                  66:    PORTA               
                                                  67:    PORTAbits           RES 1     ; 0xF80
                                                  68:    PORTB               
                                                  69:    PORTBbits           RES 1     ; 0xF81
                                                  70:    PORTC               
                                                  71:    PORTCbits           RES 1     ; 0xF82
                                                  72:                        RES 2
                                                  73:    HLVDCON             
                                                  74:    HLVDCONbits         RES 1     ; 0xF85
                                                  75:    DMACON2             
                                                  76:    DMACON2bits         RES 1     ; 0xF86
                                                  77:                        RES 1
                                                  78:    DMACON1             
                                                  79:    DMACON1bits         RES 1     ; 0xF88
                                                  80:    LATA                
                                                  81:    LATAbits            RES 1     ; 0xF89
                                                  82:    LATB                
                                                  83:    LATBbits            RES 1     ; 0xF8A
                                                  84:    LATC                
                                                  85:    LATCbits            RES 1     ; 0xF8B
                                                  86:                        RES 2
                                                  87:    ALRMVALL            RES 1     ; 0xF8E
                                                  88:    ALRMVALH            RES 1     ; 0xF8F
                                                  89:    ALRMRPT             
                                                  90:    ALRMRPTbits         RES 1     ; 0xF90
                                                  91:    ALRMCFG             
                                                  92:    ALRMCFGbits         RES 1     ; 0xF91
                                                  93:    TRISA               
                                                  94:    TRISAbits           RES 1     ; 0xF92
                                                  95:    TRISB               
                                                  96:    TRISBbits           RES 1     ; 0xF93
                                                  97:    TRISC               
                                                  98:    TRISCbits           RES 1     ; 0xF94
                                                  99:                        RES 2
                                                  100:   T3GCON              
                                                  101:   T3GCONbits          RES 1     ; 0xF97
                                                  102:   RTCVALL             RES 1     ; 0xF98
                                                  103:   RTCVALH             RES 1     ; 0xF99
                                                  104:   T1GCON              
                                                  105:   T1GCONbits          RES 1     ; 0xF9A
                                                  106:   OSCTUNE             
                                                  107:   OSCTUNEbits         RES 1     ; 0xF9B
                                                  108:   RCSTA2              
                                                  109:   RCSTA2bits          RES 1     ; 0xF9C
                                                  110:   PIE1                
                                                  111:   PIE1bits            RES 1     ; 0xF9D
                                                  112:   PIR1                
                                                  113:   PIR1bits            RES 1     ; 0xF9E
                                                  114:   IPR1                
                                                  115:   IPR1bits            RES 1     ; 0xF9F
                                                  116:   PIE2                
                                                  117:   PIE2bits            RES 1     ; 0xFA0
                                                  118:   PIR2                
                                                  119:   PIR2bits            RES 1     ; 0xFA1
                                                  120:   IPR2                
                                                  121:   IPR2bits            RES 1     ; 0xFA2
                                                  122:   PIE3                
                                                  123:   PIE3bits            RES 1     ; 0xFA3
                                                  124:   PIR3                
                                                  125:   PIR3bits            RES 1     ; 0xFA4
                                                  126:   IPR3                
                                                  127:   IPR3bits            RES 1     ; 0xFA5
                                                  128:   EECON1              
                                                  129:   EECON1bits          RES 1     ; 0xFA6
                                                  130:   EECON2              RES 1     ; 0xFA7
                                                  131:   TXSTA2              
                                                  132:   TXSTA2bits          RES 1     ; 0xFA8
                                                  133:   TXREG2              RES 1     ; 0xFA9
                                                  134:   RCREG2              RES 1     ; 0xFAA
                                                  135:   SPBRG2              RES 1     ; 0xFAB
                                                  136:   RCSTA               
                                                  137:   RCSTAbits           
                                                  138:   RCSTA1              
                                                  139:   RCSTA1bits          RES 1     ; 0xFAC
                                                  140:   TXSTA               
                                                  141:   TXSTAbits           
                                                  142:   TXSTA1              
                                                  143:   TXSTA1bits          RES 1     ; 0xFAD
                                                  144:   TXREG               
                                                  145:   TXREG1              RES 1     ; 0xFAE
                                                  146:   RCREG               
                                                  147:   RCREG1              RES 1     ; 0xFAF
                                                  148:   SPBRG               
                                                  149:   SPBRG1              RES 1     ; 0xFB0
                                                  150:   CTMUICON            
                                                  151:   CTMUICONbits        RES 1     ; 0xFB1
                                                  152:   CTMUCONL            
                                                  153:   CTMUCONLbits        RES 1     ; 0xFB2
                                                  154:   CTMUCONH            
                                                  155:   CTMUCONHbits        RES 1     ; 0xFB3
                                                  156:   CCP2CON             
                                                  157:   CCP2CONbits         
                                                  158:   ECCP2CON            
                                                  159:   ECCP2CONbits        RES 1     ; 0xFB4
                                                  160:   CCPR2               
                                                  161:   CCPR2L              RES 1     ; 0xFB5
                                                  162:   CCPR2H              RES 1     ; 0xFB6
                                                  163:   ECCP2DEL            
                                                  164:   ECCP2DELbits        
                                                  165:   PWM2CON             
                                                  166:   PWM2CONbits         RES 1     ; 0xFB7
                                                  167:   ECCP2AS             
                                                  168:   ECCP2ASbits         RES 1     ; 0xFB8
                                                  169:   PSTR2CON            
                                                  170:   PSTR2CONbits        RES 1     ; 0xFB9
                                                  171:   CCP1CON             
                                                  172:   CCP1CONbits         
                                                  173:   ECCP1CON            
                                                  174:   ECCP1CONbits        RES 1     ; 0xFBA
                                                  175:   CCPR1               
                                                  176:   CCPR1L              RES 1     ; 0xFBB
                                                  177:   CCPR1H              RES 1     ; 0xFBC
                                                  178:   ECCP1DEL            
                                                  179:   ECCP1DELbits        
                                                  180:   PWM1CON             
                                                  181:   PWM1CONbits         RES 1     ; 0xFBD
                                                  182:   ECCP1AS             
                                                  183:   ECCP1ASbits         RES 1     ; 0xFBE
                                                  184:   PSTR1CON            
                                                  185:   PSTR1CONbits        RES 1     ; 0xFBF
                                                  186:   WDTCON              
                                                  187:   WDTCONbits          RES 1     ; 0xFC0
                                                  188:   ADCON1              
                                                  189:   ADCON1bits          RES 1     ; 0xFC1
                                                  190:   ADCON0              
                                                  191:   ADCON0bits          RES 1     ; 0xFC2
                                                  192:   ADRES               
                                                  193:   ADRESL              RES 1     ; 0xFC3
                                                  194:   ADRESH              RES 1     ; 0xFC4
                                                  195:   SSP1CON2            
                                                  196:   SSP1CON2bits        
                                                  197:   SSPCON2             
                                                  198:   SSPCON2bits         RES 1     ; 0xFC5
                                                  199:   SSP1CON1            
                                                  200:   SSP1CON1bits        
                                                  201:   SSPCON1             
                                                  202:   SSPCON1bits         RES 1     ; 0xFC6
                                                  203:   SSP1STAT            
                                                  204:   SSP1STATbits        
                                                  205:   SSPSTAT             
                                                  206:   SSPSTATbits         RES 1     ; 0xFC7
                                                  207:   SSP1ADD             
                                                  208:   SSP1ADDbits         
                                                  209:   SSPADD              
                                                  210:   SSPADDbits          RES 1     ; 0xFC8
                                                  211:   SSP1BUF             
                                                  212:   SSPBUF              RES 1     ; 0xFC9
                                                  213:   T2CON               
                                                  214:   T2CONbits           RES 1     ; 0xFCA
                                                  215:   PR2                 RES 1     ; 0xFCB
                                                  216:   TMR2                RES 1     ; 0xFCC
                                                  217:   T1CON               
                                                  218:   T1CONbits           RES 1     ; 0xFCD
                                                  219:   TMR1L               RES 1     ; 0xFCE
                                                  220:   TMR1H               RES 1     ; 0xFCF
                                                  221:   RCON                
                                                  222:   RCONbits            RES 1     ; 0xFD0
                                                  223:   CM2CON              
                                                  224:   CM2CONbits          
                                                  225:   CM2CON1             
                                                  226:   CM2CON1bits         RES 1     ; 0xFD1
                                                  227:   CM1CON              
                                                  228:   CM1CONbits          
                                                  229:   CM1CON1             
                                                  230:   CM1CON1bits         RES 1     ; 0xFD2
                                                  231:   OSCCON              
                                                  232:   OSCCONbits          RES 1     ; 0xFD3
                                                  233:                       RES 1
                                                  234:   T0CON               
                                                  235:   T0CONbits           RES 1     ; 0xFD5
                                                  236:   TMR0L               RES 1     ; 0xFD6
                                                  237:   TMR0H               RES 1     ; 0xFD7
                                                  238:   STATUS              
                                                  239:   STATUSbits          RES 1     ; 0xFD8
                                                  240:   FSR2                
                                                  241:   FSR2L               RES 1     ; 0xFD9
                                                  242:   FSR2H               RES 1     ; 0xFDA
                                                  243:   PLUSW2              RES 1     ; 0xFDB
                                                  244:   PREINC2             RES 1     ; 0xFDC
                                                  245:   POSTDEC2            RES 1     ; 0xFDD
                                                  246:   POSTINC2            RES 1     ; 0xFDE
                                                  247:   INDF2               RES 1     ; 0xFDF
                                                  248:   BSR                 RES 1     ; 0xFE0
                                                  249:   FSR1                
                                                  250:   FSR1L               RES 1     ; 0xFE1
                                                  251:   FSR1H               RES 1     ; 0xFE2
                                                  252:   PLUSW1              RES 1     ; 0xFE3
                                                  253:   PREINC1             RES 1     ; 0xFE4
                                                  254:   POSTDEC1            RES 1     ; 0xFE5
                                                  255:   POSTINC1            RES 1     ; 0xFE6
                                                  256:   INDF1               RES 1     ; 0xFE7
                                                  257:   WREG                RES 1     ; 0xFE8
                                                  258:   FSR0                
                                                  259:   FSR0L               RES 1     ; 0xFE9
                                                  260:   FSR0H               RES 1     ; 0xFEA
                                                  261:   PLUSW0              RES 1     ; 0xFEB
                                                  262:   PREINC0             RES 1     ; 0xFEC
                                                  263:   POSTDEC0            RES 1     ; 0xFED
                                                  264:   POSTINC0            RES 1     ; 0xFEE
                                                  265:   INDF0               RES 1     ; 0xFEF
                                                  266:   INTCON3             
                                                  267:   INTCON3bits         RES 1     ; 0xFF0
                                                  268:   INTCON2             
                                                  269:   INTCON2bits         RES 1     ; 0xFF1
                                                  270:   INTCON              
                                                  271:   INTCONbits          RES 1     ; 0xFF2
                                                  272:   PROD                
                                                  273:   PRODL               RES 1     ; 0xFF3
                                                  274:   PRODH               RES 1     ; 0xFF4
                                                  275:   TABLAT              RES 1     ; 0xFF5
                                                  276:   TBLPTR              
                                                  277:   TBLPTRL             RES 1     ; 0xFF6
                                                  278:   TBLPTRH             RES 1     ; 0xFF7
                                                  279:   TBLPTRU             RES 1     ; 0xFF8
                                                  280:   PC                  
                                                  281:   PCL                 RES 1     ; 0xFF9
                                                  282:   PCLATH              RES 1     ; 0xFFA
                                                  283:   PCLATU              RES 1     ; 0xFFB
                                                  284:   STKPTR              
                                                  285:   STKPTRbits          RES 1     ; 0xFFC
                                                  286:   TOS                 
                                                  287:   TOSL                RES 1     ; 0xFFD
                                                  288:   TOSH                RES 1     ; 0xFFE
                                                  289:   TOSU                RES 1     ; 0xFFF
                                                  290:   
                                                  291:   SFR_BANKED0         UDATA H'EC6'
                                                  292:   
                                                  293:   RPOR0               RES 1     ; 0xEC6
                                                  294:   RPOR1               RES 1     ; 0xEC7
                                                  295:   RPOR2               RES 1     ; 0xEC8
                                                  296:   RPOR3               RES 1     ; 0xEC9
                                                  297:   RPOR4               RES 1     ; 0xECA
                                                  298:   RPOR5               RES 1     ; 0xECB
                                                  299:   RPOR6               RES 1     ; 0xECC
                                                  300:   RPOR7               RES 1     ; 0xECD
                                                  301:   RPOR8               RES 1     ; 0xECE
                                                  302:   RPOR9               RES 1     ; 0xECF
                                                  303:   RPOR10              RES 1     ; 0xED0
                                                  304:   RPOR11              RES 1     ; 0xED1
                                                  305:   RPOR12              RES 1     ; 0xED2
                                                  306:   RPOR13              RES 1     ; 0xED3
                                                  307:   
                                                  308:   SFR_BANKED1         UDATA H'ED7'
                                                  309:   RPOR17              RES 1     ; 0xED7
                                                  310:   RPOR18              RES 1     ; 0xED8
                                                  311:   
                                                  312:   SFR_BANKED2         UDATA H'EE7'
                                                  313:   RPINR1              RES 1     ; 0xEE7
                                                  314:   RPINR2              RES 1     ; 0xEE8
                                                  315:   RPINR3              RES 1     ; 0xEE9
                                                  316:   RPINR4              RES 1     ; 0xEEA
                                                  317:   
                                                  318:   SFR_BANKED3         UDATA H'EEC'
                                                  319:   RPINR6              RES 1     ; 0xEEC
                                                  320:   RPINR7              RES 1     ; 0xEED
                                                  321:   RPINR8              RES 1     ; 0xEEE
                                                  322:   
                                                  323:   SFR_BANKED4         UDATA H'EF2'
                                                  324:   RPINR12             RES 1     ; 0xEF2
                                                  325:   RPINR13             RES 1     ; 0xEF3
                                                  326:   
                                                  327:   SFR_BANKED5         UDATA H'EF6'
                                                  328:   RPINR16             RES 1     ; 0xEF6
                                                  329:   RPINR17             RES 1     ; 0xEF7
                                                  330:   
                                                  331:   SFR_BANKED6         UDATA H'EFB'
                                                  332:   RPINR21             RES 1     ; 0xEFB
                                                  333:   RPINR22             RES 1     ; 0xEFC
                                                  334:   RPINR23             RES 1     ; 0xEFD
                                                  335:   RPINR24             RES 1     ; 0xEFE
                                                  336:   PPSCON              
                                                  337:   PPSCONbits          RES 1     ; 0xEFF
                                                  338:   
                                                  339:   SFR_BANKED7         UDATA H'F26'
                                                  340:   UEP0                
                                                  341:   UEP0bits            RES 1     ; 0xF26
                                                  342:   UEP1                
                                                  343:   UEP1bits            RES 1     ; 0xF27
                                                  344:   UEP2                
                                                  345:   UEP2bits            RES 1     ; 0xF28
                                                  346:   UEP3                
                                                  347:   UEP3bits            RES 1     ; 0xF29
                                                  348:   UEP4                
                                                  349:   UEP4bits            RES 1     ; 0xF2A
                                                  350:   UEP5                
                                                  351:   UEP5bits            RES 1     ; 0xF2B
                                                  352:   UEP6                
                                                  353:   UEP6bits            RES 1     ; 0xF2C
                                                  354:   UEP7                
                                                  355:   UEP7bits            RES 1     ; 0xF2D
                                                  356:   UEP8                
                                                  357:   UEP8bits            RES 1     ; 0xF2E
                                                  358:   UEP9                
                                                  359:   UEP9bits            RES 1     ; 0xF2F
                                                  360:   UEP10               
                                                  361:   UEP10bits           RES 1     ; 0xF30
                                                  362:   UEP11               
                                                  363:   UEP11bits           RES 1     ; 0xF31
                                                  364:   UEP12               
                                                  365:   UEP12bits           RES 1     ; 0xF32
                                                  366:   UEP13               
                                                  367:   UEP13bits           RES 1     ; 0xF33
                                                  368:   UEP14               
                                                  369:   UEP14bits           RES 1     ; 0xF34
                                                  370:   UEP15               
                                                  371:   UEP15bits           RES 1     ; 0xF35
                                                  372:   UIE                 
                                                  373:   UIEbits             RES 1     ; 0xF36
                                                  374:   UEIE                
                                                  375:   UEIEbits            RES 1     ; 0xF37
                                                  376:   UADDR               
                                                  377:   UADDRbits           RES 1     ; 0xF38
                                                  378:   UCFG                
                                                  379:   UCFGbits            RES 1     ; 0xF39
                                                  380:   
                                                  381:   SFR_BANKED8         UDATA H'F3C'
                                                  382:   PADCFG1             
                                                  383:   PADCFG1bits         RES 1     ; 0xF3C
                                                  384:   REFOCON             
                                                  385:   REFOCONbits         RES 1     ; 0xF3D
                                                  386:   RTCCAL              
                                                  387:   RTCCALbits          RES 1     ; 0xF3E
                                                  388:   RTCCFG              
                                                  389:   RTCCFGbits          RES 1     ; 0xF3F
                                                  390:   ODCON3              
                                                  391:   ODCON3bits          RES 1     ; 0xF40
                                                  392:   ODCON2              
                                                  393:   ODCON2bits          RES 1     ; 0xF41
                                                  394:   ODCON1              
                                                  395:   ODCON1bits          RES 1     ; 0xF42
                                                  396:   
                                                  397:   SFR_BANKED9         UDATA H'F48'
                                                  398:   ANCON0              
                                                  399:   ANCON0bits          RES 1     ; 0xF48
                                                  400:   ANCON1              
                                                  401:   ANCON1bits          RES 1     ; 0xF49
                                                  402:   DSWAKEL             
                                                  403:   DSWAKELbits         RES 1     ; 0xF4A
                                                  404:   DSWAKEH             
                                                  405:   DSWAKEHbits         RES 1     ; 0xF4B
                                                  406:   DSCONL              
                                                  407:   DSCONLbits          RES 1     ; 0xF4C
                                                  408:   DSCONH              
                                                  409:   DSCONHbits          RES 1     ; 0xF4D
                                                  410:   DSGPR0              RES 1     ; 0xF4E
                                                  411:   DSGPR1              RES 1     ; 0xF4F
                                                  412:   
                                                  413:   SFR_BANKED10        UDATA H'F52'
                                                  414:   TCLKCON             
                                                  415:   TCLKCONbits         RES 1     ; 0xF52
                                                  416:   CVRCON              
                                                  417:   CVRCONbits          RES 1     ; 0xF53
                                                  418:   
                                                  419:   ;*** Set all of memory to zeroes ***/
                                                  420:   ; Use FSR0 to increment through memory from address 0x0
                                                  421:   ; to the end of the last bank skipping sfrs and
                                                  422:   ; unimplemented addresses.
                                                  423:   
                                                  424:       CODE
                                                  425:   __zero_memory
  52B6    0EC0     MOVLW 0xc0                     426:       movlw  0xC0      ;low byte of (end address + 1)
  52B8    6EF3     MOVWF 0xff3, ACCESS            427:       movwf  PRODL, 0
  52BA    EE00     LFSR 0, 0                      428:       lfsr   0, 0x0    ;start address
  52BC    F000     NOP
  52BE    0E0E     MOVLW 0xe                      429:       movlw  0xE       ;high byte of (end address + 1)
  52C0    D801     RCALL 0x52c4                   430:       rcall zero_block
  52C2    0012     RETURN 0                       431:       return 0
                                                  432:   zero_block
                                                  433:   loop_h
  52C4    60EA     CPFSLT 0xfea, ACCESS           434:       cpfslt FSR0H, 0
  52C6    D002     BRA 0x52cc                     435:       bra    compare_l
  52C8    6AEE     CLRF 0xfee, ACCESS             436:       clrf   POSTINC0, 0
  52CA    D7FC     BRA 0x52c4                     437:       bra    loop_h
                                                  438:   compare_l
  52CC    50F3     MOVF 0xff3, W, ACCESS          439:       movf   PRODL, 0, 0
                                                  440:   loop_l
  52CE    60E9     CPFSLT 0xfe9, ACCESS           441:       cpfslt FSR0L, 0
  52D0    0012     RETURN 0                       442:       return 0
  52D2    6AEE     CLRF 0xfee, ACCESS             443:       clrf   POSTINC0, 0
  52D4    D7FC     BRA 0x52ce                     444:       bra    loop_l
---  C:\MCC18\src\traditional\startup\c018i.c  ---------------------------------------------------
1:                 /* $Id: c018i.c,v 1.7 2006/11/15 22:53:12 moshtaa Exp $ */
2:                 
3:                 /* Copyright (c)1999 Microchip Technology */
4:                 
5:                 /* MPLAB-C18 startup code, including initialized data */
6:                 
7:                 /* external reference to __init() function */
8:                 extern void __init (void);
9:                 /* external reference to the user's main routine */
10:                extern void main (void);
11:                /* prototype for the startup function */
12:                void _entry (void);
13:                void _startup (void);
14:                /* prototype for the initialized data setup */
15:                void _do_cinit (void);
16:                
17:                extern volatile near unsigned long short TBLPTR;
18:                extern near unsigned FSR0;
19:                extern near char __FPFLAGS;
20:                #define RND 6
21:                
22:                #pragma code _entry_scn=0x000000
23:                void
24:                _entry (void)
25:                {
26:                _asm goto _startup _endasm
  0000    EF6B     GOTO 0x52d6
  0002    F029     NOP
27:                
28:                }
  0004    0012     RETURN 0
29:                #pragma code _startup_scn
30:                void
31:                _startup (void)
32:                {
33:                  _asm
34:                    // Initialize the stack pointer
35:                    lfsr 1, _stack
  52D6    EE1D     LFSR 0x1, 0xd00
  52D8    F000     NOP
36:                    lfsr 2, _stack
  52DA    EE2D     LFSR 0x2, 0xd00
  52DC    F000     NOP
37:                
38:                    clrf TBLPTRU, 0 // 1st silicon doesn't do this on POR
  52DE    6AF8     CLRF 0xff8, ACCESS
39:                
40:                    bcf __FPFLAGS,RND,0 // Initialize rounding flag for floating point libs
  52E0    9C01     BCF 0x1, 0x6, ACCESS
41:                    
42:                    _endasm 
43:                    _do_cinit ();
  52E2    EC2C     CALL 0x5058, 0
  52E4    F028     NOP
44:                
45:                loop:
46:                
47:                  // If user defined __init is not found, the one in clib.lib will be used
48:                  __init ();
  52E6    EC07     CALL 0x100e, 0
  52E8    F008     NOP
49:                
50:                  // Call the user's main routine
51:                  main ();
  52EA    EC8A     CALL 0x3b14, 0
  52EC    F01D     NOP
52:                
53:                  goto loop;
  52EE    D7FB     BRA 0x52e6
54:                }                               /* end _startup() */
  52F0    0012     RETURN 0
55:                
56:                /* MPLAB-C18 initialized data memory support */
57:                /* The linker will populate the _cinit table */
58:                extern far rom struct
59:                {
60:                  unsigned short num_init;
61:                  struct _init_entry
62:                  {
63:                    unsigned long from;
64:                    unsigned long to;
65:                    unsigned long size;
66:                  }
67:                  entries[];
68:                }
69:                _cinit;
70:                
71:                #pragma code _cinit_scn
72:                void
73:                _do_cinit (void)
74:                {
75:                  /* we'll make the assumption in the following code that these statics
76:                   * will be allocated into the same bank.
77:                   */
78:                  static short long prom;
79:                  static unsigned short curr_byte;
80:                  static unsigned short curr_entry;
81:                  static short long data_ptr;
82:                
83:                  // Initialized data...
84:                  TBLPTR = (short long)&_cinit;
  5058    0E1E     MOVLW 0x1e
  505A    6EF6     MOVWF 0xff6, ACCESS
  505C    0E10     MOVLW 0x10
  505E    6EF7     MOVWF 0xff7, ACCESS
  5060    0E00     MOVLW 0
  5062    6EF8     MOVWF 0xff8, ACCESS
85:                  _asm
86:                    movlb data_ptr
  5064    0101     MOVLB 0x1
87:                    tblrdpostinc
  5066    0009     TBLRD*+
88:                    movf TABLAT, 0, 0
  5068    50F5     MOVF 0xff5, W, ACCESS
89:                    movwf curr_entry, 1
  506A    6FD4     MOVWF 0xd4, BANKED
90:                    tblrdpostinc
  506C    0009     TBLRD*+
91:                    movf TABLAT, 0, 0
  506E    50F5     MOVF 0xff5, W, ACCESS
92:                    movwf curr_entry+1, 1
  5070    6FD5     MOVWF 0xd5, BANKED
93:                  _endasm
94:                    //while (curr_entry)
95:                    //{
96:                    test:
97:                    _asm
98:                     bnz 3
  5072    E103     BNZ 0x507a
99:                    tstfsz curr_entry, 1
  5074    67D4     TSTFSZ 0xd4, BANKED
100:                   bra 1
  5076    D001     BRA 0x507a
101:                   _endasm
102:                   goto done;
  5078    D03D     BRA 0x50f4
103:                     /* Count down so we only have to look up the data in _cinit
104:                      * once.
105:                      *
106:                      * At this point we know that TBLPTR points to the top of the current
107:                      * entry in _cinit, so we can just start reading the from, to, and
108:                      * size values.
109:                      */
110:                     _asm
111:               	/* read the source address */
112:               	tblrdpostinc
  507A    0009     TBLRD*+
113:               	movf TABLAT, 0, 0
  507C    50F5     MOVF 0xff5, W, ACCESS
114:               	movwf prom, 1
  507E    6FCF     MOVWF 0xcf, BANKED
115:               	tblrdpostinc
  5080    0009     TBLRD*+
116:               	movf TABLAT, 0, 0
  5082    50F5     MOVF 0xff5, W, ACCESS
117:               	movwf prom+1, 1
  5084    6FD0     MOVWF 0xd0, BANKED
118:               	tblrdpostinc
  5086    0009     TBLRD*+
119:               	movf TABLAT, 0, 0
  5088    50F5     MOVF 0xff5, W, ACCESS
120:               	movwf prom+2, 1
  508A    6FD1     MOVWF 0xd1, BANKED
121:               	/* skip a byte since it's stored as a 32bit int */
122:               	tblrdpostinc
  508C    0009     TBLRD*+
123:               	/* read the destination address directly into FSR0 */
124:               	tblrdpostinc
  508E    0009     TBLRD*+
125:               	movf TABLAT, 0, 0
  5090    50F5     MOVF 0xff5, W, ACCESS
126:               	movwf FSR0L, 0
  5092    6EE9     MOVWF 0xfe9, ACCESS
127:               	tblrdpostinc
  5094    0009     TBLRD*+
128:               	movf TABLAT, 0, 0
  5096    50F5     MOVF 0xff5, W, ACCESS
129:               	movwf FSR0H, 0
  5098    6EEA     MOVWF 0xfea, ACCESS
130:               	/* skip two bytes since it's stored as a 32bit int */
131:               	tblrdpostinc
  509A    0009     TBLRD*+
132:               	tblrdpostinc
  509C    0009     TBLRD*+
133:               	/* read the destination address directly into FSR0 */
134:               	tblrdpostinc
  509E    0009     TBLRD*+
135:               	movf TABLAT, 0, 0
  50A0    50F5     MOVF 0xff5, W, ACCESS
136:               	movwf curr_byte, 1
  50A2    6FD2     MOVWF 0xd2, BANKED
137:               	tblrdpostinc
  50A4    0009     TBLRD*+
138:               	movf TABLAT, 0, 0
  50A6    50F5     MOVF 0xff5, W, ACCESS
139:               	movwf curr_byte+1, 1
  50A8    6FD3     MOVWF 0xd3, BANKED
140:               	/* skip two bytes since it's stored as a 32bit int */
141:               	tblrdpostinc
  50AA    0009     TBLRD*+
142:               	tblrdpostinc
  50AC    0009     TBLRD*+
143:                     _endasm  
144:                     //prom = data_ptr->from;
145:                     //FSR0 = data_ptr->to;
146:                     //curr_byte = (unsigned short) data_ptr->size;
147:                     /* the table pointer now points to the next entry. Save it
148:                      * off since we'll be using the table pointer to do the copying
149:                      * for the entry.
150:                      */
151:                     data_ptr = TBLPTR;
  50AE    CFF6     MOVFF 0xff6, 0x1d6
  50B0    F1D6     NOP
  50B2    CFF7     MOVFF 0xff7, 0x1d7
  50B4    F1D7     NOP
  50B6    CFF8     MOVFF 0xff8, 0x1d8
  50B8    F1D8     NOP
152:                     
153:                     /* now assign the source address to the table pointer */
154:                     TBLPTR = prom;
  50BA    C1CF     MOVFF 0x1cf, 0xff6
  50BC    FFF6     NOP
  50BE    C1D0     MOVFF 0x1d0, 0xff7
  50C0    FFF7     NOP
  50C2    C1D1     MOVFF 0x1d1, 0xff8
  50C4    FFF8     NOP
155:               
156:                     /* do the copy loop */
157:                     _asm
158:                       // determine if we have any more bytes to copy
159:               	movlb curr_byte
  50C6    0101     MOVLB 0x1
160:               	movf curr_byte, 1, 1
  50C8    53D2     MOVF 0xd2, F, BANKED
161:               copy_loop:
162:               	bnz 2 // copy_one_byte
  50CA    E102     BNZ 0x50d0
163:               	movf curr_byte + 1, 1, 1
  50CC    53D3     MOVF 0xd3, F, BANKED
164:               	bz 7 // done_copying
  50CE    E007     BZ 0x50de
165:               
166:               copy_one_byte:
167:               	tblrdpostinc
  50D0    0009     TBLRD*+
168:               	movf TABLAT, 0, 0
  50D2    50F5     MOVF 0xff5, W, ACCESS
169:               	movwf POSTINC0, 0
  50D4    6EEE     MOVWF 0xfee, ACCESS
170:               
171:               	// decrement byte counter
172:               	decf curr_byte, 1, 1
  50D6    07D2     DECF 0xd2, F, BANKED
173:               	bc -8 // copy_loop
  50D8    E2F8     BC 0x50ca
174:                       decf curr_byte + 1, 1, 1
  50DA    07D3     DECF 0xd3, F, BANKED
175:               	bra -7 // copy_one_byte
  50DC    D7F9     BRA 0x50d0
176:               
177:               done_copying:
178:               
179:                     _endasm
180:                     /* restore the table pointer for the next entry */
181:                     TBLPTR = data_ptr;
  50DE    C1D6     MOVFF 0x1d6, 0xff6
  50E0    FFF6     NOP
  50E2    C1D7     MOVFF 0x1d7, 0xff7
  50E4    FFF7     NOP
  50E6    C1D8     MOVFF 0x1d8, 0xff8
  50E8    FFF8     NOP
182:                     /* next entry... */
183:                     curr_entry--;
  50EA    0101     MOVLB 0x1
  50EC    07D4     DECF 0xd4, F, BANKED
  50EE    0E00     MOVLW 0
  50F0    5BD5     SUBWFB 0xd5, F, BANKED
184:                     goto test;
  50F2    D7BF     BRA 0x5072
185:               done:
186:               ;
187:               }
  50F4    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\__init.c  --------------------------------------------------
1:                 
2:                 /** @name __init
3:                  * The {\bf __init} is called if the linker can not find a
4:                  * user defined version for it
5:                  */
6:                 
7:                 void __init (void)
8:                 {
9:                 }
  100E    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\_user_putc.c  ----------------------------------------------
1:                 /* this default version should not do anything. it is entirely a
2:                    placeholder symbol. To keep code size at a minimum, it is declared
3:                    without a return value or parameters. The caller will still clean up 
4:                    the stack frame correctly. 
5:                 
6:                    When using the _H_USER stream, the function will be implemented in
7:                    application code with the prototype:   
8:                     int _user_putc (char c);
9:                   */
10:                void
11:                _user_putc (void)
12:                {
13:                }
  1006    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\isdigit.asm  -----------------------------------------------
                                                  1:     #include "P18CXXX.INC"
                                                  2:     #include "P18MACRO.INC"
                                                  3:     
                                                  4:     ; @name isdigit
                                                  5:     ;The {\bf isdigit} function tests the value of {\bf c} to determine if it
                                                  6:     ;is a digit character. A digit character is defined as any decimal digit
                                                  7:     ;character (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).
                                                  8:     ;
                                                  9:     ; int isdigit (int c);
                                                  10:    
                                                  11:    CTYPE CODE
                                                  12:    isdigit
                                                  13:      global isdigit
                                                  14:    
                                                  15:    ; Proceedure: Use FSR0 as pointer to 'c'
                                                  16:    ;         Return with result in PROD
                                                  17:    
                                                  18:      ; Clear out result
  526E    6AF3     CLRF 0xff3, ACCESS             19:              clrf      PRODL, ACCESS
  5270    6AF4     CLRF 0xff4, ACCESS             20:    	  clrf      PRODH, ACCESS
                                                  21:    	  
                                                  22:      ; Set FSR0 = FSR1 - 2 ( location of 'c')
  5272    0EFF     MOVLW 0xff                     23:              StkSetPtrToOffset FSR0L,-1
  5274    24E1     ADDWF 0xfe1, W, ACCESS
  5276    6EE9     MOVWF 0xfe9, ACCESS
  5278    0EFF     MOVLW 0xff
  527A    20E2     ADDWFC 0xfe2, W, ACCESS
  527C    6EEA     MOVWF 0xfea, ACCESS
                                                  24:    
  527E    66ED     TSTFSZ 0xfed, ACCESS           25:              tstfsz    POSTDEC0,ACCESS
  5280    D007     BRA 0x5290                     26:              bra       jNoMatch            ; upper byte must be 0 to match
                                                  27:    
                                                  28:      ; Test for condition
                                                  29:    
  5282    0E2F     MOVLW 0x2f                     30:              jmpFleL   INDF0,ACCESS,'0'-1,jNoMatch
  5284    64EF     CPFSGT 0xfef, ACCESS
  5286    D004     BRA 0x5290
  5288    0E3A     MOVLW 0x3a                     31:              jmpFgeL   INDF0,ACCESS,'9'+1,jNoMatch
  528A    60EF     CPFSLT 0xfef, ACCESS
  528C    D001     BRA 0x5290
                                                  32:    
                                                  33:    jMatch:
  528E    2AF3     INCF 0xff3, F, ACCESS          34:              incf      PRODL,F,ACCESS
                                                  35:    jNoMatch:
  5290    0012     RETURN 0                       36:              return
---  C:\MCC18\src\traditional\stdclib\mcpyp2r.asm  -----------------------------------------------
                                                  1:     ; $Id: mcpyp2r.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name memcpypgm2ram
                                                  7:     ;The {\bf memcpypgm2ram} function performs a {\bf memcpy} where
                                                  8:     ;{\bf s1} points to data memory and {\bf s2} points to program
                                                  9:     ;memory.
                                                  10:    ;@param s1 pointer to destination in data memory
                                                  11:    ;@param s2 pointer to source in program memory
                                                  12:    ;@param n number of characters to copy
                                                  13:    ;
                                                  14:    
                                                  15:    
                                                  16:    STRING CODE
                                                  17:    memcpypgm2ram
                                                  18:      global memcpypgm2ram
                                                  19:    
                                                  20:    
                                                  21:    #ifdef __SMALL__
                                                  22:     messg "memcpypgm2ram - SMALL"
                                                  23:    
                                                  24:    
                                                  25:    ; Proceedure: Two byte pointers and two byte n.
                                                  26:    ;         Use offset from top of stack to test 'n' for zero and decrement
                                                  27:    ;         it. Use FSR0 for 'dest' and TBLPTR for 'src' 
                                                  28:    ;         Assumes TBLPTRU = 0.
                                                  29:    
                                                  30:      ; Load TBLPTR with the 'src' pointer
                                                  31:    
                                                  32:              Stk2CpyToReg -4,TBLPTRL
                                                  33:    
                                                  34:      ; Load FSR0 with the 'dest' pointer
                                                  35:    
                                                  36:              Stk2CpyToReg -2,FSR0L
                                                  37:    
                                                  38:      ; make a copy for the return value
                                                  39:    	movff FSR0L, PRODL
                                                  40:    	movff FSR0H, PRODH
                                                  41:    
                                                  42:    jLoop:
                                                  43:    
                                                  44:      ; Test 2 byte n for zero
                                                  45:    
                                                  46:              Stk2TestForZero -6,jEnd
                                                  47:    
                                                  48:      ; Decrement n 
                                                  49:    
                                                  50:              Stk2Dec   -6
                                                  51:    
                                                  52:              tblrd     *+                  ; read & increment
                                                  53:    
                                                  54:              movff     TABLAT, POSTINC0
                                                  55:              bra       jLoop
                                                  56:    
                                                  57:    jEnd
                                                  58:    
                                                  59:              return
                                                  60:    
                                                  61:    #else
                                                  62:    #ifdef __LARGE__
                                                  63:     messg "memcpypgm2ram - LARGE"
                                                  64:    
                                                  65:    
                                                  66:    ; Proceedure: Three byte rom pointer.
                                                  67:    ;         Use offset from top of stack to test 'n' for zero and decrement
                                                  68:    ;         it. Use FSR0 for 'dest' and TBLPTR for 'src' 
                                                  69:    
                                                  70:      ; Load TBLPTR with the 'src' pointer
                                                  71:    
  4CF6    0EFB     MOVLW 0xfb                     72:              Stk3CpyToReg -5,TBLPTRL
  4CF8    CFE3     MOVFF 0xfe3, 0xff6
  4CFA    FFF6     NOP
  4CFC    0EFC     MOVLW 0xfc
  4CFE    CFE3     MOVFF 0xfe3, 0xff7
  4D00    FFF7     NOP
  4D02    0EFD     MOVLW 0xfd
  4D04    CFE3     MOVFF 0xfe3, 0xff8
  4D06    FFF8     NOP
                                                  73:    
                                                  74:      ; Load FSR0 with the 'dest' pointer
                                                  75:    
  4D08    0EFE     MOVLW 0xfe                     76:              Stk2CpyToReg -2,FSR0L
  4D0A    CFE3     MOVFF 0xfe3, 0xfe9
  4D0C    FFE9     NOP
  4D0E    0EFF     MOVLW 0xff
  4D10    CFE3     MOVFF 0xfe3, 0xfea
  4D12    FFEA     NOP
                                                  77:    
                                                  78:      ; make a copy for the return value
  4D14    CFE9     MOVFF 0xfe9, 0xff3             79:    	movff FSR0L, PRODL
  4D16    FFF3     NOP
  4D18    CFEA     MOVFF 0xfea, 0xff4             80:    	movff FSR0H, PRODH
  4D1A    FFF4     NOP
                                                  81:    
                                                  82:    jLoop:
                                                  83:    
                                                  84:      ; Test 2 byte n for zero
                                                  85:    
  4D1C    0EF9     MOVLW 0xf9                     86:              Stk2TestForZero -7,jEnd
  4D1E    50E3     MOVF 0xfe3, W, ACCESS
  4D20    E103     BNZ 0x4d28
  4D22    0EFA     MOVLW 0xfa
  4D24    50E3     MOVF 0xfe3, W, ACCESS
  4D26    E009     BZ 0x4d3a
                                                  87:    
                                                  88:      ; Decrement n 
                                                  89:    
  4D28    0EF9     MOVLW 0xf9                     90:              Stk2Dec   -7
  4D2A    06E3     DECF 0xfe3, F, ACCESS
  4D2C    E202     BC 0x4d32
  4D2E    0EFA     MOVLW 0xfa
  4D30    06E3     DECF 0xfe3, F, ACCESS
                                                  91:    
  4D32    0009     TBLRD*+                        92:              tblrd     *+                  ; read & increment
                                                  93:    
  4D34    CFF5     MOVFF 0xff5, 0xfee             94:              movff     TABLAT, POSTINC0
  4D36    FFEE     NOP
  4D38    D7F1     BRA 0x4d1c                     95:              bra       jLoop
                                                  96:    
                                                  97:    jEnd
                                                  98:    
  4D3A    0012     RETURN 0                       99:              return
---  C:\MCC18\src\traditional\stdclib\memcpy.asm  ------------------------------------------------
                                                  1:     ; $Id: memcpy.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name memcpy
                                                  7:     ;``The {\bf memcpy} funciton copies {\bf n} characters from the object
                                                  8:     ;pointed to by {\bf s2} into the object pointed to by {\bf s1}. If
                                                  9:     ;copying takes place between objects that overlap, the behaviour is
                                                  10:    ;undefined.''
                                                  11:    ;Stack usage: 8 bytes. Re-entrant.
                                                  12:    ;@param s1 pointer to destination
                                                  13:    ;@param s2 pointer to source
                                                  14:    ;@param n count of bytes to copy
                                                  15:    ;@return ``The {\bf memcpy} function returns the value of {\bf s1}.''
                                                  16:    ;
                                                  17:    ; void *memcpy (void *s1, const void *s2, size_t n);
                                                  18:    
                                                  19:    
                                                  20:    STRING CODE
                                                  21:    memcpy
                                                  22:      global memcpy
                                                  23:    
                                                  24:    ; Proceedure: Use offset from top of stack to test 'n' for zero and decrement
                                                  25:    ;         it. Use FSR0 for 'dest' and FSR2 for 'src' 
                                                  26:    
                                                  27:    
                                                  28:      ; Save FSR2 on the stack. 
                                                  29:    
  4CA0    CFD9     MOVFF 0xfd9, 0xfe6             30:              Stk2PushFromReg FSR2L
  4CA2    FFE6     NOP
  4CA4    CFDA     MOVFF 0xfda, 0xfe6
  4CA6    FFE6     NOP
                                                  31:    
                                                  32:      ; Load FSR2 with the 'src' pointer
                                                  33:    
  4CA8    0EFA     MOVLW 0xfa                     34:              Stk2CpyToReg -6,FSR2L
  4CAA    CFE3     MOVFF 0xfe3, 0xfd9
  4CAC    FFD9     NOP
  4CAE    0EFB     MOVLW 0xfb
  4CB0    CFE3     MOVFF 0xfe3, 0xfda
  4CB2    FFDA     NOP
                                                  35:    
                                                  36:      ; Load FSR0 with the 'dest' pointer
                                                  37:    
  4CB4    0EFC     MOVLW 0xfc                     38:              Stk2CpyToReg -4,FSR0L
  4CB6    CFE3     MOVFF 0xfe3, 0xfe9
  4CB8    FFE9     NOP
  4CBA    0EFD     MOVLW 0xfd
  4CBC    CFE3     MOVFF 0xfe3, 0xfea
  4CBE    FFEA     NOP
                                                  39:    
                                                  40:      ; Make a copy for the return value
  4CC0    CFE9     MOVFF 0xfe9, 0xff3             41:    	  movff FSR0L, PRODL
  4CC2    FFF3     NOP
  4CC4    CFEA     MOVFF 0xfea, 0xff4             42:    	  movff FSR0H, PRODH
  4CC6    FFF4     NOP
                                                  43:    
                                                  44:    
                                                  45:    jLoop:
                                                  46:    
                                                  47:      ; Test n for zero
                                                  48:    
  4CC8    0EF8     MOVLW 0xf8                     49:              Stk2TestForZero -8,jEnd
  4CCA    50E3     MOVF 0xfe3, W, ACCESS
  4CCC    E103     BNZ 0x4cd4
  4CCE    0EF9     MOVLW 0xf9
  4CD0    50E3     MOVF 0xfe3, W, ACCESS
  4CD2    E008     BZ 0x4ce4
                                                  50:    
                                                  51:      ; Decrement n 
                                                  52:    
  4CD4    0EF8     MOVLW 0xf8                     53:              Stk2Dec   -8
  4CD6    06E3     DECF 0xfe3, F, ACCESS
  4CD8    E202     BC 0x4cde
  4CDA    0EF9     MOVLW 0xf9
  4CDC    06E3     DECF 0xfe3, F, ACCESS
                                                  54:    
  4CDE    CFDE     MOVFF 0xfde, 0xfee             55:              movff     POSTINC2, POSTINC0
  4CE0    FFEE     NOP
  4CE2    D7F2     BRA 0x4cc8                     56:              bra       jLoop
                                                  57:    
                                                  58:    jEnd
                                                  59:    
                                                  60:      ; Restore stack frame for return: restore FSR2
  4CE4    0EFF     MOVLW 0xff                     61:              Stk2PopToReg FSR2L
  4CE6    CFE3     MOVFF 0xfe3, 0xfda
  4CE8    FFDA     NOP
  4CEA    52E5     MOVF 0xfe5, F, ACCESS
  4CEC    0EFF     MOVLW 0xff
  4CEE    CFE3     MOVFF 0xfe3, 0xfd9
  4CF0    FFD9     NOP
  4CF2    52E5     MOVF 0xfe5, F, ACCESS
  4CF4    0012     RETURN 0                       62:              return
---  C:\MCC18\src\traditional\stdclib\memset.asm  ------------------------------------------------
                                                  1:     ; $Id: memset.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name memset
                                                  7:     ;``The {\bf memset} function copies the value of {\bf c} [...] into
                                                  8:     ;each of the first {\bf n} characters of the object pointed to by
                                                  9:     ;{\bf s}.''
                                                  10:    ; * The MPLAB-C18 version of the {\bf memset} function differs from the ANSI
                                                  11:    ;specified function in that {\bf c} is defined as an {\bf unsigned char}
                                                  12:    ;parameter rather than an {\bf int} parameter.
                                                  13:    ;Stack usage: 5 bytes. Re-entrant.
                                                  14:    ;@param s pointer to object
                                                  15:    ;@param c character to copy into object
                                                  16:    ;@param n number of bytes of object to copy {\bf c} into
                                                  17:    ;@return ``The {\bf memset} function returns the value of {\bf s}.''
                                                  18:    ;
                                                  19:    ; void *memset (void *s, unsigned char c, size_t n);
                                                  20:    
                                                  21:    
                                                  22:    STRING CODE
                                                  23:    memset
                                                  24:      global memset
                                                  25:    
                                                  26:    ; Proceedure: Use offset from top of stack to test 'n' for zero and decrement
                                                  27:    ;         it. Use FSR0 for 's'.
                                                  28:    
                                                  29:    
                                                  30:      ; Load FSR0 with the 's' pointer
                                                  31:    
  4D3C    0EFE     MOVLW 0xfe                     32:              Stk2CpyToReg -2,FSR0L
  4D3E    CFE3     MOVFF 0xfe3, 0xfe9
  4D40    FFE9     NOP
  4D42    0EFF     MOVLW 0xff
  4D44    CFE3     MOVFF 0xfe3, 0xfea
  4D46    FFEA     NOP
                                                  33:    
                                                  34:      ; Make a copy for the return value
  4D48    CFE9     MOVFF 0xfe9, 0xff3             35:    	  movff FSR0L, PRODL
  4D4A    FFF3     NOP
  4D4C    CFEA     MOVFF 0xfea, 0xff4             36:        	  movff FSR0H, PRODH
  4D4E    FFF4     NOP
                                                  37:    
                                                  38:    jLoop:
                                                  39:    
                                                  40:      ; Test n for zero
                                                  41:    
  4D50    0EFB     MOVLW 0xfb                     42:              Stk2TestForZero -5,jEnd
  4D52    50E3     MOVF 0xfe3, W, ACCESS
  4D54    E103     BNZ 0x4d5c
  4D56    0EFC     MOVLW 0xfc
  4D58    50E3     MOVF 0xfe3, W, ACCESS
  4D5A    E009     BZ 0x4d6e
                                                  43:    
                                                  44:      ; Decrement n 
                                                  45:    
  4D5C    0EFB     MOVLW 0xfb                     46:              Stk2Dec   -5
  4D5E    06E3     DECF 0xfe3, F, ACCESS
  4D60    E202     BC 0x4d66
  4D62    0EFC     MOVLW 0xfc
  4D64    06E3     DECF 0xfe3, F, ACCESS
                                                  47:    
                                                  48:      ; get 'c'
  4D66    0EFD     MOVLW 0xfd                     49:              movlw     -3
  4D68    50E3     MOVF 0xfe3, W, ACCESS          50:              movf      PLUSW1, W, ACCESS
                                                  51:    
                                                  52:      ; Store it in 's'
  4D6A    6EEE     MOVWF 0xfee, ACCESS            53:              movwf     POSTINC0, ACCESS
  4D6C    D7F1     BRA 0x4d50                     54:              bra       jLoop
                                                  55:    
                                                  56:    jEnd
                                                  57:    
  4D6E    0012     RETURN 0                       58:              return
---  C:\MCC18\src\traditional\stdclib\putc.c  ----------------------------------------------------
1:                 #include <stdio.h>
2:                 
3:                 int _user_putc (char c);
4:                 int _usart_putc (char c);
5:                 
6:                 int
7:                 putc (char c, FILE * f)
  50F6    CFD9     MOVFF 0xfd9, 0xfe6
  50F8    FFE6     NOP
  50FA    CFDA     MOVFF 0xfda, 0xfe6
  50FC    FFE6     NOP
  50FE    CFE1     MOVFF 0xfe1, 0xfd9
  5100    FFD9     NOP
  5102    CFE2     MOVFF 0xfe2, 0xfda
  5104    FFDA     NOP
8:                 {
9:                   /* if the handle > 0 then it's a pointer to a string buffer address.
10:                     specifically, a pointer to a pointer referencing the next available
11:                     byte in the buffer, to which the character will be stored. */
12:                  if ((int) f >= 0)
  5106    0EFB     MOVLW 0xfb
  5108    CFDB     MOVFF 0xfdb, 0x14
  510A    F014     NOP
  510C    0EFC     MOVLW 0xfc
  510E    CFDB     MOVFF 0xfdb, 0x15
  5110    F015     NOP
  5112    0100     MOVLB 0
  5114    0E80     MOVLW 0x80
  5116    1415     ANDWF 0x15, W, ACCESS
  5118    E11A     BNZ 0x514e
13:                    return (unsigned char) (*(*(char **) f)++ = c);
  511A    0EFB     MOVLW 0xfb
  511C    CFDB     MOVFF 0xfdb, 0xfe9
  511E    FFE9     NOP
  5120    0EFC     MOVLW 0xfc
  5122    CFDB     MOVFF 0xfdb, 0xfea
  5124    FFEA     NOP
  5126    CFEE     MOVFF 0xfee, 0xff3
  5128    FFF3     NOP
  512A    CFED     MOVFF 0xfed, 0xff4
  512C    FFF4     NOP
  512E    2AEE     INCF 0xfee, F, ACCESS
  5130    0E00     MOVLW 0
  5132    22EF     ADDWFC 0xfef, F, ACCESS
  5134    CFF3     MOVFF 0xff3, 0xfe9
  5136    FFE9     NOP
  5138    CFF4     MOVFF 0xff4, 0xfea
  513A    FFEA     NOP
  513C    0EFD     MOVLW 0xfd
  513E    CFDB     MOVFF 0xfdb, 0xfef
  5140    FFEF     NOP
  5142    50EF     MOVF 0xfef, W, ACCESS
  5144    6A15     CLRF 0x15, ACCESS
  5146    6EF3     MOVWF 0xff3, ACCESS
  5148    C015     MOVFF 0x15, 0xff4
  514A    FFF4     NOP
  514C    D010     BRA 0x516e
14:                
15:                  if ((signed char) f == (signed char) _H_USART)
  514E    0EFB     MOVLW 0xfb
  5150    50DB     MOVF 0xfdb, W, ACCESS
  5152    08FE     SUBLW 0xfe
  5154    E106     BNZ 0x5162
16:                    {
17:                      /* the invocation of the USART function is direct, as it's our
18:                         default value and we want it to work without needing any
19:                         direct initialization from the user */
20:                      return _usart_putc (c);
  5156    0EFD     MOVLW 0xfd
  5158    CFDB     MOVFF 0xfdb, 0xfe6
  515A    FFE6     NOP
  515C    EC79     CALL 0x52f2, 0
  515E    F029     NOP
  5160    D005     BRA 0x516c
21:                    }
22:                  else
23:                    {
24:                      /* the invocation of the user function is direct, not via a
25:                         function pointer. We just put an empty definition of the
26:                         function in the library and if the user specifies their own
27:                         version it will be found first and the library definition will 
28:                         be ignored. We do it this way because it's generally better to 
29:                         spend 2 bytes of program memory for the RETURN instruction of
30:                         the empty function than three bytes of data memory for the
31:                         function pointer. */
32:                      return _user_putc (c);
  5162    0EFD     MOVLW 0xfd
  5164    CFDB     MOVFF 0xfdb, 0xfe6
  5166    FFE6     NOP
  5168    EC03     CALL 0x1006, 0
  516A    F008     NOP
  516C    52E5     MOVF 0xfe5, F, ACCESS
33:                    }
34:                }
  516E    52E5     MOVF 0xfe5, F, ACCESS
  5170    CFE5     MOVFF 0xfe5, 0xfda
  5172    FFDA     NOP
  5174    CFE7     MOVFF 0xfe7, 0xfd9
  5176    FFD9     NOP
  5178    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\slenpgm.asm  -----------------------------------------------
                                                  1:     ; $Id: slenpgm.asm,v 1.6 2009/05/14 08:27:21 guptan Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name strlenpgm
                                                  7:     ;``The {\bf strlenpgm} function computes the length of the string pointed
                                                  8:     ;to by {\bf s}.''
                                                  9:     ;@param s pointer to the string
                                                  10:    ;@return ``The {\bf strlenpgm} function returns the number of characters
                                                  11:    ;that precede the terminating null character.''
                                                  12:    ;
                                                  13:    ; sizerom_t strlenpgm (const rom char *s);
                                                  14:    
                                                  15:    
                                                  16:      extern __AARGB2
                                                  17:    
                                                  18:    STRING CODE
                                                  19:    strlenpgm
                                                  20:      global strlenpgm
                                                  21:    
                                                  22:    #ifdef __SMALL__
                                                  23:     messg "strlenpgm - SMALL"
                                                  24:    
                                                  25:    ; Procedure: Use TBLPTR for 's' and create 'n' on stack.  Return 'n' in
                                                  26:    ; __AARGB0:__AARGB1:__AARGB2.
                                                  27:    
                                                  28:      ; Load TBLPTR by POPing 's' off stack.
                                                  29:    
                                                  30:              Stk2PopToReg TBLPTRL
                                                  31:              clrf      POSTINC1,ACCESS    ; provide extra byte below stack
                                                  32:    
                                                  33:      ; Push 3 bytes of 0 onto stack. This is initial value of 'n'.
                                                  34:              clrf      POSTINC1,ACCESS
                                                  35:              clrf      POSTINC1,ACCESS
                                                  36:              clrf      POSTINC1,ACCESS
                                                  37:    
                                                  38:      ; Scan for '\0' while counting.
                                                  39:    jLoop:
                                                  40:    
                                                  41:      ; Test for '\0'
                                                  42:              tblrd     *+                  ; read & increment
                                                  43:              movf      TABLAT, F, ACCESS
                                                  44:              bz        jEnd
                                                  45:    
                                                  46:      ; Count it
                                                  47:    
                                                  48:              Stk3Inc   -3
                                                  49:              bra       jLoop
                                                  50:    
                                                  51:    jEnd
                                                  52:    
                                                  53:              Stk3CpyToReg -3, __AARGB2
                                                  54:    
                                                  55:      ; adjust the stack pointer (FSR1) back to the position where it was when it entered the function
                                                  56:              clrf      POSTDEC1,ACCESS
                                                  57:              clrf      POSTDEC1,ACCESS
                                                  58:    
                                                  59:              return
                                                  60:    #else
                                                  61:    #ifdef __LARGE__
                                                  62:     messg "strlenpgm - LARGE"
                                                  63:    
                                                  64:    ; Procedure: Use TBLPTR for 's' and create 'n' on stack.  Return 'n' in
                                                  65:    ; __AARGB0:__AARGB1:__AARGB2.
                                                  66:    
                                                  67:      ; Load TBLPTR by POPing 's' off stack.
                                                  68:    
  4D8C    0EFF     MOVLW 0xff                     69:              Stk3PopToReg TBLPTRL
  4D8E    CFE3     MOVFF 0xfe3, 0xff8
  4D90    FFF8     NOP
  4D92    52E5     MOVF 0xfe5, F, ACCESS
  4D94    0EFF     MOVLW 0xff
  4D96    CFE3     MOVFF 0xfe3, 0xff7
  4D98    FFF7     NOP
  4D9A    52E5     MOVF 0xfe5, F, ACCESS
  4D9C    0EFF     MOVLW 0xff
  4D9E    CFE3     MOVFF 0xfe3, 0xff6
  4DA0    FFF6     NOP
  4DA2    52E5     MOVF 0xfe5, F, ACCESS
                                                  70:    
                                                  71:      ; Push 3 bytes of 0 onto stack. This is initial value of 'n'.
  4DA4    6AE6     CLRF 0xfe6, ACCESS             72:              clrf      POSTINC1,ACCESS
  4DA6    6AE6     CLRF 0xfe6, ACCESS             73:              clrf      POSTINC1,ACCESS
  4DA8    6AE6     CLRF 0xfe6, ACCESS             74:              clrf      POSTINC1,ACCESS
                                                  75:    
                                                  76:      ; Scan for '\0' while counting.
                                                  77:    jLoop:
                                                  78:    
                                                  79:      ; Test for '\0'
  4DAA    0009     TBLRD*+                        80:              tblrd     *+                  ; read & increment
  4DAC    52F5     MOVF 0xff5, F, ACCESS          81:              movf      TABLAT, F, ACCESS
  4DAE    E009     BZ 0x4dc2                      82:              bz        jEnd
                                                  83:    
                                                  84:      ; Count it
                                                  85:    
  4DB0    0EFD     MOVLW 0xfd                     86:              Stk3Inc   -3
  4DB2    2AE3     INCF 0xfe3, F, ACCESS
  4DB4    E105     BNZ 0x4dc0
  4DB6    0EFE     MOVLW 0xfe
  4DB8    2AE3     INCF 0xfe3, F, ACCESS
  4DBA    E102     BNZ 0x4dc0
  4DBC    0EFF     MOVLW 0xff
  4DBE    2AE3     INCF 0xfe3, F, ACCESS
  4DC0    D7F4     BRA 0x4daa                     87:              bra       jLoop
                                                  88:    
                                                  89:    jEnd
                                                  90:    
  4DC2    0EFD     MOVLW 0xfd                     91:              Stk3CpyToReg -3, __AARGB2
  4DC4    CFE3     MOVFF 0xfe3, 0x7
  4DC6    F007     NOP
  4DC8    0EFE     MOVLW 0xfe
  4DCA    CFE3     MOVFF 0xfe3, 0x8
  4DCC    F008     NOP
  4DCE    0EFF     MOVLW 0xff
  4DD0    CFE3     MOVFF 0xfe3, 0x9
  4DD2    F009     NOP
  4DD4    0012     RETURN 0                       92:              return
---  C:\MCC18\src\traditional\stdclib\sprintf.c  -------------------------------------------------
1:                 #include <stdio.h>
2:                 
3:                 /* sprintf() is a wrapper function which calls vfprintf() with the address
4:                    of the destination buffer as the output stream. EOF is returned on
5:                    error, else the number of characters output. */
6:                 int
7:                 sprintf (char *buf, const rom char *f, ...)
  4FAC    CFD9     MOVFF 0xfd9, 0xfe6
  4FAE    FFE6     NOP
  4FB0    CFDA     MOVFF 0xfda, 0xfe6
  4FB2    FFE6     NOP
  4FB4    CFE1     MOVFF 0xfe1, 0xfd9
  4FB6    FFD9     NOP
  4FB8    CFE2     MOVFF 0xfe2, 0xfda
  4FBA    FFDA     NOP
  4FBC    52E6     MOVF 0xfe6, F, ACCESS
  4FBE    52E6     MOVF 0xfe6, F, ACCESS
  4FC0    52E6     MOVF 0xfe6, F, ACCESS
  4FC2    52E6     MOVF 0xfe6, F, ACCESS
8:                 {
9:                   int n;
10:                  va_list ap;
11:                  va_start (ap, f);
  4FC4    50D9     MOVF 0xfd9, W, ACCESS
  4FC6    0FF9     ADDLW 0xf9
  4FC8    6E14     MOVWF 0x14, ACCESS
  4FCA    0EFF     MOVLW 0xff
  4FCC    20DA     ADDWFC 0xfda, W, ACCESS
  4FCE    6E15     MOVWF 0x15, ACCESS
  4FD0    0E02     MOVLW 0x2
  4FD2    C014     MOVFF 0x14, 0xfdb
  4FD4    FFDB     NOP
  4FD6    0E03     MOVLW 0x3
  4FD8    C015     MOVFF 0x15, 0xfdb
  4FDA    FFDB     NOP
12:                  n = vfprintf ((FILE *) & buf, f, ap);
  4FDC    0E02     MOVLW 0x2
  4FDE    CFDB     MOVFF 0xfdb, 0xfe6
  4FE0    FFE6     NOP
  4FE2    0E03     MOVLW 0x3
  4FE4    CFDB     MOVFF 0xfdb, 0xfe6
  4FE6    FFE6     NOP
  4FE8    0EF9     MOVLW 0xf9
  4FEA    CFDB     MOVFF 0xfdb, 0xfe6
  4FEC    FFE6     NOP
  4FEE    0EFA     MOVLW 0xfa
  4FF0    CFDB     MOVFF 0xfdb, 0xfe6
  4FF2    FFE6     NOP
  4FF4    0EFB     MOVLW 0xfb
  4FF6    CFDB     MOVFF 0xfdb, 0xfe6
  4FF8    FFE6     NOP
  4FFA    50D9     MOVF 0xfd9, W, ACCESS
  4FFC    0FFC     ADDLW 0xfc
  4FFE    6EE6     MOVWF 0xfe6, ACCESS
  5000    0EFF     MOVLW 0xff
  5002    20DA     ADDWFC 0xfda, W, ACCESS
  5004    6EE6     MOVWF 0xfe6, ACCESS
  5006    ECAE     CALL 0x235c, 0
  5008    F011     NOP
  500A    6E14     MOVWF 0x14, ACCESS
  500C    0E07     MOVLW 0x7
  500E    5CE1     SUBWF 0xfe1, W, ACCESS
  5010    E202     BC 0x5016
  5012    6AE1     CLRF 0xfe1, ACCESS
  5014    52E5     MOVF 0xfe5, F, ACCESS
  5016    6EE1     MOVWF 0xfe1, ACCESS
  5018    5014     MOVF 0x14, W, ACCESS
  501A    CFF3     MOVFF 0xff3, 0xfde
  501C    FFDE     NOP
  501E    CFF4     MOVFF 0xff4, 0xfdd
  5020    FFDD     NOP
13:                  va_end (ap);
14:                  *buf = '\0';
  5022    0EFC     MOVLW 0xfc
  5024    CFDB     MOVFF 0xfdb, 0xfe9
  5026    FFE9     NOP
  5028    0EFD     MOVLW 0xfd
  502A    CFDB     MOVFF 0xfdb, 0xfea
  502C    FFEA     NOP
  502E    6AEF     CLRF 0xfef, ACCESS
15:                  return n;
  5030    CFDE     MOVFF 0xfde, 0x14
  5032    F014     NOP
  5034    CFDD     MOVFF 0xfdd, 0x15
  5036    F015     NOP
  5038    C014     MOVFF 0x14, 0xff3
  503A    FFF3     NOP
  503C    C015     MOVFF 0x15, 0xff4
  503E    FFF4     NOP
16:                }
  5040    0E04     MOVLW 0x4
  5042    5CE1     SUBWF 0xfe1, W, ACCESS
  5044    E202     BC 0x504a
  5046    6AE1     CLRF 0xfe1, ACCESS
  5048    52E5     MOVF 0xfe5, F, ACCESS
  504A    6EE1     MOVWF 0xfe1, ACCESS
  504C    52E5     MOVF 0xfe5, F, ACCESS
  504E    CFE5     MOVFF 0xfe5, 0xfda
  5050    FFDA     NOP
  5052    CFE7     MOVFF 0xfe7, 0xfd9
  5054    FFD9     NOP
  5056    0012     RETURN 0
---  C:\MCC18\src\traditional\stdclib\strlen.asm  ------------------------------------------------
                                                  1:     ; $Id: strlen.asm,v 1.1 2003/12/09 22:53:20 GrosbaJ Exp $
                                                  2:     
                                                  3:     #include "P18CXXX.INC"
                                                  4:     #include "P18MACRO.INC"
                                                  5:     
                                                  6:     ; @name strlen
                                                  7:     ;``The {\bf strlen} function computes the length of the string pointed
                                                  8:     ;to by {\bf s}.''
                                                  9:     ;Stack usage: 2 bytes. Re-entrant.
                                                  10:    ;@param s pointer to the string
                                                  11:    ;@return ``The {\bf strlen} function returns the number of characters
                                                  12:    ;that precede the terminating null character.''
                                                  13:    ;
                                                  14:    ; size_t strlen (const char *s);
                                                  15:    
                                                  16:    
                                                  17:    STRING CODE
                                                  18:    strlen
                                                  19:      global strlen
                                                  20:    
                                                  21:    ; Proceedure: Use FSR0 for 's' and use PROD for 'n'.
                                                  22:    
                                                  23:      ; Load FSR0 by copying 's' off stack into FSR0.
                                                  24:    
  4D70    0EFE     MOVLW 0xfe                     25:              Stk2CpyToReg -2,FSR0L
  4D72    CFE3     MOVFF 0xfe3, 0xfe9
  4D74    FFE9     NOP
  4D76    0EFF     MOVLW 0xff
  4D78    CFE3     MOVFF 0xfe3, 0xfea
  4D7A    FFEA     NOP
                                                  26:    
                                                  27:      ; Clear PROD
  4D7C    6AF3     CLRF 0xff3, ACCESS             28:              clrf      PRODL,ACCESS
  4D7E    6AF4     CLRF 0xff4, ACCESS             29:              clrf      PRODH,ACCESS
                                                  30:    
                                                  31:      ; Scan for '\0' while counting.
                                                  32:    jLoop:
                                                  33:    
                                                  34:      ; Test for '\0'
  4D80    52EE     MOVF 0xfee, F, ACCESS          35:              movf      POSTINC0,F,ACCESS   ; set Z flag
  4D82    E003     BZ 0x4d8a                      36:              bz        jEnd
                                                  37:    
                                                  38:      ; Count it 
  4D84    4AF3     INFSNZ 0xff3, F, ACCESS        39:    	  infsnz    PRODL, F, ACCESS
  4D86    2AF4     INCF 0xff4, F, ACCESS          40:    	  incf      PRODH, F, ACCESS
                                                  41:    
  4D88    D7FB     BRA 0x4d80                     42:              bra       jLoop
                                                  43:    
                                                  44:    jEnd
                                                  45:    
  4D8A    0012     RETURN 0                       46:              return
---  C:\MCC18\src\traditional\stdclib\vfprintf.c  ------------------------------------------------
1:                 #include <stdio.h>
2:                 #include <ctype.h>
3:                 #include <string.h>
4:                 
5:                 #define _FLAG_MINUS 0x1
6:                 #define _FLAG_PLUS  0x2
7:                 #define _FLAG_SPACE 0x4
8:                 #define _FLAG_OCTO  0x8
9:                 #define _FLAG_ZERO  0x10
10:                #define _FLAG_SIGNED 0x80
11:                
12:                static const rom char s_digits[] = "0123456789abcdef";
13:                
14:                static unsigned char
15:                s_put_n_chars (FILE * handle, unsigned char n, char c)
  2330    ECD4     CALL 0x2da8, 0
  2332    F016     NOP
  2DA8    CFD9     MOVFF 0xfd9, 0xfe6
  2DAA    FFE6     NOP
  2DAC    CFDA     MOVFF 0xfda, 0xfe6
  2DAE    FFE6     NOP
  2DB0    CFE1     MOVFF 0xfe1, 0xfd9
  2DB2    FFD9     NOP
  2DB4    CFE2     MOVFF 0xfe2, 0xfda
  2DB6    FFDA     NOP
  2DB8    0012     RETURN 0
16:                {
17:                  while (n--)
  2334    0EFB     MOVLW 0xfb
  2336    CFDB     MOVFF 0xfdb, 0xff3
  2338    FFF3     NOP
  233A    06DB     DECF 0xfdb, F, ACCESS
  233C    50F3     MOVF 0xff3, W, ACCESS
  233E    0900     IORLW 0
  2340    E00A     BZ 0x2356
18:                    if (putc (c, handle) == EOF)
  2342    EC22     CALL 0x2e44, 0
  2344    F017     NOP
  2346    0EFA     MOVLW 0xfa
  2348    EC8D     CALL 0x2f1a, 0
  234A    F017     NOP
  234C    E1F3     BNZ 0x2334
  234E    1C15     COMF 0x15, W, ACCESS
  2350    E1F1     BNZ 0x2334
19:                      return 1;
  2352    0E01     MOVLW 0x1
  2354    D001     BRA 0x2358
20:                  return 0;
  2356    0E00     MOVLW 0
21:                }
  2358    EF03     GOTO 0x2e06
  235A    F017     NOP
  2E06    52E5     MOVF 0xfe5, F, ACCESS
  2E08    CFE5     MOVFF 0xfe5, 0xfda
  2E0A    FFDA     NOP
  2E0C    CFE7     MOVFF 0xfe7, 0xfd9
  2E0E    FFD9     NOP
  2E10    0012     RETURN 0
22:                
23:                #define _FMT_UNSPECIFIED 0
24:                #define _FMT_LONG 1
25:                #define _FMT_SHLONG 2
26:                #define _FMT_BYTE   3
27:                int
28:                vfprintf (auto FILE *handle, auto const rom char *f, auto va_list ap)
  235C    ECD4     CALL 0x2da8, 0
  235E    F016     NOP
  2360    0E3B     MOVLW 0x3b
  2362    24E1     ADDWF 0xfe1, W, ACCESS
  2364    E302     BNC 0x236a
  2366    68E1     SETF 0xfe1, ACCESS
  2368    52E6     MOVF 0xfe6, F, ACCESS
  236A    6EE1     MOVWF 0xfe1, ACCESS
29:                {
30:                  unsigned char c;
31:                  int count = 0;
  236C    0E01     MOVLW 0x1
  236E    6ADB     CLRF 0xfdb, ACCESS
  2370    0E02     MOVLW 0x2
  2372    6ADB     CLRF 0xfdb, ACCESS
32:                
33:                  for (c = *f; c; c = *++f)
  2374    0EF9     MOVLW 0xf9
  2376    CFDB     MOVFF 0xfdb, 0xff6
  2378    FFF6     NOP
  237A    0EFA     MOVLW 0xfa
  237C    CFDB     MOVFF 0xfdb, 0xff7
  237E    FFF7     NOP
  2380    0EFB     MOVLW 0xfb
  2382    CFDB     MOVFF 0xfdb, 0xff8
  2384    FFF8     NOP
  2386    0008     TBLRD*
  2388    50F5     MOVF 0xff5, W, ACCESS
  238A    6EDF     MOVWF 0xfdf, ACCESS
  238C    50DF     MOVF 0xfdf, W, ACCESS
  238E    E102     BNZ 0x2394
  2390    EF27     GOTO 0x2c4e
  2392    F016     NOP
  2C48    D979     RCALL 0x2f3c
  2C4A    EFC3     GOTO 0x2386
  2C4C    F011     NOP
  2F3C    50D9     MOVF 0xfd9, W, ACCESS
  2F3E    0FF9     ADDLW 0xf9
  2F40    6EE9     MOVWF 0xfe9, ACCESS
  2F42    0EFF     MOVLW 0xff
  2F44    EF37     GOTO 0x2e6e
  2F46    F017     NOP
34:                    {
35:                      if (c == '%')
  2394    0E25     MOVLW 0x25
  2396    5CDF     SUBWF 0xfdf, W, ACCESS
  2398    E002     BZ 0x239e
  239A    EF1A     GOTO 0x2c34
  239C    F016     NOP
36:                        {
37:                          unsigned char flags = 0;
  239E    0E03     MOVLW 0x3
  23A0    6ADB     CLRF 0xfdb, ACCESS
38:                          unsigned char width = 0;
  23A2    0E04     MOVLW 0x4
  23A4    6ADB     CLRF 0xfdb, ACCESS
39:                          unsigned char precision = 0;
  23A6    0E05     MOVLW 0x5
  23A8    6ADB     CLRF 0xfdb, ACCESS
40:                          unsigned char have_precision = 0;
  23AA    0E06     MOVLW 0x6
  23AC    6ADB     CLRF 0xfdb, ACCESS
41:                          unsigned char size = 0;
  23AE    0E07     MOVLW 0x7
  23B0    6ADB     CLRF 0xfdb, ACCESS
42:                          unsigned char space_cnt;
43:                          unsigned char cval;
44:                          unsigned long larg;
45:                          far rom char *romstring;
46:                          char *ramstring;
47:                          int n;
48:                          /* get the first character of the conversion specifier */
49:                          c = *++f;
  23B2    EC3C     CALL 0x2c78, 0
  23B4    F016     NOP
50:                
51:                          /**  The conversion specification has, after the '%' character:
52:                              7.9.6.1
53:                             * Zero or more flags (in any order) that modify the meaning of the
54:                               conversion specification.
55:                             * An optional minimum field width. If the converted value has 
56:                               fewer characters than the field width, it will be padded with
57:                               spaces (by default) on the left (or right, if the left
58:                               adjustment flag, described later, has been given) to the field
59:                               width. The field width takes the form of an asterisk * 
60:                               (described later) or a decimal integer.
61:                             * An optional precision that gives the minimum number of digits
62:                               to appear for the d, i, o, u, x, and X conversions, the
63:                               maximum number of digits to appear after the decimal point
64:                               character for e, E, and f conversions, the maximum number
65:                               of significant digits for the g and G conversions, or the 
66:                               maximum number of characters to be written from a string in
67:                               s conversion. The precision takes the form of a period (.)
68:                               followed by an asterisk * (described later) or by an optional
69:                               decimal integer; if only the period is specified, the precision
70:                               is taken as zero. If a precision appears with any other 
71:                               conversion specifier, the behaviour is undefined.
72:                             * An optional h specifying that a following d, i, o, u, x, or X
73:                               conversion specifier applies to a short int or unsigned short
74:                               int argument (the argument will have been promoted according
75:                               to the integer promotions, and its value shall be converted
76:                               to short int or unsigned short int before printing); an
77:                               optional h specifying that a following n conversion specifier
78:                               applies to a pointer to a short int argument; an optional l 
79:                               (ell) specifying that a following d, i, o, u, x, or X 
80:                               conversion specifier applies to a long int or unsigned long int 
81:                               argument; or an optional L specifying that a following e, E, 
82:                               f, g, or G conversion specifier applies to a long double 
83:                               argument. If an h, l, or L appears with any other conversion 
84:                               specifier, the behaviour is undefined.
85:                             * A character that specifies the type of conversion to be applied.
86:                            */
87:                
88:                          /** check for a flag.
89:                             7.9.6.1
90:                             The flag characters and their meanings are:
91:                
92:                             - The result of the conversion will be left-justified within
93:                               the field. (It will be right justified if this flag is not
94:                               specified.)
95:                             + The result of a signed conversion will always begin with a 
96:                               plus or a minus sign. (It will begin with a sign only when
97:                               a negative value is converted if this flag is not specified.)
98:                             space  If the first character of a signed conversion is not a
99:                               sign, or if a signed conversion results in no characters, a
100:                              space will be prefixed to the result. If the space and + flags
101:                              both appear, the space flag will be ignored.
102:                            # The result is to be converted to an "alternate form." For o
103:                              conversion, it increases the precision to force the first digit
104:                              of the result to be a zero. For x (or X) conversion, a nonzero
105:                              result will have 0x (or 0X) prefixed to it. For e, E, f, g, 
106:                              and G conversions, the result will always contain a decimal-
107:                              point character, even if no digits follow it. (Normally, a
108:                              decimal point character appears in the result of these
109:                              conversions only if a digit follows it.) For g and G
110:                              conversions, trailing zeros will not be removed from the 
111:                              result. For other conversions the behaviour is undefined.
112:                            0 For d, i, o, u, x, X, e, E, f, g, and G conversions, leading
113:                              zeros (following any indication of sign or base) are used to
114:                              pad to the field width; no space padding is performed. If
115:                              the 0 and - flags both appear, the 0 flag will be ignored.
116:                              For other conversions, the behaviour is undefined.
117:                           */
118:                         while (c == '-' || c == '+' || c == ' ' || c == '#'
  23B6    0E2D     MOVLW 0x2d
  23B8    5CDF     SUBWF 0xfdf, W, ACCESS
  23BA    E00C     BZ 0x23d4
  23BC    0E2B     MOVLW 0x2b
  23BE    5CDF     SUBWF 0xfdf, W, ACCESS
  23C0    E009     BZ 0x23d4
  23C2    0E20     MOVLW 0x20
  23C4    5CDF     SUBWF 0xfdf, W, ACCESS
  23C6    E006     BZ 0x23d4
  23C8    0E23     MOVLW 0x23
  2406    D7D5     BRA 0x23b2
119:                                || c == '0')
  23CA    5CDF     SUBWF 0xfdf, W, ACCESS
  23CC    E003     BZ 0x23d4
  23CE    0E30     MOVLW 0x30
  23D0    5CDF     SUBWF 0xfdf, W, ACCESS
  23D2    E11A     BNZ 0x2408
120:                           {
121:                             switch (c)
  23D4    50DF     MOVF 0xfdf, W, ACCESS
  23D6    0A30     XORLW 0x30
  23D8    E014     BZ 0x2402
  23DA    0A13     XORLW 0x13
  23DC    E00F     BZ 0x23fc
  23DE    0A03     XORLW 0x3
  23E0    E00A     BZ 0x23f6
  23E2    0A0B     XORLW 0xb
  23E4    E005     BZ 0x23f0
  23E6    0A06     XORLW 0x6
  23E8    E1E4     BNZ 0x23b2
122:                               {
123:                               case '-':
124:                                 flags |= _FLAG_MINUS;
  23EA    0E03     MOVLW 0x3
  23EC    80DB     BSF 0xfdb, 0, ACCESS
125:                                 break;
  23EE    D7E1     BRA 0x23b2
126:                               case '+':
127:                                 flags |= _FLAG_PLUS;
  23F0    0E03     MOVLW 0x3
  23F2    82DB     BSF 0xfdb, 0x1, ACCESS
128:                                 break;
  23F4    D7DE     BRA 0x23b2
129:                               case ' ':
130:                                 flags |= _FLAG_SPACE;
  23F6    0E03     MOVLW 0x3
  23F8    84DB     BSF 0xfdb, 0x2, ACCESS
131:                                 break;
  23FA    D7DB     BRA 0x23b2
132:                               case '#':
133:                                 flags |= _FLAG_OCTO;
  23FC    0E03     MOVLW 0x3
  23FE    86DB     BSF 0xfdb, 0x3, ACCESS
134:                                 break;
  2400    D7D8     BRA 0x23b2
135:                               case '0':
136:                                 flags |= _FLAG_ZERO;
  2402    0E03     MOVLW 0x3
  2404    88DB     BSF 0xfdb, 0x4, ACCESS
137:                                 break;
138:                               }
139:                             c = *++f;
140:                           }
141:                         /* the optional width field is next */
142:                         if (c == '*')
  2408    0E2A     MOVLW 0x2a
  240A    5CDF     SUBWF 0xfdf, W, ACCESS
  240C    E11B     BNZ 0x2444
143:                           {
144:                             n = va_arg (ap, int);
  240E    EC38     CALL 0x2c70, 0
  2410    F016     NOP
  2412    EC86     CALL 0x2d0c, 0
  2414    F016     NOP
  2D0C    0E13     MOVLW 0x13
  2D0E    CFEE     MOVFF 0xfee, 0xfdb
  2D10    FFDB     NOP
  2D12    0E14     MOVLW 0x14
  2D14    CFED     MOVFF 0xfed, 0xfdb
  2D16    FFDB     NOP
145:                             if (n < 0)
  2416    E010     BZ 0x2438
  2D18    0E13     MOVLW 0x13
  2D1A    CFDB     MOVFF 0xfdb, 0x14
  2D1C    F014     NOP
  2D1E    0E14     MOVLW 0x14
  2D20    CFDB     MOVFF 0xfdb, 0x15
  2D22    F015     NOP
  2D24    0100     MOVLB 0
  2D26    0E80     MOVLW 0x80
  2D28    1415     ANDWF 0x15, W, ACCESS
  2D2A    0012     RETURN 0
146:                               {
147:                                 flags |= _FLAG_MINUS;
  2418    0E03     MOVLW 0x3
  241A    80DB     BSF 0xfdb, 0, ACCESS
148:                                 width = -n;
  241C    6808     SETF 0x8, ACCESS
  241E    6809     SETF 0x9, ACCESS
  2420    0E13     MOVLW 0x13
  2422    CFDB     MOVFF 0xfdb, 0xd
  2424    F00D     NOP
  2426    0E14     MOVLW 0x14
  2428    CFDB     MOVFF 0xfdb, 0xe
  242A    F00E     NOP
  242C    EC34     CALL 0x4e68, 0
  242E    F027     NOP
  2430    0E04     MOVLW 0x4
  2432    C006     MOVFF 0x6, 0xfdb
  2434    FFDB     NOP
149:                               }
150:                             else
  2436    D003     BRA 0x243e
151:                               width = n;
  2438    0E13     MOVLW 0x13
  243A    EC6F     CALL 0x2cde, 0
  243C    F016     NOP
152:                             c = *++f;
  243E    EC3C     CALL 0x2c78, 0
  2440    F016     NOP
153:                           }
154:                         else
  2442    D00B     BRA 0x245a
155:                           {
156:                             cval = 0;
  2444    0E09     MOVLW 0x9
  2446    6ADB     CLRF 0xfdb, ACCESS
157:                             while ((unsigned char) isdigit (c))
  2448    ECDD     CALL 0x2dba, 0
  244A    F016     NOP
  244C    E003     BZ 0x2454
  2452    D7FA     BRA 0x2448
  2DBA    CFDF     MOVFF 0xfdf, 0xfe6
  2DBC    FFE6     NOP
  2DBE    6AE6     CLRF 0xfe6, ACCESS
  2DC0    EC37     CALL 0x526e, 0
  2DC2    F029     NOP
  2DC4    52E5     MOVF 0xfe5, F, ACCESS
  2DC6    52E5     MOVF 0xfe5, F, ACCESS
  2DC8    50F3     MOVF 0xff3, W, ACCESS
  2DCA    0012     RETURN 0
158:                               {
159:                                 cval = cval * 10 + c - '0';
  244E    EC51     CALL 0x2ea2, 0
  2450    F017     NOP
  2EA2    0E09     MOVLW 0x9
  2EA4    50DB     MOVF 0xfdb, W, ACCESS
  2EA6    0D0A     MULLW 0xa
  2EA8    50F3     MOVF 0xff3, W, ACCESS
  2EAA    24DF     ADDWF 0xfdf, W, ACCESS
  2EAC    0FD0     ADDLW 0xd0
  2EAE    6EE7     MOVWF 0xfe7, ACCESS
  2EB0    0E09     MOVLW 0x9
  2EB2    CFE7     MOVFF 0xfe7, 0xfdb
  2EB4    FFDB     NOP
160:                                 c = *++f;
  2EB6    EF3C     GOTO 0x2c78
  2EB8    F016     NOP
161:                               }
162:                             width = cval;
  2454    0E09     MOVLW 0x9
  2456    EC6F     CALL 0x2cde, 0
  2458    F016     NOP
163:                           }
164:               
165:                         /* if '-' is specified, '0' is ignored */
166:                         if (flags & _FLAG_MINUS)
  245A    0E03     MOVLW 0x3
  245C    B0DB     BTFSC 0xfdb, 0, ACCESS
167:                           flags &= ~_FLAG_ZERO;
  245E    98DB     BCF 0xfdb, 0x4, ACCESS
168:               
169:                         /* the optional precision field is next */
170:                         if (c == '.')
  2460    0E2E     MOVLW 0x2e
  2462    5CDF     SUBWF 0xfdf, W, ACCESS
  2464    E11B     BNZ 0x249c
171:                           {
172:                             c = *++f;
  2466    EC3C     CALL 0x2c78, 0
  2468    F016     NOP
173:                             if (c == '*')
  246A    0E2A     MOVLW 0x2a
  246C    5CDF     SUBWF 0xfdf, W, ACCESS
  246E    E10B     BNZ 0x2486
174:                               {
175:                                 n = va_arg (ap, int);
  2470    EC38     CALL 0x2c70, 0
  2472    F016     NOP
  2474    EC86     CALL 0x2d0c, 0
  2476    F016     NOP
  2C70    D929     RCALL 0x2ec4
  2C72    0E02     MOVLW 0x2
  2C74    EF29     GOTO 0x2e52
  2C76    F017     NOP
  2E52    5E14     SUBWF 0x14, F, ACCESS
  2E54    0E00     MOVLW 0
  2E56    5A15     SUBWFB 0x15, F, ACCESS
  2E58    0EF7     MOVLW 0xf7
  2E5A    C014     MOVFF 0x14, 0xfdb
  2E5C    FFDB     NOP
  2E5E    0EF8     MOVLW 0xf8
  2E60    C015     MOVFF 0x15, 0xfdb
  2E62    FFDB     NOP
  2E64    C014     MOVFF 0x14, 0xfe9
  2E66    FFE9     NOP
  2E68    C015     MOVFF 0x15, 0xfea
  2E6A    FFEA     NOP
  2E6C    0012     RETURN 0
  2EC4    0EF7     MOVLW 0xf7
  2EC6    CFDB     MOVFF 0xfdb, 0x14
  2EC8    F014     NOP
  2ECA    0EF8     MOVLW 0xf8
  2ECC    CFDB     MOVFF 0xfdb, 0x15
  2ECE    F015     NOP
  2ED0    0012     RETURN 0
176:                                 if (n >= 0)
  2478    E103     BNZ 0x2480
177:                                   {
178:                                     precision = n;
  247A    0E13     MOVLW 0x13
  247C    ECC1     CALL 0x2d82, 0
  247E    F016     NOP
  2D82    50DB     MOVF 0xfdb, W, ACCESS
  2D84    D8CE     RCALL 0x2f22
  2F22    6EE7     MOVWF 0xfe7, ACCESS
  2F24    0E05     MOVLW 0x5
  2F26    CFE7     MOVFF 0xfe7, 0xfdb
  2F28    FFDB     NOP
  2F2A    0012     RETURN 0
179:                                     have_precision = 1;
  2D86    0E01     MOVLW 0x1
  2D88    6EF3     MOVWF 0xff3, ACCESS
  2D8A    0E06     MOVLW 0x6
  2D8C    CFF3     MOVFF 0xff3, 0xfdb
  2D8E    FFDB     NOP
  2D90    0012     RETURN 0
180:                                   }
181:                                 c = *++f;
  2480    EC3C     CALL 0x2c78, 0
  2482    F016     NOP
182:                               }
183:                             else
  2484    D00B     BRA 0x249c
184:                               {
185:                                 cval = 0;
  2486    0E09     MOVLW 0x9
  2488    6ADB     CLRF 0xfdb, ACCESS
186:                                 while ((unsigned char) isdigit (c))
  248A    ECDD     CALL 0x2dba, 0
  248C    F016     NOP
  248E    E003     BZ 0x2496
  2494    D7FA     BRA 0x248a
187:                                   {
188:                                     cval = cval * 10 + c - '0';
  2490    EC51     CALL 0x2ea2, 0
  2492    F017     NOP
189:                                     c = *++f;
190:                                   }
191:                                 precision = cval;
  2496    0E09     MOVLW 0x9
  2498    ECC1     CALL 0x2d82, 0
  249A    F016     NOP
192:                                 have_precision = 1;
193:                               }
194:                           }
195:               
196:                         /* the optional 'h' specifier. since int and short int are
197:                            the same size for MPLAB C18, this is a NOP for us. */
198:                         if (c == 'h')
  249C    0E68     MOVLW 0x68
  249E    5CDF     SUBWF 0xfdf, W, ACCESS
  24A0    E107     BNZ 0x24b0
199:                           {
200:                             c = *++f;
  24A2    EC3C     CALL 0x2c78, 0
  24A4    F016     NOP
201:                             /* if 'c' is another 'h' character, this is an 'hh'
202:                                specifier and the size is 8 bits */
203:                             if (c == 'h')
  24A6    0E68     MOVLW 0x68
  24A8    5CDF     SUBWF 0xfdf, W, ACCESS
  24AA    E11D     BNZ 0x24e6
204:                               {
205:                                 size = _FMT_BYTE;
  24AC    0E03     MOVLW 0x3
206:                                 c = *++f;
207:                               }
208:                           }
209:                         /* 'z' and 't' are both 16-bit and so are NOPs */
210:                         else if (c == 't' || c == 'z')
  24AE    D018     BRA 0x24e0
  24B0    0E74     MOVLW 0x74
  24B2    5CDF     SUBWF 0xfdf, W, ACCESS
  24B4    E017     BZ 0x24e4
  24B6    0E7A     MOVLW 0x7a
  24B8    5CDF     SUBWF 0xfdf, W, ACCESS
  24BA    E014     BZ 0x24e4
211:                           c = *++f;
212:                         /* the 'H' specifier tells us to deal with 24-bit integers.
213:                            the 'T' and 'Z' specifiers are also 24 bit */
214:                         else if (c == 'H' || c == 'T' || c == 'Z')
  24BC    0E48     MOVLW 0x48
  24BE    5CDF     SUBWF 0xfdf, W, ACCESS
  24C0    E006     BZ 0x24ce
  24C2    0E54     MOVLW 0x54
  24C4    5CDF     SUBWF 0xfdf, W, ACCESS
  24C6    E003     BZ 0x24ce
  24C8    0E5A     MOVLW 0x5a
  24CA    5CDF     SUBWF 0xfdf, W, ACCESS
  24CC    E102     BNZ 0x24d2
215:                           {
216:                             size = _FMT_SHLONG;
  24CE    0E02     MOVLW 0x2
217:                             c = *++f;
218:                           }
219:                         /* the 'l' specifier tells us to deal with 32-bit integers
220:                            'j' specifies intmax_t (long in our case). */
221:                         else if (c == 'l' || c == 'j')
  24D0    D007     BRA 0x24e0
  24D2    0E6C     MOVLW 0x6c
  24D4    5CDF     SUBWF 0xfdf, W, ACCESS
  24D6    E003     BZ 0x24de
  24D8    0E6A     MOVLW 0x6a
  24DA    5CDF     SUBWF 0xfdf, W, ACCESS
  24DC    E104     BNZ 0x24e6
222:                           {
223:                             size = _FMT_LONG;
  24DE    0E01     MOVLW 0x1
  24E0    EC14     CALL 0x2e28, 0
  24E2    F017     NOP
224:                             c = *++f;
  24E4    DBC9     RCALL 0x2c78
  2C78    D961     RCALL 0x2f3c
  2C7A    0008     TBLRD*
  2C7C    50F5     MOVF 0xff5, W, ACCESS
  2C7E    6EDF     MOVWF 0xfdf, ACCESS
  2C80    0012     RETURN 0
  2E6E    20DA     ADDWFC 0xfda, W, ACCESS
  2E70    6EEA     MOVWF 0xfea, ACCESS
  2E72    2AEF     INCF 0xfef, F, ACCESS
  2E74    CFEE     MOVFF 0xfee, 0xff6
  2E76    FFF6     NOP
  2E78    0E00     MOVLW 0
  2E7A    22EF     ADDWFC 0xfef, F, ACCESS
  2E7C    CFEE     MOVFF 0xfee, 0xff7
  2E7E    FFF7     NOP
  2E80    22EF     ADDWFC 0xfef, F, ACCESS
  2E82    CFEE     MOVFF 0xfee, 0xff8
  2E84    FFF8     NOP
  2E86    0012     RETURN 0
225:                           }
226:               
227:                         switch (c)
  24E6    50DF     MOVF 0xfdf, W, ACCESS
  24E8    0A6E     XORLW 0x6e
  24EA    E101     BNZ 0x24ee
  24EC    D37F     BRA 0x2bec
  24EE    0A1E     XORLW 0x1e
  24F0    E101     BNZ 0x24f4
  24F2    D192     BRA 0x2818
  24F4    0A20     XORLW 0x20
  24F6    E101     BNZ 0x24fa
  24F8    D18F     BRA 0x2818
  24FA    0A3F     XORLW 0x3f
  24FC    E101     BNZ 0x2500
  24FE    D149     BRA 0x2792
  2500    0A1A     XORLW 0x1a
  2502    E101     BNZ 0x2506
  2504    D146     BRA 0x2792
  2506    0A0D     XORLW 0xd
  2508    E101     BNZ 0x250c
  250A    D143     BRA 0x2792
  250C    0A20     XORLW 0x20
  250E    E101     BNZ 0x2512
  2510    D140     BRA 0x2792
  2512    0A3A     XORLW 0x3a
  2514    E101     BNZ 0x2518
  2516    D13D     BRA 0x2792
  2518    0A20     XORLW 0x20
  251A    E101     BNZ 0x251e
  251C    D13A     BRA 0x2792
  251E    0A26     XORLW 0x26
  2520    E101     BNZ 0x2524
  2522    D135     BRA 0x278e
  2524    0A0D     XORLW 0xd
  2526    E101     BNZ 0x252a
  2528    D132     BRA 0x278e
  252A    0A1A     XORLW 0x1a
  252C    E101     BNZ 0x2530
  252E    D0D9     BRA 0x26e2
  2530    0A20     XORLW 0x20
  2532    E04A     BZ 0x25c8
  2534    0A30     XORLW 0x30
  2536    E01F     BZ 0x2576
  2538    0A46     XORLW 0x46
  253A    E00E     BZ 0x2558
  253C    0A25     XORLW 0x25
  253E    E001     BZ 0x2542
  2540    D383     BRA 0x2c48
228:                           {
229:                           case '\0':
230:                             /* this is undefined behaviour. we have a trailing '%' character
231:                                in the string, perhaps with some flags, width, precision
232:                                stuff as well, but no format specifier. We'll, arbitrarily,
233:                                back up a character so that the loop will terminate 
234:                                properly when it loops back and we'll output a '%'
235:                                character. */
236:                             --f;
  2542    50D9     MOVF 0xfd9, W, ACCESS
  2544    0FF9     ADDLW 0xf9
  2546    6EE9     MOVWF 0xfe9, ACCESS
  2548    0EFF     MOVLW 0xff
  254A    20DA     ADDWFC 0xfda, W, ACCESS
  254C    6EEA     MOVWF 0xfea, ACCESS
  254E    0E01     MOVLW 0x1
  2550    5EEE     SUBWF 0xfee, F, ACCESS
  2552    0E00     MOVLW 0
  2554    5AEE     SUBWFB 0xfee, F, ACCESS
  2556    5AEE     SUBWFB 0xfee, F, ACCESS
237:                             /* fallthrough */
238:                           case '%':
239:                             if (putc ('%', handle) == EOF)
  2558    EC22     CALL 0x2e44, 0
  255A    F017     NOP
  255C    0E25     MOVLW 0x25
  255E    6EE6     MOVWF 0xfe6, ACCESS
  2560    DB95     RCALL 0x2c8c
  2562    E103     BNZ 0x256a
  2564    1C15     COMF 0x15, W, ACCESS
  2566    E101     BNZ 0x256a
  2568    D369     BRA 0x2c3c
240:                               return EOF;
241:                             ++count;
  256A    EC1E     CALL 0x2e3c, 0
  256C    F017     NOP
  256E    E201     BC 0x2572
  2570    D36B     BRA 0x2c48
  2572    2ADB     INCF 0xfdb, F, ACCESS
242:                             break;
  2574    D369     BRA 0x2c48
243:                           case 'c':
244:                             space_cnt = 0;
  2576    0E08     MOVLW 0x8
  2578    6ADB     CLRF 0xfdb, ACCESS
245:                             if (width > 1)
  257A    0E04     MOVLW 0x4
  257C    50DB     MOVF 0xfdb, W, ACCESS
  257E    0801     SUBLW 0x1
  2580    E206     BC 0x258e
246:                               {
247:                                 space_cnt = width - 1;
  2582    0E04     MOVLW 0x4
  2584    04DB     DECF 0xfdb, W, ACCESS
  2586    ECE6     CALL 0x2dcc, 0
  2588    F016     NOP
248:                                 count += space_cnt;
  258A    50DB     MOVF 0xfdb, W, ACCESS
  258C    DB8B     RCALL 0x2ca4
249:                               }
250:                             if (space_cnt && !(flags & _FLAG_MINUS))
  258E    0E08     MOVLW 0x8
  2590    50DB     MOVF 0xfdb, W, ACCESS
  2592    E009     BZ 0x25a6
  2594    0E03     MOVLW 0x3
  2596    50DB     MOVF 0xfdb, W, ACCESS
  2598    0B01     ANDLW 0x1
  259A    E105     BNZ 0x25a6
251:                               {
252:                                 if (s_put_n_chars (handle, space_cnt, ' '))
  259C    DB72     RCALL 0x2c82
  259E    E001     BZ 0x25a2
  25A0    D34D     BRA 0x2c3c
253:                                   return EOF;
254:                                 space_cnt = 0;
  25A2    0E08     MOVLW 0x8
  25A4    6ADB     CLRF 0xfdb, ACCESS
255:                               }
256:                             c = va_arg (ap, int);
  25A6    DB64     RCALL 0x2c70
  25A8    CFEF     MOVFF 0xfef, 0xfdf
  25AA    FFDF     NOP
257:                             if (putc (c, handle) == EOF)
  25AC    EC96     CALL 0x2f2c, 0
  25AE    F017     NOP
  25B0    E103     BNZ 0x25b8
  25B2    1C15     COMF 0x15, W, ACCESS
  25B4    E101     BNZ 0x25b8
  25B6    D342     BRA 0x2c3c
258:                               return EOF;
259:                             ++count;
  25B8    EC1E     CALL 0x2e3c, 0
  25BA    F017     NOP
  25BC    E301     BNC 0x25c0
  25BE    2ADB     INCF 0xfdb, F, ACCESS
260:                             if (s_put_n_chars (handle, space_cnt, ' '))
  25C0    DB60     RCALL 0x2c82
  25C2    E101     BNZ 0x25c6
  25C4    D341     BRA 0x2c48
261:                               return EOF;
  25C6    D33A     BRA 0x2c3c
262:                             break;
263:                           case 'S':
264:                             if (size == _FMT_SHLONG)
  25C8    0E07     MOVLW 0x7
  25CA    50DB     MOVF 0xfdb, W, ACCESS
  25CC    0802     SUBLW 0x2
  25CE    E10F     BNZ 0x25ee
265:                               romstring = va_arg (ap, rom far char *);
  25D0    EC62     CALL 0x2ec4, 0
  25D2    F017     NOP
  25D4    0E03     MOVLW 0x3
  25D6    EC29     CALL 0x2e52, 0
  25D8    F017     NOP
  25DA    0E0E     MOVLW 0xe
  25DC    CFEE     MOVFF 0xfee, 0xfdb
  25DE    FFDB     NOP
  25E0    0E0F     MOVLW 0xf
  25E2    CFEE     MOVFF 0xfee, 0xfdb
  25E4    FFDB     NOP
  25E6    0E10     MOVLW 0x10
  25E8    CFEE     MOVFF 0xfee, 0xfdb
  25EA    FFDB     NOP
266:                             else
  25EC    D020     BRA 0x262e
267:                               romstring = (far rom char*)va_arg (ap, rom near char *);
  25EE    0EF7     MOVLW 0xf7
  25F0    CFDB     MOVFF 0xfdb, 0x17
  25F2    F017     NOP
  25F4    0EF8     MOVLW 0xf8
  25F6    CFDB     MOVFF 0xfdb, 0x18
  25F8    F018     NOP
  25FA    0E02     MOVLW 0x2
  25FC    5E17     SUBWF 0x17, F, ACCESS
  25FE    0E00     MOVLW 0
  2600    5A18     SUBWFB 0x18, F, ACCESS
  2602    0EF7     MOVLW 0xf7
  2604    C017     MOVFF 0x17, 0xfdb
  2606    FFDB     NOP
  2608    0EF8     MOVLW 0xf8
  260A    C018     MOVFF 0x18, 0xfdb
  260C    FFDB     NOP
  260E    C017     MOVFF 0x17, 0xfe9
  2610    FFE9     NOP
  2612    C018     MOVFF 0x18, 0xfea
  2614    FFEA     NOP
  2616    EC19     CALL 0x2e32, 0
  2618    F017     NOP
  261A    6A16     CLRF 0x16, ACCESS
  261C    0E0E     MOVLW 0xe
  261E    C014     MOVFF 0x14, 0xfdb
  2620    FFDB     NOP
  2622    0E0F     MOVLW 0xf
  2624    C015     MOVFF 0x15, 0xfdb
  2626    FFDB     NOP
  2628    0E10     MOVLW 0x10
  262A    C016     MOVFF 0x16, 0xfdb
  262C    FFDB     NOP
268:                             n = strlenpgm (romstring);
  262E    0E0E     MOVLW 0xe
  2630    CFDB     MOVFF 0xfdb, 0xfe6
  2632    FFE6     NOP
  2634    0E0F     MOVLW 0xf
  2636    CFDB     MOVFF 0xfdb, 0xfe6
  2638    FFE6     NOP
  263A    0E10     MOVLW 0x10
  263C    CFDB     MOVFF 0xfdb, 0xfe6
  263E    FFE6     NOP
  2640    ECC6     CALL 0x4d8c, 0
  2642    F026     NOP
  2644    52E5     MOVF 0xfe5, F, ACCESS
  2646    52E5     MOVF 0xfe5, F, ACCESS
  2648    52E5     MOVF 0xfe5, F, ACCESS
  264A    0E13     MOVLW 0x13
  264C    C007     MOVFF 0x7, 0xfdb
  264E    FFDB     NOP
  2650    0E14     MOVLW 0x14
  2652    C008     MOVFF 0x8, 0xfdb
  2654    FFDB     NOP
269:                             /* Normalize the width based on the length of the actual 
270:                                string and the precision. */
271:                             if (have_precision && precision < (unsigned char) n)
  2656    0E06     MOVLW 0x6
  2658    50DB     MOVF 0xfdb, W, ACCESS
  265A    E005     BZ 0x2666
  265C    0E13     MOVLW 0x13
  265E    EC5D     CALL 0x2eba, 0
  2660    F017     NOP
  2662    E201     BC 0x2666
272:                               n = precision;
  2664    DB6A     RCALL 0x2d3a
  2D3A    0E05     MOVLW 0x5
  2D3C    50DB     MOVF 0xfdb, W, ACCESS
  2D3E    6EE6     MOVWF 0xfe6, ACCESS
  2D40    50D9     MOVF 0xfd9, W, ACCESS
  2D42    0F13     ADDLW 0x13
  2D44    D901     RCALL 0x2f48
  2D46    52E5     MOVF 0xfe5, F, ACCESS
  2D48    50E7     MOVF 0xfe7, W, ACCESS
  2D4A    6EEE     MOVWF 0xfee, ACCESS
  2D4C    6AED     CLRF 0xfed, ACCESS
  2D4E    0012     RETURN 0
273:                             if (width < (unsigned char) n)
  2666    EC81     CALL 0x2f02, 0
  2668    F017     NOP
  266A    E202     BC 0x2670
  2F02    0E13     MOVLW 0x13
  2F04    50DB     MOVF 0xfdb, W, ACCESS
  2F06    6EF3     MOVWF 0xff3, ACCESS
  2F08    0E04     MOVLW 0x4
  2F0A    EF6A     GOTO 0x2cd4
  2F0C    F016     NOP
274:                               width = n;
  266C    0E13     MOVLW 0x13
  266E    DB37     RCALL 0x2cde
275:                             space_cnt = width - (unsigned char) n;
  2670    EC44     CALL 0x2e88, 0
  2672    F017     NOP
  2E88    0E04     MOVLW 0x4
  2E8A    CFDB     MOVFF 0xfdb, 0xfe6
  2E8C    FFE6     NOP
  2E8E    0E13     MOVLW 0x13
  2E90    50DB     MOVF 0xfdb, W, ACCESS
  2E92    52E5     MOVF 0xfe5, F, ACCESS
  2E94    5CE7     SUBWF 0xfe7, W, ACCESS
  2E96    DF9A     RCALL 0x2dcc
276:                             count += space_cnt;
  2E98    50DB     MOVF 0xfdb, W, ACCESS
  2E9A    DF04     RCALL 0x2ca4
277:                             /* we've already calculated the space count that the width
278:                                will require. now we want the width field to have the
279:                                number of character to display from the string itself,
280:                                limited by the length of the actual string and the
281:                                specified precision. */
282:                             if (have_precision && precision < width)
  2674    E006     BZ 0x2682
  2676    0E04     MOVLW 0x4
  2678    EC5D     CALL 0x2eba, 0
  267A    F017     NOP
  267C    E202     BC 0x2682
  2E9C    0E06     MOVLW 0x6
  2E9E    50DB     MOVF 0xfdb, W, ACCESS
  2EA0    0012     RETURN 0
283:                               width = precision;
  267E    0E05     MOVLW 0x5
  2680    DB2E     RCALL 0x2cde
284:                             /* if right justified, we print the spaces before the
285:                                string */
286:                             if (!(flags & _FLAG_MINUS))
  2682    0E03     MOVLW 0x3
  2684    B0DB     BTFSC 0xfdb, 0, ACCESS
  2686    D005     BRA 0x2692
287:                               {
288:                                 if (s_put_n_chars (handle, space_cnt, ' '))
  2688    DAFC     RCALL 0x2c82
  268A    E001     BZ 0x268e
  268C    D2D7     BRA 0x2c3c
289:                                   return EOF;
290:                                 space_cnt = 0;
  268E    0E08     MOVLW 0x8
  2690    6ADB     CLRF 0xfdb, ACCESS
291:                               }
292:                             cval = 0;
  2692    0E09     MOVLW 0x9
  2694    6ADB     CLRF 0xfdb, ACCESS
293:                             for (c = *romstring; c && cval < width; c = *++romstring)
  2696    0E0E     MOVLW 0xe
  2698    CFDB     MOVFF 0xfdb, 0xff6
  269A    FFF6     NOP
  269C    0E0F     MOVLW 0xf
  269E    CFDB     MOVFF 0xfdb, 0xff7
  26A0    FFF7     NOP
  26A2    0E10     MOVLW 0x10
  26A4    CFDB     MOVFF 0xfdb, 0xff8
  26A6    FFF8     NOP
  26A8    0008     TBLRD*
  26AA    50F5     MOVF 0xff5, W, ACCESS
  26AC    6EDF     MOVWF 0xfdf, ACCESS
  26AE    50DF     MOVF 0xfdf, W, ACCESS
  26B0    E014     BZ 0x26da
  26B2    EC87     CALL 0x2f0e, 0
  26B4    F017     NOP
  26B6    E211     BC 0x26da
  26CE    50D9     MOVF 0xfd9, W, ACCESS
  26D0    0F0E     ADDLW 0xe
  26D2    6EE9     MOVWF 0xfe9, ACCESS
  26D4    0E00     MOVLW 0
  26D6    DBCB     RCALL 0x2e6e
  26D8    D7E7     BRA 0x26a8
  2F0E    0E04     MOVLW 0x4
  2F10    50DB     MOVF 0xfdb, W, ACCESS
  2F12    6EF3     MOVWF 0xff3, ACCESS
  2F14    0E09     MOVLW 0x9
  2F16    EF6A     GOTO 0x2cd4
  2F18    F016     NOP
294:                               {
295:                                 if (putc (c, handle) == EOF)
  26B8    EC96     CALL 0x2f2c, 0
  26BA    F017     NOP
  26BC    E103     BNZ 0x26c4
  26BE    1C15     COMF 0x15, W, ACCESS
  26C0    E101     BNZ 0x26c4
  26C2    D2BC     BRA 0x2c3c
296:                                   return EOF;
297:                                 ++count;
  26C4    DBBB     RCALL 0x2e3c
  26C6    E301     BNC 0x26ca
  26C8    2ADB     INCF 0xfdb, F, ACCESS
298:                                 ++cval;
  26CA    0E09     MOVLW 0x9
  26CC    2ADB     INCF 0xfdb, F, ACCESS
299:                               }
300:                             /* If there are spaces left, it's left justified. 
301:                                Either way, calling the function unconditionally 
302:                                is smaller code. */
303:                             if (s_put_n_chars (handle, space_cnt, ' '))
  26DA    DAD3     RCALL 0x2c82
  26DC    E101     BNZ 0x26e0
  26DE    D2B4     BRA 0x2c48
304:                               return EOF;
  26E0    D2AD     BRA 0x2c3c
305:                             break;
306:                           case 's':
307:                             ramstring = va_arg (ap, char *);
  26E2    DAC6     RCALL 0x2c70
  26E4    0E11     MOVLW 0x11
  26E6    CFEE     MOVFF 0xfee, 0xfdb
  26E8    FFDB     NOP
  26EA    0E12     MOVLW 0x12
  26EC    CFED     MOVFF 0xfed, 0xfdb
  26EE    FFDB     NOP
308:                             n = strlen (ramstring);
  26F0    0E11     MOVLW 0x11
  26F2    CFDB     MOVFF 0xfdb, 0xfe6
  26F4    FFE6     NOP
  26F6    0E12     MOVLW 0x12
  26F8    CFDB     MOVFF 0xfdb, 0xfe6
  26FA    FFE6     NOP
  26FC    ECB8     CALL 0x4d70, 0
  26FE    F026     NOP
  2700    52E5     MOVF 0xfe5, F, ACCESS
  2702    52E5     MOVF 0xfe5, F, ACCESS
  2704    0E13     MOVLW 0x13
  2706    CFF3     MOVFF 0xff3, 0xfdb
  2708    FFDB     NOP
  270A    0E14     MOVLW 0x14
  270C    CFF4     MOVFF 0xff4, 0xfdb
  270E    FFDB     NOP
309:                             /* Normalize the width based on the length of the actual 
310:                                string and the precision. */
311:                             if (have_precision && precision < (unsigned char) n)
  2710    0E06     MOVLW 0x6
  2712    50DB     MOVF 0xfdb, W, ACCESS
  2714    E004     BZ 0x271e
  2716    0E13     MOVLW 0x13
  2718    DBD0     RCALL 0x2eba
  271A    E201     BC 0x271e
312:                               n = precision;
  271C    DB0E     RCALL 0x2d3a
313:                             if (width < (unsigned char) n)
  271E    EC81     CALL 0x2f02, 0
  2720    F017     NOP
  2722    E202     BC 0x2728
314:                               width = n;
  2724    0E13     MOVLW 0x13
  2726    DADB     RCALL 0x2cde
315:                             space_cnt = width - (unsigned char) n;
  2728    DBAF     RCALL 0x2e88
  2DCC    6EE7     MOVWF 0xfe7, ACCESS
  2DCE    0E08     MOVLW 0x8
  2DD0    CFE7     MOVFF 0xfe7, 0xfdb
  2DD2    FFDB     NOP
  2DD4    0012     RETURN 0
316:                             count += space_cnt;
317:                             /* we've already calculated the space count that the width
318:                                will require. now we want the width field to have the
319:                                number of character to display from the string itself,
320:                                limited by the length of the actual string and the
321:                                specified precision. */
322:                             if (have_precision && precision < width)
  272A    E005     BZ 0x2736
  272C    0E04     MOVLW 0x4
  272E    DBC5     RCALL 0x2eba
  2730    E202     BC 0x2736
  2EBA    50DB     MOVF 0xfdb, W, ACCESS
  2EBC    6EF3     MOVWF 0xff3, ACCESS
  2EBE    0E05     MOVLW 0x5
  2EC0    EF6A     GOTO 0x2cd4
  2EC2    F016     NOP
323:                               width = precision;
  2732    0E05     MOVLW 0x5
  2734    DAD4     RCALL 0x2cde
  2CDE    50DB     MOVF 0xfdb, W, ACCESS
  2CE0    6EE7     MOVWF 0xfe7, ACCESS
  2CE2    0E04     MOVLW 0x4
  2CE4    CFE7     MOVFF 0xfe7, 0xfdb
  2CE6    FFDB     NOP
  2CE8    0012     RETURN 0
324:                             /* if right justified, we print the spaces before the
325:                                string */
326:                             if (!(flags & _FLAG_MINUS))
  2736    0E03     MOVLW 0x3
  2738    B0DB     BTFSC 0xfdb, 0, ACCESS
  273A    D005     BRA 0x2746
327:                               {
328:                                 if (s_put_n_chars (handle, space_cnt, ' '))
  273C    DAA2     RCALL 0x2c82
  273E    E001     BZ 0x2742
  2740    D27D     BRA 0x2c3c
329:                                   return EOF;
330:                                 space_cnt = 0;
  2742    0E08     MOVLW 0x8
  2744    6ADB     CLRF 0xfdb, ACCESS
331:                               }
332:                             cval = 0;
  2746    0E09     MOVLW 0x9
  2748    6ADB     CLRF 0xfdb, ACCESS
333:                             for (c = *ramstring; c && cval < width; c = *++ramstring)
  274A    0E11     MOVLW 0x11
  274C    CFDB     MOVFF 0xfdb, 0xfe9
  274E    FFE9     NOP
  2750    0E12     MOVLW 0x12
  2752    CFDB     MOVFF 0xfdb, 0xfea
  2754    FFEA     NOP
  2756    CFEF     MOVFF 0xfef, 0xfdf
  2758    FFDF     NOP
  275A    50DF     MOVF 0xfdf, W, ACCESS
  275C    E014     BZ 0x2786
  275E    DBD7     RCALL 0x2f0e
  2760    E212     BC 0x2786
  2776    0E11     MOVLW 0x11
  2778    2ADB     INCF 0xfdb, F, ACCESS
  277A    CFDB     MOVFF 0xfdb, 0xfe9
  277C    FFE9     NOP
  277E    0E12     MOVLW 0x12
  2780    E3E8     BNC 0x2752
  2782    2ADB     INCF 0xfdb, F, ACCESS
  2784    D7E6     BRA 0x2752
334:                               {
335:                                 if (putc (c, handle) == EOF)
  2762    DBE4     RCALL 0x2f2c
  2764    E103     BNZ 0x276c
  2766    1C15     COMF 0x15, W, ACCESS
  2768    E101     BNZ 0x276c
  276A    D268     BRA 0x2c3c
336:                                   return EOF;
337:                                 ++count;
  276C    DB67     RCALL 0x2e3c
  276E    E301     BNC 0x2772
  2770    2ADB     INCF 0xfdb, F, ACCESS
338:                                 ++cval;
  2772    0E09     MOVLW 0x9
  2774    2ADB     INCF 0xfdb, F, ACCESS
339:                               }
340:                             /* If there are spaces left, it's left justified. 
341:                                Either way, calling the function unconditionally 
342:                                is smaller code. */
343:                             if (s_put_n_chars (handle, space_cnt, ' '))
  2786    DA7D     RCALL 0x2c82
  2788    E101     BNZ 0x278c
  278A    D25E     BRA 0x2c48
344:                               return EOF;
  278C    D257     BRA 0x2c3c
345:                             break;
346:                           case 'd':
347:                           case 'i':
348:                             flags |= _FLAG_SIGNED;
  278E    0E03     MOVLW 0x3
  2790    8EDB     BSF 0xfdb, 0x7, ACCESS
349:                             /* fall through */
350:                           case 'o':
351:                           case 'u':
352:                           case 'x':
353:                           case 'X':
354:                           case 'b':
355:                           case 'B':
356:                             /* This is a bit of a sneaky trick. The 'l' and 'hh' size
357:                                specifiers are valid only for the integer conversions,
358:                                not the 'p' or 'P' conversions, and are ignored for the
359:                                latter. By jumping over the additional size specifier
360:                                checks here we get the best code size since we can
361:                                limit the size checks in the remaining code. */
362:                             if (size == _FMT_LONG)
  2792    0E07     MOVLW 0x7
  2794    04DB     DECF 0xfdb, W, ACCESS
  2796    E110     BNZ 0x27b8
363:                               {
364:                                 larg = va_arg (ap, long int);
  2798    DB95     RCALL 0x2ec4
  279A    0E04     MOVLW 0x4
  279C    DB5A     RCALL 0x2e52
  279E    0E0A     MOVLW 0xa
  27A0    CFEE     MOVFF 0xfee, 0xfdb
  27A2    FFDB     NOP
  27A4    0E0B     MOVLW 0xb
  27A6    CFEE     MOVFF 0xfee, 0xfdb
  27A8    FFDB     NOP
  27AA    0E0C     MOVLW 0xc
  27AC    CFEE     MOVFF 0xfee, 0xfdb
  27AE    FFDB     NOP
  27B0    0E0D     MOVLW 0xd
  27B2    CFEE     MOVFF 0xfee, 0xfdb
  27B4    FFDB     NOP
365:                                 goto _do_integer_conversion;
  27B6    D06C     BRA 0x2890
366:                               }
367:                             else if (size == _FMT_BYTE)
  27B8    0E07     MOVLW 0x7
  27BA    50DB     MOVF 0xfdb, W, ACCESS
  27BC    0803     SUBLW 0x3
  27BE    E12C     BNZ 0x2818
368:                               {
369:                                 if (flags & _FLAG_SIGNED)
  27C0    0E03     MOVLW 0x3
  27C2    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  27C4    D00D     BRA 0x27e0
370:                                   larg = (signed char) va_arg (ap, int);
  27C6    DAB2     RCALL 0x2d2c
  27C8    0E02     MOVLW 0x2
  27CA    DA76     RCALL 0x2cb8
  27CC    CFEF     MOVFF 0xfef, 0x14
  27CE    F014     NOP
  27D0    6A15     CLRF 0x15, ACCESS
  27D2    6A16     CLRF 0x16, ACCESS
  27D4    6A17     CLRF 0x17, ACCESS
  27D6    AE14     BTFSS 0x14, 0x7, ACCESS
  27D8    D039     BRA 0x284c
  27DA    6815     SETF 0x15, ACCESS
  27DC    6816     SETF 0x16, ACCESS
371:                                 else
  27DE    D035     BRA 0x284a
372:                                   larg = (unsigned char) va_arg (ap, unsigned int);
  27E0    0EF7     MOVLW 0xf7
  27E2    CFDB     MOVFF 0xfdb, 0x15
  27E4    F015     NOP
  27E6    0EF8     MOVLW 0xf8
  27E8    CFDB     MOVFF 0xfdb, 0x16
  27EA    F016     NOP
  27EC    0E02     MOVLW 0x2
  27EE    5E15     SUBWF 0x15, F, ACCESS
  27F0    0E00     MOVLW 0
  27F2    5A16     SUBWFB 0x16, F, ACCESS
  27F4    0EF7     MOVLW 0xf7
  27F6    C015     MOVFF 0x15, 0xfdb
  27F8    FFDB     NOP
  27FA    0EF8     MOVLW 0xf8
  27FC    C016     MOVFF 0x16, 0xfdb
  27FE    FFDB     NOP
  2800    C015     MOVFF 0x15, 0xfe9
  2802    FFE9     NOP
  2804    C016     MOVFF 0x16, 0xfea
  2806    FFEA     NOP
  2808    CFEF     MOVFF 0xfef, 0x14
  280A    F014     NOP
  280C    0E0A     MOVLW 0xa
  280E    C014     MOVFF 0x14, 0xfdb
  2810    FFDB     NOP
  2812    0E0B     MOVLW 0xb
  2814    6ADB     CLRF 0xfdb, ACCESS
373:                                 goto _do_integer_conversion;
  2816    D038     BRA 0x2888
374:                               }
375:                             /* fall through */
376:                           case 'p':
377:                           case 'P':
378:                             if (size == _FMT_SHLONG)
  2818    0E07     MOVLW 0x7
  281A    50DB     MOVF 0xfdb, W, ACCESS
  281C    0802     SUBLW 0x2
  281E    E109     BNZ 0x2832
379:                               {
380:                                 if (flags & _FLAG_SIGNED)
  2820    0E03     MOVLW 0x3
  2822    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  2824    D004     BRA 0x282e
381:                                   larg = va_arg (ap, short long int);
  2826    DB59     RCALL 0x2eda
  2828    AE16     BTFSS 0x16, 0x7, ACCESS
  282A    D010     BRA 0x284c
  2DD6    CFEE     MOVFF 0xfee, 0x14
  2DD8    F014     NOP
  2DDA    CFEE     MOVFF 0xfee, 0x15
  2DDC    F015     NOP
  2DDE    CFEF     MOVFF 0xfef, 0x16
  2DE0    F016     NOP
  2DE2    6A17     CLRF 0x17, ACCESS
  2DE4    0012     RETURN 0
  2EDA    DF28     RCALL 0x2d2c
  2EDC    0E03     MOVLW 0x3
  2EDE    DEEC     RCALL 0x2cb8
  2EE0    EFEB     GOTO 0x2dd6
  2EE2    F016     NOP
382:                                 else
  282C    D00E     BRA 0x284a
383:                                   larg = va_arg (ap, unsigned short long int);
  282E    DB55     RCALL 0x2eda
384:                               }
385:                             else if (flags & _FLAG_SIGNED)
  2830    D00D     BRA 0x284c
  2832    0E03     MOVLW 0x3
  2834    AEDB     BTFSS 0xfdb, 0x7, ACCESS
  2836    D012     BRA 0x285c
386:                               larg = va_arg (ap, int);
  2838    DA79     RCALL 0x2d2c
  283A    0E02     MOVLW 0x2
  283C    DA3D     RCALL 0x2cb8
  283E    DAF9     RCALL 0x2e32
  2840    6A16     CLRF 0x16, ACCESS
  2842    6A17     CLRF 0x17, ACCESS
  2844    AE15     BTFSS 0x15, 0x7, ACCESS
  2846    D002     BRA 0x284c
  2848    6816     SETF 0x16, ACCESS
  284A    6817     SETF 0x17, ACCESS
  284C    DAE2     RCALL 0x2e12
  284E    0E0C     MOVLW 0xc
  2850    C016     MOVFF 0x16, 0xfdb
  2852    FFDB     NOP
  2854    0E0D     MOVLW 0xd
  2856    C017     MOVFF 0x17, 0xfdb
  2858    FFDB     NOP
  2CB8    5E18     SUBWF 0x18, F, ACCESS
  2CBA    0E00     MOVLW 0
  2CBC    5A19     SUBWFB 0x19, F, ACCESS
  2CBE    0EF7     MOVLW 0xf7
  2CC0    C018     MOVFF 0x18, 0xfdb
  2CC2    FFDB     NOP
  2CC4    0EF8     MOVLW 0xf8
  2CC6    C019     MOVFF 0x19, 0xfdb
  2CC8    FFDB     NOP
  2CCA    C018     MOVFF 0x18, 0xfe9
  2CCC    FFE9     NOP
  2CCE    C019     MOVFF 0x19, 0xfea
  2CD0    FFEA     NOP
  2CD2    0012     RETURN 0
  2D2C    0EF7     MOVLW 0xf7
  2D2E    CFDB     MOVFF 0xfdb, 0x18
  2D30    F018     NOP
  2D32    0EF8     MOVLW 0xf8
  2D34    CFDB     MOVFF 0xfdb, 0x19
  2D36    F019     NOP
  2D38    0012     RETURN 0
  2E12    0E0A     MOVLW 0xa
  2E14    C014     MOVFF 0x14, 0xfdb
  2E16    FFDB     NOP
  2E18    0E0B     MOVLW 0xb
  2E1A    C015     MOVFF 0x15, 0xfdb
  2E1C    FFDB     NOP
  2E1E    0012     RETURN 0
  2E32    CFEE     MOVFF 0xfee, 0x14
  2E34    F014     NOP
  2E36    CFEF     MOVFF 0xfef, 0x15
  2E38    F015     NOP
  2E3A    0012     RETURN 0
387:                             else
  285A    D01A     BRA 0x2890
388:                               larg = va_arg (ap, unsigned int);
  285C    0EF7     MOVLW 0xf7
  285E    CFDB     MOVFF 0xfdb, 0x16
  2860    F016     NOP
  2862    0EF8     MOVLW 0xf8
  2864    CFDB     MOVFF 0xfdb, 0x17
  2866    F017     NOP
  2868    0E02     MOVLW 0x2
  286A    5E16     SUBWF 0x16, F, ACCESS
  286C    0E00     MOVLW 0
  286E    5A17     SUBWFB 0x17, F, ACCESS
  2870    0EF7     MOVLW 0xf7
  2872    C016     MOVFF 0x16, 0xfdb
  2874    FFDB     NOP
  2876    0EF8     MOVLW 0xf8
  2878    C017     MOVFF 0x17, 0xfdb
  287A    FFDB     NOP
  287C    C016     MOVFF 0x16, 0xfe9
  287E    FFE9     NOP
  2880    C017     MOVFF 0x17, 0xfea
  2882    FFEA     NOP
  2884    DAD6     RCALL 0x2e32
  2886    DAC5     RCALL 0x2e12
  2888    0E0C     MOVLW 0xc
  288A    6ADB     CLRF 0xfdb, ACCESS
  288C    0E0D     MOVLW 0xd
  288E    6ADB     CLRF 0xfdb, ACCESS
389:                           _do_integer_conversion:
390:                             /* default precision is 1 */
391:                             if (!have_precision)
  2890    0E06     MOVLW 0x6
  2892    50DB     MOVF 0xfdb, W, ACCESS
  2894    E105     BNZ 0x28a0
392:                               precision = 1;
  2896    0E01     MOVLW 0x1
  2898    6EF3     MOVWF 0xff3, ACCESS
  289A    0E05     MOVLW 0x5
  289C    CFF3     MOVFF 0xff3, 0xfdb
  289E    FFDB     NOP
393:               
394:                             {
395:                               unsigned char digit_cnt = 0;
  28A0    0E15     MOVLW 0x15
  28A2    6ADB     CLRF 0xfdb, ACCESS
396:                               unsigned char prefix_cnt = 0;
  28A4    0E16     MOVLW 0x16
  28A6    6ADB     CLRF 0xfdb, ACCESS
397:                               unsigned char sign_char;
398:                               /* A 32 bit number will require at most 32 digits in the
399:                                  string representation (binary format). */
400:                               char buf[33];
401:                               /* Start storing digits least-significant first */
402:                               char *q = &buf[31];
  28A8    50D9     MOVF 0xfd9, W, ACCESS
  28AA    0F37     ADDLW 0x37
  28AC    6E14     MOVWF 0x14, ACCESS
  28AE    0E00     MOVLW 0
  28B0    20DA     ADDWFC 0xfda, W, ACCESS
  28B2    6E15     MOVWF 0x15, ACCESS
  28B4    0E39     MOVLW 0x39
  28B6    C014     MOVFF 0x14, 0xfdb
  28B8    FFDB     NOP
  28BA    0E3A     MOVLW 0x3a
  28BC    C015     MOVFF 0x15, 0xfdb
  28BE    FFDB     NOP
403:                               /* null terminate the string */
404:                               buf[32] = '\0';
  28C0    0E38     MOVLW 0x38
  28C2    6ADB     CLRF 0xfdb, ACCESS
405:               
406:                               space_cnt = 0;
  28C4    0E08     MOVLW 0x8
  28C6    6ADB     CLRF 0xfdb, ACCESS
407:                               size = 10;
  28C8    0E0A     MOVLW 0xa
  28CA    DAAE     RCALL 0x2e28
408:               
409:                               switch (c)
  28CC    50DF     MOVF 0xfdf, W, ACCESS
  28CE    0A78     XORLW 0x78
  28D0    E012     BZ 0x28f6
  28D2    0A20     XORLW 0x20
  28D4    E010     BZ 0x28f6
  28D6    0A28     XORLW 0x28
  28D8    E00C     BZ 0x28f2
  28DA    0A20     XORLW 0x20
  28DC    E00A     BZ 0x28f2
  28DE    0A3F     XORLW 0x3f
  28E0    E006     BZ 0x28ee
  28E2    0A0D     XORLW 0xd
  28E4    E002     BZ 0x28ea
  28E6    0A20     XORLW 0x20
  28E8    E108     BNZ 0x28fa
410:                                 {
411:                                 case 'b':
412:                                 case 'B':
413:                                   size = 2;
  28EA    0E02     MOVLW 0x2
414:                                   break;
  28EC    D005     BRA 0x28f8
415:                                 case 'o':
416:                                   size = 8;
  28EE    0E08     MOVLW 0x8
417:                                   break;
  28F0    D003     BRA 0x28f8
418:                                 case 'p':
419:                                 case 'P':
420:                                   /* from here on out, treat 'p' conversions just
421:                                      like 'x' conversions. */
422:                                   c += 'x' - 'p';
  28F2    0E08     MOVLW 0x8
  28F4    26DF     ADDWF 0xfdf, F, ACCESS
423:                                   /* fall through */
424:                                 case 'x':
425:                                 case 'X':
426:                                   size = 16;
  28F6    0E10     MOVLW 0x10
  28F8    DA97     RCALL 0x2e28
  2E28    6EF3     MOVWF 0xff3, ACCESS
  2E2A    0E07     MOVLW 0x7
  2E2C    CFF3     MOVFF 0xff3, 0xfdb
  2E2E    FFDB     NOP
  2E30    0012     RETURN 0
427:                                   break;
428:                                 }
429:               
430:                               /* if it's an unsigned conversion, we should ignore the
431:                                  ' ' and '+' flags */
432:                               if (!(flags & _FLAG_SIGNED))
  28FA    0E03     MOVLW 0x3
  28FC    BEDB     BTFSC 0xfdb, 0x7, ACCESS
  28FE    D002     BRA 0x2904
433:                                 flags &= ~(_FLAG_PLUS | _FLAG_SPACE);
  2900    92DB     BCF 0xfdb, 0x1, ACCESS
  2902    94DB     BCF 0xfdb, 0x2, ACCESS
434:               
435:                               /* if it's a negative value, we need to negate the
436:                                  unsigned version before we convert to text. Using
437:                                  unsigned for this allows us to (ab)use the 2's
438:                                  complement system to avoid overflow and be able to
439:                                  adequately handle LONG_MIN.
440:               
441:                                  We'll figure out what sign character to print, if
442:                                  any, here as well. */
443:                               if (flags & _FLAG_SIGNED && ((long) larg < 0))
  2904    50DB     MOVF 0xfdb, W, ACCESS
  2906    0B80     ANDLW 0x80
  2908    E024     BZ 0x2952
  290A    DA8A     RCALL 0x2e20
  290C    90D8     BCF 0xfd8, 0, ACCESS
  290E    0E03     MOVLW 0x3
  2910    50EB     MOVF 0xfeb, W, ACCESS
  2912    0A00     XORLW 0
  2914    E608     BN 0x2926
  2916    0E00     MOVLW 0
  2918    5CEE     SUBWF 0xfee, W, ACCESS
  291A    0E00     MOVLW 0
  291C    58EE     SUBWFB 0xfee, W, ACCESS
  291E    0E00     MOVLW 0
  2920    58EE     SUBWFB 0xfee, W, ACCESS
  2922    0E00     MOVLW 0
  2924    58EE     SUBWFB 0xfee, W, ACCESS
  2926    E215     BC 0x2952
  2E20    50D9     MOVF 0xfd9, W, ACCESS
  2E22    0F0A     ADDLW 0xa
  2E24    EFA4     GOTO 0x2f48
  2E26    F017     NOP
  2F48    6EE9     MOVWF 0xfe9, ACCESS
  2F4A    0E00     MOVLW 0
  2F4C    20DA     ADDWFC 0xfda, W, ACCESS
  2F4E    6EEA     MOVWF 0xfea, ACCESS
  2F50    0012     RETURN 0
444:                                 {
445:                                   larg = -(long) larg;
  2928    DA13     RCALL 0x2d50
  292A    680B     SETF 0xb, ACCESS
  292C    680C     SETF 0xc, ACCESS
  292E    680D     SETF 0xd, ACCESS
  2930    680E     SETF 0xe, ACCESS
  2932    ECBD     CALL 0x517a, 0
  2934    F028     NOP
  2936    0E0A     MOVLW 0xa
  2938    C002     MOVFF 0x2, 0xfdb
  293A    FFDB     NOP
  293C    0E0B     MOVLW 0xb
  293E    C003     MOVFF 0x3, 0xfdb
  2940    FFDB     NOP
  2942    0E0C     MOVLW 0xc
  2944    C004     MOVFF 0x4, 0xfdb
  2946    FFDB     NOP
  2948    0E0D     MOVLW 0xd
  294A    C005     MOVFF 0x5, 0xfdb
  294C    FFDB     NOP
  2D50    0E0A     MOVLW 0xa
  2D52    CFDB     MOVFF 0xfdb, 0x6
  2D54    F006     NOP
  2D56    0E0B     MOVLW 0xb
  2D58    CFDB     MOVFF 0xfdb, 0x7
  2D5A    F007     NOP
  2D5C    0E0C     MOVLW 0xc
  2D5E    CFDB     MOVFF 0xfdb, 0x8
  2D60    F008     NOP
  2D62    0E0D     MOVLW 0xd
  2D64    CFDB     MOVFF 0xfdb, 0x9
  2D66    F009     NOP
  2D68    0012     RETURN 0
446:                                   sign_char = '-';
  294E    0E2D     MOVLW 0x2d
447:                                   ++digit_cnt;
448:                                 }
449:                               else if (flags & _FLAG_PLUS)
  2950    D008     BRA 0x2962
  2952    0E03     MOVLW 0x3
  2954    A2DB     BTFSS 0xfdb, 0x1, ACCESS
  2956    D002     BRA 0x295c
450:                                 {
451:                                   sign_char = '+';
  2958    0E2B     MOVLW 0x2b
452:                                   ++digit_cnt;
453:                                 }
454:                               else if (flags & _FLAG_SPACE)
  295A    D003     BRA 0x2962
  295C    A4DB     BTFSS 0xfdb, 0x2, ACCESS
  295E    D008     BRA 0x2970
455:                                 {
456:                                   sign_char = ' ';
  2960    0E20     MOVLW 0x20
  2962    6EF3     MOVWF 0xff3, ACCESS
  2964    0E17     MOVLW 0x17
  2966    CFF3     MOVFF 0xff3, 0xfdb
  2968    FFDB     NOP
457:                                   ++digit_cnt;
  296A    0E15     MOVLW 0x15
  296C    2ADB     INCF 0xfdb, F, ACCESS
458:                                 }
459:                               else
  296E    D002     BRA 0x2974
460:                                 sign_char = '\0';
  2970    0E17     MOVLW 0x17
  2972    6ADB     CLRF 0xfdb, ACCESS
461:                               /* get the digits for the actual number. If the
462:                                  precision is zero and the value is zero, the result
463:                                  is no characters. */
464:                               if (precision || larg)
  2974    0E05     MOVLW 0x5
  2976    50DB     MOVF 0xfdb, W, ACCESS
  2978    E103     BNZ 0x2980
  297A    D9B7     RCALL 0x2cea
  297C    E101     BNZ 0x2980
  297E    D089     BRA 0x2a92
  2CEA    0E0A     MOVLW 0xa
  2CEC    CFDB     MOVFF 0xfdb, 0x14
  2CEE    F014     NOP
  2CF0    0E0B     MOVLW 0xb
  2CF2    CFDB     MOVFF 0xfdb, 0x15
  2CF4    F015     NOP
  2CF6    0E0C     MOVLW 0xc
  2CF8    CFDB     MOVFF 0xfdb, 0x16
  2CFA    F016     NOP
  2CFC    0E0D     MOVLW 0xd
  2CFE    CFDB     MOVFF 0xfdb, 0x17
  2D00    F017     NOP
  2D02    5014     MOVF 0x14, W, ACCESS
  2D04    1015     IORWF 0x15, W, ACCESS
  2D06    1016     IORWF 0x16, W, ACCESS
  2D08    1017     IORWF 0x17, W, ACCESS
  2D0A    0012     RETURN 0
465:                                 {
466:                                   do
467:                                     {
468:                                       cval = s_digits[larg % size];
  2980    0E24     MOVLW 0x24
  2982    6E14     MOVWF 0x14, ACCESS
  2984    0E53     MOVLW 0x53
  2986    6E15     MOVWF 0x15, ACCESS
  2988    0E00     MOVLW 0
  298A    6E16     MOVWF 0x16, ACCESS
  298C    0E07     MOVLW 0x7
  298E    CFDB     MOVFF 0xfdb, 0x17
  2990    F017     NOP
  2992    6A18     CLRF 0x18, ACCESS
  2994    6A19     CLRF 0x19, ACCESS
  2996    6A1A     CLRF 0x1a, ACCESS
  2998    C017     MOVFF 0x17, 0xb
  299A    F00B     NOP
  299C    C018     MOVFF 0x18, 0xc
  299E    F00C     NOP
  29A0    C019     MOVFF 0x19, 0xd
  29A2    F00D     NOP
  29A4    C01A     MOVFF 0x1a, 0xe
  29A6    F00E     NOP
  29A8    D9D3     RCALL 0x2d50
  29AA    ECF5     CALL 0x51ea, 0
  29AC    F028     NOP
  29AE    5014     MOVF 0x14, W, ACCESS
  29B0    2402     ADDWF 0x2, W, ACCESS
  29B2    6EF3     MOVWF 0xff3, ACCESS
  29B4    5015     MOVF 0x15, W, ACCESS
  29B6    2003     ADDWFC 0x3, W, ACCESS
  29B8    6EF4     MOVWF 0xff4, ACCESS
  29BA    5016     MOVF 0x16, W, ACCESS
  29BC    2004     ADDWFC 0x4, W, ACCESS
  29BE    6EF8     MOVWF 0xff8, ACCESS
  29C0    CFF4     MOVFF 0xff4, 0xff7
  29C2    FFF7     NOP
  29C4    CFF3     MOVFF 0xff3, 0xff6
  29C6    FFF6     NOP
  29C8    0008     TBLRD*
  29CA    0E09     MOVLW 0x9
  29CC    CFF5     MOVFF 0xff5, 0xfdb
  29CE    FFDB     NOP
469:                                       if (c == 'X' && cval >= 'a')
  29D0    0E58     MOVLW 0x58
  29D2    5CDF     SUBWF 0xfdf, W, ACCESS
  29D4    E10F     BNZ 0x29f4
  29D6    0E61     MOVLW 0x61
  29D8    6EF3     MOVWF 0xff3, ACCESS
  29DA    0E09     MOVLW 0x9
  29DC    D97B     RCALL 0x2cd4
  29DE    E30A     BNC 0x29f4
  2CD4    CFDB     MOVFF 0xfdb, 0xff4
  2CD6    FFF4     NOP
  2CD8    50F3     MOVF 0xff3, W, ACCESS
  2CDA    5CF4     SUBWF 0xff4, W, ACCESS
  2CDC    0012     RETURN 0
470:                                         cval -= 'a' - 'A';
  29E0    0E20     MOVLW 0x20
  29E2    6E14     MOVWF 0x14, ACCESS
  29E4    0E09     MOVLW 0x9
  29E6    CFDB     MOVFF 0xfdb, 0xfe7
  29E8    FFE7     NOP
  29EA    5014     MOVF 0x14, W, ACCESS
  29EC    5EE7     SUBWF 0xfe7, F, ACCESS
  29EE    0E09     MOVLW 0x9
  29F0    CFE7     MOVFF 0xfe7, 0xfdb
  29F2    FFDB     NOP
471:                                       larg /= size;
  29F4    0E07     MOVLW 0x7
  29F6    CFDB     MOVFF 0xfdb, 0x14
  29F8    F014     NOP
  29FA    6A15     CLRF 0x15, ACCESS
  29FC    6A16     CLRF 0x16, ACCESS
  29FE    6A17     CLRF 0x17, ACCESS
  2A00    DA0F     RCALL 0x2e20
  2A02    C014     MOVFF 0x14, 0xb
  2A04    F00B     NOP
  2A06    C015     MOVFF 0x15, 0xc
  2A08    F00C     NOP
  2A0A    C016     MOVFF 0x16, 0xd
  2A0C    F00D     NOP
  2A0E    C017     MOVFF 0x17, 0xe
  2A10    F00E     NOP
  2A12    CFEE     MOVFF 0xfee, 0x6
  2A14    F006     NOP
  2A16    CFEE     MOVFF 0xfee, 0x7
  2A18    F007     NOP
  2A1A    CFEE     MOVFF 0xfee, 0x8
  2A1C    F008     NOP
  2A1E    CFEF     MOVFF 0xfef, 0x9
  2A20    F009     NOP
  2A22    ECF5     CALL 0x51ea, 0
  2A24    F028     NOP
  2A26    C009     MOVFF 0x9, 0xfed
  2A28    FFED     NOP
  2A2A    C008     MOVFF 0x8, 0xfed
  2A2C    FFED     NOP
  2A2E    C007     MOVFF 0x7, 0xfed
  2A30    FFED     NOP
  2A32    C006     MOVFF 0x6, 0xfef
  2A34    FFEF     NOP
472:                                       *q-- = cval;
  2A36    0E39     MOVLW 0x39
  2A38    CFDB     MOVFF 0xfdb, 0xfe9
  2A3A    FFE9     NOP
  2A3C    06DB     DECF 0xfdb, F, ACCESS
  2A3E    0E3A     MOVLW 0x3a
  2A40    CFDB     MOVFF 0xfdb, 0xfea
  2A42    FFEA     NOP
  2A44    E201     BC 0x2a48
  2A46    06DB     DECF 0xfdb, F, ACCESS
  2A48    0E09     MOVLW 0x9
  2A4A    CFDB     MOVFF 0xfdb, 0xfef
  2A4C    FFEF     NOP
473:                                       ++digit_cnt;
  2A4E    0E15     MOVLW 0x15
  2A50    2ADB     INCF 0xfdb, F, ACCESS
474:                                     }
475:                                   while (larg);
  2A52    D94B     RCALL 0x2cea
  2A54    E195     BNZ 0x2980
476:                                   /* if the '#' flag was specified and we're dealing
477:                                      with an 'o', 'b', 'B', 'x', or 'X' conversion,
478:                                      we need a bit more. */
479:                                   if (flags & _FLAG_OCTO)
  2A56    0E03     MOVLW 0x3
  2A58    A6DB     BTFSS 0xfdb, 0x3, ACCESS
  2A5A    D01D     BRA 0x2a96
480:                                     {
481:                                       if (c == 'o')
  2A5C    0E6F     MOVLW 0x6f
  2A5E    5CDF     SUBWF 0xfdf, W, ACCESS
  2A60    E106     BNZ 0x2a6e
482:                                         {
483:                                           /* per the standard, for octal, the '#' flag
484:                                              makes the precision be at least one more
485:                                              than the number of digits in the number */
486:                                           if (precision <= digit_cnt)
  2A62    D9C1     RCALL 0x2de6
  2A64    E318     BNC 0x2a96
  2DE6    0E05     MOVLW 0x5
  2DE8    CFDB     MOVFF 0xfdb, 0x14
  2DEA    F014     NOP
  2DEC    0E15     MOVLW 0x15
  2DEE    50DB     MOVF 0xfdb, W, ACCESS
  2DF0    80D8     BSF 0xfd8, 0, ACCESS
  2DF2    5414     SUBFWB 0x14, W, ACCESS
  2DF4    0012     RETURN 0
487:                                             precision = digit_cnt + 1;
  2A66    0E15     MOVLW 0x15
  2A68    28DB     INCF 0xfdb, W, ACCESS
  2A6A    DA5B     RCALL 0x2f22
488:                                         }
489:                                       else if (c == 'x'
  2A6C    D014     BRA 0x2a96
  2A6E    0E78     MOVLW 0x78
490:                                                || c == 'X' || c == 'b' || c == 'B')
  2A70    5CDF     SUBWF 0xfdf, W, ACCESS
  2A72    E009     BZ 0x2a86
  2A74    0E58     MOVLW 0x58
  2A76    5CDF     SUBWF 0xfdf, W, ACCESS
  2A78    E006     BZ 0x2a86
  2A7A    0E62     MOVLW 0x62
  2A7C    5CDF     SUBWF 0xfdf, W, ACCESS
  2A7E    E003     BZ 0x2a86
  2A80    0E42     MOVLW 0x42
  2A82    5CDF     SUBWF 0xfdf, W, ACCESS
  2A84    E108     BNZ 0x2a96
491:                                         prefix_cnt = 2;
  2A86    0E02     MOVLW 0x2
  2A88    6EF3     MOVWF 0xff3, ACCESS
  2A8A    0E16     MOVLW 0x16
  2A8C    CFF3     MOVFF 0xff3, 0xfdb
  2A8E    FFDB     NOP
492:                                     }
493:                                 }
494:                               else
  2A90    D002     BRA 0x2a96
495:                                 digit_cnt = 0;
  2A92    0E15     MOVLW 0x15
  2A94    6ADB     CLRF 0xfdb, ACCESS
496:               
497:                               /* The leading zero count depends on whether the '0'
498:                                  flag was specified or not. If it was not, then the
499:                                  count is the difference between the specified
500:                                  precision and the number of digits (including the
501:                                  sign character, if any) to be printed; otherwise,
502:                                  it's as if the precision were equal to the max of
503:                                  the specified precision and the field width. If a
504:                                  precision was specified, the '0' flag is ignored,
505:                                  however. */
506:                               if ((flags & _FLAG_ZERO) && (width > precision)
  2A96    0E03     MOVLW 0x3
  2A98    50DB     MOVF 0xfdb, W, ACCESS
  2A9A    0B10     ANDLW 0x10
  2A9E    0E04     MOVLW 0x4
  2AA0    CFDB     MOVFF 0xfdb, 0x14
  2AA2    F014     NOP
  2AA4    0E05     MOVLW 0x5
  2AA6    50DB     MOVF 0xfdb, W, ACCESS
  2AA8    80D8     BSF 0xfd8, 0, ACCESS
  2AAA    5414     SUBFWB 0x14, W, ACCESS
507:                                   && !have_precision)
  2A9C    E00E     BZ 0x2aba
  2AAC    E206     BC 0x2aba
  2AAE    0E06     MOVLW 0x6
  2AB0    50DB     MOVF 0xfdb, W, ACCESS
  2AB2    E103     BNZ 0x2aba
508:                                 precision = width;
  2AB4    0E04     MOVLW 0x4
  2AB6    50DB     MOVF 0xfdb, W, ACCESS
  2AB8    DA34     RCALL 0x2f22
509:                               /* for the rest of the processing, precision contains
510:                                  the leading zero count for the conversion. */
511:                               if (precision > digit_cnt)
  2ABA    D995     RCALL 0x2de6
  2ABC    E20A     BC 0x2ad2
512:                                 precision -= digit_cnt;
  2ABE    0E05     MOVLW 0x5
  2AC0    CFDB     MOVFF 0xfdb, 0xfe7
  2AC2    FFE7     NOP
  2AC4    0E15     MOVLW 0x15
  2AC6    50DB     MOVF 0xfdb, W, ACCESS
  2AC8    5EE7     SUBWF 0xfe7, F, ACCESS
  2ACA    0E05     MOVLW 0x5
  2ACC    CFE7     MOVFF 0xfe7, 0xfdb
  2ACE    FFDB     NOP
513:                               else
  2AD0    D002     BRA 0x2ad6
514:                                 precision = 0;
  2AD2    0E05     MOVLW 0x5
  2AD4    6ADB     CLRF 0xfdb, ACCESS
515:                               /* the space count is the difference between the field
516:                                  width and the digit count plus the leading zero
517:                                  count. If the width is less than the digit count
518:                                  plus the leading zero count, the space count is
519:                                  zero. */
520:                               if (width > precision + digit_cnt + prefix_cnt)
  2AD6    0E04     MOVLW 0x4
  2AD8    CFDB     MOVFF 0xfdb, 0x14
  2ADA    F014     NOP
  2ADC    0E16     MOVLW 0x16
  2ADE    D945     RCALL 0x2d6a
  2AE0    80D8     BSF 0xfd8, 0, ACCESS
  2AE2    5414     SUBFWB 0x14, W, ACCESS
  2AE4    E214     BC 0x2b0e
  2D6A    CFDB     MOVFF 0xfdb, 0xfe6
  2D6C    FFE6     NOP
  2D6E    0E15     MOVLW 0x15
  2D70    CFDB     MOVFF 0xfdb, 0xfe6
  2D72    FFE6     NOP
  2D74    0E05     MOVLW 0x5
  2D76    50DB     MOVF 0xfdb, W, ACCESS
  2D78    52E5     MOVF 0xfe5, F, ACCESS
  2D7A    24E7     ADDWF 0xfe7, W, ACCESS
  2D7C    52E5     MOVF 0xfe5, F, ACCESS
  2D7E    24E7     ADDWF 0xfe7, W, ACCESS
  2D80    0012     RETURN 0
521:                                 space_cnt =
522:                                   width - precision - digit_cnt - prefix_cnt;
  2AE6    0E16     MOVLW 0x16
  2AE8    CFDB     MOVFF 0xfdb, 0xfe6
  2AEA    FFE6     NOP
  2AEC    0E15     MOVLW 0x15
  2AEE    CFDB     MOVFF 0xfdb, 0xfe6
  2AF0    FFE6     NOP
  2AF2    0E04     MOVLW 0x4
  2AF4    CFDB     MOVFF 0xfdb, 0xfe6
  2AF6    FFE6     NOP
  2AF8    0E05     MOVLW 0x5
  2AFA    50DB     MOVF 0xfdb, W, ACCESS
  2AFC    52E5     MOVF 0xfe5, F, ACCESS
  2AFE    5CE7     SUBWF 0xfe7, W, ACCESS
  2B00    52E5     MOVF 0xfe5, F, ACCESS
  2B02    80D8     BSF 0xfd8, 0, ACCESS
  2B04    54E7     SUBFWB 0xfe7, W, ACCESS
  2B06    52E5     MOVF 0xfe5, F, ACCESS
  2B08    80D8     BSF 0xfd8, 0, ACCESS
  2B0A    54E7     SUBFWB 0xfe7, W, ACCESS
  2B0C    D95F     RCALL 0x2dcc
523:               
524:                               /* for output, we check the justification, if it's
525:                                  right justified and the space count is positive, we
526:                                  emit the space characters first. */
527:                               if (!(flags & _FLAG_MINUS) && space_cnt)
  2B0E    0E03     MOVLW 0x3
  2B10    50DB     MOVF 0xfdb, W, ACCESS
  2B12    0B01     ANDLW 0x1
  2B14    E10B     BNZ 0x2b2c
  2B16    0E08     MOVLW 0x8
  2B18    50DB     MOVF 0xfdb, W, ACCESS
  2B1A    E008     BZ 0x2b2c
528:                                 {
529:                                   if (s_put_n_chars (handle, space_cnt, ' '))
  2B1C    D8B2     RCALL 0x2c82
  2B1E    E001     BZ 0x2b22
  2B20    D08D     BRA 0x2c3c
530:                                     return EOF;
531:                                   count += space_cnt;
  2B22    0E08     MOVLW 0x8
  2B24    50DB     MOVF 0xfdb, W, ACCESS
  2B26    D8BE     RCALL 0x2ca4
532:                                   space_cnt = 0;
  2B28    0E08     MOVLW 0x8
  2B2A    6ADB     CLRF 0xfdb, ACCESS
533:                                 }
534:                               /* if we have a sign character to print, that comes
535:                                  next */
536:                               if (sign_char)
  2B2C    0E17     MOVLW 0x17
  2B2E    50DB     MOVF 0xfdb, W, ACCESS
  2B30    E007     BZ 0x2b40
537:                                 if (putc (sign_char, handle) == EOF)
  2B32    D988     RCALL 0x2e44
  2B34    0E17     MOVLW 0x17
  2B36    D9F1     RCALL 0x2f1a
  2B38    E103     BNZ 0x2b40
  2B3A    1C15     COMF 0x15, W, ACCESS
  2B3C    E101     BNZ 0x2b40
  2B3E    D07E     BRA 0x2c3c
538:                                   return EOF;
539:                               /* if we have a prefix (0b, 0B, 0x or 0X), that's next */
540:                               if (prefix_cnt)
  2B40    0E16     MOVLW 0x16
  2B42    50DB     MOVF 0xfdb, W, ACCESS
  2B44    E016     BZ 0x2b72
541:                                 {
542:                                   if (putc ('0', handle) == EOF)
  2B46    D97E     RCALL 0x2e44
  2B48    0E30     MOVLW 0x30
  2B4A    6EE6     MOVWF 0xfe6, ACCESS
  2B4C    D89F     RCALL 0x2c8c
  2B4E    E102     BNZ 0x2b54
  2B50    1C15     COMF 0x15, W, ACCESS
  2B52    E074     BZ 0x2c3c
543:                                     return EOF;
544:                                   if (putc (c, handle) == EOF)
  2B54    D977     RCALL 0x2e44
  2B56    CFDF     MOVFF 0xfdf, 0xfe6
  2B58    FFE6     NOP
  2B5A    EC7B     CALL 0x50f6, 0
  2B5C    F028     NOP
  2B5E    52E5     MOVF 0xfe5, F, ACCESS
  2B60    52E5     MOVF 0xfe5, F, ACCESS
  2B62    52E5     MOVF 0xfe5, F, ACCESS
  2B64    CFF4     MOVFF 0xff4, 0x15
  2B66    F015     NOP
  2B68    0100     MOVLB 0
  2B6A    1CF3     COMF 0xff3, W, ACCESS
  2B6C    E102     BNZ 0x2b72
  2B6E    1C15     COMF 0x15, W, ACCESS
  2B70    E065     BZ 0x2c3c
545:                                     return EOF;
546:                                 }
547:                               /* if we have leading zeros, they follow. the prefix, if any
548:                                  is included in the number of digits when determining how
549:                                  many leading zeroes are needed. */
550:                               if (precision > prefix_cnt)
  2B72    0E05     MOVLW 0x5
  2B74    CFDB     MOVFF 0xfdb, 0x14
  2B76    F014     NOP
  2B78    0E16     MOVLW 0x16
  2B7A    50DB     MOVF 0xfdb, W, ACCESS
  2B7C    80D8     BSF 0xfd8, 0, ACCESS
  2B7E    5414     SUBFWB 0x14, W, ACCESS
  2B80    E209     BC 0x2b94
551:                                 precision -= prefix_cnt;
  2B82    0E05     MOVLW 0x5
  2B84    CFDB     MOVFF 0xfdb, 0xfe7
  2B86    FFE7     NOP
  2B88    0E16     MOVLW 0x16
  2B8A    50DB     MOVF 0xfdb, W, ACCESS
  2B8C    5EE7     SUBWF 0xfe7, F, ACCESS
  2B8E    0E05     MOVLW 0x5
  2B90    CFE7     MOVFF 0xfe7, 0xfdb
  2B92    FFDB     NOP
552:                               if (s_put_n_chars (handle, precision, '0'))
  2B94    0E30     MOVLW 0x30
  2B96    6EE6     MOVWF 0xfe6, ACCESS
  2B98    0E05     MOVLW 0x5
  2B9A    D9CB     RCALL 0x2f32
  2B9C    E14F     BNZ 0x2c3c
  2EE4    EC98     CALL 0x2330, 0
  2EE6    F011     NOP
  2EE8    52E5     MOVF 0xfe5, F, ACCESS
  2EEA    52E5     MOVF 0xfe5, F, ACCESS
  2EEC    52E5     MOVF 0xfe5, F, ACCESS
  2EEE    52E5     MOVF 0xfe5, F, ACCESS
  2EF0    0900     IORLW 0
  2EF2    0012     RETURN 0
  2F32    CFDB     MOVFF 0xfdb, 0xfe6
  2F34    FFE6     NOP
  2F36    DF86     RCALL 0x2e44
  2F38    EF72     GOTO 0x2ee4
  2F3A    F017     NOP
553:                                 return EOF;
554:                               /* print the actual number */
555:                               for (cval = *++q; cval; cval = *++q)
  2B9E    0E39     MOVLW 0x39
  2BA0    2ADB     INCF 0xfdb, F, ACCESS
  2BA2    CFDB     MOVFF 0xfdb, 0xfe9
  2BA4    FFE9     NOP
  2BA6    0E3A     MOVLW 0x3a
  2BA8    E301     BNC 0x2bac
  2BAA    2ADB     INCF 0xfdb, F, ACCESS
  2BAC    CFDB     MOVFF 0xfdb, 0xfea
  2BAE    FFEA     NOP
  2BB0    0E09     MOVLW 0x9
  2BB2    CFEF     MOVFF 0xfef, 0xfdb
  2BB4    FFDB     NOP
  2BB6    50DB     MOVF 0xfdb, W, ACCESS
  2BB8    E00E     BZ 0x2bd6
  2BC6    0E39     MOVLW 0x39
  2BC8    2ADB     INCF 0xfdb, F, ACCESS
  2BCA    CFDB     MOVFF 0xfdb, 0xfe9
  2BCC    FFE9     NOP
  2BCE    0E3A     MOVLW 0x3a
  2BD0    E3ED     BNC 0x2bac
  2BD2    2ADB     INCF 0xfdb, F, ACCESS
  2BD4    D7EB     BRA 0x2bac
556:                                 if (putc (cval, handle) == EOF)
  2BBA    D944     RCALL 0x2e44
  2BBC    0E09     MOVLW 0x9
  2BBE    D9AD     RCALL 0x2f1a
  2BC0    E102     BNZ 0x2bc6
  2BC2    1C15     COMF 0x15, W, ACCESS
  2BC4    E03B     BZ 0x2c3c
  2F1A    CFDB     MOVFF 0xfdb, 0xfe6
  2F1C    FFE6     NOP
  2F1E    EF46     GOTO 0x2c8c
  2F20    F016     NOP
557:                                   return EOF;
558:                               /* if there are any spaces left, they go to right-pad
559:                                  the field */
560:                               if (s_put_n_chars (handle, space_cnt, ' '))
  2BD6    D855     RCALL 0x2c82
  2BD8    E131     BNZ 0x2c3c
  2C82    0E20     MOVLW 0x20
  2C84    6EE6     MOVWF 0xfe6, ACCESS
  2C86    0E08     MOVLW 0x8
  2C88    EF99     GOTO 0x2f32
  2C8A    F017     NOP
  2E44    0EFC     MOVLW 0xfc
  2E46    CFDB     MOVFF 0xfdb, 0xfe6
  2E48    FFE6     NOP
  2E4A    0EFD     MOVLW 0xfd
  2E4C    CFDB     MOVFF 0xfdb, 0xfe6
  2E4E    FFE6     NOP
  2E50    0012     RETURN 0
561:                                 return EOF;
562:               
563:                               count += precision + digit_cnt + space_cnt + prefix_cnt;
  2BDA    0E16     MOVLW 0x16
  2BDC    CFDB     MOVFF 0xfdb, 0xfe6
  2BDE    FFE6     NOP
  2BE0    0E08     MOVLW 0x8
  2BE2    D8C3     RCALL 0x2d6a
  2BE4    52E5     MOVF 0xfe5, F, ACCESS
  2BE6    24E7     ADDWF 0xfe7, W, ACCESS
  2BE8    D85D     RCALL 0x2ca4
  2CA4    6E14     MOVWF 0x14, ACCESS
  2CA6    6A15     CLRF 0x15, ACCESS
  2CA8    50D9     MOVF 0xfd9, W, ACCESS
  2CAA    0F01     ADDLW 0x1
  2CAC    D94D     RCALL 0x2f48
  2CAE    5014     MOVF 0x14, W, ACCESS
  2CB0    26EE     ADDWF 0xfee, F, ACCESS
  2CB2    5015     MOVF 0x15, W, ACCESS
  2CB4    22ED     ADDWFC 0xfed, F, ACCESS
  2CB6    0012     RETURN 0
564:                             }
565:                             break;
  2BEA    D02E     BRA 0x2c48
566:                           case 'n':
567:                             switch (size)
  2BEC    0E07     MOVLW 0x7
  2BEE    50DB     MOVF 0xfdb, W, ACCESS
  2BF0    0A03     XORLW 0x3
  2BF2    E01C     BZ 0x2c2c
  2BF4    0A01     XORLW 0x1
  2BF6    E014     BZ 0x2c20
  2BF8    0A03     XORLW 0x3
  2BFA    E007     BZ 0x2c0a
568:                               {
569:                               case _FMT_LONG:
570:                                 *(long *) va_arg (ap, long *) = count;
  2C0A    D8F5     RCALL 0x2df6
  2C0C    6A19     CLRF 0x19, ACCESS
  2C0E    AE17     BTFSS 0x17, 0x7, ACCESS
  2C10    D002     BRA 0x2c16
  2C12    6818     SETF 0x18, ACCESS
  2C14    6819     SETF 0x19, ACCESS
  2C16    D82C     RCALL 0x2c70
  2C18    D8BC     RCALL 0x2d92
  2C1A    C019     MOVFF 0x19, 0xfee
  2C1C    FFEE     NOP
  2D92    50EE     MOVF 0xfee, W, ACCESS
  2D94    CFEF     MOVFF 0xfef, 0xfea
  2D96    FFEA     NOP
  2D98    6EE9     MOVWF 0xfe9, ACCESS
  2D9A    C016     MOVFF 0x16, 0xfee
  2D9C    FFEE     NOP
  2D9E    C017     MOVFF 0x17, 0xfee
  2DA0    FFEE     NOP
  2DA2    C018     MOVFF 0x18, 0xfee
  2DA4    FFEE     NOP
  2DA6    0012     RETURN 0
  2DF6    0E01     MOVLW 0x1
  2DF8    CFDB     MOVFF 0xfdb, 0x16
  2DFA    F016     NOP
  2DFC    0E02     MOVLW 0x2
  2DFE    CFDB     MOVFF 0xfdb, 0x17
  2E00    F017     NOP
  2E02    6A18     CLRF 0x18, ACCESS
  2E04    0012     RETURN 0
571:                                 break;
  2C1E    D014     BRA 0x2c48
572:                               case _FMT_SHLONG:
573:                                 *(short long *) va_arg (ap, short long *) = count;
  2C20    D8EA     RCALL 0x2df6
  2C22    BE17     BTFSC 0x17, 0x7, ACCESS
  2C24    6818     SETF 0x18, ACCESS
  2C26    D824     RCALL 0x2c70
  2C28    D8B4     RCALL 0x2d92
574:                                 break;
  2C2A    D00E     BRA 0x2c48
575:                               case _FMT_BYTE:
576:                                 *(signed char *) va_arg (ap, signed char *) = count;
  2C2C    D963     RCALL 0x2ef4
  2C2E    CFDB     MOVFF 0xfdb, 0xfef
  2C30    FFEF     NOP
577:                                 break;
  2C32    D00A     BRA 0x2c48
578:                               default:
579:                                 *(int *) va_arg (ap, int *) = count;
  2BFC    D97B     RCALL 0x2ef4
  2BFE    CFDB     MOVFF 0xfdb, 0xfee
  2C00    FFEE     NOP
  2C02    0E02     MOVLW 0x2
  2C04    CFDB     MOVFF 0xfdb, 0xfed
  2C06    FFED     NOP
  2EF4    DEBD     RCALL 0x2c70
  2EF6    50EE     MOVF 0xfee, W, ACCESS
  2EF8    CFEF     MOVFF 0xfef, 0xfea
  2EFA    FFEA     NOP
  2EFC    6EE9     MOVWF 0xfe9, ACCESS
  2EFE    0E01     MOVLW 0x1
  2F00    0012     RETURN 0
580:                                 break;
581:                               }
582:                             break;
  2C08    D01F     BRA 0x2c48
583:                           default:
584:                             /* undefined behaviour. we do nothing */
585:                             break;
586:                           }
587:                       }
588:                     else
589:                       {
590:                         if (putc (c, handle) == EOF)
  2C34    D97B     RCALL 0x2f2c
  2C36    E105     BNZ 0x2c42
  2C38    1C15     COMF 0x15, W, ACCESS
  2C3A    E103     BNZ 0x2c42
  2C8C    EC7B     CALL 0x50f6, 0
  2C8E    F028     NOP
  2C90    52E5     MOVF 0xfe5, F, ACCESS
  2C92    52E5     MOVF 0xfe5, F, ACCESS
  2C94    52E5     MOVF 0xfe5, F, ACCESS
  2C96    CFF3     MOVFF 0xff3, 0x14
  2C98    F014     NOP
  2C9A    CFF4     MOVFF 0xff4, 0x15
  2C9C    F015     NOP
  2C9E    0100     MOVLB 0
  2CA0    1CF3     COMF 0xff3, W, ACCESS
  2CA2    0012     RETURN 0
  2ED2    CFDF     MOVFF 0xfdf, 0xfe6
  2ED4    FFE6     NOP
  2ED6    EF46     GOTO 0x2c8c
  2ED8    F016     NOP
  2F2C    DF8B     RCALL 0x2e44
  2F2E    EF69     GOTO 0x2ed2
  2F30    F017     NOP
591:                           return EOF;
  2C3C    68F3     SETF 0xff3, ACCESS
  2C3E    68F4     SETF 0xff4, ACCESS
  2C40    D010     BRA 0x2c62
592:                         ++count;
  2C42    D8FC     RCALL 0x2e3c
  2C44    E301     BNC 0x2c48
  2C46    2ADB     INCF 0xfdb, F, ACCESS
  2E3C    0E01     MOVLW 0x1
  2E3E    2ADB     INCF 0xfdb, F, ACCESS
  2E40    0E02     MOVLW 0x2
  2E42    0012     RETURN 0
593:                       }
594:                   }
595:               
596:                 return count;
  2C4E    0E01     MOVLW 0x1
  2C50    CFDB     MOVFF 0xfdb, 0x14
  2C52    F014     NOP
  2C54    0E02     MOVLW 0x2
  2C56    CFDB     MOVFF 0xfdb, 0x15
  2C58    F015     NOP
  2C5A    C014     MOVFF 0x14, 0xff3
  2C5C    FFF3     NOP
  2C5E    C015     MOVFF 0x15, 0xff4
  2C60    FFF4     NOP
597:               }
  2C62    0E3B     MOVLW 0x3b
  2C64    5CE1     SUBWF 0xfe1, W, ACCESS
  2C66    E202     BC 0x2c6c
  2C68    6AE1     CLRF 0xfe1, ACCESS
  2C6A    52E5     MOVF 0xfe5, F, ACCESS
  2C6C    6EE1     MOVWF 0xfe1, ACCESS
  2C6E    D0CB     BRA 0x2e06
---  E:\Projects\DevPFG\Microchip\MDD File System\Internal Flash.c  ------------------------------
1:                 /******************************************************************************
2:                  
3:                                 Microchip Memory Disk Drive File System
4:                  
5:                  *****************************************************************************
6:                   FileName:        Internal Flash.c
7:                   Dependencies:    See includes section.
8:                   Processor:       PIC18/PIC24/dsPIC33/PIC32 microcontrollers
9:                   Compiler:        MPLAB(R) C18/C30/C32 compilers are supported by this code
10:                  Company:         Microchip Technology, Inc.
11:                 
12:                  Software License Agreement
13:                 
14:                  The software supplied herewith by Microchip Technology Incorporated
15:                  (the "Company") for its PICmicror Microcontroller is intended and
16:                  supplied to you, the Company's customer, for use solely and
17:                  exclusively on Microchip PICmicro Microcontroller products. The
18:                  software is owned by the Company and/or its supplier, and is
19:                  protected under applicable copyright laws. All rights are reserved.
20:                  Any use in violation of the foregoing restrictions may subject the
21:                  user to criminal sanctions under applicable laws, as well as to
22:                  civil liability for the breach of the terms and conditions of this
23:                  license.
24:                 
25:                  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
26:                  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:                  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:                  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:                  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:                  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:                 
32:                *****************************************************************************/
33:                //DOM-IGNORE-BEGIN
34:                /********************************************************************
35:                 Change History:
36:                  Rev    Description
37:                  -----  -----------
38:                  1.2.5  Fixed bug where sector address was calculated incorrectly
39:                  1.2.7  Re-implemented sector read/write functions for PIC24
40:                         devices.  This removes the 32kB PSV size restriction.
41:                         Also added some additional error checking.
42:                ********************************************************************/
43:                //DOM-IGNORE-END
44:                
45:                #include "Compiler.h"
46:                #include "GenericTypeDefs.h"
47:                #include "HardwareProfile.h"
48:                #include "MDD File System/FSIO.h"
49:                
50:                #if defined(USE_INTERNAL_FLASH)
51:                
52:                #include "MDD File System/FSDefs.h"
53:                #include "string.h"
54:                #include "MDD File System/Internal Flash.h"
55:                
56:                /*************************************************************************/
57:                /*  Note:  This file is included as a template of a C file for           */
58:                /*         a new physical layer. It is designed to go with               */
59:                /*         "TEMPLATEFILE.h"                                              */
60:                /*************************************************************************/
61:                
62:                /******************************************************************************
63:                 * Global Variables
64:                 *****************************************************************************/
65:                
66:                #ifdef USE_PIC18
67:                	#pragma udata
68:                	#pragma code
69:                #endif
70:                
71:                static MEDIA_INFORMATION mediaInformation;
72:                
73:                /******************************************************************************
74:                 * Prototypes
75:                 *****************************************************************************/
76:                void EraseBlock(ROM BYTE* dest);
77:                void WriteRow(void);
78:                void WriteByte(unsigned char);
79:                BYTE DISKmount( DISK *dsk);
80:                BYTE LoadMBR(DISK *dsk);
81:                BYTE LoadBootSector(DISK *dsk);
82:                extern void Delayms(BYTE milliseconds);
83:                MEDIA_INFORMATION * MediaInitialize(void);
84:                void UnlockAndActivate(BYTE);
85:                
86:                //Arbitray, but "uncommon" value.  Used by UnlockAndActivateWR() to enhance robustness.
87:                #define NVM_UNLOCK_KEY  (BYTE)0xB5   
88:                
89:                /******************************************************************************
90:                 * Function:        BYTE MediaDetect(void)
91:                 *
92:                 * PreCondition:    InitIO() function has been executed.
93:                 *
94:                 * Input:           void
95:                 *
96:                 * Output:          TRUE   - Card detected
97:                 *                  FALSE   - No card detected
98:                 *
99:                 * Side Effects:    None
100:                *
101:                * Overview:        None
102:                *
103:                * Note:            None
104:                *****************************************************************************/
105:               BYTE MDD_IntFlash_MediaDetect()
106:               {
107:               	return TRUE;
108:               }//end MediaDetect
  4846    0C01     RETLW 0x1
109:               
110:               /******************************************************************************
111:                * Function:        WORD ReadSectorSize(void)
112:                *
113:                * PreCondition:    MediaInitialize() is complete
114:                *
115:                * Input:           void
116:                *
117:                * Output:          WORD - size of the sectors for this physical media.
118:                *
119:                * Side Effects:    None
120:                *
121:                * Overview:        None
122:                *
123:                * Note:            None
124:                *****************************************************************************/
125:               WORD MDD_IntFlash_ReadSectorSize(void)
126:               {
127:                   return MEDIA_SECTOR_SIZE;
  4848    6AF3     CLRF 0xff3, ACCESS
  484A    0E02     MOVLW 0x2
  484C    6EF4     MOVWF 0xff4, ACCESS
128:               }
  484E    0012     RETURN 0
129:               
130:               /******************************************************************************
131:                * Function:        DWORD ReadCapacity(void)
132:                *
133:                * PreCondition:    MediaInitialize() is complete
134:                *
135:                * Input:           void
136:                *
137:                * Output:          DWORD - size of the "disk" - 1 (in terms of sector count).  
138:                *                  Ex: In other words, this function returns the last valid 
139:                *                  LBA address that may be read/written to.
140:                *
141:                * Side Effects:    None
142:                *
143:                * Overview:        None
144:                *
145:                * Note:            None
146:                *****************************************************************************/
147:               DWORD MDD_IntFlash_ReadCapacity(void)
148:               {
149:                   //The SCSI READ_CAPACITY command wants to know the last valid LBA address 
150:                   //that the host is allowed to read or write to.  Since LBA addresses start
151:                   //at and include 0, a return value of 0 from this function would mean the 
152:                   //host is allowed to read and write the LBA == 0x00000000, which would be 
153:                   //1 sector worth of capacity.
154:                   //Therefore, the last valid LBA that the host may access is 
155:                   //MDD_INTERNAL_FLASH_TOTAL_DISK_SIZE - 1.
156:                       
157:                   return (MDD_INTERNAL_FLASH_TOTAL_DISK_SIZE - 1); 
  4850    0E3F     MOVLW 0x3f
  4852    6E06     MOVWF 0x6, ACCESS
  4854    6A07     CLRF 0x7, ACCESS
  4856    6A08     CLRF 0x8, ACCESS
  4858    6A09     CLRF 0x9, ACCESS
158:               }
  485A    0012     RETURN 0
159:               
160:               /******************************************************************************
161:                * Function:        BYTE InitIO(void)
162:                *
163:                * PreCondition:    None
164:                *
165:                * Input:           void
166:                *
167:                * Output:          TRUE   - Card initialized
168:                *                  FALSE   - Card not initialized
169:                *
170:                * Side Effects:    None
171:                *
172:                * Overview:        None
173:                *
174:                * Note:            None
175:                *****************************************************************************/
176:               BYTE MDD_IntFlash_InitIO (void)
177:               {
178:                   return  TRUE;
179:               }
  485C    0C01     RETLW 0x1
180:               
181:               /******************************************************************************
182:                * Function:        BYTE MediaInitialize(void)
183:                *
184:                * PreCondition:    None
185:                *
186:                * Input:           None
187:                *
188:                * Output:          Returns a pointer to a MEDIA_INFORMATION structure
189:                *
190:                * Overview:        MediaInitialize initializes the media card and supporting variables.
191:                *
192:                * Note:            None
193:                *****************************************************************************/
194:               MEDIA_INFORMATION * MDD_IntFlash_MediaInitialize(void)
195:               {
196:               	mediaInformation.errorCode = MEDIA_NO_ERROR;
  485E    0101     MOVLB 0x1
  4860    6BE1     CLRF 0xe1, BANKED
197:               	return &mediaInformation;
  4862    0EE1     MOVLW 0xe1
  4864    6E14     MOVWF 0x14, ACCESS
  4866    0E01     MOVLW 0x1
  4868    C014     MOVFF 0x14, 0xff3
  486A    FFF3     NOP
  486C    6EF4     MOVWF 0xff4, ACCESS
198:               }//end MediaInitialize
  486E    0012     RETURN 0
199:               
200:               
201:               /******************************************************************************
202:                * Function:        BYTE SectorRead(DWORD sector_addr, BYTE *buffer)
203:                *
204:                * PreCondition:    None
205:                *
206:                * Input:           sector_addr - Sector address, each sector contains 512-byte
207:                *                  buffer      - Buffer where data will be stored, see
208:                *                                'ram_acs.h' for 'block' definition.
209:                *                                'Block' is dependent on whether internal or
210:                *                                external memory is used
211:                *
212:                * Output:          Returns TRUE if read successful, false otherwise
213:                *
214:                * Side Effects:    None
215:                *
216:                * Overview:        SectorRead reads 512 bytes of data from the card starting
217:                *                  at the sector address specified by sector_addr and stores
218:                *                  them in the location pointed to by 'buffer'.
219:                *
220:                * Note:            The device expects the address field in the command packet
221:                *                  to be byte address. Therefore the sector_addr must first
222:                *                  be converted to byte address. This is accomplished by
223:                *                  shifting the address left 9 times.
224:                *****************************************************************************/
225:               //The flash memory is organized differently on the different microcontroller
226:               //families.  Therefore, multiple versions of this function are implemented.
227:               #if defined(__C30__)    //PIC24 or dsPIC33 device (WORD organized flash memory)
228:               BYTE MDD_IntFlash_SectorRead(DWORD sector_addr, BYTE* buffer)
229:               {
230:                   WORD i;
231:                   DWORD flashAddress;
232:                   BYTE TBLPAGSave;
233:                   
234:                   //Error check.  Make sure the host is trying to read from a legitimate
235:                   //address, which corresponds to the MSD volume (and not some other program
236:                   //memory region beyond the end of the MSD volume).
237:                   if(sector_addr >= MDD_INTERNAL_FLASH_TOTAL_DISK_SIZE)
238:                   {
239:                       return FALSE;
240:                   }    
241:                   
242:                   //Save TBLPAG register
243:                   TBLPAGSave = TBLPAG;
244:                  
245:                   //Compute the 24 bit starting address.  Note: this is a word address, but we
246:                   //only store data in and read from the lower word (even LSB).
247:                   //Starting address will always be even, since MasterBootRecord[] uses aligned attribute in declaration.
248:                   flashAddress = (DWORD)FILES_ADDRESS + (DWORD)(sector_addr*(WORD)MEDIA_SECTOR_SIZE);  
249:                   
250:                   //Read a sector worth of data from the flash, and copy to the user specified "buffer".
251:                   for(i = 0; i < (MEDIA_SECTOR_SIZE / 2u); i++)
252:                   {
253:                       TBLPAG = (BYTE)(flashAddress >> 16);   //Load TBLPAG pointer (upper 8 bits of total address.  A sector could get split at 
254:                                                       //a 16-bit address boundary, and therefore could exist on two TBLPAG pages.
255:                                                       //Therefore, need to reload TBLPAG every iteration of the for() loop
256:                       *(WORD*)buffer = __builtin_tblrdl((WORD)flashAddress);
257:                       buffer += 2u;                   //Just wrote a word.  Increment pointer for next word.
258:                       flashAddress += 2u;             //Increment address by 2.  No MSD data stored in the upper WORD (which only has one implemented byte anyway).
259:                       
260:                   }   
261:                   
262:                   //Restore TBLPAG register to original value
263:                   TBLPAG = TBLPAGSave;
264:                   
265:                   return TRUE;
266:               }    
267:               #else   //else must be PIC18 or PIC32 device (BYTE organized flash memory)
268:               BYTE MDD_IntFlash_SectorRead(DWORD sector_addr, BYTE* buffer)
  4870    CFD9     MOVFF 0xfd9, 0xfe6
  4872    FFE6     NOP
  4874    CFE1     MOVFF 0xfe1, 0xfd9
  4876    FFD9     NOP
269:               {
270:                   //Error check.  Make sure the host is trying to read from a legitimate
271:                   //address, which corresponds to the MSD volume (and not some other program
272:                   //memory region beyond the end of the MSD volume).
273:                   if(sector_addr >= MDD_INTERNAL_FLASH_TOTAL_DISK_SIZE)
  4878    50E1     MOVF 0xfe1, W, ACCESS
  487A    0FFB     ADDLW 0xfb
  487C    6EE9     MOVWF 0xfe9, ACCESS
  487E    0EFF     MOVLW 0xff
  4880    20DA     ADDWFC 0xfda, W, ACCESS
  4882    6EEA     MOVWF 0xfea, ACCESS
  4884    0E40     MOVLW 0x40
  4886    5CEE     SUBWF 0xfee, W, ACCESS
  4888    0E00     MOVLW 0
  488A    58EE     SUBWFB 0xfee, W, ACCESS
  488C    0E00     MOVLW 0
  488E    58EE     SUBWFB 0xfee, W, ACCESS
  4890    0E00     MOVLW 0
  4892    58EE     SUBWFB 0xfee, W, ACCESS
  4894    E302     BNC 0x489a
274:                   {
275:                       return FALSE;
  4896    0E00     MOVLW 0
  4898    D037     BRA 0x4908
276:                   }   
277:                   
278:                   //Read a sector worth of data, and copy it to the specified RAM "buffer".
279:                   memcpypgm2ram
280:                   (
281:                       (void*)buffer,
  48EE    0EF9     MOVLW 0xf9
  48F0    CFDB     MOVFF 0xfdb, 0xfe6
  48F2    FFE6     NOP
  48F4    0EFA     MOVLW 0xfa
  48F6    CFDB     MOVFF 0xfdb, 0xfe6
  48F8    FFE6     NOP
282:                       (ROM void*)(MASTER_BOOT_RECORD_ADDRESS + (sector_addr * MEDIA_SECTOR_SIZE)),
  48A0    0E00     MOVLW 0
  48A2    6E17     MOVWF 0x17, ACCESS
  48A4    0E78     MOVLW 0x78
  48A6    6E18     MOVWF 0x18, ACCESS
  48A8    0E00     MOVLW 0
  48AA    6E19     MOVWF 0x19, ACCESS
  48AC    0EFB     MOVLW 0xfb
  48AE    CFDB     MOVFF 0xfdb, 0x6
  48B0    F006     NOP
  48B2    0EFC     MOVLW 0xfc
  48B4    CFDB     MOVFF 0xfdb, 0x7
  48B6    F007     NOP
  48B8    0EFD     MOVLW 0xfd
  48BA    CFDB     MOVFF 0xfdb, 0x8
  48BC    F008     NOP
  48BE    0EFE     MOVLW 0xfe
  48C0    CFDB     MOVFF 0xfdb, 0x9
  48C2    F009     NOP
  48C4    6A0B     CLRF 0xb, ACCESS
  48C6    0E02     MOVLW 0x2
  48C8    6E0C     MOVWF 0xc, ACCESS
  48CA    6A0D     CLRF 0xd, ACCESS
  48CC    6A0E     CLRF 0xe, ACCESS
  48CE    ECBD     CALL 0x517a, 0
  48D0    F028     NOP
  48D2    5017     MOVF 0x17, W, ACCESS
  48D4    2402     ADDWF 0x2, W, ACCESS
  48D6    6E14     MOVWF 0x14, ACCESS
  48D8    5018     MOVF 0x18, W, ACCESS
  48DA    2003     ADDWFC 0x3, W, ACCESS
  48DC    6E15     MOVWF 0x15, ACCESS
  48DE    5019     MOVF 0x19, W, ACCESS
  48E0    2004     ADDWFC 0x4, W, ACCESS
  48E2    6E16     MOVWF 0x16, ACCESS
  48E4    C014     MOVFF 0x14, 0xfe6
  48E6    FFE6     NOP
  48E8    C015     MOVFF 0x15, 0xfe6
  48EA    FFE6     NOP
  48EC    6EE6     MOVWF 0xfe6, ACCESS
283:                       MEDIA_SECTOR_SIZE
284:                   );
  489A    6AE6     CLRF 0xfe6, ACCESS
  489C    0E02     MOVLW 0x2
  489E    6EE6     MOVWF 0xfe6, ACCESS
  48FA    EC7B     CALL 0x4cf6, 0
  48FC    F026     NOP
  48FE    6E1A     MOVWF 0x1a, ACCESS
  4900    0E07     MOVLW 0x7
  4902    5EE1     SUBWF 0xfe1, F, ACCESS
  4904    501A     MOVF 0x1a, W, ACCESS
285:               
286:               	return TRUE;
  4906    0E01     MOVLW 0x1
287:               }//end SectorRead
  4908    52E5     MOVF 0xfe5, F, ACCESS
  490A    CFE7     MOVFF 0xfe7, 0xfd9
  490C    FFD9     NOP
  490E    0012     RETURN 0
288:               #endif
289:               
290:               
291:               /******************************************************************************
292:                * Function:        BYTE SectorWrite(DWORD sector_addr, BYTE *buffer, BYTE allowWriteToZero)
293:                *
294:                * PreCondition:    None
295:                *
296:                * Input:           sector_addr - Sector address, each sector contains 512-byte
297:                *                  buffer      - Buffer where data will be read
298:                *                  allowWriteToZero - If true, writes to the MBR will be valid
299:                *
300:                * Output:          Returns TRUE if write successful, FALSE otherwise
301:                *
302:                * Side Effects:    None
303:                *
304:                * Overview:        SectorWrite sends 512 bytes of data from the location
305:                *                  pointed to by 'buffer' to the card starting
306:                *                  at the sector address specified by sector_addr.
307:                *
308:                * Note:            The sample device expects the address field in the command packet
309:                *                  to be byte address. Therefore the sector_addr must first
310:                *                  be converted to byte address. This is accomplished by
311:                *                  shifting the address left 9 times.
312:                *****************************************************************************/
313:               #if defined(__18CXX)
314:               #pragma udata myFileBuffer
315:               #endif
316:               volatile unsigned char file_buffer[ERASE_BLOCK_SIZE] __attribute__((far));
317:               #if defined(__18CXX)
318:               #pragma udata
319:               #endif
320:               
321:               #define INTERNAL_FLASH_PROGRAM_WORD        0x4003
322:               #define INTERNAL_FLASH_ERASE               0x4042
323:               #define INTERNAL_FLASH_PROGRAM_PAGE        0x4001
324:               
325:               
326:               #if defined(__C32__)
327:                   #define PTR_SIZE DWORD
328:               #else
329:                   #define PTR_SIZE WORD
330:               #endif
331:               ROM BYTE *FileAddress = 0;
332:               
333:               
334:               #if defined(__C30__)
335:               BYTE MDD_IntFlash_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero)
336:               {
337:                   #if !defined(INTERNAL_FLASH_WRITE_PROTECT)
338:                       WORD i;
339:                       BYTE j;
340:                       WORD offset;
341:                       DWORD flashAddress;
342:                       WORD TBLPAGSave;
343:                       
344:                   
345:                       //First, error check the resulting address, to make sure the MSD host isn't trying 
346:                       //to erase/program illegal LBAs that are not part of the designated MSD volume space.
347:                       if(sector_addr >= MDD_INTERNAL_FLASH_TOTAL_DISK_SIZE)
348:                       {
349:                           return FALSE;
350:                       }  
351:                   
352:                       TBLPAGSave = TBLPAG;
353:                   
354:                       //First, save the contents of the entire erase page.  To do this, we need to get a pointer to the start of the erase page.
355:                       flashAddress = ((DWORD)FILES_ADDRESS + (DWORD)(sector_addr*MEDIA_SECTOR_SIZE)) & (DWORD)0xFFFFFC00;  //AND mask 0xFFFFFC00 is to clear the lower bits, so we go back to the start of the erase page.
356:                       //Now save all of the contents of the erase page.
357:                       for(i = 0; i < ERASE_BLOCK_SIZE;)
358:                       {
359:                           TBLPAG = (BYTE)(flashAddress >> 16);
360:                           *(WORD*)&file_buffer[i] = __builtin_tblrdl((WORD)flashAddress);
361:                           flashAddress += 2u;    //Skipping upper word.  Don't care about the implemented byte/don't use it when programming or reading from the sector.
362:                           i += 2u;
363:                       }    
364:                       
365:                       //Now we want to overwrite the file_buffer[] contents for the sector that we are trying to write to.
366:                       //Need to figure out if the buffer[] data goes in the upper sector or the lower sector of the file_buffer[]
367:                       if(sector_addr & 0x00000001)
368:                       {
369:                           //Odd sector address, must be the high file_buffer[] sector
370:                           offset = MEDIA_SECTOR_SIZE;
371:                       }
372:                       else
373:                       {
374:                           offset = 0;
375:                       }        
376:                       
377:                       //Overwrite the file_buffer[] RAM contents for the sector that we are trying to write to.
378:                       for(i = 0; i < MEDIA_SECTOR_SIZE; i++)
379:                       {
380:                           file_buffer[offset + i] = *buffer++;
381:                       } 
382:                       
383:                       //Now erase the entire erase page of flash memory.  
384:                       //First we need to calculate the actual flash memory address of the erase page.  The starting address of the erase page is as follows:
385:                       flashAddress = ((DWORD)FILES_ADDRESS + (DWORD)(sector_addr*MEDIA_SECTOR_SIZE)) & (DWORD)0xFFFFFC00;
386:                   
387:                       //Peform NVM erase operation.
388:                   	NVMCON = INTERNAL_FLASH_ERASE;				    //Page erase on next WR
389:                      	__builtin_tblwtl((WORD)flashAddress, 0xFFFF);   //Perform dummy write to load address of erase page
390:                       UnlockAndActivate(NVM_UNLOCK_KEY);
391:                   	
392:                       //Now reprogram the erase page with previously obtained contents of the file_buffer[]
393:                       //We only write to the even flash word addresses, the odd word addresses are left blank.  
394:                       //Therefore, we only store 2 bytes of application data for every 2 flash memory word addresses.
395:                       //This "wastes" 1/3 of the flash memory, but it provides extra protection from accidentally executing
396:                       //the data.  It also allows quick/convenient PSV access when reading back the flash contents.
397:                       NVMCON = INTERNAL_FLASH_PROGRAM_PAGE;
398:                       j = 0;
399:                       for(i = 0; i < ERASE_BLOCK_SIZE;)
400:                       {
401:                           TBLPAG = (BYTE)(flashAddress >> 16);
402:                           __builtin_tblwtl((WORD)flashAddress, *((WORD*)&file_buffer[i]));
403:                           flashAddress++;       
404:                           __builtin_tblwth((WORD)flashAddress, 0);
405:                           flashAddress++;       
406:                           
407:                           i += 2;
408:                           j += 2;
409:                        
410:                           //Check if we have reached a program block size boundary.  If so, program the last 128 
411:                           //useful bytes (192 bytes total, but 64 of those are filled with '0' filler bytes).
412:                           if(j >= 128u)
413:                           {
414:                               j = j - 128u;
415:                               asm("DISI #16");					//Disable interrupts for next few instructions for unlock sequence
416:                               __builtin_write_NVM();                        
417:                           }    
418:                       }    
419:                   
420:                       TBLPAG = TBLPAGSave;   
421:                       return TRUE;
422:                   #else //else of #if !defined(INTERNAL_FLASH_WRITE_PROTECT)
423:                       return TRUE;
424:                   #endif  //endif of #if !defined(INTERNAL_FLASH_WRITE_PROTECT)
425:                   
426:               }    
427:               #else   //else must be PIC18 or PIC32 device
428:               BYTE MDD_IntFlash_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero)
  4910    CFD9     MOVFF 0xfd9, 0xfe6
  4912    FFE6     NOP
  4914    CFE1     MOVFF 0xfe1, 0xfd9
  4916    FFD9     NOP
  4918    0E0E     MOVLW 0xe
  491A    26E1     ADDWF 0xfe1, F, ACCESS
429:               {
430:                   #if !defined(INTERNAL_FLASH_WRITE_PROTECT)
431:                       ROM BYTE* dest;
432:                       BOOL foundDifference;
433:                       WORD blockCounter;
434:                       WORD sectorCounter;
435:               
436:                       #if defined(__18CXX)
437:                           BYTE *p;
438:                       #endif
439:               
440:                       //First, error check the resulting address, to make sure the MSD host isn't trying 
441:                       //to erase/program illegal LBAs that are not part of the designated MSD volume space.
442:                       if(sector_addr >= MDD_INTERNAL_FLASH_TOTAL_DISK_SIZE)
  491C    50D9     MOVF 0xfd9, W, ACCESS
  491E    0FFB     ADDLW 0xfb
  4920    6EE9     MOVWF 0xfe9, ACCESS
  4922    0EFF     MOVLW 0xff
  4924    20DA     ADDWFC 0xfda, W, ACCESS
  4926    6EEA     MOVWF 0xfea, ACCESS
  4928    0E40     MOVLW 0x40
  492A    5CEE     SUBWF 0xfee, W, ACCESS
  492C    0E00     MOVLW 0
  492E    58EE     SUBWFB 0xfee, W, ACCESS
  4930    0E00     MOVLW 0
  4932    58EE     SUBWFB 0xfee, W, ACCESS
  4934    0E00     MOVLW 0
  4936    58EE     SUBWFB 0xfee, W, ACCESS
  4938    E302     BNC 0x493e
443:                       {
444:                           return FALSE;
  493A    0E00     MOVLW 0
  493C    D172     BRA 0x4c22
445:                       }  
446:               
447:                       dest = (ROM BYTE*)(MASTER_BOOT_RECORD_ADDRESS + (sector_addr * MEDIA_SECTOR_SIZE));
  493E    0E00     MOVLW 0
  4940    6E17     MOVWF 0x17, ACCESS
  4942    0E78     MOVLW 0x78
  4944    6E18     MOVWF 0x18, ACCESS
  4946    0E00     MOVLW 0
  4948    6E19     MOVWF 0x19, ACCESS
  494A    0EFB     MOVLW 0xfb
  494C    CFDB     MOVFF 0xfdb, 0x6
  494E    F006     NOP
  4950    0EFC     MOVLW 0xfc
  4952    CFDB     MOVFF 0xfdb, 0x7
  4954    F007     NOP
  4956    0EFD     MOVLW 0xfd
  4958    CFDB     MOVFF 0xfdb, 0x8
  495A    F008     NOP
  495C    0EFE     MOVLW 0xfe
  495E    CFDB     MOVFF 0xfdb, 0x9
  4960    F009     NOP
  4962    6A0B     CLRF 0xb, ACCESS
  4964    0E02     MOVLW 0x2
  4966    6E0C     MOVWF 0xc, ACCESS
  4968    6A0D     CLRF 0xd, ACCESS
  496A    6A0E     CLRF 0xe, ACCESS
  496C    ECBD     CALL 0x517a, 0
  496E    F028     NOP
  4970    5017     MOVF 0x17, W, ACCESS
  4972    2402     ADDWF 0x2, W, ACCESS
  4974    6E14     MOVWF 0x14, ACCESS
  4976    5018     MOVF 0x18, W, ACCESS
  4978    2003     ADDWFC 0x3, W, ACCESS
  497A    6E15     MOVWF 0x15, ACCESS
  497C    5019     MOVF 0x19, W, ACCESS
  497E    2004     ADDWFC 0x4, W, ACCESS
  4980    6E16     MOVWF 0x16, ACCESS
  4982    C014     MOVFF 0x14, 0xfdf
  4984    FFDF     NOP
  4986    0E01     MOVLW 0x1
  4988    C015     MOVFF 0x15, 0xfdb
  498A    FFDB     NOP
  498C    0E02     MOVLW 0x2
  498E    C016     MOVFF 0x16, 0xfdb
  4990    FFDB     NOP
448:               
449:                       sectorCounter = 0;
  4992    0E06     MOVLW 0x6
  4994    6ADB     CLRF 0xfdb, ACCESS
  4996    0E07     MOVLW 0x7
  4998    6ADB     CLRF 0xfdb, ACCESS
450:               
451:                       while(sectorCounter < MEDIA_SECTOR_SIZE)
  499A    0E06     MOVLW 0x6
  499C    CFDB     MOVFF 0xfdb, 0x14
  499E    F014     NOP
  49A0    0E07     MOVLW 0x7
  49A2    CFDB     MOVFF 0xfdb, 0x15
  49A4    F015     NOP
  49A6    0E00     MOVLW 0
  49A8    5C14     SUBWF 0x14, W, ACCESS
  49AA    0E02     MOVLW 0x2
  49AC    5815     SUBWFB 0x15, W, ACCESS
  49AE    E301     BNC 0x49b2
  49B0    D136     BRA 0x4c1e
  4C1C    D6BE     BRA 0x499a
452:                       {
453:                           foundDifference = FALSE;
  49B2    0E03     MOVLW 0x3
  49B4    6ADB     CLRF 0xfdb, ACCESS
454:                           for(blockCounter = 0; blockCounter < ERASE_BLOCK_SIZE; blockCounter++)
  49B6    0E04     MOVLW 0x4
  49B8    6ADB     CLRF 0xfdb, ACCESS
  49BA    0E05     MOVLW 0x5
  49BC    6ADB     CLRF 0xfdb, ACCESS
  49BE    0E04     MOVLW 0x4
  49C0    CFDB     MOVFF 0xfdb, 0x14
  49C2    F014     NOP
  49C4    0E05     MOVLW 0x5
  49C6    CFDB     MOVFF 0xfdb, 0x15
  49C8    F015     NOP
  49CA    0E00     MOVLW 0
  49CC    5C14     SUBWF 0x14, W, ACCESS
  49CE    0E04     MOVLW 0x4
  49D0    5815     SUBWFB 0x15, W, ACCESS
  49D2    E24C     BC 0x4a6c
  4A60    0E04     MOVLW 0x4
  4A62    2ADB     INCF 0xfdb, F, ACCESS
  4A64    0E05     MOVLW 0x5
  4A66    E301     BNC 0x4a6a
  4A68    2ADB     INCF 0xfdb, F, ACCESS
  4A6A    D7A9     BRA 0x49be
455:                           {
456:                               if(dest[sectorCounter] != buffer[sectorCounter])
  49D4    0E06     MOVLW 0x6
  49D6    CFDB     MOVFF 0xfdb, 0x15
  49D8    F015     NOP
  49DA    0E07     MOVLW 0x7
  49DC    CFDB     MOVFF 0xfdb, 0x16
  49DE    F016     NOP
  49E0    6A17     CLRF 0x17, ACCESS
  49E2    CFD9     MOVFF 0xfd9, 0xfe9
  49E4    FFE9     NOP
  49E6    CFDA     MOVFF 0xfda, 0xfea
  49E8    FFEA     NOP
  49EA    50EE     MOVF 0xfee, W, ACCESS
  49EC    2415     ADDWF 0x15, W, ACCESS
  49EE    6EF3     MOVWF 0xff3, ACCESS
  49F0    50EE     MOVF 0xfee, W, ACCESS
  49F2    2016     ADDWFC 0x16, W, ACCESS
  49F4    6EF4     MOVWF 0xff4, ACCESS
  49F6    50EE     MOVF 0xfee, W, ACCESS
  49F8    2017     ADDWFC 0x17, W, ACCESS
  49FA    6EF8     MOVWF 0xff8, ACCESS
  49FC    CFF4     MOVFF 0xff4, 0xff7
  49FE    FFF7     NOP
  4A00    CFF3     MOVFF 0xff3, 0xff6
  4A02    FFF6     NOP
  4A04    0008     TBLRD*
  4A06    CFF5     MOVFF 0xff5, 0x14
  4A08    F014     NOP
  4A0A    0E06     MOVLW 0x6
  4A0C    CFDB     MOVFF 0xfdb, 0x18
  4A0E    F018     NOP
  4A10    0E07     MOVLW 0x7
  4A12    CFDB     MOVFF 0xfdb, 0x19
  4A14    F019     NOP
  4A16    0EF9     MOVLW 0xf9
  4A18    50DB     MOVF 0xfdb, W, ACCESS
  4A1A    2418     ADDWF 0x18, W, ACCESS
  4A1C    6EE9     MOVWF 0xfe9, ACCESS
  4A1E    0EFA     MOVLW 0xfa
  4A20    50DB     MOVF 0xfdb, W, ACCESS
  4A22    2019     ADDWFC 0x19, W, ACCESS
  4A24    6EEA     MOVWF 0xfea, ACCESS
  4A26    50EF     MOVF 0xfef, W, ACCESS
  4A28    5C14     SUBWF 0x14, W, ACCESS
  4A2A    E015     BZ 0x4a56
457:                               {
458:                                   foundDifference = TRUE;
  4A2C    0E01     MOVLW 0x1
  4A2E    6EF3     MOVWF 0xff3, ACCESS
  4A30    0E03     MOVLW 0x3
  4A32    CFF3     MOVFF 0xff3, 0xfdb
  4A34    FFDB     NOP
459:                                   sectorCounter -= blockCounter;
  4A36    0E04     MOVLW 0x4
  4A38    CFDB     MOVFF 0xfdb, 0x14
  4A3A    F014     NOP
  4A3C    0E05     MOVLW 0x5
  4A3E    CFDB     MOVFF 0xfdb, 0x15
  4A40    F015     NOP
  4A42    50D9     MOVF 0xfd9, W, ACCESS
  4A44    0F06     ADDLW 0x6
  4A46    6EE9     MOVWF 0xfe9, ACCESS
  4A48    CFDA     MOVFF 0xfda, 0xfea
  4A4A    FFEA     NOP
  4A4C    5014     MOVF 0x14, W, ACCESS
  4A4E    5EEE     SUBWF 0xfee, F, ACCESS
  4A50    5015     MOVF 0x15, W, ACCESS
  4A52    5AED     SUBWFB 0xfed, F, ACCESS
460:                                   break;
  4A54    D00B     BRA 0x4a6c
461:                               }
462:                               sectorCounter++;
  4A56    0E06     MOVLW 0x6
  4A58    2ADB     INCF 0xfdb, F, ACCESS
  4A5A    0E07     MOVLW 0x7
  4A5C    E301     BNC 0x4a60
  4A5E    2ADB     INCF 0xfdb, F, ACCESS
463:                           }
464:                           if(foundDifference == TRUE)
  4A6C    0E03     MOVLW 0x3
  4A6E    04DB     DECF 0xfdb, W, ACCESS
  4A70    E001     BZ 0x4a74
  4A72    D0D4     BRA 0x4c1c
465:                           {
466:                               BYTE i,j;
467:                               PTR_SIZE address;
468:               
469:                               #if (ERASE_BLOCK_SIZE >= MEDIA_SECTOR_SIZE)
470:                                   address = ((PTR_SIZE)(dest + sectorCounter) & ~(ERASE_BLOCK_SIZE - 1));
  4A74    0E06     MOVLW 0x6
  4A76    CFDB     MOVFF 0xfdb, 0x19
  4A78    F019     NOP
  4A7A    0E07     MOVLW 0x7
  4A7C    CFDB     MOVFF 0xfdb, 0x1a
  4A7E    F01A     NOP
  4A80    6A1B     CLRF 0x1b, ACCESS
  4A82    CFD9     MOVFF 0xfd9, 0xfe9
  4A84    FFE9     NOP
  4A86    CFDA     MOVFF 0xfda, 0xfea
  4A88    FFEA     NOP
  4A8A    50EE     MOVF 0xfee, W, ACCESS
  4A8C    2419     ADDWF 0x19, W, ACCESS
  4A8E    6E16     MOVWF 0x16, ACCESS
  4A90    50EE     MOVF 0xfee, W, ACCESS
  4A92    201A     ADDWFC 0x1a, W, ACCESS
  4A94    6E17     MOVWF 0x17, ACCESS
  4A96    50EE     MOVF 0xfee, W, ACCESS
  4A98    201B     ADDWFC 0x1b, W, ACCESS
  4A9A    6E18     MOVWF 0x18, ACCESS
  4A9C    0E00     MOVLW 0
  4A9E    1416     ANDWF 0x16, W, ACCESS
  4AA0    6E14     MOVWF 0x14, ACCESS
  4AA2    0EFC     MOVLW 0xfc
  4AA4    1417     ANDWF 0x17, W, ACCESS
  4AA6    6E15     MOVWF 0x15, ACCESS
  4AA8    0E0C     MOVLW 0xc
  4AAA    C014     MOVFF 0x14, 0xfdb
  4AAC    FFDB     NOP
  4AAE    0E0D     MOVLW 0xd
  4AB0    C015     MOVFF 0x15, 0xfdb
  4AB2    FFDB     NOP
471:               
472:                                   memcpypgm2ram
473:                                   (
474:                                       (void*)file_buffer,
  4AD4    0E00     MOVLW 0
  4AD6    6EE6     MOVWF 0xfe6, ACCESS
  4AD8    0E08     MOVLW 0x8
  4ADA    6EE6     MOVWF 0xfe6, ACCESS
475:                                       (ROM void*)address,
  4ABA    0E0C     MOVLW 0xc
  4ABC    CFDB     MOVFF 0xfdb, 0x14
  4ABE    F014     NOP
  4AC0    0E0D     MOVLW 0xd
  4AC2    CFDB     MOVFF 0xfdb, 0x15
  4AC4    F015     NOP
  4AC6    6A16     CLRF 0x16, ACCESS
  4AC8    C014     MOVFF 0x14, 0xfe6
  4ACA    FFE6     NOP
  4ACC    C015     MOVFF 0x15, 0xfe6
  4ACE    FFE6     NOP
  4AD0    C016     MOVFF 0x16, 0xfe6
  4AD2    FFE6     NOP
476:                                       ERASE_BLOCK_SIZE
477:                                   );
  4AB4    6AE6     CLRF 0xfe6, ACCESS
  4AB6    0E04     MOVLW 0x4
  4AB8    6EE6     MOVWF 0xfe6, ACCESS
  4ADC    EC7B     CALL 0x4cf6, 0
  4ADE    F026     NOP
  4AE0    6E17     MOVWF 0x17, ACCESS
  4AE2    0E07     MOVLW 0x7
  4AE4    5EE1     SUBWF 0xfe1, F, ACCESS
  4AE6    5017     MOVF 0x17, W, ACCESS
478:               
479:                                   EraseBlock((ROM BYTE*)address);
  4AE8    0E0C     MOVLW 0xc
  4AEA    CFDB     MOVFF 0xfdb, 0x14
  4AEC    F014     NOP
  4AEE    0E0D     MOVLW 0xd
  4AF0    CFDB     MOVFF 0xfdb, 0x15
  4AF2    F015     NOP
  4AF4    6A16     CLRF 0x16, ACCESS
  4AF6    C014     MOVFF 0x14, 0xfe6
  4AF8    FFE6     NOP
  4AFA    C015     MOVFF 0x15, 0xfe6
  4AFC    FFE6     NOP
  4AFE    C016     MOVFF 0x16, 0xfe6
  4B00    FFE6     NOP
  4B02    D89B     RCALL 0x4c3a
  4B04    52E5     MOVF 0xfe5, F, ACCESS
  4B06    52E5     MOVF 0xfe5, F, ACCESS
  4B08    52E5     MOVF 0xfe5, F, ACCESS
480:               
481:                                   address = ((PTR_SIZE)(dest + sectorCounter) & (ERASE_BLOCK_SIZE - 1));
  4B0A    0E06     MOVLW 0x6
  4B0C    CFDB     MOVFF 0xfdb, 0x19
  4B0E    F019     NOP
  4B10    0E07     MOVLW 0x7
  4B12    CFDB     MOVFF 0xfdb, 0x1a
  4B14    F01A     NOP
  4B16    6A1B     CLRF 0x1b, ACCESS
  4B18    CFD9     MOVFF 0xfd9, 0xfe9
  4B1A    FFE9     NOP
  4B1C    CFDA     MOVFF 0xfda, 0xfea
  4B1E    FFEA     NOP
  4B20    50EE     MOVF 0xfee, W, ACCESS
  4B22    2419     ADDWF 0x19, W, ACCESS
  4B24    6E16     MOVWF 0x16, ACCESS
  4B26    50EE     MOVF 0xfee, W, ACCESS
  4B28    201A     ADDWFC 0x1a, W, ACCESS
  4B2A    6E17     MOVWF 0x17, ACCESS
  4B2C    50EE     MOVF 0xfee, W, ACCESS
  4B2E    201B     ADDWFC 0x1b, W, ACCESS
  4B30    6E18     MOVWF 0x18, ACCESS
  4B32    0EFF     MOVLW 0xff
  4B34    1416     ANDWF 0x16, W, ACCESS
  4B36    6E14     MOVWF 0x14, ACCESS
  4B38    0E03     MOVLW 0x3
  4B3A    1417     ANDWF 0x17, W, ACCESS
  4B3C    6E15     MOVWF 0x15, ACCESS
  4B3E    0E0C     MOVLW 0xc
  4B40    C014     MOVFF 0x14, 0xfdb
  4B42    FFDB     NOP
  4B44    0E0D     MOVLW 0xd
  4B46    C015     MOVFF 0x15, 0xfdb
  4B48    FFDB     NOP
482:               
483:                                   memcpy
484:                                   (
485:                                       (void*)(&file_buffer[address]),
  4B5C    0E0C     MOVLW 0xc
  4B5E    CFDB     MOVFF 0xfdb, 0x14
  4B60    F014     NOP
  4B62    0E0D     MOVLW 0xd
  4B64    CFDB     MOVFF 0xfdb, 0x15
  4B66    F015     NOP
  4B68    0E00     MOVLW 0
  4B6A    2614     ADDWF 0x14, F, ACCESS
  4B6C    0E08     MOVLW 0x8
  4B6E    2215     ADDWFC 0x15, F, ACCESS
  4B70    C014     MOVFF 0x14, 0xfe6
  4B72    FFE6     NOP
  4B74    C015     MOVFF 0x15, 0xfe6
  4B76    FFE6     NOP
486:                                       (void*)buffer,
  4B50    0EF9     MOVLW 0xf9
  4B52    CFDB     MOVFF 0xfdb, 0xfe6
  4B54    FFE6     NOP
  4B56    0EFA     MOVLW 0xfa
  4B58    CFDB     MOVFF 0xfdb, 0xfe6
  4B5A    FFE6     NOP
487:                                       MEDIA_SECTOR_SIZE
488:                                   );
  4B4A    6AE6     CLRF 0xfe6, ACCESS
  4B4C    0E02     MOVLW 0x2
  4B4E    6EE6     MOVWF 0xfe6, ACCESS
  4B78    EC50     CALL 0x4ca0, 0
  4B7A    F026     NOP
  4B7C    6E16     MOVWF 0x16, ACCESS
  4B7E    0E06     MOVLW 0x6
  4B80    5EE1     SUBWF 0xfe1, F, ACCESS
  4B82    5016     MOVF 0x16, W, ACCESS
489:               
490:                               #else
491:               
492:                                   address = ((WORD)(&dest[sectorCounter]) & ~(ERASE_BLOCK_SIZE - 1));
493:               
494:                                   EraseBlock((ROM BYTE*)address);
495:               
496:                                   sectorCounter = sectorCounter & ~(ERASE_BLOCK_SIZE - 1);
497:               
498:                                   memcpy
499:                                   (
500:                                       (void*)file_buffer,
501:                                       (void*)buffer+sectorCounter,
502:                                       ERASE_BLOCK_SIZE
503:                                   );
504:                               #endif
505:               
506:                               //sectorCounter = sectorCounter & ~(ERASE_BLOCK_SIZE - 1);
507:               
508:                               i=ERASE_BLOCK_SIZE/WRITE_BLOCK_SIZE;
  4B84    0E10     MOVLW 0x10
  4B86    6EF3     MOVWF 0xff3, ACCESS
  4B88    0E0A     MOVLW 0xa
  4B8A    CFF3     MOVFF 0xff3, 0xfdb
  4B8C    FFDB     NOP
509:                               j=0;
  4B8E    0E0B     MOVLW 0xb
  4B90    6ADB     CLRF 0xfdb, ACCESS
510:               
511:                               #if defined(__18CXX)
512:                                   p = file_buffer;
  4B92    50D9     MOVF 0xfd9, W, ACCESS
  4B94    0F08     ADDLW 0x8
  4B96    6EE9     MOVWF 0xfe9, ACCESS
  4B98    CFDA     MOVFF 0xfda, 0xfea
  4B9A    FFEA     NOP
  4B9C    0E00     MOVLW 0
  4B9E    6EEE     MOVWF 0xfee, ACCESS
  4BA0    0E08     MOVLW 0x8
  4BA2    6EED     MOVWF 0xfed, ACCESS
513:                               #endif
514:               
515:                               while(i-->0)
  4BA4    0E0A     MOVLW 0xa
  4BA6    CFDB     MOVFF 0xfdb, 0xff3
  4BA8    FFF3     NOP
  4BAA    06DB     DECF 0xfdb, F, ACCESS
  4BAC    50F3     MOVF 0xff3, W, ACCESS
  4BAE    0800     SUBLW 0
  4BB0    E235     BC 0x4c1c
  4C1A    D7C4     BRA 0x4ba4
516:                               {
517:                                   //Write the new data
518:                                   for(blockCounter = 0; blockCounter < WRITE_BLOCK_SIZE; blockCounter++)
  4BB2    0E04     MOVLW 0x4
  4BB4    6ADB     CLRF 0xfdb, ACCESS
  4BB6    0E05     MOVLW 0x5
  4BB8    6ADB     CLRF 0xfdb, ACCESS
  4BBA    0E04     MOVLW 0x4
  4BBC    CFDB     MOVFF 0xfdb, 0x14
  4BBE    F014     NOP
  4BC0    0E05     MOVLW 0x5
  4BC2    CFDB     MOVFF 0xfdb, 0x15
  4BC4    F015     NOP
  4BC6    0E40     MOVLW 0x40
  4BC8    5C14     SUBWF 0x14, W, ACCESS
  4BCA    0E00     MOVLW 0
  4BCC    5815     SUBWFB 0x15, W, ACCESS
  4BCE    E217     BC 0x4bfe
  4BF2    0E04     MOVLW 0x4
  4BF4    2ADB     INCF 0xfdb, F, ACCESS
  4BF6    0E05     MOVLW 0x5
  4BF8    E301     BNC 0x4bfc
  4BFA    2ADB     INCF 0xfdb, F, ACCESS
  4BFC    D7DE     BRA 0x4bba
519:                                   {
520:                                       //Write the data
521:                                       #if defined(__18CXX)
522:                                           TABLAT = *p++;
  4BD0    0E08     MOVLW 0x8
  4BD2    CFDB     MOVFF 0xfdb, 0xfe9
  4BD4    FFE9     NOP
  4BD6    2ADB     INCF 0xfdb, F, ACCESS
  4BD8    0E09     MOVLW 0x9
  4BDA    CFDB     MOVFF 0xfdb, 0xfea
  4BDC    FFEA     NOP
  4BDE    E301     BNC 0x4be2
  4BE0    2ADB     INCF 0xfdb, F, ACCESS
  4BE2    50EF     MOVF 0xfef, W, ACCESS
  4BE4    6EF5     MOVWF 0xff5, ACCESS
523:                                           _asm tblwtpostinc _endasm
  4BE6    000D     TBLWT*+
524:                                           sectorCounter++;
  4BE8    0E06     MOVLW 0x6
  4BEA    2ADB     INCF 0xfdb, F, ACCESS
  4BEC    0E07     MOVLW 0x7
  4BEE    E301     BNC 0x4bf2
  4BF0    2ADB     INCF 0xfdb, F, ACCESS
525:                                       #endif
526:               
527:                                       #if defined(__C32__)
528:                                               NVMWriteWord((DWORD*)KVA_TO_PA(FileAddress), *((DWORD*)&file_buffer[sectorCounter]));
529:                                               FileAddress += 4;
530:                                               sectorCounter += 4;
531:                                       #endif
532:                                   }
533:               
534:                                   j++;
  4BFE    0E0B     MOVLW 0xb
  4C00    2ADB     INCF 0xfdb, F, ACCESS
535:               
536:                                   //write the row
537:                                   #if defined(__18CXX)
538:                                       // Start the write process: reposition tblptr back into memory block that we want to write to.
539:                                        _asm tblrdpostdec _endasm
  4C02    000A     TBLRD*-
540:               
541:                                       // Write flash memory, enable write control.
542:                                       EECON1 = 0x84;
  4C04    0E84     MOVLW 0x84
  4C06    6EA6     MOVWF 0xfa6, ACCESS
543:                                       UnlockAndActivate(NVM_UNLOCK_KEY);
  4C08    0EB5     MOVLW 0xb5
  4C0A    6EE6     MOVWF 0xfe6, ACCESS
  4C0C    D82D     RCALL 0x4c68
  4C0E    52E5     MOVF 0xfe5, F, ACCESS
544:                                       TBLPTR++;
  4C10    2AF6     INCF 0xff6, F, ACCESS
  4C12    0E00     MOVLW 0
  4C14    22F7     ADDWFC 0xff7, F, ACCESS
  4C16    0E00     MOVLW 0
  4C18    22F8     ADDWFC 0xff8, F, ACCESS
545:                                   #endif
546:                               }
547:                           }
548:                       }
549:                   	return TRUE;
  4C1E    0E01     MOVLW 0x1
  4C20    D000     BRA 0x4c22
550:                   #else
551:                       return TRUE;
552:                   #endif
553:               } //end SectorWrite
  4C22    6E14     MOVWF 0x14, ACCESS
  4C24    0E0E     MOVLW 0xe
  4C26    5CE1     SUBWF 0xfe1, W, ACCESS
  4C28    E202     BC 0x4c2e
  4C2A    6AE1     CLRF 0xfe1, ACCESS
  4C2C    52E5     MOVF 0xfe5, F, ACCESS
  4C2E    6EE1     MOVWF 0xfe1, ACCESS
  4C30    5014     MOVF 0x14, W, ACCESS
  4C32    52E5     MOVF 0xfe5, F, ACCESS
  4C34    CFE7     MOVFF 0xfe7, 0xfd9
  4C36    FFD9     NOP
  4C38    0012     RETURN 0
554:               #endif  //#if defined(__C30__)
555:               
556:               
557:               
558:               #if !defined(INTERNAL_FLASH_WRITE_PROTECT)
559:               void EraseBlock(ROM BYTE* dest)
  4C3A    CFD9     MOVFF 0xfd9, 0xfe6
  4C3C    FFE6     NOP
  4C3E    CFE1     MOVFF 0xfe1, 0xfd9
  4C40    FFD9     NOP
560:               {
561:                   #if defined(__18CXX)
562:                       TBLPTR = (unsigned short long)dest;
  4C42    0EFC     MOVLW 0xfc
  4C44    CFDB     MOVFF 0xfdb, 0xff6
  4C46    FFF6     NOP
  4C48    0EFD     MOVLW 0xfd
  4C4A    CFDB     MOVFF 0xfdb, 0xff7
  4C4C    FFF7     NOP
  4C4E    0EFE     MOVLW 0xfe
  4C50    CFDB     MOVFF 0xfdb, 0xff8
  4C52    FFF8     NOP
563:               
564:                       //Erase the current block
565:                       EECON1 = 0x94;
  4C54    0E94     MOVLW 0x94
  4C56    6EA6     MOVWF 0xfa6, ACCESS
566:                       UnlockAndActivate(NVM_UNLOCK_KEY);
  4C58    0EB5     MOVLW 0xb5
  4C5A    6EE6     MOVWF 0xfe6, ACCESS
  4C5C    D805     RCALL 0x4c68
  4C5E    52E5     MOVF 0xfe5, F, ACCESS
567:                   #endif
568:               
569:                   #if defined(__C32__)
570:                       FileAddress = dest;
571:                       NVMErasePage((BYTE *)KVA_TO_PA(dest));
572:                   #endif
573:               }
  4C60    52E5     MOVF 0xfe5, F, ACCESS
  4C62    CFE7     MOVFF 0xfe7, 0xfd9
  4C64    FFD9     NOP
  4C66    0012     RETURN 0
574:               
575:               
576:               //------------------------------------------------------------------------------
577:               #warning "Double click this message and read inline code comments.  For production designs, recommend adding application specific robustness features here."
578:               //Function: void UnlockAndActivate(BYTE UnlockKey)
579:               //Description: Activates and initiates a flash memory self erase or program 
580:               //operation.  Useful for writing to the MSD drive volume.
581:               //Note: Self erase/writes to flash memory could potentially corrupt the
582:               //firmware of the application, if the unlock sequence is ever executed
583:               //unintentionally, or if the table pointer is pointing to an invalid
584:               //range (not inside the MSD volume range).  Therefore, in order to ensure
585:               //a fully reliable design that is suitable for mass production, it is strongly
586:               //recommended to implement several robustness checks prior to actually
587:               //performing any self erase/program unlock sequence.  See additional inline 
588:               //code comments.
589:               //------------------------------------------------------------------------------
590:               void UnlockAndActivate(BYTE UnlockKey)
  4C68    CFD9     MOVFF 0xfd9, 0xfe6
  4C6A    FFE6     NOP
  4C6C    CFE1     MOVFF 0xfe1, 0xfd9
  4C6E    FFD9     NOP
  4C70    52E6     MOVF 0xfe6, F, ACCESS
591:               {
592:                   #if defined(__18CXX)
593:                       BYTE InterruptEnableSave;
594:                   #endif
595:                     
596:                   //Should verify that the voltage on Vdd/Vddcore is high enough to meet
597:                   //the datasheet minimum voltage vs. frequency graph for the device.
598:                   //If the microcontroller is "overclocked" (ex: by running at maximum rated
599:                   //frequency, but then not suppling enough voltage to meet the datasheet
600:                   //voltage vs. frequency graph), errant code execution could occur.  It is
601:                   //therefore strongly recommended to check the voltage prior to performing a 
602:                   //flash self erase/write unlock sequence.  If the voltage is too low to meet
603:                   //the voltage vs. frequency graph in the datasheet, the firmware should not 
604:                   //inititate a self erase/program operation, and instead it should either:
605:                   //1.  Clock switch to a lower frequency that does meet the voltage/frequency graph.  Or,
606:                   //2.  Put the microcontroller to Sleep mode.
607:                   
608:                   //The method used to measure Vdd and/or Vddcore will depend upon the 
609:                   //microcontroller model and the module features available in the device, but
610:                   //several options are available on many of the microcontrollers, ex:
611:                   //1.  HLVD module
612:                   //2.  WDTCON<LVDSTAT> indicator bit
613:                   //3.  Perform ADC operation, with the VBG channel selected, using Vdd/Vss as 
614:                   //      references to the ADC.  Then perform math operations to valculate the Vdd.
615:                   //      On some micros, the ADC can also measure the Vddcore voltage, allowing
616:                   //      the firmware to calculate the absolute Vddcore voltage, if it has already
617:                   //      calculated and knows the ADC reference voltage.
618:                   //4.  Use integrated general purpose comparator(s) to sense Vdd/Vddcore voltage
619:                   //      is above proper threshold.
620:                   //5.  If the micrcontroller implements a user adjustable BOR circuit, enable
621:                   //      it and set the trip point high enough to avoid overclocking altogether.
622:                   
623:                   //Example psuedo code.  Exact implementation will be application specific.
624:                   //Please implement appropriate code that best meets your application requirements.
625:                   //if(GetVddcoreVoltage() < MIN_ALLOWED_VOLTAGE)
626:                   //{
627:                   //    ClockSwitchToSafeFrequencyForGivenVoltage();    //Or even better, go to sleep mode.
628:                   //    return;       
629:                   //}    
630:               
631:               
632:                   //Should also verify the TBLPTR is pointing to a valid range (part of the MSD
633:                   //volume, and not a part of the application firmware space).
634:                   //Example code for PIC18 (commented out since the actual address range is 
635:                   //application specific):
636:                   //if((TBLPTR > MSD_VOLUME_MAX_ADDRESS) || (TBLPTR < MSD_VOLUME_START_ADDRESS)) 
637:                   //{
638:                   //    return;
639:                   //}  
640:                   
641:                   //Verify the UnlockKey is the correct value, to make sure this function is 
642:                   //getting executed intentionally, from a calling function that knew it
643:                   //should pass the correct NVM_UNLOCK_KEY value to this function.
644:                   //If this function got executed unintentionally, then it would be unlikely
645:                   //that the UnlockKey variable would have been loaded with the proper value.
646:                   if(UnlockKey != NVM_UNLOCK_KEY)
  4C72    0EFE     MOVLW 0xfe
  4C74    50DB     MOVF 0xfdb, W, ACCESS
  4C76    08B5     SUBLW 0xb5
  4C78    E002     BZ 0x4c7e
647:                   {
648:                       #if defined(__18CXX)
649:                           EECON1bits.WREN = 0;
  4C7A    94A6     BCF 0xfa6, 0x2, ACCESS
650:                       #endif
651:                       return;
  4C7C    D00B     BRA 0x4c94
652:                   }    
653:                   
654:                 
655:                   //We passed the robustness checks.  Time to Erase/Write the flash memory.
656:                   #if defined(__18CXX)
657:                       InterruptEnableSave = INTCON;
  4C7E    50F2     MOVF 0xff2, W, ACCESS
  4C80    6EDF     MOVWF 0xfdf, ACCESS
658:                       INTCONbits.GIEH = 0;    //Disable interrupts for unlock sequence.
  4C82    9EF2     BCF 0xff2, 0x7, ACCESS
659:                       EECON2 = 0x55;
  4C84    0E55     MOVLW 0x55
  4C86    6EA7     MOVWF 0xfa7, ACCESS
660:                       EECON2 = 0xAA;
  4C88    0EAA     MOVLW 0xaa
  4C8A    6EA7     MOVWF 0xfa7, ACCESS
661:                       EECON1bits.WR = 1;      //CPU stalls until flash erase/write is complete
  4C8C    82A6     BSF 0xfa6, 0x1, ACCESS
662:                       EECON1bits.WREN = 0;    //Good practice to disable any further writes now.
  4C8E    94A6     BCF 0xfa6, 0x2, ACCESS
663:                       //Safe to re-enable interrupts now, if they were previously enabled.
664:                       if(InterruptEnableSave & 0x80)  //Check if GIEH was previously set
  4C90    BEDF     BTFSC 0xfdf, 0x7, ACCESS
665:                       {
666:                           INTCONbits.GIEH = 1;
  4C92    8EF2     BSF 0xff2, 0x7, ACCESS
667:                       }    
668:                   #endif    
669:                   #if defined(__C30__)
670:                   	asm("DISI #16");					//Disable interrupts for next few instructions for unlock sequence
671:               	    __builtin_write_NVM();
672:                   #endif
673:                       
674:               }    
  4C94    52E5     MOVF 0xfe5, F, ACCESS
  4C96    52E5     MOVF 0xfe5, F, ACCESS
  4C98    CFE7     MOVFF 0xfe7, 0xfd9
  4C9A    FFD9     NOP
  4C9C    0012     RETURN 0
675:               #endif  //endif of "#if !defined(INTERNAL_FLASH_WRITE_PROTECT)"
676:               
677:               
678:               /******************************************************************************
679:                * Function:        BYTE WriteProtectState(void)
680:                *
681:                * PreCondition:    None
682:                *
683:                * Input:           None
684:                *
685:                * Output:          BYTE    - Returns the status of the "write enabled" pin
686:                *
687:                * Side Effects:    None
688:                *
689:                * Overview:        Determines if the card is write-protected
690:                *
691:                * Note:            None
692:                *****************************************************************************/
693:               
694:               BYTE MDD_IntFlash_WriteProtectState(void)
695:               {
696:                   #if defined(INTERNAL_FLASH_WRITE_PROTECT)
697:                       return TRUE;
698:                   #else
699:               	    return FALSE;
700:                   #endif
701:               }
  4C9E    0C00     RETLW 0
---  E:\Projects\DevPFG\Microchip\USB\CDC Device Driver\usb_function_cdc.c  ----------------------
1:                 /********************************************************************************
2:                   File Information:
3:                     FileName:       usb_function_cdc.c
4:                     Dependencies:   See INCLUDES section
5:                     Processor:      PIC18 or PIC24 USB Microcontrollers
6:                     Hardware:       The code is natively intended to be used on the following
7:                                     hardware platforms: PICDEMT FS USB Demo Board,
8:                                     PIC18F87J50 FS USB Plug-In Module, or
9:                                     Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                                    modified for use on other USB platforms by editing the
11:                                    HardwareProfile.h file.
12:                    Complier:   Microchip C18 (for PIC18) or C30 (for PIC24)
13:                    Company:        Microchip Technology, Inc.
14:                
15:                    Software License Agreement:
16:                
17:                    The software supplied herewith by Microchip Technology Incorporated
18:                    (the "Company") for its PICr Microcontroller is intended and
19:                    supplied to you, the Company's customer, for use solely and
20:                    exclusively on Microchip PIC Microcontroller products. The
21:                    software is owned by the Company and/or its supplier, and is
22:                    protected under applicable copyright laws. All rights are reserved.
23:                    Any use in violation of the foregoing restrictions may subject the
24:                    user to criminal sanctions under applicable laws, as well as to
25:                    civil liability for the breach of the terms and conditions of this
26:                    license.
27:                
28:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                    
35:                  Summary:
36:                    This file contains all of functions, macros, definitions, variables,
37:                    datatypes, etc. that are required for usage with the CDC function
38:                    driver. This file should be included in projects that use the CDC
39:                    \function driver.
40:                    
41:                    
42:                    
43:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
44:                    Device Driver" directory.
45:                  Description:
46:                    USB CDC Function Driver File
47:                    
48:                    This file contains all of functions, macros, definitions, variables,
49:                    datatypes, etc. that are required for usage with the CDC function
50:                    driver. This file should be included in projects that use the CDC
51:                    \function driver.
52:                    
53:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
54:                    Device Driver" directory.
55:                    
56:                    When including this file in a new project, this file can either be
57:                    referenced from the directory in which it was installed or copied
58:                    directly into the user application folder. If the first method is
59:                    chosen to keep the file located in the folder in which it is installed
60:                    then include paths need to be added so that the library and the
61:                    application both know where to reference each others files. If the
62:                    application folder is located in the same folder as the Microchip
63:                    folder (like the current demo folders), then the following include
64:                    paths need to be added to the application's project:
65:                    
66:                    ..\\Include
67:                    
68:                    .
69:                    
70:                    If a different directory structure is used, modify the paths as
71:                    required. An example using absolute paths instead of relative paths
72:                    would be the following:
73:                    
74:                    C:\\Microchip Solutions\\Microchip\\Include
75:                    
76:                    C:\\Microchip Solutions\\My Demo Application                                 
77:                  ********************************************************************************/
78:                
79:                /********************************************************************
80:                 Change History:
81:                  Rev    Description
82:                  ----   -----------
83:                  2.3    Decricated the mUSBUSARTIsTxTrfReady() macro.  It is 
84:                         replaced by the USBUSARTIsTxTrfReady() function.
85:                
86:                  2.6    Minor definition changes
87:                
88:                  2.6a   No Changes
89:                
90:                  2.7    Fixed error in the part support list of the variables section
91:                         where the address of the CDC variables are defined.  The 
92:                         PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
93:                         was incorrectly named PIC18F4458.
94:                
95:                         http://www.microchip.com/forums/fb.aspx?m=487397
96:                
97:                  2.8    Minor change to CDCInitEP() to enhance ruggedness in
98:                         multithreaded usage scenarios.
99:                
100:               ********************************************************************/
101:               
102:               /** I N C L U D E S **********************************************************/
103:               #include "USB/usb.h"
104:               #include "USB/usb_function_cdc.h"
105:               //#include "HardwareProfile.h"
106:               
107:               #ifdef USB_USE_CDC
108:               
109:               /** V A R I A B L E S ********************************************************/
110:               #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50) 
111:                   #pragma udata usbram2
112:               #elif defined(__18F2455) || defined(__18F2550) || defined(__18F4455) || defined(__18F4550)\
113:                   || defined(__18F2458) || defined(__18F2553) || defined(__18F4458) || defined(__18F4553)
114:                   #pragma udata USB_VARIABLES=0x500
115:               #elif defined(__18F4450) || defined(__18F2450)
116:               	#pragma udata USB_VARIABLES=0x480
117:               #else
118:                   #pragma udata
119:               #endif
120:               
121:               volatile FAR CDC_NOTICE cdc_notice;
122:               volatile FAR unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE];
123:               volatile FAR unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE];
124:               LINE_CODING line_coding;    // Buffer to store line coding information
125:               
126:               #pragma udata
127:               BYTE cdc_rx_len;            // total rx length
128:               
129:               BYTE cdc_trf_state;         // States are defined cdc.h
130:               POINTER pCDCSrc;            // Dedicated source pointer
131:               POINTER pCDCDst;            // Dedicated destination pointer
132:               BYTE cdc_tx_len;            // total tx length
133:               BYTE cdc_mem_type;          // _ROM, _RAM
134:               
135:               USB_HANDLE CDCDataOutHandle;
136:               USB_HANDLE CDCDataInHandle;
137:               
138:               
139:               CONTROL_SIGNAL_BITMAP control_signal_bitmap;
140:               DWORD BaudRateGen;			// BRG value calculated from baudrate
141:               extern BYTE  i;
142:               extern BYTE_VAL *pDst;
143:               
144:               /**************************************************************************
145:                 SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
146:                 requests according to the CDC specification.
147:                 However, it is not really being used here, therefore a dummy buffer is
148:                 used for conformance.
149:                **************************************************************************/
150:               #define dummy_length    0x08
151:               BYTE_VAL dummy_encapsulated_cmd_response[dummy_length];
152:               
153:               #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
154:               CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
155:               #endif
156:               
157:               /** P R I V A T E  P R O T O T Y P E S ***************************************/
158:               void USBCDCSetLineCoding(void);
159:               
160:               /** D E C L A R A T I O N S **************************************************/
161:               //#pragma code
162:               
163:               /** C L A S S  S P E C I F I C  R E Q ****************************************/
164:               /******************************************************************************
165:                	Function:
166:                		void USBCheckCDCRequest(void)
167:                
168:                	Description:
169:                		This routine checks the setup data packet to see if it
170:                		knows how to handle it
171:                		
172:                	PreCondition:
173:                		None
174:               
175:               	Parameters:
176:               		None
177:               		
178:               	Return Values:
179:               		None
180:               		
181:               	Remarks:
182:               		None
183:               		 
184:                 *****************************************************************************/
185:               void USBCheckCDCRequest(void)
186:               {
187:                   /*
188:                    * If request recipient is not an interface then return
189:                    */
190:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
  43D4    0104     MOVLB 0x4
  43D6    5140     MOVF 0x40, W, BANKED
  43D8    0B1F     ANDLW 0x1f
  43DA    0801     SUBLW 0x1
  43DC    E001     BZ 0x43e0
  43DE    0012     RETURN 0
191:               
192:                   /*
193:                    * If request type is not class-specific then return
194:                    */
195:                   if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
  43E0    5140     MOVF 0x40, W, BANKED
  43E2    0B60     ANDLW 0x60
  43E4    42E8     RRNCF 0xfe8, F, ACCESS
  43E6    42E8     RRNCF 0xfe8, F, ACCESS
  43E8    42E8     RRNCF 0xfe8, F, ACCESS
  43EA    42E8     RRNCF 0xfe8, F, ACCESS
  43EC    42E8     RRNCF 0xfe8, F, ACCESS
  43EE    0801     SUBLW 0x1
  43F0    E001     BZ 0x43f4
  43F2    0012     RETURN 0
196:               
197:                   /*
198:                    * Interface ID must match interface numbers associated with
199:                    * CDC class, else return
200:                    */
201:                   if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
  43F4    0544     DECF 0x44, W, BANKED
202:                      (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
  43F6    E003     BZ 0x43fe
  43F8    0544     DECF 0x44, W, BANKED
  43FA    E001     BZ 0x43fe
  43FC    0012     RETURN 0
203:                   
204:                   switch(SetupPkt.bRequest)
  43FE    5141     MOVF 0x41, W, BANKED
  4400    0A22     XORLW 0x22
  4402    E035     BZ 0x446e
  4404    0A03     XORLW 0x3
  4406    E028     BZ 0x4458
  4408    0A01     XORLW 0x1
  440A    E015     BZ 0x4436
  440C    0A21     XORLW 0x21
  440E    E00D     BZ 0x442a
  4410    0A01     XORLW 0x1
  4412    E001     BZ 0x4416
  4414    0012     RETURN 0
205:                   {
206:                       //****** These commands are required ******//
207:                       case SEND_ENCAPSULATED_COMMAND:
208:                        //send the packet
209:                           inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
  4416    0100     MOVLB 0
  4418    0EF3     MOVLW 0xf3
  441A    6F79     MOVWF 0x79, BANKED
  441C    0E05     MOVLW 0x5
  441E    6F7A     MOVWF 0x7a, BANKED
210:                           inPipes[0].wCount.Val = dummy_length;
  4420    0E08     MOVLW 0x8
  4422    6F7D     MOVWF 0x7d, BANKED
  4424    6B7E     CLRF 0x7e, BANKED
211:                           inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
  4426    817C     BSF 0x7c, 0, BANKED
212:                           inPipes[0].info.bits.busy = 1;
213:                           break;
  4428    D025     BRA 0x4474
214:                       case GET_ENCAPSULATED_RESPONSE:
215:                           // Populate dummy_encapsulated_cmd_response first.
216:                           inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
  442A    0100     MOVLB 0
  442C    0EF3     MOVLW 0xf3
  442E    6F79     MOVWF 0x79, BANKED
  4430    0E05     MOVLW 0x5
  4432    6F7A     MOVWF 0x7a, BANKED
217:                           inPipes[0].info.bits.busy = 1;
218:                           break;
  4434    D01F     BRA 0x4474
219:                       //****** End of required commands ******//
220:               
221:                       #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
222:                       case SET_LINE_CODING:
223:                           outPipes[0].wCount.Val = SetupPkt.wLength;
  4436    C446     MOVFF 0x446, 0x82
  4438    F082     NOP
  443A    C447     MOVFF 0x447, 0x83
  443C    F083     NOP
224:                           outPipes[0].pDst.bRam = (BYTE*)LINE_CODING_TARGET;
  443E    0100     MOVLB 0
  4440    0E51     MOVLW 0x51
  4442    6F7F     MOVWF 0x7f, BANKED
  4444    0E05     MOVLW 0x5
  4446    6F80     MOVWF 0x80, BANKED
225:                           outPipes[0].pFunc = LINE_CODING_PFUNC;
  4448    0EB4     MOVLW 0xb4
  444A    6F84     MOVWF 0x84, BANKED
  444C    0E3D     MOVLW 0x3d
  444E    6F85     MOVWF 0x85, BANKED
  4450    0E00     MOVLW 0
  4452    6F86     MOVWF 0x86, BANKED
226:                           outPipes[0].info.bits.busy = 1;
  4454    8F81     BSF 0x81, 0x7, BANKED
227:                           break;
  4456    0012     RETURN 0
228:                           
229:                       case GET_LINE_CODING:
230:                           USBEP0SendRAMPtr(
  4458    0100     MOVLB 0
  445A    0ED9     MOVLW 0xd9
  445C    6F79     MOVWF 0x79, BANKED
  445E    0E05     MOVLW 0x5
  4460    6F7A     MOVWF 0x7a, BANKED
  4462    0E07     MOVLW 0x7
  4464    6F7D     MOVWF 0x7d, BANKED
  4466    6B7E     CLRF 0x7e, BANKED
  4468    0EC1     MOVLW 0xc1
  446A    6F7C     MOVWF 0x7c, BANKED
231:                               (BYTE*)&line_coding,
  446C    0012     RETURN 0
232:                               LINE_CODING_LENGTH,
233:                               USB_EP0_INCLUDE_ZERO);
234:                           break;
  446E    C442     MOVFF 0x442, 0x5ee
  4470    F5EE     NOP
235:               
236:                       case SET_CONTROL_LINE_STATE:
237:                           control_signal_bitmap._byte = (BYTE)SetupPkt.W_Value.v[0];
  4472    0100     MOVLB 0
  4474    8F7C     BSF 0x7c, 0x7, BANKED
238:                           CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);
  4476    0012     RETURN 0
239:                           CONFIGURE_DTR(control_signal_bitmap.DTE_PRESENT);
240:                           inPipes[0].info.bits.busy = 1;
241:                           break;
242:                       #endif
243:               
244:                       #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
245:                       case SEND_BREAK:                        // Optional
246:                           inPipes[0].info.bits.busy = 1;
247:               			if (SetupPkt.wValue == 0xFFFF)
248:               			{
249:               				UART_ENABLE = 0;  // turn off USART
250:               				UART_TRISTx = 0;   // Make TX pin an output
251:               				UART_Tx = 0;   // make it low
252:               			}
253:               			else if (SetupPkt.wValue == 0x0000)
254:               			{
255:               				UART_ENABLE = 1;  // turn on USART
256:               				UART_TRISTx = 1;   // Make TX pin an input
257:               			}
258:               			else
259:               			{
260:                               UART_SEND_BREAK();
261:               			}
262:                           break;
263:                       #endif
264:                       default:
265:                           break;
266:                   }//end switch(SetupPkt.bRequest)
267:               
268:               }//end USBCheckCDCRequest
269:               
270:               /** U S E R  A P I ***********************************************************/
271:               
272:               /**************************************************************************
273:                 Function:
274:                       void CDCInitEP(void)
275:                   
276:                 Summary:
277:                   This function initializes the CDC function driver. This function should
278:                   be called after the SET_CONFIGURATION command.
279:                 Description:
280:                   This function initializes the CDC function driver. This function sets
281:                   the default line coding (baud rate, bit parity, number of data bits,
282:                   and format). This function also enables the endpoints and prepares for
283:                   the first transfer from the host.
284:                   
285:                   This function should be called after the SET_CONFIGURATION command.
286:                   This is most simply done by calling this function from the
287:                   USBCBInitEP() function.
288:                   
289:                   Typical Usage:
290:                   <code>
291:                       void USBCBInitEP(void)
292:                       {
293:                           CDCInitEP();
294:                       }
295:                   </code>
296:                 Conditions:
297:                   None
298:                 Remarks:
299:                   None                                                                   
300:                 **************************************************************************/
301:               void CDCInitEP(void)
302:               {
303:                  	//Abstract line coding information
304:                  	line_coding.dwDTERate.Val = 19200;      // baud rate
  4478    0105     MOVLB 0x5
  447A    6BD9     CLRF 0xd9, BANKED
  447C    0E4B     MOVLW 0x4b
  447E    6FDA     MOVWF 0xda, BANKED
  4480    6BDB     CLRF 0xdb, BANKED
  4482    6BDC     CLRF 0xdc, BANKED
305:                  	line_coding.bCharFormat = 0x00;             // 1 stop bit
  4484    6BDD     CLRF 0xdd, BANKED
306:                  	line_coding.bParityType = 0x00;             // None
  4486    6BDE     CLRF 0xde, BANKED
307:                  	line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
  4488    0E08     MOVLW 0x8
  448A    6FDF     MOVWF 0xdf, BANKED
308:               
309:                   cdc_rx_len = 0;
  448C    6BE0     CLRF 0xe0, BANKED
310:                   
311:                   /*
312:                    * Do not have to init Cnt of IN pipes here.
313:                    * Reason:  Number of BYTEs to send to the host
314:                    *          varies from one transaction to
315:                    *          another. Cnt should equal the exact
316:                    *          number of BYTEs to transmit for
317:                    *          a given IN transaction.
318:                    *          This number of BYTEs will only
319:                    *          be known right before the data is
320:                    *          sent.
321:                    */
322:                   USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
  448E    0E1A     MOVLW 0x1a
  4490    6EE6     MOVWF 0xfe6, ACCESS
  4492    0E02     MOVLW 0x2
  4494    6EE6     MOVWF 0xfe6, ACCESS
  4496    EC04     CALL 0x2008, 0
  4498    F010     NOP
  449A    52E5     MOVF 0xfe5, F, ACCESS
  449C    52E5     MOVF 0xfe5, F, ACCESS
323:                   USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
  449E    0E1E     MOVLW 0x1e
  44A0    6EE6     MOVWF 0xfe6, ACCESS
  44A2    0E03     MOVLW 0x3
  44A4    6EE6     MOVWF 0xfe6, ACCESS
  44A6    EC04     CALL 0x2008, 0
  44A8    F010     NOP
  44AA    52E5     MOVF 0xfe5, F, ACCESS
  44AC    52E5     MOVF 0xfe5, F, ACCESS
324:               
325:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
  44AE    0E40     MOVLW 0x40
  44B0    6EE6     MOVWF 0xfe6, ACCESS
  44B2    0E59     MOVLW 0x59
  44B4    6EE6     MOVWF 0xfe6, ACCESS
  44B6    0E05     MOVLW 0x5
  44B8    6EE6     MOVWF 0xfe6, ACCESS
  44BA    6AE6     CLRF 0xfe6, ACCESS
  44BC    0E03     MOVLW 0x3
  44BE    6EE6     MOVWF 0xfe6, ACCESS
  44C0    ECA9     CALL 0x2152, 0
  44C2    F010     NOP
  44C4    6E14     MOVWF 0x14, ACCESS
  44C6    0E05     MOVLW 0x5
  44C8    5EE1     SUBWF 0xfe1, F, ACCESS
  44CA    5014     MOVF 0x14, W, ACCESS
  44CC    CFF3     MOVFF 0xff3, 0x5ea
  44CE    F5EA     NOP
  44D0    CFF4     MOVFF 0xff4, 0x5eb
  44D2    F5EB     NOP
326:                   CDCDataInHandle = NULL;
  44D4    0105     MOVLB 0x5
  44D6    6BEC     CLRF 0xec, BANKED
  44D8    6BED     CLRF 0xed, BANKED
327:                   
328:                   cdc_trf_state = CDC_TX_READY;
  44DA    6BE1     CLRF 0xe1, BANKED
329:               }//end CDCInitEP
  44DC    0012     RETURN 0
330:               
331:               /**********************************************************************************
332:                 Function:
333:                       BYTE getsUSBUSART(char *buffer, BYTE len)
334:                   
335:                 Summary:
336:                   getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
337:                   endpoint to a user's specified location. It is a non-blocking function.
338:                   It does not wait for data if there is no data available. Instead it
339:                   returns '0' to notify the caller that there is no data available.
340:               
341:                 Description:
342:                   getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
343:                   endpoint to a user's specified location. It is a non-blocking function.
344:                   It does not wait for data if there is no data available. Instead it
345:                   returns '0' to notify the caller that there is no data available.
346:                   
347:                   Typical Usage:
348:                   <code>
349:                       BYTE numBytes;
350:                       BYTE buffer[64]
351:                   
352:                       numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
353:                       if(numBytes \> 0)
354:                       {
355:                           //we received numBytes bytes of data and they are copied into
356:                           //  the "buffer" variable.  We can do something with the data
357:                           //  here.
358:                       }
359:                   </code>
360:                 Conditions:
361:                   Value of input argument 'len' should be smaller than the maximum
362:                   endpoint size responsible for receiving bulk data from USB host for CDC
363:                   class. Input argument 'buffer' should point to a buffer area that is
364:                   bigger or equal to the size specified by 'len'.
365:                 Input:
366:                   buffer -  Pointer to where received BYTEs are to be stored
367:                   len -     The number of BYTEs expected.
368:                                                                                                  
369:                 **********************************************************************************/
370:               BYTE getsUSBUSART(char *buffer, BYTE len)
  44DE    CFD9     MOVFF 0xfd9, 0xfe6
  44E0    FFE6     NOP
  44E2    CFE1     MOVFF 0xfe1, 0xfd9
  44E4    FFD9     NOP
371:               {
372:                   cdc_rx_len = 0;
  44E6    0105     MOVLB 0x5
  44E8    6BE0     CLRF 0xe0, BANKED
373:                   
374:                   if(!USBHandleBusy(CDCDataOutHandle))
  44EA    51EA     MOVF 0xea, W, BANKED
  44EC    11EB     IORWF 0xeb, W, BANKED
  44EE    E102     BNZ 0x44f4
  44F0    0E00     MOVLW 0
  44F2    D008     BRA 0x4504
  44F4    C5EA     MOVFF 0x5ea, 0xfe9
  44F6    FFE9     NOP
  44F8    C5EB     MOVFF 0x5eb, 0xfea
  44FA    FFEA     NOP
  44FC    50EF     MOVF 0xfef, W, ACCESS
  44FE    0B80     ANDLW 0x80
  4500    E001     BZ 0x4504
  4502    0E01     MOVLW 0x1
  4504    0900     IORLW 0
  4506    E145     BNZ 0x4592
375:                   {
376:                       /*
377:                        * Adjust the expected number of BYTEs to equal
378:                        * the actual number of BYTEs received.
379:                        */
380:                       if(len > USBHandleGetLength(CDCDataOutHandle))
  4508    0EFC     MOVLW 0xfc
  450A    CFDB     MOVFF 0xfdb, 0x14
  450C    F014     NOP
  450E    C5EA     MOVFF 0x5ea, 0xfe9
  4510    FFE9     NOP
  4512    C5EB     MOVFF 0x5eb, 0xfea
  4514    FFEA     NOP
  4516    52EE     MOVF 0xfee, F, ACCESS
  4518    50EF     MOVF 0xfef, W, ACCESS
  451A    80D8     BSF 0xfd8, 0, ACCESS
  451C    5414     SUBFWB 0x14, W, ACCESS
  451E    E208     BC 0x4530
381:                           len = USBHandleGetLength(CDCDataOutHandle);
  4520    C5EA     MOVFF 0x5ea, 0xfe9
  4522    FFE9     NOP
  4524    C5EB     MOVFF 0x5eb, 0xfea
  4526    FFEA     NOP
  4528    52EE     MOVF 0xfee, F, ACCESS
  452A    0EFC     MOVLW 0xfc
  452C    CFEF     MOVFF 0xfef, 0xfdb
  452E    FFDB     NOP
382:                       
383:                       /*
384:                        * Copy data from dual-ram buffer to user's buffer
385:                        */
386:                       for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
  4530    6BE0     CLRF 0xe0, BANKED
  4532    0EFC     MOVLW 0xfc
  4534    50DB     MOVF 0xfdb, W, ACCESS
  4536    5DE0     SUBWF 0xe0, W, BANKED
  4538    E219     BC 0x456c
  4568    2BE0     INCF 0xe0, F, BANKED
  456A    D7E3     BRA 0x4532
387:                           buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
  453A    51E0     MOVF 0xe0, W, BANKED
  453C    6AEA     CLRF 0xfea, ACCESS
  453E    0F59     ADDLW 0x59
  4540    6EE9     MOVWF 0xfe9, ACCESS
  4542    0E05     MOVLW 0x5
  4544    22EA     ADDWFC 0xfea, F, ACCESS
  4546    50EF     MOVF 0xfef, W, ACCESS
  4548    6EE6     MOVWF 0xfe6, ACCESS
  454A    51E0     MOVF 0xe0, W, BANKED
  454C    6EE7     MOVWF 0xfe7, ACCESS
  454E    0EFD     MOVLW 0xfd
  4550    CFDB     MOVFF 0xfdb, 0xfe9
  4552    FFE9     NOP
  4554    0EFE     MOVLW 0xfe
  4556    CFDB     MOVFF 0xfdb, 0xfea
  4558    FFEA     NOP
  455A    50E7     MOVF 0xfe7, W, ACCESS
  455C    26E9     ADDWF 0xfe9, F, ACCESS
  455E    0E00     MOVLW 0
  4560    22EA     ADDWFC 0xfea, F, ACCESS
  4562    52E5     MOVF 0xfe5, F, ACCESS
  4564    50E7     MOVF 0xfe7, W, ACCESS
  4566    6EEF     MOVWF 0xfef, ACCESS
388:               
389:                       /*
390:                        * Prepare dual-ram buffer for next OUT transaction
391:                        */
392:               
393:                       CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
  456C    0E40     MOVLW 0x40
  456E    6EE6     MOVWF 0xfe6, ACCESS
  4570    0E59     MOVLW 0x59
  4572    6EE6     MOVWF 0xfe6, ACCESS
  4574    0E05     MOVLW 0x5
  4576    6EE6     MOVWF 0xfe6, ACCESS
  4578    6AE6     CLRF 0xfe6, ACCESS
  457A    0E03     MOVLW 0x3
  457C    6EE6     MOVWF 0xfe6, ACCESS
  457E    ECA9     CALL 0x2152, 0
  4580    F010     NOP
  4582    6E14     MOVWF 0x14, ACCESS
  4584    0E05     MOVLW 0x5
  4586    5EE1     SUBWF 0xfe1, F, ACCESS
  4588    5014     MOVF 0x14, W, ACCESS
  458A    CFF3     MOVFF 0xff3, 0x5ea
  458C    F5EA     NOP
  458E    CFF4     MOVFF 0xff4, 0x5eb
  4590    F5EB     NOP
394:               
395:                   }//end if
396:                   
397:                   return cdc_rx_len;
  4592    0105     MOVLB 0x5
  4594    51E0     MOVF 0xe0, W, BANKED
398:                   
399:               }//end getsUSBUSART
  4596    52E5     MOVF 0xfe5, F, ACCESS
  4598    CFE7     MOVFF 0xfe7, 0xfd9
  459A    FFD9     NOP
  459C    0012     RETURN 0
400:               
401:               /******************************************************************************
402:                 Function:
403:               	void putUSBUSART(char *data, BYTE length)
404:               		
405:                 Summary:
406:                   putUSBUSART writes an array of data to the USB. Use this version, is
407:                   capable of transfering 0x00 (what is typically a NULL character in any of
408:                   the string transfer functions).
409:               
410:                 Description:
411:                   putUSBUSART writes an array of data to the USB. Use this version, is
412:                   capable of transfering 0x00 (what is typically a NULL character in any of
413:                   the string transfer functions).
414:                   
415:                   Typical Usage:
416:                   <code>
417:                       if(USBUSARTIsTxTrfReady())
418:                       {
419:                           char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
420:                           putUSBUSART(data,5);
421:                       }
422:                   </code>
423:                   
424:                   The transfer mechanism for device-to-host(put) is more flexible than
425:                   host-to-device(get). It can handle a string of data larger than the
426:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
427:                   \long string of data over multiple USB transactions. CDCTxService()
428:                   must be called periodically to keep sending blocks of data to the host.
429:               
430:                 Conditions:
431:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
432:                   transfer is complete and is ready to receive a new block of data. The
433:                   string of characters pointed to by 'data' must equal to or smaller than
434:                   255 BYTEs.
435:               
436:                 Input:
437:                   char *data - pointer to a RAM array of data to be transfered to the host
438:                   BYTE length - the number of bytes to be transfered (must be less than 255).
439:               		
440:                *****************************************************************************/
441:               void putUSBUSART(char *data, BYTE  length)
  459E    CFD9     MOVFF 0xfd9, 0xfe6
  45A0    FFE6     NOP
  45A2    CFE1     MOVFF 0xfe1, 0xfd9
  45A4    FFD9     NOP
442:               {
443:                   /*
444:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
445:                    * before calling this function.
446:                    * As a safety precaution, this fuction checks the state one more time
447:                    * to make sure it does not override any pending transactions.
448:                    *
449:                    * Currently it just quits the routine without reporting any errors back
450:                    * to the user.
451:                    *
452:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
453:                    *             before calling this function!
454:                    * Example:
455:                    * if(USBUSARTIsTxTrfReady())
456:                    *     putUSBUSART(pData, Length);
457:                    *
458:                    * IMPORTANT: Never use the following blocking while loop to wait:
459:                    * while(!USBUSARTIsTxTrfReady())
460:                    *     putUSBUSART(pData, Length);
461:                    *
462:                    * The whole firmware framework is written based on cooperative
463:                    * multi-tasking and a blocking code is not acceptable.
464:                    * Use a state machine instead.
465:                    */
466:                   USBMaskInterrupts();
  45A6    98A0     BCF 0xfa0, 0x4, ACCESS
467:                   if(cdc_trf_state == CDC_TX_READY)
  45A8    0105     MOVLB 0x5
  45AA    51E1     MOVF 0xe1, W, BANKED
  45AC    E10C     BNZ 0x45c6
468:                   {
469:                       mUSBUSARTTxRam((BYTE*)data, length);     // See cdc.h
  45AE    0EFD     MOVLW 0xfd
  45B0    CFDB     MOVFF 0xfdb, 0x5e2
  45B2    F5E2     NOP
  45B4    0EFE     MOVLW 0xfe
  45B6    CFDB     MOVFF 0xfdb, 0x5e3
  45B8    F5E3     NOP
  45BA    0EFC     MOVLW 0xfc
  45BC    CFDB     MOVFF 0xfdb, 0x5e8
  45BE    F5E8     NOP
  45C0    0E01     MOVLW 0x1
  45C2    6FE9     MOVWF 0xe9, BANKED
  45C4    6FE1     MOVWF 0xe1, BANKED
470:                   }
471:                   USBUnmaskInterrupts();
  45C6    88A0     BSF 0xfa0, 0x4, ACCESS
472:               }//end putUSBUSART
  45C8    52E5     MOVF 0xfe5, F, ACCESS
  45CA    CFE7     MOVFF 0xfe7, 0xfd9
  45CC    FFD9     NOP
  45CE    0012     RETURN 0
473:               
474:               /******************************************************************************
475:               	Function:
476:               		void putsUSBUSART(char *data)
477:               		
478:                 Summary:
479:                   putsUSBUSART writes a string of data to the USB including the null
480:                   character. Use this version, 'puts', to transfer data from a RAM buffer.
481:               
482:                 Description:
483:                   putsUSBUSART writes a string of data to the USB including the null
484:                   character. Use this version, 'puts', to transfer data from a RAM buffer.
485:                   
486:                   Typical Usage:
487:                   <code>
488:                       if(USBUSARTIsTxTrfReady())
489:                       {
490:                           char data[] = "Hello World";
491:                           putsUSBUSART(data);
492:                       }
493:                   </code>
494:                   
495:                   The transfer mechanism for device-to-host(put) is more flexible than
496:                   host-to-device(get). It can handle a string of data larger than the
497:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
498:                   \long string of data over multiple USB transactions. CDCTxService()
499:                   must be called periodically to keep sending blocks of data to the host.
500:               
501:                 Conditions:
502:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
503:                   transfer is complete and is ready to receive a new block of data. The
504:                   string of characters pointed to by 'data' must equal to or smaller than
505:                   255 BYTEs.
506:               
507:                 Input:
508:                   char *data -  null\-terminated string of constant data. If a
509:                                           null character is not found, 255 BYTEs of data
510:                                           will be transferred to the host.
511:               		
512:                *****************************************************************************/
513:                
514:               void putsUSBUSART(char *data)
  45D0    CFD9     MOVFF 0xfd9, 0xfe6
  45D2    FFE6     NOP
  45D4    CFE1     MOVFF 0xfe1, 0xfd9
  45D6    FFD9     NOP
  45D8    0E03     MOVLW 0x3
  45DA    26E1     ADDWF 0xfe1, F, ACCESS
515:               {
516:                   BYTE len;
517:                   char *pData;
518:               
519:                   /*
520:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
521:                    * before calling this function.
522:                    * As a safety precaution, this fuction checks the state one more time
523:                    * to make sure it does not override any pending transactions.
524:                    *
525:                    * Currently it just quits the routine without reporting any errors back
526:                    * to the user.
527:                    *
528:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
529:                    *             before calling this function!
530:                    * Example:
531:                    * if(USBUSARTIsTxTrfReady())
532:                    *     putsUSBUSART(pData, Length);
533:                    *
534:                    * IMPORTANT: Never use the following blocking while loop to wait:
535:                    * while(!USBUSARTIsTxTrfReady())
536:                    *     putsUSBUSART(pData);
537:                    *
538:                    * The whole firmware framework is written based on cooperative
539:                    * multi-tasking and a blocking code is not acceptable.
540:                    * Use a state machine instead.
541:                    */
542:                   USBMaskInterrupts();
  45DC    98A0     BCF 0xfa0, 0x4, ACCESS
543:                   if(cdc_trf_state != CDC_TX_READY)
  45DE    0105     MOVLB 0x5
  45E0    51E1     MOVF 0xe1, W, BANKED
  45E2    E12D     BNZ 0x463e
544:                   {
545:                       USBUnmaskInterrupts();
546:                       return;
547:                   }
548:                   
549:                   /*
550:                    * While loop counts the number of BYTEs to send including the
551:                    * null character.
552:                    */
553:                   len = 0;
  45E4    6ADF     CLRF 0xfdf, ACCESS
554:                   pData = data;
  45E6    0EFD     MOVLW 0xfd
  45E8    CFDB     MOVFF 0xfdb, 0x8
  45EA    F008     NOP
  45EC    0EFE     MOVLW 0xfe
  45EE    CFDB     MOVFF 0xfdb, 0x9
  45F0    F009     NOP
  45F2    52DE     MOVF 0xfde, F, ACCESS
  45F4    C008     MOVFF 0x8, 0xfde
  45F6    FFDE     NOP
  45F8    C009     MOVFF 0x9, 0xfdd
  45FA    FFDD     NOP
  45FC    52DD     MOVF 0xfdd, F, ACCESS
555:                   do
556:                   {
557:                       len++;
  45FE    2ADF     INCF 0xfdf, F, ACCESS
558:                       if(len == 255) break;       // Break loop once max len is reached.
  4600    50DF     MOVF 0xfdf, W, ACCESS
  4602    6E14     MOVWF 0x14, ACCESS
  4604    6A15     CLRF 0x15, ACCESS
  4606    0EFF     MOVLW 0xff
  4608    1814     XORWF 0x14, W, ACCESS
  460A    E102     BNZ 0x4610
  460C    5015     MOVF 0x15, W, ACCESS
  460E    E00B     BZ 0x4626
559:                   }while(*pData++);
  4610    0E01     MOVLW 0x1
  4612    CFDB     MOVFF 0xfdb, 0xfe9
  4614    FFE9     NOP
  4616    2ADB     INCF 0xfdb, F, ACCESS
  4618    0E02     MOVLW 0x2
  461A    CFDB     MOVFF 0xfdb, 0xfea
  461C    FFEA     NOP
  461E    E301     BNC 0x4622
  4620    2ADB     INCF 0xfdb, F, ACCESS
  4622    50EF     MOVF 0xfef, W, ACCESS
  4624    E1EC     BNZ 0x45fe
560:                   
561:                   /*
562:                    * Second piece of information (length of data to send) is ready.
563:                    * Call mUSBUSARTTxRam to setup the transfer.
564:                    * The actual transfer process will be handled by CDCTxService(),
565:                    * which should be called once per Main Program loop.
566:                    */
567:               //    mUSBUSARTTxRam((BYTE*)data, len);     // See cdc.h
568:                   mUSBUSARTTxRam((BYTE*)data, len-1);     // fucking STUPID, DON'T send the null
  4626    0EFD     MOVLW 0xfd
  4628    CFDB     MOVFF 0xfdb, 0x5e2
  462A    F5E2     NOP
  462C    0EFE     MOVLW 0xfe
  462E    CFDB     MOVFF 0xfdb, 0x5e3
  4630    F5E3     NOP
  4632    04DF     DECF 0xfdf, W, ACCESS
  4634    0105     MOVLB 0x5
  4636    6FE8     MOVWF 0xe8, BANKED
  4638    0E01     MOVLW 0x1
  463A    6FE9     MOVWF 0xe9, BANKED
  463C    6FE1     MOVWF 0xe1, BANKED
569:                   USBUnmaskInterrupts();
  463E    88A0     BSF 0xfa0, 0x4, ACCESS
570:               }//end putsUSBUSART
  4640    0E03     MOVLW 0x3
  4642    5CE1     SUBWF 0xfe1, W, ACCESS
  4644    E202     BC 0x464a
  4646    6AE1     CLRF 0xfe1, ACCESS
  4648    52E5     MOVF 0xfe5, F, ACCESS
  464A    6EE1     MOVWF 0xfe1, ACCESS
  464C    52E5     MOVF 0xfe5, F, ACCESS
  464E    CFE7     MOVFF 0xfe7, 0xfd9
  4650    FFD9     NOP
  4652    0012     RETURN 0
571:               
572:               /**************************************************************************
573:                 Function:
574:                       void putrsUSBUSART(const ROM char *data)
575:                   
576:                 Summary:
577:                   putrsUSBUSART writes a string of data to the USB including the null
578:                   character. Use this version, 'putrs', to transfer data literals and
579:                   data located in program memory.
580:               
581:                 Description:
582:                   putrsUSBUSART writes a string of data to the USB including the null
583:                   character. Use this version, 'putrs', to transfer data literals and
584:                   data located in program memory.
585:                   
586:                   Typical Usage:
587:                   <code>
588:                       if(USBUSARTIsTxTrfReady())
589:                       {
590:                           putrsUSBUSART("Hello World");
591:                       }
592:                   </code>
593:                   
594:                   The transfer mechanism for device-to-host(put) is more flexible than
595:                   host-to-device(get). It can handle a string of data larger than the
596:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
597:                   \long string of data over multiple USB transactions. CDCTxService()
598:                   must be called periodically to keep sending blocks of data to the host.
599:               
600:                 Conditions:
601:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
602:                   transfer is complete and is ready to receive a new block of data. The
603:                   string of characters pointed to by 'data' must equal to or smaller than
604:                   255 BYTEs.
605:               
606:                 Input:
607:                   const ROM char *data -  null\-terminated string of constant data. If a
608:                                           null character is not found, 255 BYTEs of data
609:                                           will be transferred to the host.
610:                                                                                          
611:                 **************************************************************************/
612:               void putrsUSBUSART(const ROM char *data)
  4654    CFD9     MOVFF 0xfd9, 0xfe6
  4656    FFE6     NOP
  4658    CFE1     MOVFF 0xfe1, 0xfd9
  465A    FFD9     NOP
  465C    0E04     MOVLW 0x4
  465E    26E1     ADDWF 0xfe1, F, ACCESS
613:               {
614:                   BYTE len;
615:                   const ROM char *pData;
616:               
617:                   /*
618:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
619:                    * before calling this function.
620:                    * As a safety precaution, this fuction checks the state one more time
621:                    * to make sure it does not override any pending transactions.
622:                    *
623:                    * Currently it just quits the routine without reporting any errors back
624:                    * to the user.
625:                    *
626:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()
627:                    *             before calling this function!
628:                    * Example:
629:                    * if(USBUSARTIsTxTrfReady())
630:                    *     putsUSBUSART(pData);
631:                    *
632:                    * IMPORTANT: Never use the following blocking while loop to wait:
633:                    * while(cdc_trf_state != CDC_TX_READY)
634:                    *     putsUSBUSART(pData);
635:                    *
636:                    * The whole firmware framework is written based on cooperative
637:                    * multi-tasking and a blocking code is not acceptable.
638:                    * Use a state machine instead.
639:                    */
640:                   USBMaskInterrupts();
  4660    98A0     BCF 0xfa0, 0x4, ACCESS
641:                   if(cdc_trf_state != CDC_TX_READY)
  4662    0105     MOVLB 0x5
  4664    51E1     MOVF 0xe1, W, BANKED
  4666    E13A     BNZ 0x46dc
642:                   {
643:                       USBUnmaskInterrupts();
644:                       return;
645:                   }
646:                   
647:                   /*
648:                    * While loop counts the number of BYTEs to send including the
649:                    * null character.
650:                    */
651:                   len = 0;
  4668    6ADF     CLRF 0xfdf, ACCESS
652:                   pData = data;
  466A    50D9     MOVF 0xfd9, W, ACCESS
  466C    0FFC     ADDLW 0xfc
  466E    6EE9     MOVWF 0xfe9, ACCESS
  4670    0EFF     MOVLW 0xff
  4672    20DA     ADDWFC 0xfda, W, ACCESS
  4674    6EEA     MOVWF 0xfea, ACCESS
  4676    0E01     MOVLW 0x1
  4678    CFEE     MOVFF 0xfee, 0xfdb
  467A    FFDB     NOP
  467C    0E02     MOVLW 0x2
  467E    CFEE     MOVFF 0xfee, 0xfdb
  4680    FFDB     NOP
  4682    0E03     MOVLW 0x3
  4684    CFEE     MOVFF 0xfee, 0xfdb
  4686    FFDB     NOP
653:                   do
654:                   {
655:                       len++;
  4688    2ADF     INCF 0xfdf, F, ACCESS
656:                       if(len == 255) break;       // Break loop once max len is reached.
  468A    50DF     MOVF 0xfdf, W, ACCESS
  468C    6E14     MOVWF 0x14, ACCESS
  468E    6A15     CLRF 0x15, ACCESS
  4690    0EFF     MOVLW 0xff
  4692    1814     XORWF 0x14, W, ACCESS
  4694    E102     BNZ 0x469a
  4696    5015     MOVF 0x15, W, ACCESS
  4698    E012     BZ 0x46be
657:                   }while(*pData++);
  469A    50D9     MOVF 0xfd9, W, ACCESS
  469C    0F01     ADDLW 0x1
  469E    6EE9     MOVWF 0xfe9, ACCESS
  46A0    CFDA     MOVFF 0xfda, 0xfea
  46A2    FFEA     NOP
  46A4    CFEF     MOVFF 0xfef, 0xff6
  46A6    FFF6     NOP
  46A8    2AEE     INCF 0xfee, F, ACCESS
  46AA    CFEF     MOVFF 0xfef, 0xff7
  46AC    FFF7     NOP
  46AE    0E00     MOVLW 0
  46B0    22EE     ADDWFC 0xfee, F, ACCESS
  46B2    CFEF     MOVFF 0xfef, 0xff8
  46B4    FFF8     NOP
  46B6    22EE     ADDWFC 0xfee, F, ACCESS
  46B8    0008     TBLRD*
  46BA    50F5     MOVF 0xff5, W, ACCESS
  46BC    E1E5     BNZ 0x4688
658:                   
659:                   /*
660:                    * Second piece of information (length of data to send) is ready.
661:                    * Call mUSBUSARTTxRom to setup the transfer.
662:                    * The actual transfer process will be handled by CDCTxService(),
663:                    * which should be called once per Main Program loop.
664:                    */
665:               
666:               //    mUSBUSARTTxRom((ROM BYTE*)data,len); // See cdc.h
667:                   mUSBUSARTTxRom((ROM BYTE*)data,len); // fucking STUPID, DON'T send the null
  46BE    0EFC     MOVLW 0xfc
  46C0    CFDB     MOVFF 0xfdb, 0x5e2
  46C2    F5E2     NOP
  46C4    0EFD     MOVLW 0xfd
  46C6    CFDB     MOVFF 0xfdb, 0x5e3
  46C8    F5E3     NOP
  46CA    0EFE     MOVLW 0xfe
  46CC    CFDB     MOVFF 0xfdb, 0x5e4
  46CE    F5E4     NOP
  46D0    CFDF     MOVFF 0xfdf, 0x5e8
  46D2    F5E8     NOP
  46D4    0105     MOVLB 0x5
  46D6    6BE9     CLRF 0xe9, BANKED
  46D8    0E01     MOVLW 0x1
  46DA    6FE1     MOVWF 0xe1, BANKED
668:                   USBUnmaskInterrupts();
  46DC    88A0     BSF 0xfa0, 0x4, ACCESS
669:               
670:               }//end putrsUSBUSART
  46DE    0E04     MOVLW 0x4
  46E0    5CE1     SUBWF 0xfe1, W, ACCESS
  46E2    E202     BC 0x46e8
  46E4    6AE1     CLRF 0xfe1, ACCESS
  46E6    52E5     MOVF 0xfe5, F, ACCESS
  46E8    6EE1     MOVWF 0xfe1, ACCESS
  46EA    52E5     MOVF 0xfe5, F, ACCESS
  46EC    CFE7     MOVFF 0xfe7, 0xfd9
  46EE    FFD9     NOP
  46F0    0012     RETURN 0
671:               
672:               /************************************************************************
673:                 Function:
674:                       void CDCTxService(void)
675:                   
676:                 Summary:
677:                   CDCTxService handles device-to-host transaction(s). This function
678:                   should be called once per Main Program loop after the device reaches
679:                   the configured state.
680:                 Description:
681:                   CDCTxService handles device-to-host transaction(s). This function
682:                   should be called once per Main Program loop after the device reaches
683:                   the configured state.
684:                   
685:                   Typical Usage:
686:                   <code>
687:                   void main(void)
688:                   {
689:                       USBDeviceInit();
690:                       while(1)
691:                       {
692:                           USBDeviceTasks();
693:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
694:                              (USBIsDeviceSuspended() == TRUE))
695:                           {
696:                               //Either the device is not configured or we are suspended
697:                               //  so we don't want to do execute any application code
698:                               continue;   //go back to the top of the while loop
699:                           }
700:                           else
701:                           {
702:                               //Keep trying to send data to the PC as required
703:                               CDCTxService();
704:                   
705:                               //Run application code.
706:                               UserApplication();
707:                           }
708:                       }
709:                   }
710:                   </code>
711:                 Conditions:
712:                   None
713:                 Remarks:
714:                   None                                                                 
715:                 ************************************************************************/
716:                
717:               void CDCTxService(void)
  46F2    CFD9     MOVFF 0xfd9, 0xfe6
  46F4    FFE6     NOP
  46F6    CFE1     MOVFF 0xfe1, 0xfd9
  46F8    FFD9     NOP
  46FA    0E02     MOVLW 0x2
  46FC    26E1     ADDWF 0xfe1, F, ACCESS
718:               {
719:                   BYTE byte_to_send;
720:                   BYTE i;
721:                   
722:                   USBMaskInterrupts();
  46FE    98A0     BCF 0xfa0, 0x4, ACCESS
723:                   if(USBHandleBusy(CDCDataInHandle)) 
  4700    0105     MOVLB 0x5
  4702    51EC     MOVF 0xec, W, BANKED
  4704    11ED     IORWF 0xed, W, BANKED
  4706    E102     BNZ 0x470c
  4708    0E00     MOVLW 0
  470A    D008     BRA 0x471c
  470C    C5EC     MOVFF 0x5ec, 0xfe9
  470E    FFE9     NOP
  4710    C5ED     MOVFF 0x5ed, 0xfea
  4712    FFEA     NOP
  4714    50EF     MOVF 0xfef, W, ACCESS
  4716    0B80     ANDLW 0x80
  4718    E001     BZ 0x471c
  471A    0E01     MOVLW 0x1
  471C    0900     IORLW 0
  471E    E106     BNZ 0x472c
724:                   {
725:                       USBUnmaskInterrupts();
726:                       return;
727:                   }
728:               
729:                   /*
730:                    * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
731:                    * By having this stage, user can always check cdc_trf_state,
732:                    * and not having to call mCDCUsartTxIsBusy() directly.
733:                    */
734:                   if(cdc_trf_state == CDC_TX_COMPLETING)
  4720    0E03     MOVLW 0x3
  4722    5DE1     SUBWF 0xe1, W, BANKED
  4724    E101     BNZ 0x4728
735:                       cdc_trf_state = CDC_TX_READY;
  4726    6BE1     CLRF 0xe1, BANKED
736:                   
737:                   /*
738:                    * If CDC_TX_READY state, nothing to do, just return.
739:                    */
740:                   if(cdc_trf_state == CDC_TX_READY)
  4728    51E1     MOVF 0xe1, W, BANKED
  472A    E102     BNZ 0x4730
741:                   {
742:                       USBUnmaskInterrupts();
  472C    88A0     BSF 0xfa0, 0x4, ACCESS
743:                       return;
  472E    D081     BRA 0x4832
744:                   }
745:                   
746:                   /*
747:                    * If CDC_TX_BUSY_ZLP state, send zero length packet
748:                    */
749:                   if(cdc_trf_state == CDC_TX_BUSY_ZLP)
  4730    0E02     MOVLW 0x2
  4732    5DE1     SUBWF 0xe1, W, BANKED
  4734    E116     BNZ 0x4762
750:                   {
751:                       CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
  4736    6AE6     CLRF 0xfe6, ACCESS
  4738    0E00     MOVLW 0
  473A    6EE6     MOVWF 0xfe6, ACCESS
  473C    6AE6     CLRF 0xfe6, ACCESS
  473E    0E01     MOVLW 0x1
  4740    6EE6     MOVWF 0xfe6, ACCESS
  4742    0E03     MOVLW 0x3
  4744    6EE6     MOVWF 0xfe6, ACCESS
  4746    ECA9     CALL 0x2152, 0
  4748    F010     NOP
  474A    6E14     MOVWF 0x14, ACCESS
  474C    0E05     MOVLW 0x5
  474E    5EE1     SUBWF 0xfe1, F, ACCESS
  4750    5014     MOVF 0x14, W, ACCESS
  4752    CFF3     MOVFF 0xff3, 0x5ec
  4754    F5EC     NOP
  4756    CFF4     MOVFF 0xff4, 0x5ed
  4758    F5ED     NOP
752:                       //CDC_DATA_BD_IN.CNT = 0;
753:                       cdc_trf_state = CDC_TX_COMPLETING;
  475A    0105     MOVLB 0x5
  475C    0E03     MOVLW 0x3
  475E    6FE1     MOVWF 0xe1, BANKED
754:                   }
755:                   else if(cdc_trf_state == CDC_TX_BUSY)
  4760    D067     BRA 0x4830
  4762    05E1     DECF 0xe1, W, BANKED
  4764    E165     BNZ 0x4830
756:                   {
757:                       /*
758:                        * First, have to figure out how many byte of data to send.
759:                        */
760:                   	if(cdc_tx_len > sizeof(cdc_data_tx))
  4766    0E40     MOVLW 0x40
  4768    6E14     MOVWF 0x14, ACCESS
  476A    6A15     CLRF 0x15, ACCESS
  476C    51E8     MOVF 0xe8, W, BANKED
  476E    5C14     SUBWF 0x14, W, ACCESS
  4770    0E00     MOVLW 0
  4772    5815     SUBWFB 0x15, W, ACCESS
  4774    E203     BC 0x477c
761:                   	    byte_to_send = sizeof(cdc_data_tx);
  4776    0E40     MOVLW 0x40
  4778    6EDF     MOVWF 0xfdf, ACCESS
762:                   	else
  477A    D002     BRA 0x4780
763:                   	    byte_to_send = cdc_tx_len;
  477C    C5E8     MOVFF 0x5e8, 0xfdf
  477E    FFDF     NOP
764:               
765:                       /*
766:                        * Subtract the number of bytes just about to be sent from the total.
767:                        */
768:                   	cdc_tx_len = cdc_tx_len - byte_to_send;
  4780    50DF     MOVF 0xfdf, W, ACCESS
  4782    5DE8     SUBWF 0xe8, W, BANKED
  4784    6FE8     MOVWF 0xe8, BANKED
769:                   	  
770:                       pCDCDst.bRam = (BYTE*)&cdc_data_tx; // Set destination pointer
  4786    0E99     MOVLW 0x99
  4788    6FE5     MOVWF 0xe5, BANKED
  478A    0E05     MOVLW 0x5
  478C    6FE6     MOVWF 0xe6, BANKED
771:                       
772:                       i = byte_to_send;
  478E    0E01     MOVLW 0x1
  4790    CFDF     MOVFF 0xfdf, 0xfdb
  4792    FFDB     NOP
773:                       if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
  4794    51E9     MOVF 0xe9, W, BANKED
  4796    E119     BNZ 0x47ca
774:                       {
775:                           while(i)
  4798    0E01     MOVLW 0x1
  479A    50DB     MOVF 0xfdb, W, ACCESS
  479C    E02B     BZ 0x47f4
  47C8    D7E7     BRA 0x4798
776:                           {
777:                               *pCDCDst.bRam = *pCDCSrc.bRom;
  479E    C5E2     MOVFF 0x5e2, 0xff6
  47A0    FFF6     NOP
  47A2    C5E3     MOVFF 0x5e3, 0xff7
  47A4    FFF7     NOP
  47A6    C5E4     MOVFF 0x5e4, 0xff8
  47A8    FFF8     NOP
  47AA    0008     TBLRD*
  47AC    50F5     MOVF 0xff5, W, ACCESS
  47AE    C5E5     MOVFF 0x5e5, 0xfe9
  47B0    FFE9     NOP
  47B2    C5E6     MOVFF 0x5e6, 0xfea
  47B4    FFEA     NOP
  47B6    6EEF     MOVWF 0xfef, ACCESS
778:                               pCDCDst.bRam++;
  47B8    2BE5     INCF 0xe5, F, BANKED
  47BA    0E00     MOVLW 0
  47BC    23E6     ADDWFC 0xe6, F, BANKED
779:                               pCDCSrc.bRom++;
  47BE    2BE2     INCF 0xe2, F, BANKED
  47C0    23E3     ADDWFC 0xe3, F, BANKED
  47C2    23E4     ADDWFC 0xe4, F, BANKED
780:                               i--;
  47C4    0E01     MOVLW 0x1
  47C6    06DB     DECF 0xfdb, F, ACCESS
781:                           }//end while(byte_to_send)
782:                       }
783:                       else // _RAM
784:                       {
785:                           while(i)
  47CA    0E01     MOVLW 0x1
  47CC    50DB     MOVF 0xfdb, W, ACCESS
  47CE    E012     BZ 0x47f4
  47F2    D7EB     BRA 0x47ca
786:                           {
787:                               *pCDCDst.bRam = *pCDCSrc.bRam;
  47D0    C5E2     MOVFF 0x5e2, 0xfe9
  47D2    FFE9     NOP
  47D4    C5E3     MOVFF 0x5e3, 0xfea
  47D6    FFEA     NOP
  47D8    50EF     MOVF 0xfef, W, ACCESS
  47DA    C5E5     MOVFF 0x5e5, 0xfe9
  47DC    FFE9     NOP
  47DE    C5E6     MOVFF 0x5e6, 0xfea
  47E0    FFEA     NOP
  47E2    6EEF     MOVWF 0xfef, ACCESS
788:                               pCDCDst.bRam++;
  47E4    2BE5     INCF 0xe5, F, BANKED
  47E6    0E00     MOVLW 0
  47E8    23E6     ADDWFC 0xe6, F, BANKED
789:                               pCDCSrc.bRam++;
  47EA    2BE2     INCF 0xe2, F, BANKED
  47EC    23E3     ADDWFC 0xe3, F, BANKED
790:                               i--;
  47EE    0E01     MOVLW 0x1
  47F0    06DB     DECF 0xfdb, F, ACCESS
791:                           }//end while(byte_to_send._word)
792:                       }//end if(cdc_mem_type...)
793:                       
794:                       /*
795:                        * Lastly, determine if a zero length packet state is necessary.
796:                        * See explanation in USB Specification 2.0: Section 5.8.3
797:                        */
798:                       if(cdc_tx_len == 0)
  47F4    0105     MOVLB 0x5
  47F6    51E8     MOVF 0xe8, W, BANKED
  47F8    E107     BNZ 0x4808
799:                       {
800:                           if(byte_to_send == CDC_DATA_IN_EP_SIZE)
  47FA    0E40     MOVLW 0x40
  47FC    5CDF     SUBWF 0xfdf, W, ACCESS
  47FE    E102     BNZ 0x4804
801:                               cdc_trf_state = CDC_TX_BUSY_ZLP;
  4800    0E02     MOVLW 0x2
802:                           else
  4802    D001     BRA 0x4806
803:                               cdc_trf_state = CDC_TX_COMPLETING;
  4804    0E03     MOVLW 0x3
  4806    6FE1     MOVWF 0xe1, BANKED
804:                       }//end if(cdc_tx_len...)
805:                       CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_tx,byte_to_send);
  4808    CFDF     MOVFF 0xfdf, 0xfe6
  480A    FFE6     NOP
  480C    0E99     MOVLW 0x99
  480E    6EE6     MOVWF 0xfe6, ACCESS
  4810    0E05     MOVLW 0x5
  4812    6EE6     MOVWF 0xfe6, ACCESS
  4814    0E01     MOVLW 0x1
  4816    6EE6     MOVWF 0xfe6, ACCESS
  4818    0E03     MOVLW 0x3
  481A    6EE6     MOVWF 0xfe6, ACCESS
  481C    ECA9     CALL 0x2152, 0
  481E    F010     NOP
  4820    6E14     MOVWF 0x14, ACCESS
  4822    0E05     MOVLW 0x5
  4824    5EE1     SUBWF 0xfe1, F, ACCESS
  4826    5014     MOVF 0x14, W, ACCESS
  4828    CFF3     MOVFF 0xff3, 0x5ec
  482A    F5EC     NOP
  482C    CFF4     MOVFF 0xff4, 0x5ed
  482E    F5ED     NOP
806:               
807:                   }//end if(cdc_tx_sate == CDC_TX_BUSY)
808:                   USBUnmaskInterrupts();
  4830    88A0     BSF 0xfa0, 0x4, ACCESS
809:               }//end CDCTxService
  4832    0E02     MOVLW 0x2
  4834    5CE1     SUBWF 0xfe1, W, ACCESS
  4836    E202     BC 0x483c
  4838    6AE1     CLRF 0xfe1, ACCESS
  483A    52E5     MOVF 0xfe5, F, ACCESS
  483C    6EE1     MOVWF 0xfe1, ACCESS
  483E    52E5     MOVF 0xfe5, F, ACCESS
  4840    CFE7     MOVFF 0xfe7, 0xfd9
  4842    FFD9     NOP
  4844    0012     RETURN 0
---  E:\Projects\DevPFG\Microchip\USB\MSD Device Driver\usb_function_msd.c  ----------------------
1:                 /*********************************************************************
2:                   File Information:
3:                     FileName:        usb_function_msd.c
4:                     Dependencies:    See INCLUDES section below
5:                     Processor:       PIC18, PIC24, or PIC32
6:                     Compiler:        C18, C30, or C32
7:                     Company:         Microchip Technology, Inc.
8:                 
9:                     Software License Agreement
10:                
11:                    The software supplied herewith by Microchip Technology Incorporated
12:                    (the "Company") for its PICmicror Microcontroller is intended and
13:                    supplied to you, the Company's customer, for use solely and
14:                    exclusively on Microchip PICmicro Microcontroller products. The
15:                    software is owned by the Company and/or its supplier, and is
16:                    protected under applicable copyright laws. All rights are reserved.
17:                    Any use in violation of the foregoing restrictions may subject the
18:                    user to criminal sanctions under applicable laws, as well as to
19:                    civil liability for the breach of the terms and conditions of this
20:                    license.
21:                
22:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
23:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
24:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
25:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
26:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
27:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
28:                
29:                  Summary:
30:                    This file contains functions, macros, definitions, variables,
31:                    datatypes, etc. that are required for use of the MSD function
32:                    driver. This file should be included in projects that use the MSD
33:                    \function driver.
34:                    
35:                    
36:                    
37:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\MSD
38:                    Device Driver" directory.
39:                
40:                  Description:
41:                    USB MSD Function Driver File
42:                    
43:                    This file contains functions, macros, definitions, variables,
44:                    datatypes, etc. that are required for use of the MSD function
45:                    driver. This file should be included in projects that use the MSD
46:                    \function driver.
47:                    
48:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\MSD
49:                    Device Driver" directory.
50:                    
51:                    When including this file in a new project, this file can either be
52:                    referenced from the directory in which it was installed or copied
53:                    directly into the user application folder. If the first method is
54:                    chosen to keep the file located in the folder in which it is installed
55:                    then include paths need to be added so that the library and the
56:                    application both know where to reference each others files. If the
57:                    application folder is located in the same folder as the Microchip
58:                    folder (like the current demo folders), then the following include
59:                    paths need to be added to the application's project:
60:                    
61:                    ..\\..\\Microchip\\Include
62:                    .
63:                    
64:                    If a different directory structure is used, modify the paths as
65:                    required. An example using absolute paths instead of relative paths
66:                    would be the following:
67:                    
68:                    C:\\Microchip Solutions\\Microchip\\Include
69:                    
70:                    C:\\Microchip Solutions\\My Demo Application
71:                
72:                Change History:
73:                  Rev         Description
74:                  ----------  ----------------------------------------------------------
75:                  2.6 - 2.7a  No change
76:                  2.7b		  Improved error case checking, error case recovery, and 
77:                			  sense key/status reporting to the host.
78:                  			  Implemented adjustable read/write failure retry feature.
79:                			  Fixed minor bug that would have interfered with supporting 
80:                			  more than 7 LUNs simultaneously.
81:                
82:                ********************************************************************/
83:                 
84:                /** I N C L U D E S **************************************************/
85:                #include "USB/USB.h"
86:                #include "HardwareProfile.h"
87:                #include "FSConfig.h"
88:                
89:                #include "./USB/usb_function_msd.h"
90:                
91:                #ifdef USB_USE_MSD
92:                
93:                #if MAX_LUN == 0
94:                    #define LUN_INDEX 0
95:                #else
96:                    #define LUN_INDEX gblCBW.bCBWLUN
97:                #endif
98:                
99:                #if defined(__C30__) || defined(__C32__)
100:                   #if defined(USE_INTERNAL_FLASH)
101:                       #include "MDD File System/Internal Flash.h"
102:                   #endif
103:               
104:                   #if defined(USE_SD_INTERFACE_WITH_SPI)
105:                       #include "MDD File System/SD-SPI.h"
106:                   #endif
107:               
108:                   extern LUN_FUNCTIONS LUN[MAX_LUN + 1];
109:                   #define LUNMediaInitialize()                LUN[LUN_INDEX].MediaInitialize()
110:                   #define LUNReadCapacity()                   LUN[LUN_INDEX].ReadCapacity()
111:                   #define LUNReadSectorSize()                 LUN[LUN_INDEX].ReadSectorSize()
112:                   #define LUNMediaDetect()                    LUN[LUN_INDEX].MediaDetect()
113:                   #define LUNSectorWrite(bLBA,pDest,Write0)   LUN[LUN_INDEX].SectorWrite(bLBA, pDest, Write0)
114:                   #define LUNWriteProtectState()              LUN[LUN_INDEX].WriteProtectState()
115:                   #define LUNSectorRead(bLBA,pSrc)            LUN[LUN_INDEX].SectorRead(bLBA, pSrc)
116:               #else
117:                   #if defined(USE_INTERNAL_FLASH)
118:                       #include "MDD File System/Internal Flash.h"
119:                   #endif
120:               
121:                   #if defined(USE_SD_INTERFACE_WITH_SPI)
122:                       #include "MDD File System/SD-SPI.h"
123:                   #endif
124:               
125:                   #define LUNMediaInitialize()                MDD_MediaInitialize()
126:                   #define LUNReadCapacity()                   MDD_ReadCapacity()
127:                   #define LUNReadSectorSize()                 MDD_ReadSectorSize()
128:                   #define LUNMediaDetect()                    MDD_MediaDetect()
129:                   #define LUNSectorWrite(bLBA,pDest,Write0)   MDD_SectorWrite(bLBA, pDest, Write0)
130:                   #define LUNWriteProtectState()              MDD_WriteProtectState()
131:                   #define LUNSectorRead(bLBA,pSrc)            MDD_SectorRead(bLBA, pSrc)
132:               #endif
133:               
134:               //Adjustable user options
135:               #define MSD_FAILED_READ_MAX_ATTEMPTS  (BYTE)100u    //Used for error case handling
136:               #define MSD_FAILED_WRITE_MAX_ATTEMPTS (BYTE)100u    //Used for error case handling
137:               
138:               /** V A R I A B L E S ************************************************/
139:               #pragma udata
140:               BYTE MSD_State;			// Takes values MSD_WAIT, MSD_DATA_IN or MSD_DATA_OUT
141:               BYTE MSDReadState;
142:               BYTE MSDWriteState;
143:               BYTE MSDRetryAttempt;
144:               USB_MSD_CBW gblCBW;	
145:               BYTE gblCBWLength;
146:               RequestSenseResponse gblSenseData[MAX_LUN + 1];
147:               BYTE *ptrNextData;
148:               USB_HANDLE USBMSDOutHandle;
149:               USB_HANDLE USBMSDInHandle;
150:               WORD MSBBufferIndex;
151:               WORD gblMediaPresent; 
152:               BOOL SoftDetach[MAX_LUN + 1];
153:               static BYTE MSDCommandState = MSD_COMMAND_WAIT;
154:               
155:               static WORD_VAL TransferLength;
156:               static DWORD_VAL LBA;
157:               
158:               /* 
159:                * Number of Blocks and Block Length are global because 
160:                * for every READ_10 and WRITE_10 command need to verify if the last LBA 
161:                * is less than gblNumBLKS	
162:                */	
163:               DWORD_VAL gblNumBLKS,gblBLKLen;	
164:               extern const ROM InquiryResponse inq_resp;
165:               
166:               /** P R I V A T E  P R O T O T Y P E S ***************************************/
167:               BYTE MSDProcessCommand(void);
168:               BYTE MSDReadHandler(void);
169:               BYTE MSDWriteHandler(void);
170:               void ResetSenseData(void);
171:               
172:               /** D E C L A R A T I O N S **************************************************/
173:               #pragma code
174:               
175:               /** C L A S S  S P E C I F I C  R E Q ****************************************/
176:               
177:               /******************************************************************************
178:                 Function:
179:                   void USBMSDInit(void)
180:                   
181:                 Summary:
182:                   This routine initializes the MSD class packet handles, prepares to
183:                   receive a MSD packet, and initializes the MSD state machine. This
184:                   \function should be called once after the device is enumerated.
185:               
186:                 Description:
187:                   This routine initializes the MSD class packet handles, prepares to
188:                   receive a MSD packet, and initializes the MSD state machine. This
189:                   \function should be called once after the device is enumerated.
190:                   
191:                   Typical Usage:
192:                   <code>
193:                   void USBCBInitEP(void)
194:                   {
195:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
196:                       USBMSDInit();
197:                   }
198:                   </code>
199:                 Conditions:
200:                   The device should already be enumerated with a configuration that
201:                   supports MSD before calling this function.
202:                   
203:                 Paramters: None
204:               
205:                 Remarks:
206:                   None                                                                                                          
207:                 ****************************************************************************/	
208:               void USBMSDInit(void)
209:               {
210:                   USBMSDInHandle = 0;
  2F52    0104     MOVLB 0x4
  2F54    6BB6     CLRF 0xb6, BANKED
  2F56    6BB7     CLRF 0xb7, BANKED
211:                   USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(BYTE*)&msd_cbw,MSD_OUT_EP_SIZE);
  2F58    0E40     MOVLW 0x40
  2F5A    6EE6     MOVWF 0xfe6, ACCESS
  2F5C    0E50     MOVLW 0x50
  2F5E    6EE6     MOVWF 0xfe6, ACCESS
  2F60    0E04     MOVLW 0x4
  2F62    6EE6     MOVWF 0xfe6, ACCESS
  2F64    6AE6     CLRF 0xfe6, ACCESS
  2F66    0E01     MOVLW 0x1
  2F68    6EE6     MOVWF 0xfe6, ACCESS
  2F6A    ECA9     CALL 0x2152, 0
  2F6C    F010     NOP
  2F6E    6E14     MOVWF 0x14, ACCESS
  2F70    0E05     MOVLW 0x5
  2F72    5EE1     SUBWF 0xfe1, F, ACCESS
  2F74    5014     MOVF 0x14, W, ACCESS
  2F76    CFF3     MOVFF 0xff3, 0x4b4
  2F78    F4B4     NOP
  2F7A    CFF4     MOVFF 0xff4, 0x4b5
  2F7C    F4B5     NOP
212:                   MSD_State = MSD_WAIT;
  2F7E    0104     MOVLB 0x4
  2F80    6B7C     CLRF 0x7c, BANKED
213:                   MSDCommandState = MSD_COMMAND_WAIT;
  2F82    0105     MOVLB 0x5
  2F84    69FE     SETF 0xfe, BANKED
214:                   MSDReadState = MSD_READ10_WAIT;
  2F86    0104     MOVLB 0x4
  2F88    6B7D     CLRF 0x7d, BANKED
215:                   MSDWriteState = MSD_WRITE10_WAIT;
  2F8A    6B7E     CLRF 0x7e, BANKED
216:                   gblNumBLKS.Val = 0;
  2F8C    6BC3     CLRF 0xc3, BANKED
  2F8E    6BC4     CLRF 0xc4, BANKED
  2F90    6BC5     CLRF 0xc5, BANKED
  2F92    6BC6     CLRF 0xc6, BANKED
217:                   gblBLKLen.Val = 0;
  2F94    6BC7     CLRF 0xc7, BANKED
  2F96    6BC8     CLRF 0xc8, BANKED
  2F98    6BC9     CLRF 0xc9, BANKED
  2F9A    6BCA     CLRF 0xca, BANKED
218:               
219:                   gblMediaPresent = 0;
  2F9C    6BBA     CLRF 0xba, BANKED
  2F9E    6BBB     CLRF 0xbb, BANKED
220:               
221:                   //For each of the possible logical units
222:                   for(gblCBW.bCBWLUN=0;gblCBW.bCBWLUN<(MAX_LUN + 1);gblCBW.bCBWLUN++)
  2FA0    6B8D     CLRF 0x8d, BANKED
  2FA2    0E01     MOVLW 0x1
  2FA4    5D8D     SUBWF 0x8d, W, BANKED
  2FA6    E222     BC 0x2fec
  2FE6    0104     MOVLB 0x4
  2FE8    2B8D     INCF 0x8d, F, BANKED
  2FEA    D7DB     BRA 0x2fa2
223:                   {
224:                       //clear all of the soft detach variables
225:                       SoftDetach[gblCBW.bCBWLUN] =  FALSE;
  2FA8    518D     MOVF 0x8d, W, BANKED
  2FAA    6AEA     CLRF 0xfea, ACCESS
  2FAC    0FBC     ADDLW 0xbc
  2FAE    6EE9     MOVWF 0xfe9, ACCESS
  2FB0    0E04     MOVLW 0x4
  2FB2    22EA     ADDWFC 0xfea, F, ACCESS
  2FB4    6AEF     CLRF 0xfef, ACCESS
226:               
227:                       //see if the media is attached
228:                       if(LUNMediaDetect())
  2FB6    EC23     CALL 0x4846, 0
  2FB8    F024     NOP
  2FBA    0900     IORLW 0
  2FBC    E012     BZ 0x2fe2
229:                       {
230:                           //initialize the media
231:                           if(LUNMediaInitialize())
  2FBE    EC2F     CALL 0x485e, 0
  2FC0    F024     NOP
  2FC2    CFF3     MOVFF 0xff3, 0x14
  2FC4    F014     NOP
  2FC6    CFF4     MOVFF 0xff4, 0x15
  2FC8    F015     NOP
  2FCA    50F3     MOVF 0xff3, W, ACCESS
  2FCC    10F4     IORWF 0xff4, W, ACCESS
  2FCE    E009     BZ 0x2fe2
232:                           {
233:                               //if the media was present and successfully initialized
234:                               //  then mark and indicator that the media is ready
235:                               gblMediaPresent |= ((WORD)1<<gblCBW.bCBWLUN);
  2FD0    0104     MOVLB 0x4
  2FD2    518D     MOVF 0x8d, W, BANKED
  2FD4    EC87     CALL 0x530e, 0
  2FD6    F029     NOP
  2FD8    50F3     MOVF 0xff3, W, ACCESS
  2FDA    0104     MOVLB 0x4
  2FDC    13BA     IORWF 0xba, F, BANKED
  2FDE    50F4     MOVF 0xff4, W, ACCESS
  2FE0    13BB     IORWF 0xbb, F, BANKED
236:                           }
237:                       }
238:                       ResetSenseData();
  2FE2    ECE3     CALL 0x39c6, 0
  2FE4    F01C     NOP
239:                   }
240:               }
  2FEC    0012     RETURN 0
241:               
242:               /******************************************************************************
243:                	Function:
244:                		void USBCheckMSDRequest(void)
245:               
246:                	Summary:
247:                		This routine handles MSD specific request that happen on EP0.  
248:                       This function should be called from the USBCBCheckOtherReq() call back 
249:                       function whenever implementing an MSD device.
250:               
251:                	Description:
252:                		This routine handles MSD specific request that happen on EP0.  These
253:                       include, but are not limited to, the standard RESET and GET_MAX_LUN 
254:                		command requests.  This function should be called from the 
255:                       USBCBCheckOtherReq() call back function whenever using an MSD device.	
256:               
257:                       Typical Usage:
258:                       <code>
259:                       void USBCBCheckOtherReq(void)
260:                       {
261:                           //Since the stack didn't handle the request I need to check
262:                           //  my class drivers to see if it is for them
263:                           USBCheckMSDRequest();
264:                       }
265:                       </code>
266:               
267:                	PreCondition:
268:                		None
269:                		
270:                	Parameters:
271:                		None
272:                	
273:                	Return Values:
274:                		None
275:                		
276:                	Remarks:
277:                		None
278:                
279:                *****************************************************************************/	
280:               void USBCheckMSDRequest(void)
281:               {
282:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
  2FEE    0104     MOVLB 0x4
  2FF0    5140     MOVF 0x40, W, BANKED
  2FF2    0B1F     ANDLW 0x1f
  2FF4    0801     SUBLW 0x1
  2FF6    E001     BZ 0x2ffa
  2FF8    0012     RETURN 0
283:                   if(SetupPkt.bIntfID != MSD_INTF_ID) return;
  2FFA    5144     MOVF 0x44, W, BANKED
  2FFC    E001     BZ 0x3000
  2FFE    0012     RETURN 0
284:               
285:               	switch(SetupPkt.bRequest)
  3000    5141     MOVF 0x41, W, BANKED
  3002    0AFE     XORLW 0xfe
  3004    E00B     BZ 0x301c
  3006    0A01     XORLW 0x1
  3008    E001     BZ 0x300c
  300A    0012     RETURN 0
286:                   {
287:               	    case MSD_RESET:
288:               	        //Host would typically issue this after a STALL event on an MSD
289:               	        //bulk endpoint.  The MSD reset should re-initialize status
290:               	        //so as to prepare for a new CBW.  Any currently ongoing command
291:               	        //block should be aborted, but the STALL and DTS states need to be
292:               	        //maintained (host will re-initialize these seperately using 
293:               	        //CLEAR_FEATURE, endpoint halt).
294:                           MSD_State = MSD_WAIT;
  300C    0104     MOVLB 0x4
  300E    6B7C     CLRF 0x7c, BANKED
295:                           MSDCommandState = MSD_COMMAND_WAIT;
  3010    0105     MOVLB 0x5
  3012    69FE     SETF 0xfe, BANKED
296:                           MSDReadState = MSD_READ10_WAIT;
  3014    0104     MOVLB 0x4
  3016    6B7D     CLRF 0x7d, BANKED
297:                           MSDWriteState = MSD_WRITE10_WAIT;
  3018    6B7E     CLRF 0x7e, BANKED
298:               	    	break;
  301A    0012     RETURN 0
299:               	    case GET_MAX_LUN:
300:                           //If the host asks for the maximum number of logical units
301:                           //  then send out a packet with that information
302:               	    	CtrlTrfData[0] = MAX_LUN;
  301C    0104     MOVLB 0x4
  301E    6B48     CLRF 0x48, BANKED
303:                           USBEP0SendRAMPtr((BYTE*)&CtrlTrfData[0],1,USB_EP0_INCLUDE_ZERO);
  3020    0100     MOVLB 0
  3022    0E48     MOVLW 0x48
  3024    6F79     MOVWF 0x79, BANKED
  3026    0E04     MOVLW 0x4
  3028    6F7A     MOVWF 0x7a, BANKED
  302A    0E01     MOVLW 0x1
  302C    6F7D     MOVWF 0x7d, BANKED
  302E    6B7E     CLRF 0x7e, BANKED
  3030    0EC1     MOVLW 0xc1
  3032    6F7C     MOVWF 0x7c, BANKED
304:               	    	break;
305:                   }	//end switch(SetupPkt.bRequest)
306:               }
  3034    0012     RETURN 0
307:               
308:               /*********************************************************************************
309:                 Function:
310:                       BYTE MSDTasks(void)
311:                   
312:                 Summary:
313:                   This function runs the MSD class state machines and all of its
314:                   sub-systems. This function should be called periodically once the
315:                   device is in the configured state in order to keep the MSD state
316:                   machine going.
317:                 Description:
318:                   This function runs the MSD class state machines and all of its
319:                   sub-systems. This function should be called periodically once the
320:                   device is in the configured state in order to keep the MSD state
321:                   machine going.
322:                   
323:                   Typical Usage:
324:                   <code>
325:                   void main(void)
326:                   {
327:                       USBDeviceInit();
328:                       while(1)
329:                       {
330:                           USBDeviceTasks();
331:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
332:                              (USBIsDeviceSuspended() == TRUE))
333:                           {
334:                               //Either the device is not configured or we are suspended
335:                               //  so we don't want to do execute any application code
336:                               continue;   //go back to the top of the while loop
337:                           }
338:                           else
339:                           {
340:                               //Keep the MSD state machine going
341:                               MSDTasks();
342:                   
343:                               //Run application code.
344:                               UserApplication();
345:                           }
346:                       }
347:                   }
348:                   </code>
349:                 Conditions:
350:                   None
351:                 Return Values:
352:                   BYTE -  the current state of the MSD state machine the valid values are
353:                           defined in MSD.h under the MSDTasks state machine declaration section.
354:                           The possible values are the following\:
355:                           * MSD_WAIT
356:                           * MSD_DATA_IN
357:                           * MSD_DATA_OUT
358:                           * MSD_SEND_CSW
359:                 Remarks:
360:                   None                                                                          
361:                 *********************************************************************************/	
362:               BYTE MSDTasks(void)
  3036    CFD9     MOVFF 0xfd9, 0xfe6
  3038    FFE6     NOP
  303A    CFE1     MOVFF 0xfe1, 0xfd9
  303C    FFD9     NOP
  303E    52E6     MOVF 0xfe6, F, ACCESS
363:               {
364:                   BYTE i;
365:                   
366:                   switch(MSD_State)
  3040    0104     MOVLB 0x4
  3042    517C     MOVF 0x7c, W, BANKED
  3044    0A03     XORLW 0x3
  3046    E101     BNZ 0x304a
  3048    D0B7     BRA 0x31b8
  304A    0A01     XORLW 0x1
  304C    E101     BNZ 0x3050
  304E    D0A3     BRA 0x3196
  3050    0A03     XORLW 0x3
  3052    E101     BNZ 0x3056
  3054    D09C     BRA 0x318e
  3056    0A01     XORLW 0x1
  3058    E001     BZ 0x305c
  305A    D0F6     BRA 0x3248
367:                   {
368:                       case MSD_WAIT:
369:                       {
370:                           //If the MSD state machine is waiting for something to happen
371:                           if(!USBHandleBusy(USBMSDOutHandle))
  305C    51B4     MOVF 0xb4, W, BANKED
  305E    11B5     IORWF 0xb5, W, BANKED
  3060    E102     BNZ 0x3066
  3062    0E00     MOVLW 0
  3064    D008     BRA 0x3076
  3066    C4B4     MOVFF 0x4b4, 0xfe9
  3068    FFE9     NOP
  306A    C4B5     MOVFF 0x4b5, 0xfea
  306C    FFEA     NOP
  306E    50EF     MOVF 0xfef, W, ACCESS
  3070    0B80     ANDLW 0x80
  3072    E001     BZ 0x3076
  3074    0E01     MOVLW 0x1
  3076    0900     IORLW 0
  3078    E001     BZ 0x307c
  307A    D0E7     BRA 0x324a
372:                           {
373:                       		//If we received an OUT packet from the host
374:                               //  then copy the data from the buffer to a global
375:                               //  buffer so that we can keep the information but
376:                               //  reuse the buffer
377:                       		gblCBW.dCBWSignature=msd_cbw.dCBWSignature;					
  307C    C450     MOVFF 0x450, 0x480
  307E    F480     NOP
  3080    C451     MOVFF 0x451, 0x481
  3082    F481     NOP
  3084    C452     MOVFF 0x452, 0x482
  3086    F482     NOP
  3088    C453     MOVFF 0x453, 0x483
  308A    F483     NOP
378:                       		gblCBW.dCBWTag=msd_cbw.dCBWTag;
  308C    C454     MOVFF 0x454, 0x484
  308E    F484     NOP
  3090    C455     MOVFF 0x455, 0x485
  3092    F485     NOP
  3094    C456     MOVFF 0x456, 0x486
  3096    F486     NOP
  3098    C457     MOVFF 0x457, 0x487
  309A    F487     NOP
379:                       		gblCBW.dCBWDataTransferLength=msd_cbw.dCBWDataTransferLength;
  309C    C458     MOVFF 0x458, 0x488
  309E    F488     NOP
  30A0    C459     MOVFF 0x459, 0x489
  30A2    F489     NOP
  30A4    C45A     MOVFF 0x45a, 0x48a
  30A6    F48A     NOP
  30A8    C45B     MOVFF 0x45b, 0x48b
  30AA    F48B     NOP
380:                           	gblCBW.bCBWFlags=msd_cbw.bCBWFlags;
  30AC    C45C     MOVFF 0x45c, 0x48c
  30AE    F48C     NOP
381:                           	gblCBW.bCBWLUN=msd_cbw.bCBWLUN;
  30B0    C45D     MOVFF 0x45d, 0x48d
  30B2    F48D     NOP
382:                       	    gblCBW.bCBWCBLength=msd_cbw.bCBWCBLength;		// 3 MSB are zero
  30B4    C45E     MOVFF 0x45e, 0x48e
  30B6    F48E     NOP
383:               
384:                           	for (i=0;i<msd_cbw.bCBWCBLength;i++)
  30B8    6ADF     CLRF 0xfdf, ACCESS
  30BA    0104     MOVLB 0x4
  30BC    515E     MOVF 0x5e, W, BANKED
  30BE    5CDF     SUBWF 0xfdf, W, ACCESS
  30C0    E213     BC 0x30e8
  30E4    2ADF     INCF 0xfdf, F, ACCESS
  30E6    D7E9     BRA 0x30ba
385:                           	{
386:                           		gblCBW.CBWCB[i]=msd_cbw.CBWCB[i];
  30C2    50DF     MOVF 0xfdf, W, ACCESS
  30C4    6AEA     CLRF 0xfea, ACCESS
  30C6    0F5F     ADDLW 0x5f
  30C8    6EE9     MOVWF 0xfe9, ACCESS
  30CA    0E04     MOVLW 0x4
  30CC    22EA     ADDWFC 0xfea, F, ACCESS
  30CE    50EF     MOVF 0xfef, W, ACCESS
  30D0    6EE6     MOVWF 0xfe6, ACCESS
  30D2    50DF     MOVF 0xfdf, W, ACCESS
  30D4    6AEA     CLRF 0xfea, ACCESS
  30D6    0F8F     ADDLW 0x8f
  30D8    6EE9     MOVWF 0xfe9, ACCESS
  30DA    0E04     MOVLW 0x4
  30DC    22EA     ADDWFC 0xfea, F, ACCESS
  30DE    52E5     MOVF 0xfe5, F, ACCESS
  30E0    50E7     MOVF 0xfe7, W, ACCESS
  30E2    6EEF     MOVWF 0xfef, ACCESS
387:                               }
388:                           		
389:                               gblCBWLength=USBHandleGetLength(USBMSDOutHandle);
  30E8    C4B4     MOVFF 0x4b4, 0xfe9
  30EA    FFE9     NOP
  30EC    C4B5     MOVFF 0x4b5, 0xfea
  30EE    FFEA     NOP
  30F0    52EE     MOVF 0xfee, F, ACCESS
  30F2    CFEF     MOVFF 0xfef, 0x49f
  30F4    F49F     NOP
390:               
391:                       	    //If this CBW is valid?
392:                       		if ((gblCBWLength==MSD_CBW_SIZE)&&(gblCBW.dCBWSignature==0x43425355)) 
  30F6    0E1F     MOVLW 0x1f
  30F8    0104     MOVLB 0x4
  30FA    5D9F     SUBWF 0x9f, W, BANKED
  30FC    E001     BZ 0x3100
  30FE    D0A5     BRA 0x324a
  3100    0E55     MOVLW 0x55
  3102    1980     XORWF 0x80, W, BANKED
  3104    E001     BZ 0x3108
  3106    D0A1     BRA 0x324a
  3108    0E53     MOVLW 0x53
  310A    1981     XORWF 0x81, W, BANKED
  310C    E001     BZ 0x3110
  310E    D09D     BRA 0x324a
  3110    0E42     MOVLW 0x42
  3112    1982     XORWF 0x82, W, BANKED
  3114    E001     BZ 0x3118
  3116    D099     BRA 0x324a
  3118    0E43     MOVLW 0x43
  311A    1983     XORWF 0x83, W, BANKED
  311C    E001     BZ 0x3120
  311E    D095     BRA 0x324a
393:                           	{
394:                                   //Is this CBW meaningful?	
395:                      				if((gblCBW.bCBWLUN<=0x0f)
  3120    518D     MOVF 0x8d, W, BANKED
  3122    080F     SUBLW 0xf
396:                              		&&(gblCBW.bCBWCBLength<=0x10)
  3128    518E     MOVF 0x8e, W, BANKED
  312A    0810     SUBLW 0x10
397:                              		&&(gblCBW.bCBWCBLength>=0x01)
  3124    E201     BC 0x3128
  3126    D091     BRA 0x324a
  312C    E201     BC 0x3130
  312E    D08D     BRA 0x324a
  3130    0E01     MOVLW 0x1
  3132    5D8E     SUBWF 0x8e, W, BANKED
398:                              		&&(gblCBW.bCBWFlags==0x00||gblCBW.bCBWFlags==0x80)) 
  3134    E201     BC 0x3138
  3136    D089     BRA 0x324a
  3138    518C     MOVF 0x8c, W, BANKED
  313A    E004     BZ 0x3144
  313C    0E80     MOVLW 0x80
  313E    5D8C     SUBWF 0x8c, W, BANKED
  3140    E001     BZ 0x3144
  3142    D083     BRA 0x324a
399:                           		{
400:                               		//Prepare the CSW to be sent
401:                                   	msd_csw.dCSWTag=gblCBW.dCBWTag;
  3144    C484     MOVFF 0x484, 0x473
  3146    F473     NOP
  3148    C485     MOVFF 0x485, 0x474
  314A    F474     NOP
  314C    C486     MOVFF 0x486, 0x475
  314E    F475     NOP
  3150    C487     MOVFF 0x487, 0x476
  3152    F476     NOP
402:                                   	msd_csw.dCSWSignature=0x53425355;
  3154    0104     MOVLB 0x4
  3156    0E55     MOVLW 0x55
  3158    6F6F     MOVWF 0x6f, BANKED
  315A    0E53     MOVLW 0x53
  315C    6F70     MOVWF 0x70, BANKED
  315E    0E42     MOVLW 0x42
  3160    6F71     MOVWF 0x71, BANKED
  3162    0E53     MOVLW 0x53
  3164    6F72     MOVWF 0x72, BANKED
403:                                   	
404:                                   	//Keep track of retry attempts, in case of temporary failures
405:                                   	//during processing of a command.
406:                                   	MSDRetryAttempt = 0;
  3166    0104     MOVLB 0x4
  3168    6B7F     CLRF 0x7f, BANKED
407:                                   	
408:                                   	//Check the command.  With the exception of the REQUEST_SENSE
409:                                   	//command, we should reset the sense key info for each new command block.
410:                                   	//Assume the command will get processed successfully (and hence "NO SENSE" 
411:                                   	//response, which is used for success cases), unless handler code
412:                                   	//later on detects some kind of error.  If it does, it should
413:                                   	//update the sense keys to reflect the type of error detected,
414:                                   	//prior to sending the CSW.
415:                                   	if(gblCBW.CBWCB[0] != MSD_REQUEST_SENSE)
  316A    0E03     MOVLW 0x3
  316C    5D8F     SUBWF 0x8f, W, BANKED
  316E    E006     BZ 0x317c
416:                                   	{
417:                                     		gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
  3170    91A2     BCF 0xa2, 0, BANKED
  3172    93A2     BCF 0xa2, 0x1, BANKED
  3174    95A2     BCF 0xa2, 0x2, BANKED
  3176    97A2     BCF 0xa2, 0x3, BANKED
418:                       			        gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
  3178    6BAC     CLRF 0xac, BANKED
419:                       			        gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
  317A    6BAD     CLRF 0xad, BANKED
420:                   			        }
421:                                   	
422:                       				/* If direction is device to host*/
423:                       				if (gblCBW.bCBWFlags==0x80)
  317C    0E80     MOVLW 0x80
  317E    5D8C     SUBWF 0x8c, W, BANKED
  3180    E102     BNZ 0x3186
424:                       				{
425:                       					MSD_State=MSD_DATA_IN;
  3182    0E01     MOVLW 0x1
426:                       				}
427:                       				else if (gblCBW.bCBWFlags==0x00) 
  3184    D017     BRA 0x31b4
  3186    518C     MOVF 0x8c, W, BANKED
  3188    E160     BNZ 0x324a
428:                           			{
429:                       					/* If direction is host to device*/
430:                       					/* prepare to read data in msd_buffer */
431:                           			    MSD_State=MSD_DATA_OUT;
  318A    0E02     MOVLW 0x2
432:                       				}        								
433:                       			}
434:                       		}
435:                           }
436:                           break;
  318C    D013     BRA 0x31b4
437:                       }
438:                       case MSD_DATA_IN:
439:                           if(MSDProcessCommand() == MSD_COMMAND_WAIT)
  318E    DA1D     RCALL 0x35ca
  3190    08FF     SUBLW 0xff
  3192    E15B     BNZ 0x324a
440:                           {
441:                               // Done processing the command, send the status
442:                               MSD_State = MSD_SEND_CSW;
443:                           }
444:                           break;
  3194    D00D     BRA 0x31b0
445:                       case MSD_DATA_OUT:
446:                           if(MSDProcessCommand() == MSD_COMMAND_WAIT)
  3196    DA19     RCALL 0x35ca
  3198    08FF     SUBLW 0xff
  319A    E157     BNZ 0x324a
447:                           {
448:                   			/* Finished receiving the data prepare and send the status */
449:                   		  	if ((msd_csw.bCSWStatus==0x00)&&(msd_csw.dCSWDataResidue!=0)) 
  319C    0104     MOVLB 0x4
  319E    517B     MOVF 0x7b, W, BANKED
  31A0    E107     BNZ 0x31b0
  31A2    5177     MOVF 0x77, W, BANKED
  31A4    1178     IORWF 0x78, W, BANKED
  31A6    1179     IORWF 0x79, W, BANKED
  31A8    117A     IORWF 0x7a, W, BANKED
  31AA    E002     BZ 0x31b0
450:                   		  	{
451:                   		  		msd_csw.bCSWStatus=0x02;
  31AC    0E02     MOVLW 0x2
  31AE    6F7B     MOVWF 0x7b, BANKED
452:                   		    }
453:                               MSD_State = MSD_SEND_CSW;
  31B0    0104     MOVLB 0x4
  31B2    0E03     MOVLW 0x3
  31B4    6F7C     MOVWF 0x7c, BANKED
454:                           }
455:                           break;
  31B6    D049     BRA 0x324a
456:                       case MSD_SEND_CSW:
457:                           if(USBHandleBusy(USBMSDInHandle))
  31B8    51B6     MOVF 0xb6, W, BANKED
  31BA    11B7     IORWF 0xb7, W, BANKED
  31BC    E102     BNZ 0x31c2
  31BE    0E00     MOVLW 0
  31C0    D008     BRA 0x31d2
  31C2    C4B6     MOVFF 0x4b6, 0xfe9
  31C4    FFE9     NOP
  31C6    C4B7     MOVFF 0x4b7, 0xfea
  31C8    FFEA     NOP
  31CA    50EF     MOVF 0xfef, W, ACCESS
  31CC    0B80     ANDLW 0x80
  31CE    E001     BZ 0x31d2
  31D0    0E01     MOVLW 0x1
  31D2    0900     IORLW 0
  31D4    E13A     BNZ 0x324a
458:                           {
459:                               //The TX buffer is not ready to send the status yet.
460:                               break;
461:                           }
462:                           
463:                           USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(BYTE*)&msd_csw,MSD_CSW_SIZE);
  31D6    0E0D     MOVLW 0xd
  31D8    6EE6     MOVWF 0xfe6, ACCESS
  31DA    0E6F     MOVLW 0x6f
  31DC    6EE6     MOVWF 0xfe6, ACCESS
  31DE    0E04     MOVLW 0x4
  31E0    6EE6     MOVWF 0xfe6, ACCESS
  31E2    0E01     MOVLW 0x1
  31E4    6EE6     MOVWF 0xfe6, ACCESS
  31E6    6EE6     MOVWF 0xfe6, ACCESS
  31E8    ECA9     CALL 0x2152, 0
  31EA    F010     NOP
  31EC    6E14     MOVWF 0x14, ACCESS
  31EE    0E05     MOVLW 0x5
  31F0    5EE1     SUBWF 0xfe1, F, ACCESS
  31F2    5014     MOVF 0x14, W, ACCESS
  31F4    CFF3     MOVFF 0xff3, 0x4b6
  31F6    F4B6     NOP
  31F8    CFF4     MOVFF 0xff4, 0x4b7
  31FA    F4B7     NOP
464:                           
465:                           //Get ready for next command to come in
466:                           if(!USBHandleBusy(USBMSDOutHandle))
  31FC    0104     MOVLB 0x4
  31FE    51B4     MOVF 0xb4, W, BANKED
  3200    11B5     IORWF 0xb5, W, BANKED
  3202    E102     BNZ 0x3208
  3204    0E00     MOVLW 0
  3206    D008     BRA 0x3218
  3208    C4B4     MOVFF 0x4b4, 0xfe9
  320A    FFE9     NOP
  320C    C4B5     MOVFF 0x4b5, 0xfea
  320E    FFEA     NOP
  3210    50EF     MOVF 0xfef, W, ACCESS
  3212    0B80     ANDLW 0x80
  3214    E001     BZ 0x3218
  3216    0E01     MOVLW 0x1
  3218    0900     IORLW 0
  321A    E113     BNZ 0x3242
467:                           {
468:                               USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(BYTE*)&msd_cbw,sizeof(msd_cbw));
  321C    0E1F     MOVLW 0x1f
  321E    6EE6     MOVWF 0xfe6, ACCESS
  3220    0E50     MOVLW 0x50
  3222    6EE6     MOVWF 0xfe6, ACCESS
  3224    0E04     MOVLW 0x4
  3226    6EE6     MOVWF 0xfe6, ACCESS
  3228    6AE6     CLRF 0xfe6, ACCESS
  322A    0E01     MOVLW 0x1
  322C    6EE6     MOVWF 0xfe6, ACCESS
  322E    ECA9     CALL 0x2152, 0
  3230    F010     NOP
  3232    6E14     MOVWF 0x14, ACCESS
  3234    0E05     MOVLW 0x5
  3236    5EE1     SUBWF 0xfe1, F, ACCESS
  3238    5014     MOVF 0x14, W, ACCESS
  323A    CFF3     MOVFF 0xff3, 0x4b4
  323C    F4B4     NOP
  323E    CFF4     MOVFF 0xff4, 0x4b5
  3240    F4B5     NOP
469:                           }
470:                       
471:                          	MSD_State=MSD_WAIT;
  3242    0104     MOVLB 0x4
  3244    6B7C     CLRF 0x7c, BANKED
472:                           break;
  3246    D001     BRA 0x324a
473:                           
474:                       default:
475:                           //Illegal condition that should not happen, but might occur if the
476:                           //device firmware incorrectly calls MSDTasks() prior to calling
477:                           //USBMSDInit() during the set-configuration portion of enumeration.
478:                           MSD_State=MSD_WAIT;
  3248    6B7C     CLRF 0x7c, BANKED
479:                   }
480:                   
481:                   return MSD_State;
  324A    0104     MOVLB 0x4
  324C    517C     MOVF 0x7c, W, BANKED
482:               }
  324E    52E5     MOVF 0xfe5, F, ACCESS
  3250    52E5     MOVF 0xfe5, F, ACCESS
  3252    CFE7     MOVFF 0xfe7, 0xfd9
  3254    FFD9     NOP
  3256    0012     RETURN 0
483:               
484:               /******************************************************************************
485:                	Function:
486:                		void MSDProcessCommandMediaPresent(void)
487:                		
488:                	Description:
489:                		This funtion processes a command received through the MSD
490:                		class driver
491:                		
492:                	PreCondition:
493:                		None
494:                		
495:                	Paramters:
496:                		None
497:                	
498:                	Return Values:
499:                		BYTE - the current state of the MSDProcessCommand state
500:                		machine.  The valid values are defined in MSD.h under the 
501:                		MSDProcessCommand state machine declaration section
502:                		
503:                	Remarks:
504:                		None
505:                
506:                *****************************************************************************/	
507:               void MSDProcessCommandMediaPresent(void)
  3258    CFD9     MOVFF 0xfd9, 0xfe6
  325A    FFE6     NOP
  325C    CFE1     MOVFF 0xfe1, 0xfd9
  325E    FFD9     NOP
  3260    0E09     MOVLW 0x9
  3262    26E1     ADDWF 0xfe1, F, ACCESS
508:               {
509:                   BYTE i; 
510:               
511:                   switch(MSDCommandState)
  3264    0105     MOVLB 0x5
  3266    51FE     MOVF 0xfe, W, BANKED
  3268    0AFE     XORLW 0xfe
  326A    E101     BNZ 0x326e
  326C    D0F7     BRA 0x345c
  326E    0A03     XORLW 0x3
  3270    E101     BNZ 0x3274
  3272    D0C9     BRA 0x3406
  3274    0AD2     XORLW 0xd2
  3276    E101     BNZ 0x327a
  3278    D0BD     BRA 0x33f4
  327A    0A34     XORLW 0x34
  327C    E101     BNZ 0x3280
  327E    D0BA     BRA 0x33f4
  3280    0A1B     XORLW 0x1b
  3282    E101     BNZ 0x3286
  3284    D0AC     BRA 0x33de
  3286    0A1E     XORLW 0x1e
  3288    E101     BNZ 0x328c
  328A    D099     BRA 0x33be
  328C    0A04     XORLW 0x4
  328E    E101     BNZ 0x3292
  3290    D08B     BRA 0x33a8
  3292    0A19     XORLW 0x19
  3294    E065     BZ 0x3360
  3296    0A29     XORLW 0x29
  3298    E05E     BZ 0x3356
  329A    0A02     XORLW 0x2
  329C    E057     BZ 0x334c
  329E    0A0D     XORLW 0xd
  32A0    E01E     BZ 0x32de
  32A2    0A37     XORLW 0x37
  32A4    E006     BZ 0x32b2
  32A6    0AED     XORLW 0xed
  32A8    E001     BZ 0x32ac
  32AA    D0D8     BRA 0x345c
512:                   {
513:                       case MSD_COMMAND_WAIT:
514:                           //copy the received command to the command state machine
515:                           MSDCommandState = gblCBW.CBWCB[0];
  32AC    C48F     MOVFF 0x48f, 0x5fe
  32AE    F5FE     NOP
516:                           break;
  32B0    D0E8     BRA 0x3482
517:                   	case MSD_INQUIRY:
518:                   	{
519:                           //copy the inquiry results from the defined ROM buffer 
520:                           //  into the USB buffer so that it can be transmitted
521:                       	memcpypgm2ram(
522:                       	    (void *)&msd_buffer[0],
  32C4    0E00     MOVLW 0
  32C6    6EE6     MOVWF 0xfe6, ACCESS
  32C8    0E06     MOVLW 0x6
  32CA    6EE6     MOVWF 0xfe6, ACCESS
523:                       	    (ROM void*)&inq_resp,
  32B8    0E92     MOVLW 0x92
  32BA    6EE6     MOVWF 0xfe6, ACCESS
  32BC    0E52     MOVLW 0x52
  32BE    6EE6     MOVWF 0xfe6, ACCESS
  32C0    0E00     MOVLW 0
  32C2    6EE6     MOVWF 0xfe6, ACCESS
524:                       	    sizeof(InquiryResponse)
  32B2    0E24     MOVLW 0x24
525:                       	    );
  32B4    6EE6     MOVWF 0xfe6, ACCESS
  32B6    6AE6     CLRF 0xfe6, ACCESS
  32CC    EC7B     CALL 0x4cf6, 0
  32CE    F026     NOP
  32D0    6E14     MOVWF 0x14, ACCESS
  32D2    0E07     MOVLW 0x7
  32D4    5EE1     SUBWF 0xfe1, F, ACCESS
  32D6    5014     MOVF 0x14, W, ACCESS
526:                       	msd_csw.dCSWDataResidue=sizeof(InquiryResponse);
  32D8    0104     MOVLB 0x4
  32DA    0E24     MOVLW 0x24
527:                       	msd_csw.bCSWStatus=0x00;			// success
528:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
529:                           break;
  32DC    D05F     BRA 0x339c
530:                       }
531:                       case MSD_READ_CAPACITY:
532:                       {
533:                           //If the host asked for the capacity of the device
534:                           DWORD_VAL sectorSize;
535:                           DWORD_VAL capacity;
536:               
537:                       	msd_csw.bCSWStatus=0x00;			  // success
  32DE    0104     MOVLB 0x4
  32E0    6B7B     CLRF 0x7b, BANKED
538:                           
539:                           //get the information from the physical media
540:                           capacity.Val = LUNReadCapacity();
  32E2    EC28     CALL 0x4850, 0
  32E4    F024     NOP
  32E6    0E05     MOVLW 0x5
  32E8    C006     MOVFF 0x6, 0xfdb
  32EA    FFDB     NOP
  32EC    0E06     MOVLW 0x6
  32EE    C007     MOVFF 0x7, 0xfdb
  32F0    FFDB     NOP
  32F2    0E07     MOVLW 0x7
  32F4    C008     MOVFF 0x8, 0xfdb
  32F6    FFDB     NOP
  32F8    0E08     MOVLW 0x8
  32FA    C009     MOVFF 0x9, 0xfdb
  32FC    FFDB     NOP
541:                           sectorSize.Val = LUNReadSectorSize();
  32FE    EC24     CALL 0x4848, 0
  3300    F024     NOP
  3302    0E01     MOVLW 0x1
  3304    CFF3     MOVFF 0xff3, 0xfdb
  3306    FFDB     NOP
  3308    0E02     MOVLW 0x2
  330A    CFF4     MOVFF 0xff4, 0xfdb
  330C    FFDB     NOP
  330E    0E03     MOVLW 0x3
  3310    6ADB     CLRF 0xfdb, ACCESS
  3312    0E04     MOVLW 0x4
  3314    6ADB     CLRF 0xfdb, ACCESS
542:                           
543:                           //copy the data to the buffer
544:                       	msd_buffer[0]=capacity.v[3];
  3316    0E08     MOVLW 0x8
  3318    CFDB     MOVFF 0xfdb, 0x600
  331A    F600     NOP
545:                       	msd_buffer[1]=capacity.v[2];
  331C    0E07     MOVLW 0x7
  331E    CFDB     MOVFF 0xfdb, 0x601
  3320    F601     NOP
546:                       	msd_buffer[2]=capacity.v[1];
  3322    0E06     MOVLW 0x6
  3324    CFDB     MOVFF 0xfdb, 0x602
  3326    F602     NOP
547:                       	msd_buffer[3]=capacity.v[0];
  3328    0E05     MOVLW 0x5
  332A    CFDB     MOVFF 0xfdb, 0x603
  332C    F603     NOP
548:                       	
549:                       	msd_buffer[4]=sectorSize.v[3];
  332E    0E04     MOVLW 0x4
  3330    CFDB     MOVFF 0xfdb, 0x604
  3332    F604     NOP
550:                       	msd_buffer[5]=sectorSize.v[2];
  3334    0E03     MOVLW 0x3
  3336    CFDB     MOVFF 0xfdb, 0x605
  3338    F605     NOP
551:                       	msd_buffer[6]=sectorSize.v[1];
  333A    0E02     MOVLW 0x2
  333C    CFDB     MOVFF 0xfdb, 0x606
  333E    F606     NOP
552:                       	msd_buffer[7]=sectorSize.v[0];
  3340    0E01     MOVLW 0x1
  3342    CFDB     MOVFF 0xfdb, 0x607
  3344    F607     NOP
553:                       
554:                       	msd_csw.dCSWDataResidue=0x08;		  // size of response
  3346    0104     MOVLB 0x4
  3348    0E08     MOVLW 0x8
555:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
556:                           break;
  334A    D037     BRA 0x33ba
557:                       }
558:               		case MSD_READ_10:
559:                       	if(MSDReadHandler() == MSD_READ10_WAIT)
  334C    D98B     RCALL 0x3664
  334E    0900     IORLW 0
  3350    E001     BZ 0x3354
  3352    D097     BRA 0x3482
560:                       	{
561:               			    MSDCommandState = MSD_COMMAND_WAIT;
562:                           }
563:                           break;
  3354    D055     BRA 0x3400
564:                   	case MSD_WRITE_10:
565:                       	if(MSDWriteHandler() == MSD_WRITE10_WAIT)
  3356    DA45     RCALL 0x37e2
  3358    0900     IORLW 0
  335A    E001     BZ 0x335e
  335C    D092     BRA 0x3482
566:                       	{
567:               			    MSDCommandState = MSD_COMMAND_WAIT;
568:                           }
569:               		    break;
  335E    D050     BRA 0x3400
570:                       case MSD_REQUEST_SENSE:    
571:                         	for(i=0;i<sizeof(RequestSenseResponse);i++)
  3360    6ADF     CLRF 0xfdf, ACCESS
  3362    50DF     MOVF 0xfdf, W, ACCESS
  3364    6E14     MOVWF 0x14, ACCESS
  3366    6A15     CLRF 0x15, ACCESS
  3368    0E12     MOVLW 0x12
  336A    5C14     SUBWF 0x14, W, ACCESS
  336C    0E00     MOVLW 0
  336E    5815     SUBWFB 0x15, W, ACCESS
  3370    E213     BC 0x3398
  3394    2ADF     INCF 0xfdf, F, ACCESS
  3396    D7E5     BRA 0x3362
572:                         	{
573:                         		msd_buffer[i]=gblSenseData[LUN_INDEX]._byte[i];
  3372    50DF     MOVF 0xfdf, W, ACCESS
  3374    6AEA     CLRF 0xfea, ACCESS
  3376    0FA0     ADDLW 0xa0
  3378    6EE9     MOVWF 0xfe9, ACCESS
  337A    0E04     MOVLW 0x4
  337C    22EA     ADDWFC 0xfea, F, ACCESS
  337E    50EF     MOVF 0xfef, W, ACCESS
  3380    6EE6     MOVWF 0xfe6, ACCESS
  3382    50DF     MOVF 0xfdf, W, ACCESS
  3384    6AEA     CLRF 0xfea, ACCESS
  3386    0F00     ADDLW 0
  3388    6EE9     MOVWF 0xfe9, ACCESS
  338A    0E06     MOVLW 0x6
  338C    22EA     ADDWFC 0xfea, F, ACCESS
  338E    52E5     MOVF 0xfe5, F, ACCESS
  3390    50E7     MOVF 0xfe7, W, ACCESS
  3392    6EEF     MOVWF 0xfef, ACCESS
574:                           }
575:                         	
576:                           msd_csw.dCSWDataResidue=sizeof(RequestSenseResponse);
  3398    0104     MOVLB 0x4
  339A    0E12     MOVLW 0x12
  339C    6F77     MOVWF 0x77, BANKED
  339E    6B78     CLRF 0x78, BANKED
  33A0    6B79     CLRF 0x79, BANKED
  33A2    6B7A     CLRF 0x7a, BANKED
577:                         	msd_csw.bCSWStatus=0x0;					// success
  33A4    6B7B     CLRF 0x7b, BANKED
578:                         	MSDCommandState = MSD_COMMAND_RESPONSE;
579:                           break;
  33A6    D06A     BRA 0x347c
580:               	    case MSD_MODE_SENSE:
581:                       	msd_buffer[0]=0x02;
  33A8    0106     MOVLB 0x6
  33AA    0E02     MOVLW 0x2
  33AC    6F00     MOVWF 0, BANKED
582:                       	msd_buffer[1]=0x00;
  33AE    6B01     CLRF 0x1, BANKED
583:                       	msd_buffer[2]=0x00;
  33B0    6B02     CLRF 0x2, BANKED
584:                       	msd_buffer[3]=0x00;
  33B2    6B03     CLRF 0x3, BANKED
585:                       	
586:                       	msd_csw.bCSWStatus=0x0;
  33B4    0104     MOVLB 0x4
  33B6    6B7B     CLRF 0x7b, BANKED
587:                       	msd_csw.dCSWDataResidue=0x04;
  33B8    0E04     MOVLW 0x4
  33BA    6F77     MOVWF 0x77, BANKED
588:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
589:                   	    break;
  33BC    D05C     BRA 0x3476
590:               		case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
591:                           if(LUNMediaDetect())
  33BE    EC23     CALL 0x4846, 0
  33C0    F024     NOP
  33C2    0900     IORLW 0
  33C4    E117     BNZ 0x33f4
592:                           {
593:                       		msd_csw.bCSWStatus=0x00;
594:                       		msd_csw.dCSWDataResidue=0x00;
595:                       	}
596:                           else
597:                           {
598:                       		gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
  33C6    0104     MOVLB 0x4
  33C8    91A2     BCF 0xa2, 0, BANKED
  33CA    83A2     BSF 0xa2, 0x1, BANKED
  33CC    95A2     BCF 0xa2, 0x2, BANKED
  33CE    97A2     BCF 0xa2, 0x3, BANKED
599:                       		gblSenseData[LUN_INDEX].ASC=ASC_MEDIUM_NOT_PRESENT;
  33D0    0E3A     MOVLW 0x3a
  33D2    6FAC     MOVWF 0xac, BANKED
600:                       		gblSenseData[LUN_INDEX].ASCQ=ASCQ_MEDIUM_NOT_PRESENT;
  33D4    6BAD     CLRF 0xad, BANKED
601:                       		msd_csw.bCSWStatus=0x01;
  33D6    0104     MOVLB 0x4
  33D8    0E01     MOVLW 0x1
  33DA    6F7B     MOVWF 0x7b, BANKED
602:                       	}
603:               			MSDCommandState = MSD_COMMAND_WAIT;
604:                           break;
  33DC    D011     BRA 0x3400
605:               		case MSD_TEST_UNIT_READY:
606:                           if((gblSenseData[LUN_INDEX].SenseKey==S_UNIT_ATTENTION) && (msd_csw.bCSWStatus==1))
  33DE    0104     MOVLB 0x4
  33E0    51A2     MOVF 0xa2, W, BANKED
  33E2    0B0F     ANDLW 0xf
  33E4    0806     SUBLW 0x6
  33E6    E103     BNZ 0x33ee
  33E8    0104     MOVLB 0x4
  33EA    057B     DECF 0x7b, W, BANKED
  33EC    E009     BZ 0x3400
607:                           {
608:                               MSDCommandState = MSD_COMMAND_WAIT;
609:                           }
610:                           else
611:                           {
612:                           	ResetSenseData();
  33EE    DAEB     RCALL 0x39c6
613:                           	msd_csw.dCSWDataResidue=0x00;
  33F0    0104     MOVLB 0x4
614:                   			MSDCommandState = MSD_COMMAND_WAIT;
615:                           }
616:                           break;
  33F2    D002     BRA 0x33f8
617:               		case MSD_VERIFY:
618:                           //Fall through to STOP_START
619:               		case MSD_STOP_START:
620:                       	msd_csw.bCSWStatus=0x0;
  33F4    0104     MOVLB 0x4
  33F6    6B7B     CLRF 0x7b, BANKED
621:                       	msd_csw.dCSWDataResidue=0x00;
  33F8    6B77     CLRF 0x77, BANKED
  33FA    6B78     CLRF 0x78, BANKED
  33FC    6B79     CLRF 0x79, BANKED
  33FE    6B7A     CLRF 0x7a, BANKED
622:               			MSDCommandState = MSD_COMMAND_WAIT;
  3400    0105     MOVLB 0x5
  3402    69FE     SETF 0xfe, BANKED
623:                           break;
  3404    D03E     BRA 0x3482
624:                       case MSD_COMMAND_RESPONSE:
625:                           if(USBHandleBusy(USBMSDInHandle) == FALSE)
  3406    0104     MOVLB 0x4
  3408    51B6     MOVF 0xb6, W, BANKED
  340A    11B7     IORWF 0xb7, W, BANKED
  340C    E102     BNZ 0x3412
  340E    0E00     MOVLW 0
  3410    D008     BRA 0x3422
  3412    C4B6     MOVFF 0x4b6, 0xfe9
  3414    FFE9     NOP
  3416    C4B7     MOVFF 0x4b7, 0xfea
  3418    FFEA     NOP
  341A    50EF     MOVF 0xfef, W, ACCESS
  341C    0B80     ANDLW 0x80
  341E    E001     BZ 0x3422
  3420    0E01     MOVLW 0x1
  3422    0900     IORLW 0
  3424    E12E     BNZ 0x3482
626:                           {
627:                               USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(BYTE*)&msd_buffer[0],msd_csw.dCSWDataResidue);
  3426    C477     MOVFF 0x477, 0xfe6
  3428    FFE6     NOP
  342A    0E00     MOVLW 0
  342C    6EE6     MOVWF 0xfe6, ACCESS
  342E    0E06     MOVLW 0x6
  3430    6EE6     MOVWF 0xfe6, ACCESS
  3432    0E01     MOVLW 0x1
  3434    6EE6     MOVWF 0xfe6, ACCESS
  3436    6EE6     MOVWF 0xfe6, ACCESS
  3438    ECA9     CALL 0x2152, 0
  343A    F010     NOP
  343C    6E14     MOVWF 0x14, ACCESS
  343E    0E05     MOVLW 0x5
  3440    5EE1     SUBWF 0xfe1, F, ACCESS
  3442    5014     MOVF 0x14, W, ACCESS
  3444    CFF3     MOVFF 0xff3, 0x4b6
  3446    F4B6     NOP
  3448    CFF4     MOVFF 0xff4, 0x4b7
  344A    F4B7     NOP
628:               			    MSDCommandState = MSD_COMMAND_WAIT;
  344C    0105     MOVLB 0x5
  344E    69FE     SETF 0xfe, BANKED
629:               
630:                       		msd_csw.dCSWDataResidue=0;
  3450    0104     MOVLB 0x4
  3452    6B77     CLRF 0x77, BANKED
  3454    6B78     CLRF 0x78, BANKED
  3456    6B79     CLRF 0x79, BANKED
  3458    6B7A     CLRF 0x7a, BANKED
631:                           }
632:                           break;
  345A    D013     BRA 0x3482
633:                       case MSD_COMMAND_ERROR:
634:               		default:
635:                       	ResetSenseData();
  345C    DAB4     RCALL 0x39c6
636:               			gblSenseData[LUN_INDEX].SenseKey=S_ILLEGAL_REQUEST;
  345E    0104     MOVLB 0x4
  3460    81A2     BSF 0xa2, 0, BANKED
  3462    93A2     BCF 0xa2, 0x1, BANKED
  3464    85A2     BSF 0xa2, 0x2, BANKED
  3466    97A2     BCF 0xa2, 0x3, BANKED
637:               			gblSenseData[LUN_INDEX].ASC=ASC_INVALID_COMMAND_OPCODE;
  3468    0E20     MOVLW 0x20
  346A    6FAC     MOVWF 0xac, BANKED
638:               			gblSenseData[LUN_INDEX].ASCQ=ASCQ_INVALID_COMMAND_OPCODE;
  346C    6BAD     CLRF 0xad, BANKED
639:               			msd_csw.bCSWStatus=0x01;
  346E    0104     MOVLB 0x4
  3470    0E01     MOVLW 0x1
  3472    6F7B     MOVWF 0x7b, BANKED
640:               			msd_csw.dCSWDataResidue=0x00;
  3474    6B77     CLRF 0x77, BANKED
  3476    6B78     CLRF 0x78, BANKED
  3478    6B79     CLRF 0x79, BANKED
  347A    6B7A     CLRF 0x7a, BANKED
641:               			MSDCommandState = MSD_COMMAND_RESPONSE;
  347C    0105     MOVLB 0x5
  347E    0EFD     MOVLW 0xfd
  3480    6FFE     MOVWF 0xfe, BANKED
642:                		    break;
643:               	} // end switch	
644:               }
  3482    0E09     MOVLW 0x9
  3484    5CE1     SUBWF 0xfe1, W, ACCESS
  3486    E202     BC 0x348c
  3488    6AE1     CLRF 0xfe1, ACCESS
  348A    52E5     MOVF 0xfe5, F, ACCESS
  348C    6EE1     MOVWF 0xfe1, ACCESS
  348E    52E5     MOVF 0xfe5, F, ACCESS
  3490    CFE7     MOVFF 0xfe7, 0xfd9
  3492    FFD9     NOP
  3494    0012     RETURN 0
645:               
646:               /******************************************************************************
647:                	Function:
648:                		void MSDProcessCommandMediaAbsent(void)
649:                		
650:                	Description:
651:                		This funtion processes a command received through the MSD
652:                		class driver
653:                		
654:                	PreCondition:
655:                		None
656:                		
657:                	Parameters:
658:                		None
659:                	
660:                	Return Values:
661:                		BYTE - the current state of the MSDProcessCommand state
662:                		machine.  The valid values are defined in MSD.h under the 
663:                		MSDProcessCommand state machine declaration section
664:                		
665:                	Remarks:
666:                		None
667:                
668:                 *****************************************************************************/	
669:               void MSDProcessCommandMediaAbsent(void)
  3496    CFD9     MOVFF 0xfd9, 0xfe6
  3498    FFE6     NOP
  349A    CFE1     MOVFF 0xfe1, 0xfd9
  349C    FFD9     NOP
  349E    52E6     MOVF 0xfe6, F, ACCESS
670:               {
671:                   BYTE i;
672:               
673:                   switch(MSDCommandState)
  34A0    0105     MOVLB 0x5
  34A2    51FE     MOVF 0xfe, W, BANKED
  34A4    0AFD     XORLW 0xfd
  34A6    E055     BZ 0x3552
  34A8    0A02     XORLW 0x2
  34AA    E050     BZ 0x354c
  34AC    0AED     XORLW 0xed
  34AE    E030     BZ 0x3510
  34B0    0A0C     XORLW 0xc
  34B2    E101     BNZ 0x34b6
  34B4    D080     BRA 0x35b6
  34B6    0A1E     XORLW 0x1e
  34B8    E101     BNZ 0x34bc
  34BA    D07D     BRA 0x35b6
  34BC    0A03     XORLW 0x3
  34BE    E174     BNZ 0x35a8
674:                   {
675:                       case MSD_REQUEST_SENSE:
676:                       {
677:                           ResetSenseData();
  34C0    DA82     RCALL 0x39c6
678:                           gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
  34C2    0104     MOVLB 0x4
  34C4    91A2     BCF 0xa2, 0, BANKED
  34C6    83A2     BSF 0xa2, 0x1, BANKED
  34C8    95A2     BCF 0xa2, 0x2, BANKED
  34CA    97A2     BCF 0xa2, 0x3, BANKED
679:                   		gblSenseData[LUN_INDEX].ASC=ASC_MEDIUM_NOT_PRESENT;
  34CC    0E3A     MOVLW 0x3a
  34CE    6FAC     MOVWF 0xac, BANKED
680:                   		gblSenseData[LUN_INDEX].ASCQ=ASCQ_MEDIUM_NOT_PRESENT;
  34D0    6BAD     CLRF 0xad, BANKED
681:               
682:                         	for(i=0;i<sizeof(RequestSenseResponse);i++)
  34D2    6ADF     CLRF 0xfdf, ACCESS
  34D4    50DF     MOVF 0xfdf, W, ACCESS
  34D6    6E14     MOVWF 0x14, ACCESS
  34D8    6A15     CLRF 0x15, ACCESS
  34DA    0E12     MOVLW 0x12
  34DC    5C14     SUBWF 0x14, W, ACCESS
  34DE    0E00     MOVLW 0
  34E0    5815     SUBWFB 0x15, W, ACCESS
  34E2    E213     BC 0x350a
  3506    2ADF     INCF 0xfdf, F, ACCESS
  3508    D7E5     BRA 0x34d4
683:                         	{
684:                         		msd_buffer[i]=gblSenseData[LUN_INDEX]._byte[i];
  34E4    50DF     MOVF 0xfdf, W, ACCESS
  34E6    6AEA     CLRF 0xfea, ACCESS
  34E8    0FA0     ADDLW 0xa0
  34EA    6EE9     MOVWF 0xfe9, ACCESS
  34EC    0E04     MOVLW 0x4
  34EE    22EA     ADDWFC 0xfea, F, ACCESS
  34F0    50EF     MOVF 0xfef, W, ACCESS
  34F2    6EE6     MOVWF 0xfe6, ACCESS
  34F4    50DF     MOVF 0xfdf, W, ACCESS
  34F6    6AEA     CLRF 0xfea, ACCESS
  34F8    0F00     ADDLW 0
  34FA    6EE9     MOVWF 0xfe9, ACCESS
  34FC    0E06     MOVLW 0x6
  34FE    22EA     ADDWFC 0xfea, F, ACCESS
  3500    52E5     MOVF 0xfe5, F, ACCESS
  3502    50E7     MOVF 0xfe7, W, ACCESS
  3504    6EEF     MOVWF 0xfef, ACCESS
685:                           }
686:                         	
687:                           msd_csw.dCSWDataResidue=sizeof(RequestSenseResponse);
  350A    0104     MOVLB 0x4
  350C    0E12     MOVLW 0x12
688:                         	msd_csw.bCSWStatus=0x0;					// success
689:                         	MSDCommandState = MSD_COMMAND_RESPONSE;
690:                           break;
  350E    D015     BRA 0x353a
691:                       } 
692:                       case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
693:                       case MSD_TEST_UNIT_READY:
694:                       {
695:                   		msd_csw.bCSWStatus=0x01;
696:                           MSDCommandState = MSD_COMMAND_WAIT;
697:                           break;
698:                       }
699:                       case MSD_INQUIRY:
700:                       {
701:                       	memcpypgm2ram(
702:                       	    (void *)&msd_buffer[0],
  3522    0E00     MOVLW 0
  3524    6EE6     MOVWF 0xfe6, ACCESS
  3526    0E06     MOVLW 0x6
  3528    6EE6     MOVWF 0xfe6, ACCESS
703:                       	    (ROM void*)&inq_resp,
  3516    0E92     MOVLW 0x92
  3518    6EE6     MOVWF 0xfe6, ACCESS
  351A    0E52     MOVLW 0x52
  351C    6EE6     MOVWF 0xfe6, ACCESS
  351E    0E00     MOVLW 0
  3520    6EE6     MOVWF 0xfe6, ACCESS
704:                       	    sizeof(InquiryResponse)
  3510    0E24     MOVLW 0x24
705:                       	    );
  3512    6EE6     MOVWF 0xfe6, ACCESS
  3514    6AE6     CLRF 0xfe6, ACCESS
  352A    EC7B     CALL 0x4cf6, 0
  352C    F026     NOP
  352E    6E14     MOVWF 0x14, ACCESS
  3530    0E07     MOVLW 0x7
  3532    5EE1     SUBWF 0xfe1, F, ACCESS
  3534    5014     MOVF 0x14, W, ACCESS
706:                       	msd_csw.dCSWDataResidue=sizeof(InquiryResponse);
  3536    0104     MOVLB 0x4
  3538    0E24     MOVLW 0x24
  353A    6F77     MOVWF 0x77, BANKED
  353C    6B78     CLRF 0x78, BANKED
  353E    6B79     CLRF 0x79, BANKED
  3540    6B7A     CLRF 0x7a, BANKED
707:                       	msd_csw.bCSWStatus=0x00;			// success
  3542    6B7B     CLRF 0x7b, BANKED
708:                       	MSDCommandState = MSD_COMMAND_RESPONSE;
  3544    0105     MOVLB 0x5
  3546    0EFD     MOVLW 0xfd
  3548    6FFE     MOVWF 0xfe, BANKED
709:                           break;
  354A    D03A     BRA 0x35c0
710:                       }
711:                       case MSD_COMMAND_WAIT:
712:                       {
713:                           MSDCommandState = gblCBW.CBWCB[0];
  354C    C48F     MOVFF 0x48f, 0x5fe
  354E    F5FE     NOP
714:                           break;
  3550    D037     BRA 0x35c0
715:                       }
716:                       case MSD_COMMAND_RESPONSE:
717:                           if(USBHandleBusy(USBMSDInHandle) == FALSE)
  3552    0104     MOVLB 0x4
  3554    51B6     MOVF 0xb6, W, BANKED
  3556    11B7     IORWF 0xb7, W, BANKED
  3558    E102     BNZ 0x355e
  355A    0E00     MOVLW 0
  355C    D008     BRA 0x356e
  355E    C4B6     MOVFF 0x4b6, 0xfe9
  3560    FFE9     NOP
  3562    C4B7     MOVFF 0x4b7, 0xfea
  3564    FFEA     NOP
  3566    50EF     MOVF 0xfef, W, ACCESS
  3568    0B80     ANDLW 0x80
  356A    E001     BZ 0x356e
  356C    0E01     MOVLW 0x1
  356E    0900     IORLW 0
  3570    E127     BNZ 0x35c0
718:                           {
719:                               USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(BYTE*)&msd_buffer[0],msd_csw.dCSWDataResidue);
  3572    C477     MOVFF 0x477, 0xfe6
  3574    FFE6     NOP
  3576    0E00     MOVLW 0
  3578    6EE6     MOVWF 0xfe6, ACCESS
  357A    0E06     MOVLW 0x6
  357C    6EE6     MOVWF 0xfe6, ACCESS
  357E    0E01     MOVLW 0x1
  3580    6EE6     MOVWF 0xfe6, ACCESS
  3582    6EE6     MOVWF 0xfe6, ACCESS
  3584    ECA9     CALL 0x2152, 0
  3586    F010     NOP
  3588    6E14     MOVWF 0x14, ACCESS
  358A    0E05     MOVLW 0x5
  358C    5EE1     SUBWF 0xfe1, F, ACCESS
  358E    5014     MOVF 0x14, W, ACCESS
  3590    CFF3     MOVFF 0xff3, 0x4b6
  3592    F4B6     NOP
  3594    CFF4     MOVFF 0xff4, 0x4b7
  3596    F4B7     NOP
720:               			    MSDCommandState = MSD_COMMAND_WAIT;
  3598    0105     MOVLB 0x5
  359A    69FE     SETF 0xfe, BANKED
721:               
722:                       		msd_csw.dCSWDataResidue=0;
  359C    0104     MOVLB 0x4
  359E    6B77     CLRF 0x77, BANKED
  35A0    6B78     CLRF 0x78, BANKED
  35A2    6B79     CLRF 0x79, BANKED
  35A4    6B7A     CLRF 0x7a, BANKED
723:                           }
724:                           break;
  35A6    D00C     BRA 0x35c0
725:                       default:
726:                       {
727:                           //Stall MSD endpoint IN
728:                           USBStallEndpoint(MSD_DATA_IN_EP,1);
  35A8    0E01     MOVLW 0x1
  35AA    6EE6     MOVWF 0xfe6, ACCESS
  35AC    6EE6     MOVWF 0xfe6, ACCESS
  35AE    EC3B     CALL 0x2076, 0
  35B0    F010     NOP
  35B2    52E5     MOVF 0xfe5, F, ACCESS
  35B4    52E5     MOVF 0xfe5, F, ACCESS
729:                   		msd_csw.bCSWStatus=0x01;
  35B6    0104     MOVLB 0x4
  35B8    0E01     MOVLW 0x1
  35BA    6F7B     MOVWF 0x7b, BANKED
730:                           MSDCommandState = MSD_COMMAND_WAIT;
  35BC    0105     MOVLB 0x5
  35BE    69FE     SETF 0xfe, BANKED
731:                           break;
732:                       }
733:                   }
734:               }
  35C0    52E5     MOVF 0xfe5, F, ACCESS
  35C2    52E5     MOVF 0xfe5, F, ACCESS
  35C4    CFE7     MOVFF 0xfe7, 0xfd9
  35C6    FFD9     NOP
  35C8    0012     RETURN 0
735:               
736:               /******************************************************************************
737:                	Function:
738:                		BYTE MSDProcessCommand(void)
739:                		
740:                	Description:
741:                		This funtion processes a command received through the MSD
742:                		class driver
743:                		
744:                	PreCondition:
745:                		None
746:                		
747:                	Paramters:
748:                		None
749:                		
750:                	Return Values:
751:                		BYTE - the current state of the MSDProcessCommand state
752:                		machine.  The valid values are defined in MSD.h under the
753:                		MSDProcessCommand state machine declaration section
754:                		
755:                	Remarks:
756:                		None
757:                
758:                *****************************************************************************/	
759:               BYTE MSDProcessCommand(void)
760:               {   
761:                 	if(LUNMediaDetect() == FALSE || SoftDetach[gblCBW.bCBWLUN] == TRUE)
  35CA    EC23     CALL 0x4846, 0
  35CC    F024     NOP
  35CE    0900     IORLW 0
  35D0    E009     BZ 0x35e4
  35D2    0104     MOVLB 0x4
  35D4    518D     MOVF 0x8d, W, BANKED
  35D6    6AEA     CLRF 0xfea, ACCESS
  35D8    0FBC     ADDLW 0xbc
  35DA    6EE9     MOVWF 0xfe9, ACCESS
  35DC    0E04     MOVLW 0x4
  35DE    22EA     ADDWFC 0xfea, F, ACCESS
  35E0    04EF     DECF 0xfef, W, ACCESS
  35E2    E110     BNZ 0x3604
762:                   {
763:                       gblMediaPresent &= ~((WORD)1<<gblCBW.bCBWLUN);
  35E4    0104     MOVLB 0x4
  35E6    518D     MOVF 0x8d, W, BANKED
  35E8    EC87     CALL 0x530e, 0
  35EA    F029     NOP
  35EC    CFF3     MOVFF 0xff3, 0x14
  35EE    F014     NOP
  35F0    CFF4     MOVFF 0xff4, 0x15
  35F2    F015     NOP
  35F4    1E14     COMF 0x14, F, ACCESS
  35F6    1E15     COMF 0x15, F, ACCESS
  35F8    5014     MOVF 0x14, W, ACCESS
  35FA    0104     MOVLB 0x4
  35FC    17BA     ANDWF 0xba, F, BANKED
  35FE    5015     MOVF 0x15, W, ACCESS
  3600    17BB     ANDWF 0xbb, F, BANKED
764:               
765:                       MSDProcessCommandMediaAbsent();
766:                  	}
767:                   else
  3602    D02A     BRA 0x3658
768:                   {
769:                       if((gblMediaPresent & ((WORD)1<<gblCBW.bCBWLUN)) == 0)
  3604    518D     MOVF 0x8d, W, BANKED
  3606    EC87     CALL 0x530e, 0
  3608    F029     NOP
  360A    0104     MOVLB 0x4
  360C    51BA     MOVF 0xba, W, BANKED
  360E    14F3     ANDWF 0xff3, W, ACCESS
  3610    6E14     MOVWF 0x14, ACCESS
  3612    51BB     MOVF 0xbb, W, BANKED
  3614    14F4     ANDWF 0xff4, W, ACCESS
  3616    6E15     MOVWF 0x15, ACCESS
  3618    5014     MOVF 0x14, W, ACCESS
  361A    1015     IORWF 0x15, W, ACCESS
  361C    E11F     BNZ 0x365c
770:                       {
771:                           if(LUNMediaInitialize())
  361E    EC2F     CALL 0x485e, 0
  3620    F024     NOP
  3622    CFF3     MOVFF 0xff3, 0x14
  3624    F014     NOP
  3626    CFF4     MOVFF 0xff4, 0x15
  3628    F015     NOP
  362A    50F3     MOVF 0xff3, W, ACCESS
  362C    10F4     IORWF 0xff4, W, ACCESS
  362E    E014     BZ 0x3658
772:                           {
773:                               gblMediaPresent |= ((WORD)1<<gblCBW.bCBWLUN);
  3630    0104     MOVLB 0x4
  3632    518D     MOVF 0x8d, W, BANKED
  3634    EC87     CALL 0x530e, 0
  3636    F029     NOP
  3638    50F3     MOVF 0xff3, W, ACCESS
  363A    0104     MOVLB 0x4
  363C    13BA     IORWF 0xba, F, BANKED
  363E    50F4     MOVF 0xff4, W, ACCESS
  3640    13BB     IORWF 0xbb, F, BANKED
774:               
775:                       		gblSenseData[LUN_INDEX].SenseKey=S_UNIT_ATTENTION;
  3642    91A2     BCF 0xa2, 0, BANKED
  3644    83A2     BSF 0xa2, 0x1, BANKED
  3646    85A2     BSF 0xa2, 0x2, BANKED
  3648    97A2     BCF 0xa2, 0x3, BANKED
776:                       		gblSenseData[LUN_INDEX].ASC=0x28;
  364A    0E28     MOVLW 0x28
  364C    6FAC     MOVWF 0xac, BANKED
777:                       		gblSenseData[LUN_INDEX].ASCQ=0x00;
  364E    6BAD     CLRF 0xad, BANKED
778:                               msd_csw.bCSWStatus=0x01;
  3650    0104     MOVLB 0x4
  3652    0E01     MOVLW 0x1
  3654    6F7B     MOVWF 0x7b, BANKED
779:               
780:                               MSDProcessCommandMediaPresent();
781:                           }
782:                           else
  3656    D002     BRA 0x365c
783:                           {
784:                               MSDProcessCommandMediaAbsent();
  3658    DF1E     RCALL 0x3496
785:                           }
786:                       }
787:                       else
  365A    D001     BRA 0x365e
788:                       {
789:                           MSDProcessCommandMediaPresent();
  365C    DDFD     RCALL 0x3258
790:                       }
791:                   }
792:               
793:                   return MSDCommandState;
  365E    0105     MOVLB 0x5
  3660    51FE     MOVF 0xfe, W, BANKED
794:               }
  3662    0012     RETURN 0
795:               
796:               /******************************************************************************
797:                	Function:
798:                		BYTE MSDReadHandler(void)
799:                		
800:                	Description:
801:                		This funtion processes a read command received through 
802:                		the MSD class driver
803:                		
804:                	PreCondition:
805:                		None
806:                		
807:                	Parameters:
808:                		None
809:                		
810:                	Return Values:
811:                		BYTE - the current state of the MSDReadHandler state
812:                		machine.  The valid values are defined in MSD.h under the 
813:                		MSDReadHandler state machine declaration section
814:                		
815:                	Remarks:
816:                		None
817:                
818:                 *****************************************************************************/
819:               
820:               BYTE MSDReadHandler(void)
821:               {
822:                   switch(MSDReadState)
  3664    0104     MOVLB 0x4
  3666    517D     MOVF 0x7d, W, BANKED
  3668    0A04     XORLW 0x4
  366A    E101     BNZ 0x366e
  366C    D07B     BRA 0x3764
  366E    0A07     XORLW 0x7
  3670    E06C     BZ 0x374a
  3672    0A01     XORLW 0x1
  3674    E023     BZ 0x36bc
  3676    0A03     XORLW 0x3
  3678    E018     BZ 0x36aa
  367A    0A01     XORLW 0x1
  367C    E001     BZ 0x3680
  367E    D0AA     BRA 0x37d4
823:                   {
824:                       case MSD_READ10_WAIT:
825:                       	LBA.v[3]=gblCBW.CBWCB[2];
  3680    C491     MOVFF 0x491, 0x4c2
  3682    F4C2     NOP
826:                       	LBA.v[2]=gblCBW.CBWCB[3];
  3684    C492     MOVFF 0x492, 0x4c1
  3686    F4C1     NOP
827:                       	LBA.v[1]=gblCBW.CBWCB[4];
  3688    C493     MOVFF 0x493, 0x4c0
  368A    F4C0     NOP
828:                       	LBA.v[0]=gblCBW.CBWCB[5];
  368C    C494     MOVFF 0x494, 0x4bf
  368E    F4BF     NOP
829:                       	
830:                       	TransferLength.v[1]=gblCBW.CBWCB[7];
  3690    C496     MOVFF 0x496, 0x4be
  3692    F4BE     NOP
831:                       	TransferLength.v[0]=gblCBW.CBWCB[8];
  3694    C497     MOVFF 0x497, 0x4bd
  3696    F4BD     NOP
832:               
833:                           //Assume success initially, msd_csw.bCSWStatus will get set to 0x01 
834:                           //or 0x02 later if an error is detected during the actual read sequence.        	
835:                       	msd_csw.bCSWStatus=0x0;
  3698    0104     MOVLB 0x4
  369A    6B7B     CLRF 0x7b, BANKED
836:                       	msd_csw.dCSWDataResidue=0x0;
  369C    6B77     CLRF 0x77, BANKED
  369E    6B78     CLRF 0x78, BANKED
  36A0    6B79     CLRF 0x79, BANKED
  36A2    6B7A     CLRF 0x7a, BANKED
837:                       	
838:                           MSDReadState = MSD_READ10_BLOCK;
  36A4    0104     MOVLB 0x4
  36A6    0E01     MOVLW 0x1
  36A8    6F7D     MOVWF 0x7d, BANKED
839:                           //Fall through to MSD_READ_BLOCK
840:                       case MSD_READ10_BLOCK:
841:                           if(TransferLength.Val == 0)
  36AA    51BD     MOVF 0xbd, W, BANKED
  36AC    11BE     IORWF 0xbe, W, BANKED
  36AE    E101     BNZ 0x36b2
  36B0    D095     BRA 0x37dc
842:                           {
843:                               MSDReadState = MSD_READ10_WAIT;
844:                               break;
845:                           }
846:                           
847:                           TransferLength.Val--;					// we have read 1 LBA
  36B2    07BD     DECF 0xbd, F, BANKED
  36B4    0E00     MOVLW 0
  36B6    5BBE     SUBWFB 0xbe, F, BANKED
848:                           MSDReadState = MSD_READ10_SECTOR;
  36B8    0E02     MOVLW 0x2
  36BA    6F7D     MOVWF 0x7d, BANKED
849:                           //Fall through to MSD_READ10_SECTOR
850:                       case MSD_READ10_SECTOR:
851:                           //if the old data isn't completely sent yet
852:                           if(USBHandleBusy(USBMSDInHandle) != 0)
  36BC    51B6     MOVF 0xb6, W, BANKED
  36BE    11B7     IORWF 0xb7, W, BANKED
  36C0    E102     BNZ 0x36c6
  36C2    0E00     MOVLW 0
  36C4    D008     BRA 0x36d6
  36C6    C4B6     MOVFF 0x4b6, 0xfe9
  36C8    FFE9     NOP
  36CA    C4B7     MOVFF 0x4b7, 0xfea
  36CC    FFEA     NOP
  36CE    50EF     MOVF 0xfef, W, ACCESS
  36D0    0B80     ANDLW 0x80
  36D2    E001     BZ 0x36d6
  36D4    0E01     MOVLW 0x1
  36D6    0900     IORLW 0
  36D8    E001     BZ 0x36dc
  36DA    D081     BRA 0x37de
853:                           {
854:                               break;
855:                           }
856:                           
857:                           //Try to read a sector worth of data from the media, but check for
858:                           //possible errors.
859:                   		if(LUNSectorRead(LBA.Val, (BYTE*)&msd_buffer[0]) != TRUE)
  36DC    0E00     MOVLW 0
  36DE    6EE6     MOVWF 0xfe6, ACCESS
  36E0    0E06     MOVLW 0x6
  36E2    6EE6     MOVWF 0xfe6, ACCESS
  36E4    C4BF     MOVFF 0x4bf, 0xfe6
  36E6    FFE6     NOP
  36E8    C4C0     MOVFF 0x4c0, 0xfe6
  36EA    FFE6     NOP
  36EC    C4C1     MOVFF 0x4c1, 0xfe6
  36EE    FFE6     NOP
  36F0    C4C2     MOVFF 0x4c2, 0xfe6
  36F2    FFE6     NOP
  36F4    EC38     CALL 0x4870, 0
  36F6    F024     NOP
  36F8    6E14     MOVWF 0x14, ACCESS
  36FA    0E06     MOVLW 0x6
  36FC    5EE1     SUBWF 0xfe1, F, ACCESS
  36FE    5014     MOVF 0x14, W, ACCESS
  3700    0801     SUBLW 0x1
  3702    E010     BZ 0x3724
860:                   		{
861:               				if(MSDRetryAttempt < MSD_FAILED_READ_MAX_ATTEMPTS)
  3704    0E64     MOVLW 0x64
  3706    0104     MOVLB 0x4
  3708    5D7F     SUBWF 0x7f, W, BANKED
  370A    E202     BC 0x3710
862:               				{
863:               				    MSDRetryAttempt++;
  370C    2B7F     INCF 0x7f, F, BANKED
864:                                   break;
  370E    D067     BRA 0x37de
865:               				}
866:               				else
867:               				{  
868:                   				//Too many consecutive failed reads have occurred.  Need to
869:                   				//give up and abandon the sector read attempt; something must
870:                   				//be wrong and we don't want to get stuck in an infinite loop.
871:                   				//Need to indicate to the host that a device error occurred.
872:                   				//However, we can't send the CSW immediately, since the host
873:                   				//still expects to receive sector read data on the IN endpoint 
874:                   				//first.  Therefore, we still send dummy bytes, before
875:                   				//we send the CSW with the failed status in it.
876:                   				msd_csw.bCSWStatus=0x01;		// Error 0x01 Refer page#18
  3710    0104     MOVLB 0x4
  3712    0E01     MOVLW 0x1
  3714    6F7B     MOVWF 0x7b, BANKED
877:                                                                   // of BOT specifications
878:                                   //Set error status sense keys, so the host can check them later
879:                                   //to determine how to proceed.
880:                                   gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
  3716    0104     MOVLB 0x4
  3718    81A2     BSF 0xa2, 0, BANKED
  371A    83A2     BSF 0xa2, 0x1, BANKED
  371C    95A2     BCF 0xa2, 0x2, BANKED
  371E    97A2     BCF 0xa2, 0x3, BANKED
881:               			        gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
  3720    6BAC     CLRF 0xac, BANKED
882:               			        gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
  3722    6BAD     CLRF 0xad, BANKED
883:                               }
884:                           }//else we successfully read a sector worth of data from our media
885:               
886:                           LBA.Val++;
  3724    0104     MOVLB 0x4
  3726    2BBF     INCF 0xbf, F, BANKED
  3728    0E00     MOVLW 0
  372A    23C0     ADDWFC 0xc0, F, BANKED
  372C    23C1     ADDWFC 0xc1, F, BANKED
  372E    23C2     ADDWFC 0xc2, F, BANKED
887:               			msd_csw.dCSWDataResidue=BLOCKLEN_512;//in order to send the
  3730    0104     MOVLB 0x4
  3732    6B77     CLRF 0x77, BANKED
  3734    0E02     MOVLW 0x2
  3736    6F78     MOVWF 0x78, BANKED
  3738    6B79     CLRF 0x79, BANKED
  373A    6B7A     CLRF 0x7a, BANKED
888:                                                                //512 bytes of data read
889:                                                                
890:                           ptrNextData=(BYTE *)&msd_buffer[0];
  373C    0104     MOVLB 0x4
  373E    0E00     MOVLW 0
  3740    6FB2     MOVWF 0xb2, BANKED
  3742    0E06     MOVLW 0x6
  3744    6FB3     MOVWF 0xb3, BANKED
891:                           
892:                           MSDReadState = MSD_READ10_TX_SECTOR;
  3746    0E03     MOVLW 0x3
  3748    6F7D     MOVWF 0x7d, BANKED
893:                   
894:                           //Fall through to MSD_READ10_TX_SECTOR
895:                       case MSD_READ10_TX_SECTOR:
896:                           if(msd_csw.dCSWDataResidue == 0)
  374A    0104     MOVLB 0x4
  374C    5177     MOVF 0x77, W, BANKED
  374E    1178     IORWF 0x78, W, BANKED
  3750    1179     IORWF 0x79, W, BANKED
  3752    117A     IORWF 0x7a, W, BANKED
  3754    E104     BNZ 0x375e
897:                           {
898:                               MSDReadState = MSD_READ10_BLOCK;
  3756    0104     MOVLB 0x4
  3758    0E01     MOVLW 0x1
  375A    6F7D     MOVWF 0x7d, BANKED
899:                               break;
  375C    D040     BRA 0x37de
900:                           }
901:                           
902:                           MSDReadState = MSD_READ10_TX_PACKET;
  375E    0104     MOVLB 0x4
  3760    0E04     MOVLW 0x4
  3762    6F7D     MOVWF 0x7d, BANKED
903:                           //Fall through to MSD_READ10_TX_PACKET
904:                           
905:                       case MSD_READ10_TX_PACKET:
906:                   		/* Write next chunk of data to EP Buffer and send */
907:                           
908:                           //Make sure the endpoint is available before using it.
909:                           if(USBHandleBusy(USBMSDInHandle))
  3764    51B6     MOVF 0xb6, W, BANKED
  3766    11B7     IORWF 0xb7, W, BANKED
  3768    E102     BNZ 0x376e
  376A    0E00     MOVLW 0
  376C    D008     BRA 0x377e
  376E    C4B6     MOVFF 0x4b6, 0xfe9
  3770    FFE9     NOP
  3772    C4B7     MOVFF 0x4b7, 0xfea
  3774    FFEA     NOP
  3776    50EF     MOVF 0xfef, W, ACCESS
  3778    0B80     ANDLW 0x80
  377A    E001     BZ 0x377e
  377C    0E01     MOVLW 0x1
  377E    0900     IORLW 0
  3780    E12E     BNZ 0x37de
910:                           {
911:                               break;
912:                           }
913:                           //Prepare the USB module to send an IN transaction worth of data to the host.
914:                           USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,ptrNextData,MSD_IN_EP_SIZE);
  3782    0E40     MOVLW 0x40
  3784    6EE6     MOVWF 0xfe6, ACCESS
  3786    C4B2     MOVFF 0x4b2, 0xfe6
  3788    FFE6     NOP
  378A    C4B3     MOVFF 0x4b3, 0xfe6
  378C    FFE6     NOP
  378E    0E01     MOVLW 0x1
  3790    6EE6     MOVWF 0xfe6, ACCESS
  3792    6EE6     MOVWF 0xfe6, ACCESS
  3794    ECA9     CALL 0x2152, 0
  3796    F010     NOP
  3798    6E14     MOVWF 0x14, ACCESS
  379A    0E05     MOVLW 0x5
  379C    5EE1     SUBWF 0xfe1, F, ACCESS
  379E    5014     MOVF 0x14, W, ACCESS
  37A0    CFF3     MOVFF 0xff3, 0x4b6
  37A2    F4B6     NOP
  37A4    CFF4     MOVFF 0xff4, 0x4b7
  37A6    F4B7     NOP
915:                           
916:                			MSDReadState = MSD_READ10_TX_SECTOR;
  37A8    0104     MOVLB 0x4
  37AA    0E03     MOVLW 0x3
  37AC    6F7D     MOVWF 0x7d, BANKED
917:               
918:                   		gblCBW.dCBWDataTransferLength-=	MSD_IN_EP_SIZE;
  37AE    0E40     MOVLW 0x40
  37B0    5F88     SUBWF 0x88, F, BANKED
  37B2    0E00     MOVLW 0
  37B4    5B89     SUBWFB 0x89, F, BANKED
  37B6    5B8A     SUBWFB 0x8a, F, BANKED
  37B8    5B8B     SUBWFB 0x8b, F, BANKED
919:                   		msd_csw.dCSWDataResidue-=MSD_IN_EP_SIZE;
  37BA    0E40     MOVLW 0x40
  37BC    0104     MOVLB 0x4
  37BE    5F77     SUBWF 0x77, F, BANKED
  37C0    0E00     MOVLW 0
  37C2    5B78     SUBWFB 0x78, F, BANKED
  37C4    5B79     SUBWFB 0x79, F, BANKED
  37C6    5B7A     SUBWFB 0x7a, F, BANKED
920:                   		ptrNextData+=MSD_IN_EP_SIZE;
  37C8    0E40     MOVLW 0x40
  37CA    0104     MOVLB 0x4
  37CC    27B2     ADDWF 0xb2, F, BANKED
  37CE    0E00     MOVLW 0
  37D0    23B3     ADDWFC 0xb3, F, BANKED
921:                           break;
  37D2    D005     BRA 0x37de
922:                       
923:                       default:
924:                           //Illegal condition, should never occur.  In the event that it ever
925:                           //did occur anyway, try to notify the host of the error.
926:                           msd_csw.bCSWStatus=0x02;  //indicate "Phase Error"
  37D4    0104     MOVLB 0x4
  37D6    0E02     MOVLW 0x2
  37D8    6F7B     MOVWF 0x7b, BANKED
927:                           //Advance state machine
928:                           MSDReadState = MSD_READ10_WAIT;
  37DA    0104     MOVLB 0x4
  37DC    6B7D     CLRF 0x7d, BANKED
929:                   }
930:                   
931:                   return MSDReadState;
  37DE    517D     MOVF 0x7d, W, BANKED
932:               }
  37E0    0012     RETURN 0
933:               
934:               
935:               /******************************************************************************
936:                	Function:
937:                		BYTE MSDWriteHandler(void)
938:                		
939:                	Description:
940:                		This funtion processes a write command received through 
941:                		the MSD class driver
942:                		
943:                	PreCondition:
944:                		None
945:                		
946:                	Parameters:
947:                		None
948:                		
949:                	Return Values:
950:                		BYTE - the current state of the MSDWriteHandler state
951:                		machine.  The valid values are defined in MSD.h under the 
952:                		MSDWriteHandler state machine declaration section
953:                		
954:                	Remarks:
955:                		None
956:                
957:                *****************************************************************************/
958:               BYTE MSDWriteHandler(void)
959:               {
960:                   switch(MSDWriteState)
  37E2    0104     MOVLB 0x4
  37E4    517E     MOVF 0x7e, W, BANKED
  37E6    0A02     XORLW 0x2
  37E8    E101     BNZ 0x37ec
  37EA    D0AA     BRA 0x3940
  37EC    0A06     XORLW 0x6
  37EE    E06D     BZ 0x38ca
  37F0    0A07     XORLW 0x7
  37F2    E026     BZ 0x3840
  37F4    0A02     XORLW 0x2
  37F6    E014     BZ 0x3820
  37F8    0A01     XORLW 0x1
  37FA    E001     BZ 0x37fe
  37FC    D0DD     BRA 0x39b8
961:                   {
962:                       case MSD_WRITE10_WAIT:
963:                        	/* Read the LBA, TransferLength fields from Command Block
964:                              NOTE: CB is Big-Endian */
965:                       
966:                       	LBA.v[3]=gblCBW.CBWCB[2];
  37FE    C491     MOVFF 0x491, 0x4c2
  3800    F4C2     NOP
967:                       	LBA.v[2]=gblCBW.CBWCB[3];
  3802    C492     MOVFF 0x492, 0x4c1
  3804    F4C1     NOP
968:                       	LBA.v[1]=gblCBW.CBWCB[4];
  3806    C493     MOVFF 0x493, 0x4c0
  3808    F4C0     NOP
969:                       	LBA.v[0]=gblCBW.CBWCB[5];
  380A    C494     MOVFF 0x494, 0x4bf
  380C    F4BF     NOP
970:                       	TransferLength.v[1]=gblCBW.CBWCB[7];
  380E    C496     MOVFF 0x496, 0x4be
  3810    F4BE     NOP
971:                       	TransferLength.v[0]=gblCBW.CBWCB[8];
  3812    C497     MOVFF 0x497, 0x4bd
  3814    F4BD     NOP
972:                       
973:                       	//Initially assume success, unless handler code later encounters an
974:                       	//error condition and sets the status to 0x01 or 0x02.
975:                       	msd_csw.bCSWStatus=0x0;	
  3816    0104     MOVLB 0x4
  3818    6B7B     CLRF 0x7b, BANKED
976:                       	
977:                       	MSD_State = MSD_WRITE10_BLOCK;
  381A    0104     MOVLB 0x4
  381C    0E01     MOVLW 0x1
  381E    6F7C     MOVWF 0x7c, BANKED
978:                       	//Fall through to MSD_WRITE10_BLOCK
979:                       case MSD_WRITE10_BLOCK:
980:                           if(TransferLength.Val == 0)
  3820    51BD     MOVF 0xbd, W, BANKED
  3822    11BE     IORWF 0xbe, W, BANKED
  3824    E101     BNZ 0x3828
  3826    D0CC     BRA 0x39c0
981:                           {
982:                               MSDWriteState = MSD_WRITE10_WAIT;
983:                               break;
984:                           }
985:                           
986:                           MSDWriteState = MSD_WRITE10_RX_SECTOR;
  3828    0E03     MOVLW 0x3
  382A    6F7E     MOVWF 0x7e, BANKED
987:                           ptrNextData=(BYTE *)&msd_buffer[0];
  382C    0E00     MOVLW 0
  382E    6FB2     MOVWF 0xb2, BANKED
  3830    0E06     MOVLW 0x6
  3832    6FB3     MOVWF 0xb3, BANKED
988:                             
989:                       	msd_csw.dCSWDataResidue=BLOCKLEN_512;
  3834    0104     MOVLB 0x4
  3836    6B77     CLRF 0x77, BANKED
  3838    0E02     MOVLW 0x2
  383A    6F78     MOVWF 0x78, BANKED
  383C    6B79     CLRF 0x79, BANKED
  383E    6B7A     CLRF 0x7a, BANKED
990:                       	
991:                           //Fall through to MSD_WRITE10_RX_SECTOR
992:                       case MSD_WRITE10_RX_SECTOR:
993:                       {
994:                     		/* Read 512B into msd_buffer*/
995:                     		if(msd_csw.dCSWDataResidue>0) 
  3840    80D8     BSF 0xfd8, 0, ACCESS
  3842    0E00     MOVLW 0
  3844    0104     MOVLB 0x4
  3846    5577     SUBFWB 0x77, W, BANKED
  3848    0E00     MOVLW 0
  384A    5578     SUBFWB 0x78, W, BANKED
  384C    0E00     MOVLW 0
  384E    5579     SUBFWB 0x79, W, BANKED
  3850    0E00     MOVLW 0
  3852    557A     SUBFWB 0x7a, W, BANKED
  3854    E228     BC 0x38a6
996:                     		{
997:                               if(USBHandleBusy(USBMSDOutHandle) == TRUE)
  3856    0104     MOVLB 0x4
  3858    51B4     MOVF 0xb4, W, BANKED
  385A    11B5     IORWF 0xb5, W, BANKED
  385C    E102     BNZ 0x3862
  385E    0E00     MOVLW 0
  3860    D008     BRA 0x3872
  3862    C4B4     MOVFF 0x4b4, 0xfe9
  3864    FFE9     NOP
  3866    C4B5     MOVFF 0x4b5, 0xfea
  3868    FFEA     NOP
  386A    50EF     MOVF 0xfef, W, ACCESS
  386C    0B80     ANDLW 0x80
  386E    E001     BZ 0x3872
  3870    0E01     MOVLW 0x1
  3872    0900     IORLW 0
  3874    E001     BZ 0x3878
  3876    D0A5     BRA 0x39c2
998:                               {
999:                                   break;
1000:                              }
1001:              
1002:                              USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,ptrNextData,MSD_OUT_EP_SIZE);
  3878    0E40     MOVLW 0x40
  387A    6EE6     MOVWF 0xfe6, ACCESS
  387C    C4B2     MOVFF 0x4b2, 0xfe6
  387E    FFE6     NOP
  3880    C4B3     MOVFF 0x4b3, 0xfe6
  3882    FFE6     NOP
  3884    6AE6     CLRF 0xfe6, ACCESS
  3886    0E01     MOVLW 0x1
  3888    6EE6     MOVWF 0xfe6, ACCESS
  388A    ECA9     CALL 0x2152, 0
  388C    F010     NOP
  388E    6E14     MOVWF 0x14, ACCESS
  3890    0E05     MOVLW 0x5
  3892    5EE1     SUBWF 0xfe1, F, ACCESS
  3894    5014     MOVF 0x14, W, ACCESS
  3896    CFF3     MOVFF 0xff3, 0x4b4
  3898    F4B4     NOP
  389A    CFF4     MOVFF 0xff4, 0x4b5
  389C    F4B5     NOP
1003:                              MSDWriteState = MSD_WRITE10_RX_PACKET;
  389E    0104     MOVLB 0x4
  38A0    0E04     MOVLW 0x4
  38A2    6F7E     MOVWF 0x7e, BANKED
1004:                              //Fall through to MSD_WRITE10_RX_PACKET
1005:                    	    }
1006:                    	    else
  38A4    D012     BRA 0x38ca
1007:                    	    {
1008:                        		//We finished receiving a sector worth of data from the host.
1009:                        		//Check if the media is write protected before deciding what
1010:                        		//to do with the data.
1011:                        		if(LUNWriteProtectState()) 
  38A6    EC4F     CALL 0x4c9e, 0
  38A8    F026     NOP
  38AA    0900     IORLW 0
  38AC    E00B     BZ 0x38c4
1012:                              {
1013:                                  //The device appears to be write protected.
1014:                            	    //Let host know error occurred.  The bCSWStatus flag is also used by
1015:                            	    //the write handler, to know not to even attempt the write sequence.
1016:                            	    msd_csw.bCSWStatus=0x01;    
  38AE    0104     MOVLB 0x4
  38B0    0E01     MOVLW 0x1
  38B2    6F7B     MOVWF 0x7b, BANKED
1017:                            	    
1018:                                  //Set sense keys so the host knows what caused the error.
1019:                            	    gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
  38B4    0104     MOVLB 0x4
  38B6    91A2     BCF 0xa2, 0, BANKED
  38B8    83A2     BSF 0xa2, 0x1, BANKED
  38BA    95A2     BCF 0xa2, 0x2, BANKED
  38BC    97A2     BCF 0xa2, 0x3, BANKED
1020:                            	    gblSenseData[LUN_INDEX].ASC=ASC_WRITE_PROTECTED;
  38BE    0E27     MOVLW 0x27
  38C0    6FAC     MOVWF 0xac, BANKED
1021:                            	    gblSenseData[LUN_INDEX].ASCQ=ASCQ_WRITE_PROTECTED;
  38C2    6BAD     CLRF 0xad, BANKED
1022:                            	}
1023:                 			    MSDWriteState = MSD_WRITE10_SECTOR;     
  38C4    0104     MOVLB 0x4
  38C6    0E02     MOVLW 0x2
1024:                    			break;
  38C8    D075     BRA 0x39b4
1025:                        	}
1026:                      }
1027:                      //Fall through to MSD_WRITE10_RX_PACKET
1028:                      case MSD_WRITE10_RX_PACKET:
1029:                          if(USBHandleBusy(USBMSDOutHandle) == TRUE)
  38CA    51B4     MOVF 0xb4, W, BANKED
  38CC    11B5     IORWF 0xb5, W, BANKED
  38CE    E102     BNZ 0x38d4
  38D0    0E00     MOVLW 0
  38D2    D008     BRA 0x38e4
  38D4    C4B4     MOVFF 0x4b4, 0xfe9
  38D6    FFE9     NOP
  38D8    C4B5     MOVFF 0x4b5, 0xfea
  38DA    FFEA     NOP
  38DC    50EF     MOVF 0xfef, W, ACCESS
  38DE    0B80     ANDLW 0x80
  38E0    E001     BZ 0x38e4
  38E2    0E01     MOVLW 0x1
  38E4    0900     IORLW 0
  38E6    E16D     BNZ 0x39c2
1030:                          {
1031:                              break;
1032:                          }
1033:                          
1034:                      	gblCBW.dCBWDataTransferLength-=USBHandleGetLength(USBMSDOutHandle);		// 64B read
  38E8    C4B4     MOVFF 0x4b4, 0xfe9
  38EA    FFE9     NOP
  38EC    C4B5     MOVFF 0x4b5, 0xfea
  38EE    FFEA     NOP
  38F0    52EE     MOVF 0xfee, F, ACCESS
  38F2    CFEF     MOVFF 0xfef, 0x14
  38F4    F014     NOP
  38F6    6A15     CLRF 0x15, ACCESS
  38F8    6A16     CLRF 0x16, ACCESS
  38FA    6A17     CLRF 0x17, ACCESS
  38FC    5014     MOVF 0x14, W, ACCESS
  38FE    5F88     SUBWF 0x88, F, BANKED
  3900    5015     MOVF 0x15, W, ACCESS
  3902    5B89     SUBWFB 0x89, F, BANKED
  3904    5016     MOVF 0x16, W, ACCESS
  3906    5B8A     SUBWFB 0x8a, F, BANKED
  3908    5017     MOVF 0x17, W, ACCESS
  390A    5B8B     SUBWFB 0x8b, F, BANKED
1035:                      	msd_csw.dCSWDataResidue-=USBHandleGetLength(USBMSDOutHandle);
  390C    C4B4     MOVFF 0x4b4, 0xfe9
  390E    FFE9     NOP
  3910    C4B5     MOVFF 0x4b5, 0xfea
  3912    FFEA     NOP
  3914    52EE     MOVF 0xfee, F, ACCESS
  3916    CFEF     MOVFF 0xfef, 0x14
  3918    F014     NOP
  391A    6A15     CLRF 0x15, ACCESS
  391C    6A16     CLRF 0x16, ACCESS
  391E    6A17     CLRF 0x17, ACCESS
  3920    5014     MOVF 0x14, W, ACCESS
  3922    0104     MOVLB 0x4
  3924    5F77     SUBWF 0x77, F, BANKED
  3926    5015     MOVF 0x15, W, ACCESS
  3928    5B78     SUBWFB 0x78, F, BANKED
  392A    5016     MOVF 0x16, W, ACCESS
  392C    5B79     SUBWFB 0x79, F, BANKED
  392E    5017     MOVF 0x17, W, ACCESS
  3930    5B7A     SUBWFB 0x7a, F, BANKED
1036:                          ptrNextData += MSD_OUT_EP_SIZE;
  3932    0E40     MOVLW 0x40
  3934    0104     MOVLB 0x4
  3936    27B2     ADDWF 0xb2, F, BANKED
  3938    0E00     MOVLW 0
  393A    23B3     ADDWFC 0xb3, F, BANKED
1037:                          
1038:                          MSDWriteState = MSD_WRITE10_RX_SECTOR;
  393C    0E03     MOVLW 0x3
1039:                          break;
  393E    D03A     BRA 0x39b4
1040:                      case MSD_WRITE10_SECTOR:
1041:                      {
1042:                          //Make sure that no error has been detected, before performing the write
1043:                          //operation.  If there was an error, skip the write operation, but allow
1044:                          //the TransferLength to continue decrementing, so that we can eventually
1045:                          //receive all OUT bytes that the host is planning on sending us.  Only
1046:                          //after that is complete will the host send the IN token for the CSW packet,
1047:                          //which will contain the bCSWStatus letting it know an error occurred.
1048:                    		if(msd_csw.bCSWStatus == 0x00)
  3940    0104     MOVLB 0x4
  3942    517B     MOVF 0x7b, W, BANKED
  3944    E12E     BNZ 0x39a2
1049:                    		{
1050:                        		if(LUNSectorWrite(LBA.Val, (BYTE*)&msd_buffer[0], (LBA.Val==0)?TRUE:FALSE) != TRUE)
  3946    0104     MOVLB 0x4
  3948    51BF     MOVF 0xbf, W, BANKED
  394A    11C0     IORWF 0xc0, W, BANKED
  394C    11C1     IORWF 0xc1, W, BANKED
  394E    11C2     IORWF 0xc2, W, BANKED
  3950    E102     BNZ 0x3956
  3952    0E01     MOVLW 0x1
  3954    D001     BRA 0x3958
  3956    0E00     MOVLW 0
  3958    6EE6     MOVWF 0xfe6, ACCESS
  395A    0E00     MOVLW 0
  395C    6EE6     MOVWF 0xfe6, ACCESS
  395E    0E06     MOVLW 0x6
  3960    6EE6     MOVWF 0xfe6, ACCESS
  3962    C4BF     MOVFF 0x4bf, 0xfe6
  3964    FFE6     NOP
  3966    C4C0     MOVFF 0x4c0, 0xfe6
  3968    FFE6     NOP
  396A    C4C1     MOVFF 0x4c1, 0xfe6
  396C    FFE6     NOP
  396E    C4C2     MOVFF 0x4c2, 0xfe6
  3970    FFE6     NOP
  3972    EC88     CALL 0x4910, 0
  3974    F024     NOP
  3976    6E14     MOVWF 0x14, ACCESS
  3978    0E07     MOVLW 0x7
  397A    5EE1     SUBWF 0xfe1, F, ACCESS
  397C    5014     MOVF 0x14, W, ACCESS
  397E    0801     SUBLW 0x1
  3980    E010     BZ 0x39a2
1051:                        		{
1052:                            		//The write operation failed for some reason.  Keep track of retry
1053:                            		//attempts and abort if repeated write attempts also fail.
1054:                  				if(MSDRetryAttempt < MSD_FAILED_WRITE_MAX_ATTEMPTS)
  3982    0E64     MOVLW 0x64
  3984    0104     MOVLB 0x4
  3986    5D7F     SUBWF 0x7f, W, BANKED
  3988    E202     BC 0x398e
1055:                  				{
1056:                  				    MSDRetryAttempt++;
  398A    2B7F     INCF 0x7f, F, BANKED
1057:                                      break;
  398C    D01A     BRA 0x39c2
1058:                  				}
1059:                  				else
1060:                  				{  
1061:                      				//Too many consecutive failed write attempts have occurred. 
1062:                      				//Need to give up and abandon the write attempt.
1063:                      				msd_csw.bCSWStatus=0x01;		// Error 0x01 Refer page#18
  398E    0104     MOVLB 0x4
  3990    0E01     MOVLW 0x1
  3992    6F7B     MOVWF 0x7b, BANKED
1064:                                                                      // of BOT specifications
1065:                                      //Set error status sense keys, so the host can check them later
1066:                                      //to determine how to proceed.
1067:                                      gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
  3994    0104     MOVLB 0x4
  3996    81A2     BSF 0xa2, 0, BANKED
  3998    83A2     BSF 0xa2, 0x1, BANKED
  399A    95A2     BCF 0xa2, 0x2, BANKED
  399C    97A2     BCF 0xa2, 0x3, BANKED
1068:                  			        gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
  399E    6BAC     CLRF 0xac, BANKED
1069:                  			        gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
  39A0    6BAD     CLRF 0xad, BANKED
1070:                                  }              		
1071:                        		}
1072:                    		}
1073:                    
1074:                          //One LBA is written (unless an error occurred).  Advance state
1075:                          //variables so we can eventually finish handling the CBW request.
1076:                    		LBA.Val++;				
  39A2    0104     MOVLB 0x4
  39A4    2BBF     INCF 0xbf, F, BANKED
  39A6    0E00     MOVLW 0
  39A8    23C0     ADDWFC 0xc0, F, BANKED
  39AA    23C1     ADDWFC 0xc1, F, BANKED
  39AC    23C2     ADDWFC 0xc2, F, BANKED
1077:                    		TransferLength.Val--;      
  39AE    07BD     DECF 0xbd, F, BANKED
  39B0    5BBE     SUBWFB 0xbe, F, BANKED
1078:                          MSDWriteState = MSD_WRITE10_BLOCK;
  39B2    0E01     MOVLW 0x1
  39B4    6F7E     MOVWF 0x7e, BANKED
1079:                          break;
  39B6    D005     BRA 0x39c2
1080:                      } 
1081:                      
1082:                      default:
1083:                          //Illegal condition which should not occur.  If for some reason it
1084:                          //does, try to let the host know know an error has occurred.
1085:                          msd_csw.bCSWStatus=0x02;    //Phase Error
  39B8    0104     MOVLB 0x4
  39BA    0E02     MOVLW 0x2
  39BC    6F7B     MOVWF 0x7b, BANKED
1086:                          MSDWriteState = MSD_WRITE10_WAIT;            
  39BE    0104     MOVLB 0x4
  39C0    6B7E     CLRF 0x7e, BANKED
1087:                  }
1088:                  
1089:                  return MSDWriteState;
  39C2    517E     MOVF 0x7e, W, BANKED
1090:              }
  39C4    0012     RETURN 0
1091:              
1092:              /******************************************************************************
1093:               	Function:
1094:               		void ResetSenseData(void)
1095:               		
1096:               	Description:
1097:               		This routine resets the Sense Data, initializing the
1098:               		structure RequestSenseResponse gblSenseData.
1099:               		
1100:               	PreCondition:
1101:               		None 
1102:               		
1103:               	Parameters:
1104:               		None
1105:               		
1106:               	Return Values:
1107:               		None
1108:               		
1109:               	Remarks:
1110:               		None
1111:               			
1112:                *****************************************************************************/
1113:              void ResetSenseData(void) 
1114:              {
1115:              	gblSenseData[LUN_INDEX].ResponseCode=S_CURRENT;
  39C6    0104     MOVLB 0x4
  39C8    91A0     BCF 0xa0, 0, BANKED
  39CA    93A0     BCF 0xa0, 0x1, BANKED
  39CC    95A0     BCF 0xa0, 0x2, BANKED
  39CE    97A0     BCF 0xa0, 0x3, BANKED
  39D0    89A0     BSF 0xa0, 0x4, BANKED
  39D2    8BA0     BSF 0xa0, 0x5, BANKED
  39D4    8DA0     BSF 0xa0, 0x6, BANKED
1116:              	gblSenseData[LUN_INDEX].VALID=0;			// no data in the information field
  39D6    9FA0     BCF 0xa0, 0x7, BANKED
1117:              	gblSenseData[LUN_INDEX].Obsolete=0x0;
  39D8    6BA1     CLRF 0xa1, BANKED
1118:              	gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
  39DA    91A2     BCF 0xa2, 0, BANKED
  39DC    93A2     BCF 0xa2, 0x1, BANKED
  39DE    95A2     BCF 0xa2, 0x2, BANKED
  39E0    97A2     BCF 0xa2, 0x3, BANKED
1119:              	//gblSenseData.Resv;
1120:              	gblSenseData[LUN_INDEX].ILI=0;
  39E2    9BA2     BCF 0xa2, 0x5, BANKED
1121:              	gblSenseData[LUN_INDEX].EOM=0;
  39E4    9DA2     BCF 0xa2, 0x6, BANKED
1122:              	gblSenseData[LUN_INDEX].FILEMARK=0;
  39E6    9FA2     BCF 0xa2, 0x7, BANKED
1123:              	gblSenseData[LUN_INDEX].InformationB0=0x00;
  39E8    6BA3     CLRF 0xa3, BANKED
1124:              	gblSenseData[LUN_INDEX].InformationB1=0x00;
  39EA    6BA4     CLRF 0xa4, BANKED
1125:              	gblSenseData[LUN_INDEX].InformationB2=0x00;
  39EC    6BA5     CLRF 0xa5, BANKED
1126:              	gblSenseData[LUN_INDEX].InformationB3=0x00;
  39EE    6BA6     CLRF 0xa6, BANKED
1127:              	gblSenseData[LUN_INDEX].AddSenseLen=0x0a;	// n-7 (n=17 (0..17))
  39F0    0E0A     MOVLW 0xa
  39F2    6FA7     MOVWF 0xa7, BANKED
1128:              	gblSenseData[LUN_INDEX].CmdSpecificInfo.Val=0x0;
  39F4    6BA8     CLRF 0xa8, BANKED
  39F6    6BA9     CLRF 0xa9, BANKED
  39F8    6BAA     CLRF 0xaa, BANKED
  39FA    6BAB     CLRF 0xab, BANKED
1129:              	gblSenseData[LUN_INDEX].ASC=0x0;
  39FC    6BAC     CLRF 0xac, BANKED
1130:              	gblSenseData[LUN_INDEX].ASCQ=0x0;
  39FE    6BAD     CLRF 0xad, BANKED
1131:              	gblSenseData[LUN_INDEX].FRUC=0x0;
  3A00    6BAE     CLRF 0xae, BANKED
1132:              	gblSenseData[LUN_INDEX].SenseKeySpecific[0]=0x0;
  3A02    6BAF     CLRF 0xaf, BANKED
1133:              	gblSenseData[LUN_INDEX].SenseKeySpecific[1]=0x0;
  3A04    6BB0     CLRF 0xb0, BANKED
1134:              	gblSenseData[LUN_INDEX].SenseKeySpecific[2]=0x0;
  3A06    6BB1     CLRF 0xb1, BANKED
1135:              }
  3A08    0012     RETURN 0
---  E:\Projects\DevPFG\Microchip\USB\usb_device.c  ----------------------------------------------
1:                 /********************************************************************
2:                   File Information:
3:                     FileName:     	usb_device.c
4:                     Dependencies:	See INCLUDES section
5:                     Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                     Hardware:		This code is natively intended to be used on Mirochip USB
7:                                     demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                     section) for list of available platforms.  The firmware may 
9:                                     be modified for use on other USB platforms by editing the
10:                    				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                    Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                    and C32 (for PIC32)
13:                    Company:		Microchip Technology, Inc.
14:                    
15:                    Software License Agreement:
16:                    
17:                    The software supplied herewith by Microchip Technology Incorporated
18:                    (the "Company") for its PICr Microcontroller is intended and
19:                    supplied to you, the Company's customer, for use solely and
20:                    exclusively on Microchip PIC Microcontroller products. The
21:                    software is owned by the Company and/or its supplier, and is
22:                    protected under applicable copyright laws. All rights are reserved.
23:                    Any use in violation of the foregoing restrictions may subject the
24:                    user to criminal sanctions under applicable laws, as well as to
25:                    civil liability for the breach of the terms and conditions of this
26:                    license.
27:                    
28:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                
35:                  Summary:
36:                    This file contains functions, macros, definitions, variables,
37:                    datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                    stack. This file should be included in projects that use the device stack. 
39:                    
40:                    This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                    directory.
42:                
43:                  Description:
44:                    USB Device Stack File
45:                    
46:                    This file contains functions, macros, definitions, variables,
47:                    datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                    stack. This file should be included in projects that use the device stack.
49:                    
50:                    This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                    directory.
52:                    
53:                    When including this file in a new project, this file can either be
54:                    referenced from the directory in which it was installed or copied
55:                    directly into the user application folder. If the first method is
56:                    chosen to keep the file located in the folder in which it is installed
57:                    then include paths need to be added so that the library and the
58:                    application both know where to reference each others files. If the
59:                    application folder is located in the same folder as the Microchip
60:                    folder (like the current demo folders), then the following include
61:                    paths need to be added to the application's project:
62:                    
63:                    .
64:                    ..\\..\\MicrochipInclude
65:                    
66:                    If a different directory structure is used, modify the paths as
67:                    required. An example using absolute paths instead of relative paths
68:                    would be the following:
69:                    
70:                    C:\\Microchip Solutions\\Microchip\\Include
71:                    
72:                    C:\\Microchip Solutions\\My Demo Application 
73:                
74:                ********************************************************************
75:                 File Description:
76:                
77:                 Change History:
78:                  Rev    Description
79:                  ----   -----------
80:                  2.6    Added USBCancelIO() function.  Moved and some stack
81:                         defintions to be more consistant with the host stack.
82:                
83:                  2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                         inability to transmit on an endpoint if using ping-pong
85:                         and an odd number of packets had been sent on that endpoint 
86:                
87:                  2.7    Fixed error where the USB error interrupt flag was not getting
88:                         cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                         http://www.microchip.com/forums/tm.aspx?m=479085
90:                
91:                         Fixed issue with dual role mode when device run in polling
92:                         mode.  Interrupts were remaining enabled after the host mode
93:                         operation was complete.  This was incompatible with polling
94:                         mode operation.
95:                
96:                         Changed how the bus sensing works.  In previous revisions it
97:                         was impossible to use the USBDeviceDetach to detach from the
98:                         bus if the bus voltage was still present.  This is now
99:                         possible.  It was also possible to move the device to the 
100:                        ATTACHED state in interrupt mode even if the bus voltage 
101:                        wasn't available.  This is now prohibited unless VBUS is
102:                        present.
103:                        
104:                        Improved error case handling when the host sends more OUT
105:                        bytes in a control transfer than the firmware was expecting
106:                        to receive (based on the size parameter when calling USBEP0Receive()).
107:                        
108:                        In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                        variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                        function.  
111:               
112:                 2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                        devices.
114:               
115:                        Fixed an error on 16-bit and 32-bit processors where a word access
116:                        could be performed on a byte pointer resulting in possible address
117:                        errors with odd aligned pointers.
118:                        
119:                 2.8    Several changes to the way control transfers get processed,
120:                        so as to support the ability to allow application/class specific
121:                        handler code to defer the status stage.  
122:                        Implemented USBCtrlEPAllowStatusStage() API function.
123:                        Implemented USBDeferStatusStage() API function (macro).
124:                        These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                        requirement, while allowing USB class handlers more flexibility.
126:                        
127:                        Also implemented the following API functions and macros, for delaying 
128:                        the data stage of a control transfer (with data stage):
129:                        USBDeferINDataStage()
130:                        USBDeferOUTDataStage()
131:                        USBOUTDataStageDeferred()
132:                        USBINDataStageDeferred()
133:                        USBCtrlEPAllowDataStage()      
134:                        
135:                        Fixed USB reset event handler issue, where the USB stack would 
136:                        re-initialize global interrupt settings in the interrupt context, on 
137:                        PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                        
139:                        Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                        Previous implementation would not always initialize endpoints correctly 
141:                        to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                        all ping pong mode and usage scenarios.
143:               ********************************************************************/
144:               
145:               /*----------------------------------------------------------------------------------
146:               The USBDeviceTasks() function is responsible for detecting and processing various
147:               USB bus events and host requests, such as those required for USB enumeration, when
148:               the USB cable is first attached to the host.  This function is the main dispatcher
149:               routine for the USB stack.
150:               
151:               Additional API functions and macros are also provided by the USB stack, which can be 
152:               used to send/receive USB data to/from the host, among other things.  A full list 
153:               of the available implemented functions/macros are provided in the 
154:               "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
155:               the USB API documentation can be found from:
156:               
157:               Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
158:               
159:               Once the help file is opened, the API functions/macros are described in the following section:
160:               Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
161:               Additional API functions may also be provided depending upon the specific USB device class
162:               implemented, and these functions are also documented in the MCHPFSUSB Library Help.
163:               
164:               
165:               If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
166:               usb_config.h), then the application firmware is reponsible for calling the 
167:               USBDeviceTasks() function periodically.  If the USB stack is operated in the 
168:               "USB_INTERRUPT" mode, then the application firmware does not have to directly 
169:               call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
170:               
171:               In order to properly operate a USB connection, and to correctly process and respond
172:               to control transfers in the maximum time allowed by the USB specifications, the
173:               USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
174:               fashion.
175:               
176:               When the USB module is enabled, the USB cable is attached to the host, the USB bus
177:               is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
178:               with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
179:               time between calls to the USBDeviceTasks() function needs to be:
180:               
181:               The faster of:
182:               1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
183:               2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
184:               3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
185:               
186:               Additional details of the above timing limits are provided:
187:               
188:               Timing item #1: This parameter originates from the 2ms set address "recovery interval"
189:               specification dictated by section "9.2.6.3 Set Address Processing" of the official 
190:               USB 2.0 specifications.
191:               
192:               Timing item #2: This parameter originates from several "10 ms" criteria in the 
193:               USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
194:               intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
195:               
196:               Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
197:               transaction rate implemented by the application.  The USBDeviceTasks() function is
198:               responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
199:               then no further USB transactions are allowed to occur, until the firmware pops entries
200:               off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
201:               a rate at least as fast as once every three times the USBTransferOnePacket() function
202:               is called.  This ensures that the rate that USTAT FIFO entries are getting added to
203:               the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
204:               USBDeviceTasks() function will pop up to 4 entries per call), which is a
205:               necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
206:               USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
207:               USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
208:               and is therefore recommended.
209:               
210:               When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
211:               parameters should be interpreted to be the longest allowed time that the USB 
212:               interrupts may be masked/disabled for, before re-enabling the USB interrupts.
213:               
214:               Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
215:               will still have potential USB data rate speed and processing latency benefits.
216:               It is also beneficial to call USBDeviceTasks() more often than theoretically 
217:               required, since it has been observed that not all host/drivers/bios/hubs are 
218:               100% consistently compliant with all timing parameters of the USB 2.0 specifications.
219:               Therefore, in a USB_POLLING based application, it is still suggested to call 
220:               USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
221:               performance, along with best possible compatibility with all existing USB 
222:               hosts/hubs (both those that are compliant and [partially] non-compliant).
223:               
224:               If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
225:               to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
226:               per 100us, or preferrably faster).  Therefore, in all applications, it is 
227:               normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
228:               USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
229:               allow for much more relaxed timing requirements, and therefore greater application
230:               firmware design flexibility.
231:               //----------------------------------------------------------------------------------*/
232:               
233:               /** INCLUDES *******************************************************/
234:               #include "./USB/USB.h"
235:               #include "HardwareProfile.h"
236:               
237:               #include "../USB/usb_device_local.h"
238:               
239:               
240:               #if defined(USB_USE_MSD)
241:                   #include "./USB/usb_function_msd.h"
242:               #endif
243:               
244:               #if !defined(USE_USB_BUS_SENSE_IO)
245:                   #undef USB_BUS_SENSE
246:                   #define USB_BUS_SENSE 1
247:               #endif
248:               
249:               /** Definitions ****************************************************/
250:               
251:               /** VARIABLES ******************************************************/
252:               #pragma udata
253:               
254:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
255:               USB_VOLATILE BYTE USBActiveConfiguration;
256:               USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
257:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
258:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
259:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
260:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
261:               USB_VOLATILE BYTE shortPacketStatus;
262:               USB_VOLATILE BYTE controlTransferState;
263:               USB_VOLATILE IN_PIPE inPipes[1];
264:               USB_VOLATILE OUT_PIPE outPipes[1];
265:               USB_VOLATILE BYTE *pDst;
266:               USB_VOLATILE BOOL RemoteWakeup;
267:               USB_VOLATILE BOOL USBBusIsSuspended;
268:               USB_VOLATILE USTAT_FIELDS USTATcopy;
269:               USB_VOLATILE BYTE endpoint_number;
270:               USB_VOLATILE BOOL BothEP0OutUOWNsSet;
271:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
272:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
273:               USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
274:               volatile BOOL USBDeferStatusStagePacket;
275:               volatile BOOL USBStatusStageEnabledFlag1;
276:               volatile BOOL USBStatusStageEnabledFlag2;
277:               volatile BOOL USBDeferINDataStagePackets;
278:               volatile BOOL USBDeferOUTDataStagePackets;
279:               
280:               
281:               /** USB FIXED LOCATION VARIABLES ***********************************/
282:               #if defined(__18CXX)
283:                   #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50)
284:                       #pragma udata USB_BDT=0x200     //See Linker Script, BDT in bank 2 on these devices - usb2:0x200-0x2FF(256-byte)
285:                   #elif defined(__18F47J53) || defined(__18F46J53) || defined(__18F27J53) || defined(__18F26J53) || defined(__18LF47J53) || defined(__18LF46J53) || defined(__18LF27J53) || defined(__18LF26J53)
286:               		#pragma udata USB_BDT=0xD00		//BDT in Bank 13 on these devices
287:                   #else
288:                       #pragma udata USB_BDT=0x400     //All other PIC18 devices place the BDT in usb4:0x400-0x4FF(256-byte)
289:               	#endif
290:               #endif
291:               
292:               /********************************************************************
293:                * Section A: Buffer Descriptor Table
294:                * - 256 bytes max.  Actual size depends on number of endpoints enabled and 
295:                *   the ping pong buffering mode.
296:                * - USB_MAX_EP_NUMBER is defined in usb_config.h
297:                *******************************************************************/
298:               #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
299:                   volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 2] __attribute__ ((aligned (512)));
300:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
301:                   volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 2)+1] __attribute__ ((aligned (512)));
302:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
303:                   volatile BDT_ENTRY BDT[(USB_MAX_EP_NUMBER + 1) * 4] __attribute__ ((aligned (512)));
304:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
305:                   volatile BDT_ENTRY BDT[((USB_MAX_EP_NUMBER + 1) * 4)-2] __attribute__ ((aligned (512)));
306:               #else
307:                   #error "No ping pong mode defined."
308:               #endif
309:               
310:               /********************************************************************
311:                * Section B: EP0 Buffer Space
312:                *******************************************************************/
313:               volatile CTRL_TRF_SETUP SetupPkt;           // 8-byte only
314:               volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE];
315:               
316:               /********************************************************************
317:                * Section C: non-EP0 Buffer Space
318:                *******************************************************************/
319:               // Can provide compile time option to do software pingpong
320:               #if defined(USB_USE_HID)
321:                   volatile unsigned char hid_report_out[HID_INT_OUT_EP_SIZE];
322:                   volatile unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
323:               #endif
324:               
325:               #if defined(USB_USE_MSD)
326:               	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
327:               	volatile USB_MSD_CBW msd_cbw;
328:               	volatile USB_MSD_CSW msd_csw;
329:               	//#pragma udata
330:               
331:               	#if defined(__18CXX)
332:               		#pragma udata myMSD=MSD_BUFFER_ADDRESS
333:               	#endif
334:               	volatile char msd_buffer[512];
335:               #endif
336:               
337:               #if defined(__18CXX)
338:               #pragma udata
339:               #endif
340:               
341:               ////Depricated in v2.2 - will be removed in a future revision
342:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
343:                   //Device descriptor
344:                   extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
345:               #else
346:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
347:               #endif
348:               
349:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
350:                   //Array of configuration descriptors
351:                   extern ROM BYTE *ROM USB_CD_Ptr[];
352:               #else
353:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
354:               #endif
355:               
356:               extern ROM BYTE *ROM USB_SD_Ptr[];
357:               
358:               /** DECLARATIONS ***************************************************/
359:               #pragma code
360:               
361:               /** Macros *********************************************************/
362:               
363:               /** Function Prototypes ********************************************/
364:               //External
365:               //This is the prototype for the required user event handler
366:               BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size);
367:               
368:               //Internal Functions
369:               static void USBCtrlEPService(void);
370:               static void USBCtrlTrfSetupHandler(void);
371:               static void USBCtrlTrfInHandler(void);
372:               static void USBCheckStdRequest(void);
373:               static void USBStdGetDscHandler(void);
374:               static void USBCtrlEPServiceComplete(void);
375:               static void USBCtrlTrfTxService(void);
376:               static void USBCtrlTrfRxService(void);
377:               static void USBStdSetCfgHandler(void);
378:               static void USBStdGetStatusHandler(void);
379:               static void USBStdFeatureReqHandler(void);
380:               static void USBCtrlTrfOutHandler(void);
381:               static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
382:               static void USBWakeFromSuspend(void);
383:               static void USBSuspend(void);
384:               static void USBStallHandler(void);
385:               
386:               //static BOOL USBIsTxBusy(BYTE EPNumber);
387:               //static void USBPut(BYTE EPNum, BYTE Data);
388:               //static void USBEPService(void);
389:               //static void USBProtocolResetHandler(void);
390:               
391:               /******************************************************************************/
392:               /** Functions Implementations *************************************************/
393:               /******************************************************************************/
394:               
395:               //DOM-IGNORE-BEGIN
396:               /****************************************************************************
397:                 Function:
398:                   void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
399:               
400:                 Description:
401:                   This function will advance the passed pointer to the next buffer based on
402:                   the ping pong option setting.  This function should be used for EP1-EP15
403:                   only.  This function is not valid for EP0.
404:               
405:                 Precondition:
406:                   None
407:               
408:                 Parameters:
409:                   BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
410:                   to the next buffer state
411:               
412:                 Return Values:
413:                   None
414:               
415:                 Remarks:
416:                   None
417:               
418:                 ***************************************************************************/
419:               //DOM-IGNORE-END
420:               #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
421:               #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
422:               #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
423:               
424:               //DOM-IGNORE-BEGIN
425:               /****************************************************************************
426:                 Function:
427:                   void USBDeviceInit(void)
428:               
429:                 Description:
430:                   This function initializes the device stack
431:                   it in the default state
432:               
433:                 Precondition:
434:                   None
435:               
436:                 Parameters:
437:                   None
438:               
439:                 Return Values:
440:                   None
441:               
442:                 Remarks:
443:                   The USB module will be completely reset including
444:                   all of the internal variables, registers, and
445:                   interrupt flags.
446:                 ***************************************************************************/
447:               //DOM-IGNORE-END
448:               void USBDeviceInit(void)
  1044    CFD9     MOVFF 0xfd9, 0xfe6
  1046    FFE6     NOP
  1048    CFE1     MOVFF 0xfe1, 0xfd9
  104A    FFD9     NOP
  104C    52E6     MOVF 0xfe6, F, ACCESS
449:               {
450:                   BYTE i;
451:               
452:                   USBDisableInterrupts();
  104E    98A0     BCF 0xfa0, 0x4, ACCESS
453:               
454:                   // Clear all USB error flags
455:                   USBClearInterruptRegister(U1EIR);  
  1050    6A63     CLRF 0xf63, ACCESS
456:                      
457:                   // Clears all USB interrupts          
458:                   USBClearInterruptRegister(U1IR); 
  1052    6A62     CLRF 0xf62, ACCESS
459:               
460:                   //Clear all of the endpoint control registers
461:                   U1EP0 = 0;
  1054    010F     MOVLB 0xf
  1056    6B26     CLRF 0x26, BANKED
462:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
  1058    0E03     MOVLW 0x3
  105A    6EE6     MOVWF 0xfe6, ACCESS
  105C    6AE6     CLRF 0xfe6, ACCESS
  105E    6AE6     CLRF 0xfe6, ACCESS
  1060    0E27     MOVLW 0x27
  1062    6EE6     MOVWF 0xfe6, ACCESS
  1064    0E0F     MOVLW 0xf
  1066    6EE6     MOVWF 0xfe6, ACCESS
  1068    EC9E     CALL 0x4d3c, 0
  106A    F026     NOP
  106C    6E14     MOVWF 0x14, ACCESS
  106E    0E05     MOVLW 0x5
  1070    5EE1     SUBWF 0xfe1, F, ACCESS
  1072    5014     MOVF 0x14, W, ACCESS
463:               
464:                   SetConfigurationOptions();
  1074    010F     MOVLB 0xf
  1076    0E16     MOVLW 0x16
  1078    6F39     MOVWF 0x39, BANKED
  107A    0E9F     MOVLW 0x9f
  107C    6F37     MOVWF 0x37, BANKED
  107E    0E7B     MOVLW 0x7b
  1080    6F36     MOVWF 0x36, BANKED
465:               
466:                   //power up the module (if not already powered)
467:                   USBPowerModule();
468:               
469:                   //set the address of the BDT (if applicable)
470:                   USBSetBDTAddress(BDT);
471:               
472:                   //Clear all of the BDT entries
473:                   for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
  1082    6ADF     CLRF 0xfdf, ACCESS
  1084    50DF     MOVF 0xfdf, W, ACCESS
  1086    6E14     MOVWF 0x14, ACCESS
  1088    6A15     CLRF 0x15, ACCESS
  108A    0E10     MOVLW 0x10
  108C    5C14     SUBWF 0x14, W, ACCESS
  108E    0E00     MOVLW 0
  1090    5815     SUBWFB 0x15, W, ACCESS
  1092    E210     BC 0x10b4
  10B0    2ADF     INCF 0xfdf, F, ACCESS
  10B2    D7E8     BRA 0x1084
474:                   {
475:                       BDT[i].Val = 0x00;
  1094    50DF     MOVF 0xfdf, W, ACCESS
  1096    0D04     MULLW 0x4
  1098    CFF3     MOVFF 0xff3, 0xfe9
  109A    FFE9     NOP
  109C    CFF4     MOVFF 0xff4, 0xfea
  109E    FFEA     NOP
  10A0    0E00     MOVLW 0
  10A2    26E9     ADDWF 0xfe9, F, ACCESS
  10A4    0E04     MOVLW 0x4
  10A6    22EA     ADDWFC 0xfea, F, ACCESS
  10A8    6AEE     CLRF 0xfee, ACCESS
  10AA    6AEE     CLRF 0xfee, ACCESS
  10AC    6AEE     CLRF 0xfee, ACCESS
  10AE    6AEE     CLRF 0xfee, ACCESS
476:                   }
477:               
478:                   // Assert reset request to all of the Ping Pong buffer pointers
479:                   USBPingPongBufferReset = 1;                    
  10B4    8C65     BSF 0xf65, 0x6, ACCESS
480:               
481:                   // Reset to default address
482:                   U1ADDR = 0x00;                   
  10B6    010F     MOVLB 0xf
  10B8    6B38     CLRF 0x38, BANKED
483:               
484:                   // Make sure packet processing is enabled
485:                   USBPacketDisable = 0;           
  10BA    9865     BCF 0xf65, 0x4, ACCESS
486:               
487:                   //Stop trying to reset ping pong buffer pointers
488:                   USBPingPongBufferReset = 0;
  10BC    9C65     BCF 0xf65, 0x6, ACCESS
489:               
490:                   // Flush any pending transactions
491:                   while(USBTransactionCompleteIF == 1)      
  10BE    A662     BTFSS 0xf62, 0x3, ACCESS
  10C0    D007     BRA 0x10d0
  10CE    D7F7     BRA 0x10be
492:                   {
493:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
  10C2    9662     BCF 0xf62, 0x3, ACCESS
494:                       //Initialize USB stack software state variables
495:                       inPipes[0].info.Val = 0;
  10C4    0100     MOVLB 0
  10C6    6B7C     CLRF 0x7c, BANKED
496:                       outPipes[0].info.Val = 0;
  10C8    6B81     CLRF 0x81, BANKED
497:                       outPipes[0].wCount.Val = 0;
  10CA    6B82     CLRF 0x82, BANKED
  10CC    6B83     CLRF 0x83, BANKED
498:                   }
499:               
500:                   //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
501:                   //try and arm a status stage, even before the first control transfer starts.
502:                   USBStatusStageEnabledFlag1 = TRUE;  
  10D0    0100     MOVLB 0
  10D2    0E01     MOVLW 0x1
  10D4    6F98     MOVWF 0x98, BANKED
503:                   USBStatusStageEnabledFlag2 = TRUE;
  10D6    6F99     MOVWF 0x99, BANKED
504:                   //Initialize other flags
505:                   USBDeferINDataStagePackets = FALSE;
  10D8    6B9A     CLRF 0x9a, BANKED
506:                   USBDeferOUTDataStagePackets = FALSE;
  10DA    6B9B     CLRF 0x9b, BANKED
507:                   USBBusIsSuspended = FALSE;
  10DC    6B8A     CLRF 0x8a, BANKED
508:               
509:               	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
510:               	//pointers to NULL, so they don't get used inadvertently.  
511:               	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
  10DE    6ADF     CLRF 0xfdf, ACCESS
  10E0    0E04     MOVLW 0x4
  10E2    5CDF     SUBWF 0xfdf, W, ACCESS
  10E4    E226     BC 0x1132
  112E    2ADF     INCF 0xfdf, F, ACCESS
  1130    D7D7     BRA 0x10e0
512:               	{
513:               		pBDTEntryIn[i] = 0u;
  10E6    6AEA     CLRF 0xfea, ACCESS
  10E8    34DF     RLCF 0xfdf, W, ACCESS
  10EA    0BFE     ANDLW 0xfe
  10EC    36EA     RLCF 0xfea, F, ACCESS
  10EE    6EE9     MOVWF 0xfe9, ACCESS
  10F0    0E6F     MOVLW 0x6f
  10F2    26E9     ADDWF 0xfe9, F, ACCESS
  10F4    0E00     MOVLW 0
  10F6    22EA     ADDWFC 0xfea, F, ACCESS
  10F8    6AEE     CLRF 0xfee, ACCESS
  10FA    6AED     CLRF 0xfed, ACCESS
514:               		pBDTEntryOut[i] = 0u;		
  10FC    6AEA     CLRF 0xfea, ACCESS
  10FE    34DF     RLCF 0xfdf, W, ACCESS
  1100    0BFE     ANDLW 0xfe
  1102    36EA     RLCF 0xfea, F, ACCESS
  1104    6EE9     MOVWF 0xfe9, ACCESS
  1106    0E67     MOVLW 0x67
  1108    26E9     ADDWF 0xfe9, F, ACCESS
  110A    0E00     MOVLW 0
  110C    22EA     ADDWFC 0xfea, F, ACCESS
  110E    6AEE     CLRF 0xfee, ACCESS
  1110    6AED     CLRF 0xfed, ACCESS
515:               		ep_data_in[i].Val = 0u;
  1112    50DF     MOVF 0xfdf, W, ACCESS
  1114    6AEA     CLRF 0xfea, ACCESS
  1116    0F8E     ADDLW 0x8e
  1118    6EE9     MOVWF 0xfe9, ACCESS
  111A    0E00     MOVLW 0
  111C    22EA     ADDWFC 0xfea, F, ACCESS
  111E    6AEF     CLRF 0xfef, ACCESS
516:                       ep_data_out[i].Val = 0u;
  1120    50DF     MOVF 0xfdf, W, ACCESS
  1122    6AEA     CLRF 0xfea, ACCESS
  1124    0F92     ADDLW 0x92
  1126    6EE9     MOVWF 0xfe9, ACCESS
  1128    0E00     MOVLW 0
  112A    22EA     ADDWFC 0xfea, F, ACCESS
  112C    6AEF     CLRF 0xfef, ACCESS
517:               	}
518:               
519:                   //Get ready for the first packet
520:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
  1132    0100     MOVLB 0
  1134    0E08     MOVLW 0x8
  1136    6F6F     MOVWF 0x6f, BANKED
  1138    0E04     MOVLW 0x4
  113A    6F70     MOVWF 0x70, BANKED
521:                   // Initialize EP0 as a Ctrl EP
522:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
  113C    010F     MOVLB 0xf
  113E    0E16     MOVLW 0x16
  1140    6F26     MOVWF 0x26, BANKED
523:               	//Prepare for the first SETUP on EP0 OUT
524:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
  1142    0104     MOVLB 0x4
  1144    0E40     MOVLW 0x40
  1146    6F02     MOVWF 0x2, BANKED
  1148    0E04     MOVLW 0x4
  114A    6F03     MOVWF 0x3, BANKED
525:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
  114C    0E08     MOVLW 0x8
  114E    6F01     MOVWF 0x1, BANKED
526:                   BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
  1150    0E84     MOVLW 0x84
  1152    6F00     MOVWF 0, BANKED
527:               
528:                   // Clear active configuration
529:                   USBActiveConfiguration = 0;     
  1154    0100     MOVLB 0
  1156    6B61     CLRF 0x61, BANKED
530:               
531:                   //Indicate that we are now in the detached state        
532:                   USBDeviceState = DETACHED_STATE;
  1158    6B60     CLRF 0x60, BANKED
533:               }
  115A    52E5     MOVF 0xfe5, F, ACCESS
  115C    52E5     MOVF 0xfe5, F, ACCESS
  115E    CFE7     MOVFF 0xfe7, 0xfd9
  1160    FFD9     NOP
  1162    0012     RETURN 0
534:               
535:               //DOM-IGNORE-BEGIN
536:               /****************************************************************************
537:                 Function:
538:                   void USBDeviceTasks(void)
539:               
540:                 Description:
541:                   This function is the main state machine of the 
542:                   USB device side stack.  This function should be
543:                   called periodically to receive and transmit
544:                   packets through the stack.  This function should
545:                   be called  preferably once every 100us 
546:                   during the enumeration process.  After the
547:                   enumeration process this function still needs to
548:                   be called periodically to respond to various
549:                   situations on the bus but is more relaxed in its
550:                   time requirements.  This function should also
551:                   be called at least as fast as the OUT data
552:                   expected from the PC.
553:               
554:                 Precondition:
555:                   None
556:               
557:                 Parameters:
558:                   None
559:               
560:                 Return Values:
561:                   None
562:               
563:                 Remarks:
564:                   None
565:                 ***************************************************************************/
566:               //DOM-IGNORE-END
567:               
568:               #if defined(USB_INTERRUPT) 
569:                 #if defined(__18CXX)
570:                   void USBDeviceTasks(void)
  1164    CFD9     MOVFF 0xfd9, 0xfe6
  1166    FFE6     NOP
  1168    CFE1     MOVFF 0xfe1, 0xfd9
  116A    FFD9     NOP
  116C    52E6     MOVF 0xfe6, F, ACCESS
571:                 #elif defined(__C30__)
572:                   void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
573:                 #elif defined(__PIC32MX__)
574:                   void __attribute__((interrupt(),vector(45))) _USB1Interrupt( void ) 
575:                 #endif
576:               #else
577:               void USBDeviceTasks(void)
578:               #endif
579:               {
580:                   BYTE i;
581:               
582:               #ifdef USB_SUPPORT_OTG
583:                   //SRP Time Out Check
584:                   if (USBOTGSRPIsReady())
585:                   {
586:                       if (USBT1MSECIF && USBT1MSECIE)
587:                       {
588:                           if (USBOTGGetSRPTimeOutFlag())
589:                           {
590:                               if (USBOTGIsSRPTimeOutExpired())
591:                               {
592:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
593:                               }       
594:                           }
595:               
596:                           //Clear Interrupt Flag
597:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
598:                       }
599:                   }
600:               #endif
601:               
602:                   #if defined(USB_POLLING)
603:                   //If the interrupt option is selected then the customer is required
604:                   //  to notify the stack when the device is attached or removed from the
605:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
606:                   if (USB_BUS_SENSE != 1)
607:                   {
608:                        // Disable module & detach from bus
609:                        U1CON = 0;             
610:               
611:                        // Mask all USB interrupts              
612:                        U1IE = 0;          
613:               
614:                        //Move to the detached state                  
615:                        USBDeviceState = DETACHED_STATE;
616:               
617:                        #ifdef  USB_SUPPORT_OTG    
618:                            //Disable D+ Pullup
619:                            U1OTGCONbits.DPPULUP = 0;
620:               
621:                            //Disable HNP
622:                            USBOTGDisableHnp();
623:               
624:                            //Deactivate HNP
625:                            USBOTGDeactivateHnp();
626:                            
627:                            //If ID Pin Changed State
628:                            if (USBIDIF && USBIDIE)
629:                            {  
630:                                //Re-detect & Initialize
631:                                 USBOTGInitialize();
632:               
633:                                 //Clear ID Interrupt Flag
634:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
635:                            }
636:                        #endif
637:               
638:                        #ifdef __C30__
639:                            //USBClearInterruptFlag(U1OTGIR, 3); 
640:                        #endif
641:                           //return so that we don't go through the rest of 
642:                           //the state machine
643:                        USBClearUSBInterrupt();
644:                        return;
645:                   }
646:               
647:               	#ifdef USB_SUPPORT_OTG
648:                   //If Session Is Started Then
649:                   else
650:               	{
651:                       //If SRP Is Ready
652:                       if (USBOTGSRPIsReady())
653:                       {   
654:                           //Clear SRPReady
655:                           USBOTGClearSRPReady();
656:               
657:                           //Clear SRP Timeout Flag
658:                           USBOTGClearSRPTimeOutFlag();
659:               
660:                           //Indicate Session Started
661:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
662:                       }
663:                   }
664:               	#endif	//#ifdef USB_SUPPORT_OTG
665:               
666:                   //if we are in the detached state
667:                   if(USBDeviceState == DETACHED_STATE)
668:                   {
669:               	    //Initialize register to known value
670:                       U1CON = 0;                          
671:               
672:                       // Mask all USB interrupts
673:                       U1IE = 0;                                
674:               
675:                       //Enable/set things like: pull ups, full/low-speed mode, 
676:                       //set the ping pong mode, and set internal transceiver
677:                       SetConfigurationOptions();
678:               
679:                       // Enable module & attach to bus
680:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
681:               
682:                       //moved to the attached state
683:                       USBDeviceState = ATTACHED_STATE;
684:               
685:                       #ifdef  USB_SUPPORT_OTG
686:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
687:                       #endif
688:                   }
689:               	#endif  //#if defined(USB_POLLING)
690:               
691:                   if(USBDeviceState == ATTACHED_STATE)
  116E    0100     MOVLB 0
  1170    0560     DECF 0x60, W, BANKED
  1172    E109     BNZ 0x1186
692:                   {
693:                       /*
694:                        * After enabling the USB module, it takes some time for the
695:                        * voltage on the D+ or D- line to rise high enough to get out
696:                        * of the SE0 condition. The USB Reset interrupt should not be
697:                        * unmasked until the SE0 condition is cleared. This helps
698:                        * prevent the firmware from misinterpreting this unique event
699:                        * as a USB bus reset from the USB host.
700:                        */
701:               
702:                       if(!USBSE0Event)
  1174    BA65     BTFSC 0xf65, 0x5, ACCESS
  1176    D007     BRA 0x1186
703:                       {
704:                           USBClearInterruptRegister(U1IR);// Clear all USB interrupts
  1178    6A62     CLRF 0xf62, ACCESS
705:                           #if defined(USB_POLLING)
706:                               U1IE=0;                        // Mask all USB interrupts
707:                           #endif
708:                           USBResetIE = 1;             // Unmask RESET interrupt
  117A    010F     MOVLB 0xf
  117C    8136     BSF 0x36, 0, BANKED
709:                           USBIdleIE = 1;             // Unmask IDLE interrupt
  117E    8936     BSF 0x36, 0x4, BANKED
710:                           USBDeviceState = POWERED_STATE;
  1180    0100     MOVLB 0
  1182    0E02     MOVLW 0x2
  1184    6F60     MOVWF 0x60, BANKED
711:                       }
712:                   }
713:               
714:                   #ifdef  USB_SUPPORT_OTG
715:                       //If ID Pin Changed State
716:                       if (USBIDIF && USBIDIE)
717:                       {  
718:                           //Re-detect & Initialize
719:                           USBOTGInitialize();
720:               
721:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
722:                       }
723:                   #endif
724:               
725:                   /*
726:                    * Task A: Service USB Activity Interrupt
727:                    */
728:                   if(USBActivityIF && USBActivityIE)
  1186    5062     MOVF 0xf62, W, ACCESS
  1188    0B04     ANDLW 0x4
  118A    E006     BZ 0x1198
  118C    010F     MOVLB 0xf
  118E    5136     MOVF 0x36, W, BANKED
  1190    0B04     ANDLW 0x4
  1192    E002     BZ 0x1198
729:                   {
730:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
  1194    9462     BCF 0xf62, 0x2, ACCESS
731:                       #if defined(USB_SUPPORT_OTG)
732:                           U1OTGIR = 0x10;        
733:                       #else
734:                           USBWakeFromSuspend();
  1196    D8CE     RCALL 0x1334
735:                       #endif
736:                   }
737:               
738:                   /*
739:                    * Pointless to continue servicing if the device is in suspend mode.
740:                    */
741:                   if(USBSuspendControl==1)
  1198    B265     BTFSC 0xf65, 0x1, ACCESS
  119A    D05C     BRA 0x1254
742:                   {
743:                       USBClearUSBInterrupt();
744:                       return;
745:                   }
746:               
747:                   /*
748:                    * Task B: Service USB Bus Reset Interrupt.
749:                    * When bus reset is received during suspend, ACTVIF will be set first,
750:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
751:                    * This is why URSTIF is checked after ACTVIF.
752:                    *
753:                    * The USB reset flag is masked when the USB state is in
754:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
755:                    * cause a USB reset event during these two states.
756:                    */
757:                   if(USBResetIF && USBResetIE)
  119C    5062     MOVF 0xf62, W, ACCESS
  119E    0B01     ANDLW 0x1
  11A0    E00A     BZ 0x11b6
  11A2    010F     MOVLB 0xf
  11A4    5136     MOVF 0x36, W, BANKED
  11A6    0B01     ANDLW 0x1
  11A8    E006     BZ 0x11b6
758:                   {
759:                       USBDeviceInit();
  11AA    DF4C     RCALL 0x1044
760:               
761:                       //Re-enable the interrupts since the USBDeviceInit() function will
762:                       //  disable them.  This will do nothing in a polling setup
763:                       USBUnmaskInterrupts();
  11AC    88A0     BSF 0xfa0, 0x4, ACCESS
764:               
765:                       USBDeviceState = DEFAULT_STATE;
  11AE    0100     MOVLB 0
  11B0    0E04     MOVLW 0x4
  11B2    6F60     MOVWF 0x60, BANKED
766:               
767:                       #ifdef USB_SUPPORT_OTG
768:                            //Disable HNP
769:                            USBOTGDisableHnp();
770:               
771:                            //Deactivate HNP
772:                            USBOTGDeactivateHnp();
773:                       #endif
774:               
775:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
  11B4    9062     BCF 0xf62, 0, ACCESS
776:                   }
777:               
778:                   /*
779:                    * Task C: Service other USB interrupts
780:                    */
781:                   if(USBIdleIF && USBIdleIE)
  11B6    5062     MOVF 0xf62, W, ACCESS
  11B8    0B10     ANDLW 0x10
  11BA    E006     BZ 0x11c8
  11BC    010F     MOVLB 0xf
  11BE    5136     MOVF 0x36, W, BANKED
  11C0    0B10     ANDLW 0x10
  11C2    E002     BZ 0x11c8
782:                   { 
783:                       #ifdef  USB_SUPPORT_OTG 
784:                           //If Suspended, Try to switch to Host
785:                           USBOTGSelectRole(ROLE_HOST);
786:                       #else
787:                           USBSuspend();
  11C4    D8A1     RCALL 0x1308
788:                       #endif
789:                       
790:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
  11C6    9862     BCF 0xf62, 0x4, ACCESS
791:                   }
792:               
793:                   if(USBSOFIF)
  11C8    AC62     BTFSS 0xf62, 0x6, ACCESS
  11CA    D01A     BRA 0x1200
794:                   {
795:                       if(USBSOFIE)
  11CC    010F     MOVLB 0xf
  11CE    AD36     BTFSS 0x36, 0x6, BANKED
  11D0    D00F     BRA 0x11f0
796:                       {
797:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
  11D2    0E01     MOVLW 0x1
  11D4    6EE6     MOVWF 0xfe6, ACCESS
  11D6    6AE6     CLRF 0xfe6, ACCESS
  11D8    0E00     MOVLW 0
  11DA    6EE6     MOVWF 0xfe6, ACCESS
  11DC    6AE6     CLRF 0xfe6, ACCESS
  11DE    0E73     MOVLW 0x73
  11E0    6EE6     MOVWF 0xfe6, ACCESS
  11E2    6AE6     CLRF 0xfe6, ACCESS
  11E4    ECA0     CALL 0x4340, 0
  11E6    F021     NOP
  11E8    6E14     MOVWF 0x14, ACCESS
  11EA    0E06     MOVLW 0x6
  11EC    5EE1     SUBWF 0xfe1, F, ACCESS
  11EE    5014     MOVF 0x14, W, ACCESS
798:                       }    
799:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
  11F0    9C62     BCF 0xf62, 0x6, ACCESS
800:                       
801:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
802:                           //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
803:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
804:                               #warning "Double click this message.  See inline code comments."
805:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
806:                               //not strictly needed in all applications (ex: those that never call 
807:                               //USBDeferStatusStage() and don't use host to device (OUT) control
808:                               //transfers with data stage).  
809:                               //However, if this feature is enabled and used, it requires a timer 
810:                               //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
811:                               //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
812:                               //packets at a 1ms rate, which generates SOFIF interrupts.
813:                               //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
814:                               //below.  However, the host does not send SOF packets to Low Speed devices.  
815:                               //Therefore, some other method  (ex: using a general purpose microcontroller 
816:                               //timer, such as Timer0) needs to be implemented to call and execute the below code
817:                               //at a once/1ms rate, in a low speed USB application.
818:                               //Note: Pre-condition to executing the below code: USBDeviceInit() should have
819:                               //been called at least once (since the last microcontroller reset/power up), 
820:                               //prior to executing the below code.
821:                           #endif
822:                           
823:                           //Decrement our status stage counter.
824:                           if(USBStatusStageTimeoutCounter != 0u)
  11F2    0100     MOVLB 0
  11F4    5196     MOVF 0x96, W, BANKED
  11F6    E001     BZ 0x11fa
825:                           {
826:                               USBStatusStageTimeoutCounter--;
  11F8    0796     DECF 0x96, F, BANKED
827:                           }
828:                           //Check if too much time has elapsed since progress was made in 
829:                           //processing the control transfer, without arming the status stage.  
830:                           //If so, auto-arm the status stage to ensure that the control 
831:                           //transfer can [eventually] complete, within the timing limits
832:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
833:                           if(USBStatusStageTimeoutCounter == 0)
  11FA    5196     MOVF 0x96, W, BANKED
  11FC    E101     BNZ 0x1200
834:                           {
835:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
  11FE    DB54     RCALL 0x18a8
836:                           } 
837:                       #endif
838:                   }
839:               
840:                   if(USBStallIF && USBStallIE)
  1200    5062     MOVF 0xf62, W, ACCESS
  1202    0B20     ANDLW 0x20
  1204    E005     BZ 0x1210
  1206    010F     MOVLB 0xf
  1208    5136     MOVF 0x36, W, BANKED
  120A    0B20     ANDLW 0x20
  120C    E001     BZ 0x1210
841:                   {
842:                       USBStallHandler();
  120E    D862     RCALL 0x12d4
843:                   }
844:               
845:                   if(USBErrorIF && USBErrorIE)
  1210    5062     MOVF 0xf62, W, ACCESS
  1212    0B02     ANDLW 0x2
  1214    E014     BZ 0x123e
  1216    010F     MOVLB 0xf
  1218    5136     MOVF 0x36, W, BANKED
  121A    0B02     ANDLW 0x2
  121C    E010     BZ 0x123e
846:                   {
847:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
  121E    0E01     MOVLW 0x1
  1220    6EE6     MOVWF 0xfe6, ACCESS
  1222    6AE6     CLRF 0xfe6, ACCESS
  1224    0E00     MOVLW 0
  1226    6EE6     MOVWF 0xfe6, ACCESS
  1228    6AE6     CLRF 0xfe6, ACCESS
  122A    68E6     SETF 0xfe6, ACCESS
  122C    0E7F     MOVLW 0x7f
  122E    6EE6     MOVWF 0xfe6, ACCESS
  1230    ECA0     CALL 0x4340, 0
  1232    F021     NOP
  1234    6E14     MOVWF 0x14, ACCESS
  1236    0E06     MOVLW 0x6
  1238    5EE1     SUBWF 0xfe1, F, ACCESS
  123A    5014     MOVF 0x14, W, ACCESS
848:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
  123C    6A63     CLRF 0xf63, ACCESS
849:               
850:                       //On PIC18 or PIC24F, clearing the source of the error will automatically
851:                       //  clear the interrupt flag.  On PIC32 the interrut flag must be manually
852:                       //  cleared. 
853:                       #if defined(__C32__) || defined(__C30__)
854:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
855:                       #endif
856:                   }
857:               
858:                   /*
859:                    * Pointless to continue servicing if the host has not sent a bus reset.
860:                    * Once bus reset is received, the device transitions into the DEFAULT
861:                    * state and is ready for communication.
862:                    */
863:                   if(USBDeviceState < DEFAULT_STATE)
  123E    0E04     MOVLW 0x4
  1240    0100     MOVLB 0
  1242    6EE7     MOVWF 0xfe7, ACCESS
  1244    1960     XORWF 0x60, W, BANKED
  1246    AEE8     BTFSS 0xfe8, 0x7, ACCESS
  1248    D002     BRA 0x124e
  124A    34E7     RLCF 0xfe7, W, ACCESS
  124C    D002     BRA 0x1252
  124E    50E7     MOVF 0xfe7, W, ACCESS
  1250    5D60     SUBWF 0x60, W, BANKED
  1252    E202     BC 0x1258
864:                   {
865:               	    USBClearUSBInterrupt();
  1254    98A1     BCF 0xfa1, 0x4, ACCESS
866:               	    return; 
  1256    D039     BRA 0x12ca
867:               	}  
868:               
869:                   /*
870:                    * Task D: Servicing USB Transaction Complete Interrupt
871:                    */
872:                   if(USBTransactionCompleteIE)
  1258    010F     MOVLB 0xf
  125A    A736     BTFSS 0x36, 0x3, BANKED
  125C    D035     BRA 0x12c8
873:                   {
874:               	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
  125E    6ADF     CLRF 0xfdf, ACCESS
  1260    0E04     MOVLW 0x4
  1262    5CDF     SUBWF 0xfdf, W, ACCESS
  1264    E231     BC 0x12c8
  12C4    2ADF     INCF 0xfdf, F, ACCESS
  12C6    D7CC     BRA 0x1260
875:               		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
876:               		    if(USBTransactionCompleteIF)
  1266    A662     BTFSS 0xf62, 0x3, ACCESS
  1268    D02F     BRA 0x12c8
877:               		    {
878:                   		    //Save and extract USTAT register info.  Will use this info later.
879:                               USTATcopy.Val = U1STAT;
  126A    CF64     MOVFF 0xf64, 0x8b
  126C    F08B     NOP
880:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
  126E    0100     MOVLB 0
  1270    518B     MOVF 0x8b, W, BANKED
  1272    0B78     ANDLW 0x78
  1274    42E8     RRNCF 0xfe8, F, ACCESS
  1276    42E8     RRNCF 0xfe8, F, ACCESS
  1278    42E8     RRNCF 0xfe8, F, ACCESS
  127A    6F8C     MOVWF 0x8c, BANKED
881:                               
882:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
  127C    9662     BCF 0xf62, 0x3, ACCESS
883:                               
884:                               //Keep track of the hardware ping pong state for endpoints other
885:                               //than EP0, if ping pong buffering is enabled.
886:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
887:                                   if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
  127E    B58B     BTFSC 0x8b, 0x2, BANKED
  1280    D006     BRA 0x128e
888:                                   {
889:                                       ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
  1282    518C     MOVF 0x8c, W, BANKED
  1284    6AEA     CLRF 0xfea, ACCESS
  1286    0F92     ADDLW 0x92
  1288    6EE9     MOVWF 0xfe9, ACCESS
  128A    0E00     MOVLW 0
890:                                   }   
891:                                   else
  128C    D005     BRA 0x1298
892:                                   {
893:                                       ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
  128E    518C     MOVF 0x8c, W, BANKED
  1290    6AEA     CLRF 0xfea, ACCESS
  1292    0F8E     ADDLW 0x8e
  1294    6EE9     MOVWF 0xfe9, ACCESS
  1296    0E00     MOVLW 0
  1298    22EA     ADDWFC 0xfea, F, ACCESS
  129A    70EF     BTG 0xfef, 0, ACCESS
894:                                   }         
895:                               #endif    
896:                               
897:                               //USBCtrlEPService only services transactions over EP0.
898:                               //It ignores all other EP transactions.
899:                               if(endpoint_number == 0)
  129C    518C     MOVF 0x8c, W, BANKED
  129E    E102     BNZ 0x12a4
900:                               {
901:                                   USBCtrlEPService();
  12A0    D861     RCALL 0x1364
902:                               }
903:                               else
  12A2    D010     BRA 0x12c4
904:                               {
905:                                   USB_TRASFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
  12A4    0E00     MOVLW 0
  12A6    6EE6     MOVWF 0xfe6, ACCESS
  12A8    6AE6     CLRF 0xfe6, ACCESS
  12AA    0E8B     MOVLW 0x8b
  12AC    6EE6     MOVWF 0xfe6, ACCESS
  12AE    0E00     MOVLW 0
  12B0    6EE6     MOVWF 0xfe6, ACCESS
  12B2    0E72     MOVLW 0x72
  12B4    6EE6     MOVWF 0xfe6, ACCESS
  12B6    6AE6     CLRF 0xfe6, ACCESS
  12B8    ECA0     CALL 0x4340, 0
  12BA    F021     NOP
  12BC    6E14     MOVWF 0x14, ACCESS
  12BE    0E06     MOVLW 0x6
  12C0    5EE1     SUBWF 0xfe1, F, ACCESS
  12C2    5014     MOVF 0x14, W, ACCESS
906:                               }
907:               		    }//end if(USBTransactionCompleteIF)
908:               		    else
909:               		    	break;	//USTAT FIFO must be empty.
910:               		}//end for()
911:               	}//end if(USBTransactionCompleteIE)   
912:               
913:                   USBClearUSBInterrupt();
  12C8    98A1     BCF 0xfa1, 0x4, ACCESS
914:               }//end of USBDeviceTasks()
  12CA    52E5     MOVF 0xfe5, F, ACCESS
  12CC    52E5     MOVF 0xfe5, F, ACCESS
  12CE    CFE7     MOVFF 0xfe7, 0xfd9
  12D0    FFD9     NOP
  12D2    0012     RETURN 0
915:               
916:               /********************************************************************
917:                * Function:        void USBStallHandler(void)
918:                *
919:                * PreCondition:    None
920:                *
921:                * Input:           None
922:                *
923:                * Output:          None
924:                *
925:                * Side Effects:    
926:                *
927:                * Overview:        This function handles the event of a STALL 
928:                *                  occuring on the bus
929:                *
930:                * Note:            None
931:                *******************************************************************/
932:               static void USBStallHandler(void)
933:               {
934:                   /*
935:                    * Does not really have to do anything here,
936:                    * even for the control endpoint.
937:                    * All BDs of Endpoint 0 are owned by SIE right now,
938:                    * but once a Setup Transaction is received, the ownership
939:                    * for EP0_OUT will be returned to CPU.
940:                    * When the Setup Transaction is serviced, the ownership
941:                    * for EP0_IN will then be forced back to CPU by firmware.
942:                    */
943:               
944:                   /* v2b fix */
945:                   if(U1EP0bits.EPSTALL == 1)
  12D4    010F     MOVLB 0xf
  12D6    A126     BTFSS 0x26, 0, BANKED
  12D8    D015     BRA 0x1304
946:                   {
947:                       // UOWN - if 0, owned by CPU, if 1, owned by SIE
948:                       if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
  12DA    C063     MOVFF 0x63, 0xfe9
  12DC    FFE9     NOP
  12DE    C064     MOVFF 0x64, 0xfea
  12E0    FFEA     NOP
  12E2    50EF     MOVF 0xfef, W, ACCESS
  12E4    0880     SUBLW 0x80
  12E6    E10D     BNZ 0x1302
  12E8    C06F     MOVFF 0x6f, 0xfe9
  12EA    FFE9     NOP
  12EC    C070     MOVFF 0x70, 0xfea
  12EE    FFEA     NOP
  12F0    50EF     MOVF 0xfef, W, ACCESS
  12F2    0884     SUBLW 0x84
  12F4    E106     BNZ 0x1302
949:                       {
950:                           // Set ep0Bo to stall also
951:                           pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
  12F6    C063     MOVFF 0x63, 0xfe9
  12F8    FFE9     NOP
  12FA    C064     MOVFF 0x64, 0xfea
  12FC    FFEA     NOP
  12FE    0E8C     MOVLW 0x8c
  1300    6EEF     MOVWF 0xfef, ACCESS
952:                       }//end if
953:                       U1EP0bits.EPSTALL = 0;               // Clear stall status
  1302    9126     BCF 0x26, 0, BANKED
954:                   }//end if
955:               
956:                   USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
  1304    9A62     BCF 0xf62, 0x5, ACCESS
957:               }
  1306    0012     RETURN 0
958:               
959:               /********************************************************************
960:                * Function:        void USBSuspend(void)
961:                *
962:                * PreCondition:    None
963:                *
964:                * Input:           None
965:                *
966:                * Output:          None
967:                *
968:                * Side Effects:    
969:                *
970:                * Overview:        This function handles if the host tries to 
971:                *                  suspend the device
972:                *
973:                * Note:            None
974:                *******************************************************************/
975:               static void USBSuspend(void)
976:               {
977:                   /*
978:                    * NOTE: Do not clear UIRbits.ACTVIF here!
979:                    * Reason:
980:                    * ACTVIF is only generated once an IDLEIF has been generated.
981:                    * This is a 1:1 ratio interrupt generation.
982:                    * For every IDLEIF, there will be only one ACTVIF regardless of
983:                    * the number of subsequent bus transitions.
984:                    *
985:                    * If the ACTIF is cleared here, a problem could occur when:
986:                    * [       IDLE       ][bus activity ->
987:                    * <--- 3 ms ----->     ^
988:                    *                ^     ACTVIF=1
989:                    *                IDLEIF=1
990:                    *  #           #           #           #   (#=Program polling flags)
991:                    *                          ^
992:                    *                          This polling loop will see both
993:                    *                          IDLEIF=1 and ACTVIF=1.
994:                    *                          However, the program services IDLEIF first
995:                    *                          because ACTIVIE=0.
996:                    *                          If this routine clears the only ACTIVIF,
997:                    *                          then it can never get out of the suspend
998:                    *                          mode.
999:                    */
1000:                  USBActivityIE = 1;                     // Enable bus activity interrupt
  1308    010F     MOVLB 0xf
  130A    8536     BSF 0x36, 0x2, BANKED
1001:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
  130C    9862     BCF 0xf62, 0x4, ACCESS
1002:              
1003:              #if defined(__18CXX)
1004:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
  130E    8265     BSF 0xf65, 0x1, ACCESS
1005:                                                          // mode, SIE clock inactive
1006:              #endif
1007:                  USBBusIsSuspended = TRUE;
  1310    0100     MOVLB 0
  1312    0E01     MOVLW 0x1
  1314    6F8A     MOVWF 0x8a, BANKED
1008:               
1009:                  /*
1010:                   * At this point the PIC can go into sleep,idle, or
1011:                   * switch to a slower clock, etc.  This should be done in the
1012:                   * USBCBSuspend() if necessary.
1013:                   */
1014:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
  1316    0E00     MOVLW 0
  1318    6EE6     MOVWF 0xfe6, ACCESS
  131A    6AE6     CLRF 0xfe6, ACCESS
  131C    6EE6     MOVWF 0xfe6, ACCESS
  131E    6AE6     CLRF 0xfe6, ACCESS
  1320    0E75     MOVLW 0x75
  1322    6EE6     MOVWF 0xfe6, ACCESS
  1324    6AE6     CLRF 0xfe6, ACCESS
  1326    ECA0     CALL 0x4340, 0
  1328    F021     NOP
  132A    6E14     MOVWF 0x14, ACCESS
  132C    0E06     MOVLW 0x6
  132E    5EE1     SUBWF 0xfe1, F, ACCESS
  1330    5014     MOVF 0x14, W, ACCESS
1015:              }
  1332    0012     RETURN 0
1016:              
1017:              /********************************************************************
1018:               * Function:        void USBWakeFromSuspend(void)
1019:               *
1020:               * PreCondition:    None
1021:               *
1022:               * Input:           None
1023:               *
1024:               * Output:          None
1025:               *
1026:               * Side Effects:    None
1027:               *
1028:               * Overview:
1029:               *
1030:               * Note:            None
1031:               *******************************************************************/
1032:              static void USBWakeFromSuspend(void)
1033:              {
1034:                  USBBusIsSuspended = FALSE;
  1334    0100     MOVLB 0
  1336    6B8A     CLRF 0x8a, BANKED
1035:              
1036:                  /*
1037:                   * If using clock switching, the place to restore the original
1038:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
1039:                   */
1040:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
  1338    0E00     MOVLW 0
  133A    6EE6     MOVWF 0xfe6, ACCESS
  133C    6AE6     CLRF 0xfe6, ACCESS
  133E    6EE6     MOVWF 0xfe6, ACCESS
  1340    6AE6     CLRF 0xfe6, ACCESS
  1342    0E74     MOVLW 0x74
  1344    6EE6     MOVWF 0xfe6, ACCESS
  1346    6AE6     CLRF 0xfe6, ACCESS
  1348    ECA0     CALL 0x4340, 0
  134A    F021     NOP
  134C    6E14     MOVWF 0x14, ACCESS
  134E    0E06     MOVLW 0x6
  1350    5EE1     SUBWF 0xfe1, F, ACCESS
  1352    5014     MOVF 0x14, W, ACCESS
1041:              
1042:                  #if defined(__18CXX)
1043:                      //To avoid improperly clocking the USB module, make sure the oscillator
1044:                      //settings are consistant with USB operation before clearing the SUSPND bit.
1045:                      //Make sure the correct oscillator settings are selected in the 
1046:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
1047:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
  1354    9265     BCF 0xf65, 0x1, ACCESS
1048:                                              // mode.
1049:                  #endif
1050:              
1051:              
1052:                  USBActivityIE = 0;
  1356    010F     MOVLB 0xf
  1358    9536     BCF 0x36, 0x2, BANKED
1053:              
1054:                  /********************************************************************
1055:                  Bug Fix: Feb 26, 2007 v2.1
1056:                  *********************************************************************
1057:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
1058:                  up from Suspend or while the USB module is suspended. A few clock cycles
1059:                  are required to synchronize the internal hardware state machine before
1060:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
1061:                  before the internal hardware is synchronized may not have an effect on
1062:                  the value of ACTVIF. Additonally, if the USB module uses the clock from
1063:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
1064:                  module may not be immediately operational while waiting for the 96 MHz
1065:                  PLL to lock.
1066:                  ********************************************************************/
1067:              
1068:                  // UIRbits.ACTVIF = 0;                      // Removed
1069:                  #if defined(__18CXX)
1070:                  while(USBActivityIF)
  135A    A462     BTFSS 0xf62, 0x2, ACCESS
  135C    D002     BRA 0x1362
  1360    D7FC     BRA 0x135a
1071:                  #endif
1072:                  {
1073:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
  135E    9462     BCF 0xf62, 0x2, ACCESS
1074:                  }  // Added
1075:              
1076:              }//end USBWakeFromSuspend
  1362    0012     RETURN 0
1077:              
1078:              /********************************************************************
1079:               * Function:        void USBCtrlEPService(void)
1080:               *
1081:               * PreCondition:    USTAT is loaded with a valid endpoint address.
1082:               *
1083:               * Input:           None
1084:               *
1085:               * Output:          None
1086:               *
1087:               * Side Effects:    None
1088:               *
1089:               * Overview:        USBCtrlEPService checks for three transaction
1090:               *                  types that it knows how to service and services
1091:               *                  them:
1092:               *                  1. EP0 SETUP
1093:               *                  2. EP0 OUT
1094:               *                  3. EP0 IN
1095:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
1096:               *
1097:               * Note:            None
1098:               *******************************************************************/
1099:              static void USBCtrlEPService(void)
  1364    CFD9     MOVFF 0xfd9, 0xfe6
  1366    FFE6     NOP
  1368    CFE1     MOVFF 0xfe1, 0xfd9
  136A    FFD9     NOP
  136C    52E6     MOVF 0xfe6, F, ACCESS
1100:              {
1101:                  //If we get to here, that means a successful transaction has just occurred 
1102:                  //on EP0.  This means "progress" has occurred in the currently pending 
1103:                  //control transfer, so we should re-initialize our timeout counter.
1104:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
1105:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
  136E    0100     MOVLB 0
  1370    0E2D     MOVLW 0x2d
  1372    6F96     MOVWF 0x96, BANKED
1106:                  #endif
1107:              	
1108:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
1109:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
  1374    0EFD     MOVLW 0xfd
  1376    158B     ANDWF 0x8b, W, BANKED
  1378    E153     BNZ 0x1420
1110:                  {
1111:              		//Point to the EP0 OUT buffer of the buffer that arrived
1112:                      #if defined(__18CXX)
1113:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
  137A    0E7E     MOVLW 0x7e
  137C    158B     ANDWF 0x8b, W, BANKED
  137E    40E8     RRNCF 0xfe8, W, ACCESS
  1380    0B7F     ANDLW 0x7f
  1382    0D04     MULLW 0x4
  1384    CFF3     MOVFF 0xff3, 0x63
  1386    F063     NOP
  1388    CFF4     MOVFF 0xff4, 0x64
  138A    F064     NOP
  138C    0E00     MOVLW 0
  138E    2763     ADDWF 0x63, F, BANKED
  1390    0E04     MOVLW 0x4
  1392    2364     ADDWFC 0x64, F, BANKED
1114:                      #elif defined(__C30__) || defined(__C32__)
1115:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
1116:                      #else
1117:                          #error "unimplemented"
1118:                      #endif
1119:              
1120:              		//Set the next out to the current out packet
1121:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
  1394    C063     MOVFF 0x63, 0x65
  1396    F065     NOP
  1398    C064     MOVFF 0x64, 0x66
  139A    F066     NOP
1122:              		//Toggle it to the next ping pong buffer (if applicable)
1123:                      ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
  139C    7565     BTG 0x65, 0x2, BANKED
1124:              
1125:              		//If the current EP0 OUT buffer has a SETUP packet
1126:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
  139E    C063     MOVFF 0x63, 0xfe9
  13A0    FFE9     NOP
  13A2    C064     MOVFF 0x64, 0xfea
  13A4    FFEA     NOP
  13A6    50EF     MOVF 0xfef, W, ACCESS
  13A8    0B3C     ANDLW 0x3c
  13AA    42E8     RRNCF 0xfe8, F, ACCESS
  13AC    42E8     RRNCF 0xfe8, F, ACCESS
  13AE    080D     SUBLW 0xd
  13B0    E135     BNZ 0x141c
1127:                      {
1128:                          unsigned char setup_cnt;
1129:              
1130:              	        //The SETUP transaction data may have gone into the the CtrlTrfData 
1131:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
1132:              	        //before the transaction.  Therefore, we should copy the data to the 
1133:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
1134:                          for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
  13B2    6ADF     CLRF 0xfdf, ACCESS
  13B4    0E08     MOVLW 0x8
  13B6    5CDF     SUBWF 0xfdf, W, ACCESS
  13B8    E223     BC 0x1400
  13FC    2ADF     INCF 0xfdf, F, ACCESS
  13FE    D7DA     BRA 0x13b4
1135:                          {
1136:                              *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
  13BA    C063     MOVFF 0x63, 0xfe9
  13BC    FFE9     NOP
  13BE    C064     MOVFF 0x64, 0xfea
  13C0    FFEA     NOP
  13C2    0E02     MOVLW 0x2
  13C4    26E9     ADDWF 0xfe9, F, ACCESS
  13C6    0E00     MOVLW 0
  13C8    22EA     ADDWFC 0xfea, F, ACCESS
  13CA    50EE     MOVF 0xfee, W, ACCESS
  13CC    CFEF     MOVFF 0xfef, 0xfea
  13CE    FFEA     NOP
  13D0    6EE9     MOVWF 0xfe9, ACCESS
  13D2    50EF     MOVF 0xfef, W, ACCESS
  13D4    6EE6     MOVWF 0xfe6, ACCESS
  13D6    50DF     MOVF 0xfdf, W, ACCESS
  13D8    6AEA     CLRF 0xfea, ACCESS
  13DA    0F40     ADDLW 0x40
  13DC    6EE9     MOVWF 0xfe9, ACCESS
  13DE    0E04     MOVLW 0x4
  13E0    22EA     ADDWFC 0xfea, F, ACCESS
  13E2    52E5     MOVF 0xfe5, F, ACCESS
  13E4    50E7     MOVF 0xfe7, W, ACCESS
  13E6    6EEF     MOVWF 0xfef, ACCESS
1137:                              pBDTEntryEP0OutCurrent->ADR++;
  13E8    C063     MOVFF 0x63, 0xfe9
  13EA    FFE9     NOP
  13EC    C064     MOVFF 0x64, 0xfea
  13EE    FFEA     NOP
  13F0    0E02     MOVLW 0x2
  13F2    26E9     ADDWF 0xfe9, F, ACCESS
  13F4    0E00     MOVLW 0
  13F6    22EA     ADDWFC 0xfea, F, ACCESS
  13F8    2AEE     INCF 0xfee, F, ACCESS
  13FA    22EF     ADDWFC 0xfef, F, ACCESS
1138:                          }    
1139:                          pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
  1400    C063     MOVFF 0x63, 0xfe9
  1402    FFE9     NOP
  1404    C064     MOVFF 0x64, 0xfea
  1406    FFEA     NOP
  1408    0E02     MOVLW 0x2
  140A    26E9     ADDWF 0xfe9, F, ACCESS
  140C    0E00     MOVLW 0
  140E    22EA     ADDWFC 0xfea, F, ACCESS
  1410    0E40     MOVLW 0x40
  1412    6EEE     MOVWF 0xfee, ACCESS
  1414    0E04     MOVLW 0x4
  1416    6EED     MOVWF 0xfed, ACCESS
1140:              
1141:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
1142:                          USBCtrlTrfSetupHandler();
  1418    D80D     RCALL 0x1434
1143:                      }
1144:                      else
  141A    D007     BRA 0x142a
1145:                      {
1146:              			//Handle the DATA transfer
1147:                          USBCtrlTrfOutHandler();
  141C    D83A     RCALL 0x1492
1148:                      }
1149:                  }
1150:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
  141E    D005     BRA 0x142a
  1420    0EFD     MOVLW 0xfd
  1422    158B     ANDWF 0x8b, W, BANKED
  1424    0804     SUBLW 0x4
  1426    E101     BNZ 0x142a
1151:                  {
1152:              		//Otherwise the transmission was and EP0 IN
1153:              		//  so take care of the IN transfer
1154:                      USBCtrlTrfInHandler();
  1428    D859     RCALL 0x14dc
1155:                  }
1156:              
1157:              }//end USBCtrlEPService
  142A    52E5     MOVF 0xfe5, F, ACCESS
  142C    52E5     MOVF 0xfe5, F, ACCESS
  142E    CFE7     MOVFF 0xfe7, 0xfd9
  1430    FFD9     NOP
  1432    0012     RETURN 0
1158:              
1159:              /********************************************************************
1160:               * Function:        void USBCtrlTrfSetupHandler(void)
1161:               *
1162:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
1163:               *
1164:               * Input:           None
1165:               *
1166:               * Output:          None
1167:               *
1168:               * Side Effects:    None
1169:               *
1170:               * Overview:        This routine is a task dispatcher and has 3 stages.
1171:               *                  1. It initializes the control transfer state machine.
1172:               *                  2. It calls on each of the module that may know how to
1173:               *                     service the Setup Request from the host.
1174:               *                     Module Example: USBD, HID, CDC, MSD, ...
1175:               *                     A callback function, USBCBCheckOtherReq(),
1176:               *                     is required to call other module handlers.
1177:               *                  3. Once each of the modules has had a chance to check if
1178:               *                     it is responsible for servicing the request, stage 3
1179:               *                     then checks direction of the transfer to determine how
1180:               *                     to prepare EP0 for the control transfer.
1181:               *                     Refer to USBCtrlEPServiceComplete() for more details.
1182:               *
1183:               * Note:            Microchip USB Firmware has three different states for
1184:               *                  the control transfer state machine:
1185:               *                  1. WAIT_SETUP
1186:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
1187:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
1188:               *                  Refer to firmware manual to find out how one state
1189:               *                  is transitioned to another.
1190:               *
1191:               *                  A Control Transfer is composed of many USB transactions.
1192:               *                  When transferring data over multiple transactions,
1193:               *                  it is important to keep track of data source, data
1194:               *                  destination, and data count. These three parameters are
1195:               *                  stored in pSrc,pDst, and wCount. A flag is used to
1196:               *                  note if the data source is from ROM or RAM.
1197:               *
1198:               *******************************************************************/
1199:              static void USBCtrlTrfSetupHandler(void)
1200:              {
1201:                  //--------------------------------------------------------------------------
1202:                  //1. Re-initialize state tracking variables related to control transfers.
1203:                  //--------------------------------------------------------------------------
1204:                  shortPacketStatus = SHORT_PKT_NOT_USED;  
  1434    0100     MOVLB 0
  1436    6B77     CLRF 0x77, BANKED
1205:                  USBDeferStatusStagePacket = FALSE;
  1438    6B97     CLRF 0x97, BANKED
1206:                  USBDeferINDataStagePackets = FALSE;
  143A    6B9A     CLRF 0x9a, BANKED
1207:                  USBDeferOUTDataStagePackets = FALSE;
  143C    6B9B     CLRF 0x9b, BANKED
1208:                  BothEP0OutUOWNsSet = FALSE;    
  143E    6B8D     CLRF 0x8d, BANKED
1209:                  controlTransferState = WAIT_SETUP;
  1440    6B78     CLRF 0x78, BANKED
1210:              
1211:                  //Abandon any previous control transfers that might have been using EP0.
1212:                  //Ordinarily, nothing actually needs abandoning, since the previous control
1213:                  //transfer would have completed successfully prior to the host sending the next
1214:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
1215:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
1216:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
1217:                  //by the class request handler that will be called next.
1218:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
  1442    C06F     MOVFF 0x6f, 0xfe9
  1444    FFE9     NOP
  1446    C070     MOVFF 0x70, 0xfea
  1448    FFEA     NOP
  144A    9EEF     BCF 0xfef, 0x7, ACCESS
1219:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
  144C    756F     BTG 0x6f, 0x2, BANKED
1220:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
  144E    C06F     MOVFF 0x6f, 0xfe9
  1450    FFE9     NOP
  1452    C070     MOVFF 0x70, 0xfea
  1454    FFEA     NOP
  1456    9EEF     BCF 0xfef, 0x7, ACCESS
1221:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
  1458    756F     BTG 0x6f, 0x2, BANKED
1222:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
  145A    C065     MOVFF 0x65, 0xfe9
  145C    FFE9     NOP
  145E    C066     MOVFF 0x66, 0xfea
  1460    FFEA     NOP
  1462    9EEF     BCF 0xfef, 0x7, ACCESS
1223:              
1224:                  inPipes[0].info.Val = 0;
  1464    6B7C     CLRF 0x7c, BANKED
1225:                  inPipes[0].wCount.Val = 0;
  1466    6B7D     CLRF 0x7d, BANKED
  1468    6B7E     CLRF 0x7e, BANKED
1226:                  outPipes[0].info.Val = 0;
  146A    6B81     CLRF 0x81, BANKED
1227:                  outPipes[0].wCount.Val = 0;
  146C    6B82     CLRF 0x82, BANKED
  146E    6B83     CLRF 0x83, BANKED
1228:                  
1229:              
1230:                  //--------------------------------------------------------------------------
1231:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
1232:                  //--------------------------------------------------------------------------
1233:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
  1470    D892     RCALL 0x1596
1234:                  USB_DISABLE_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
  1472    0E00     MOVLW 0
  1474    6EE6     MOVWF 0xfe6, ACCESS
  1476    6AE6     CLRF 0xfe6, ACCESS
  1478    6EE6     MOVWF 0xfe6, ACCESS
  147A    6AE6     CLRF 0xfe6, ACCESS
  147C    0E03     MOVLW 0x3
  147E    6EE6     MOVWF 0xfe6, ACCESS
  1480    6AE6     CLRF 0xfe6, ACCESS
  1482    ECA0     CALL 0x4340, 0
  1484    F021     NOP
  1486    6E14     MOVWF 0x14, ACCESS
  1488    0E06     MOVLW 0x6
  148A    5EE1     SUBWF 0xfe1, F, ACCESS
  148C    5014     MOVF 0x14, W, ACCESS
1235:              
1236:              
1237:                  //--------------------------------------------------------------------------
1238:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
1239:                  //   progress.  If one of the above handlers (in step 2) knew how to process
1240:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
1241:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
1242:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to 
1243:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
1244:                  //   process the request.  In this case, the default behavior will be to
1245:                  //   perform protocol STALL on EP0.
1246:                  //-------------------------------------------------------------------------- 
1247:                  USBCtrlEPServiceComplete();
  148E    EFE1     GOTO 0x1bc2
  1490    F00D     NOP
1248:              }//end USBCtrlTrfSetupHandler
1249:              
1250:              
1251:              /******************************************************************************
1252:               * Function:        void USBCtrlTrfOutHandler(void)
1253:               *
1254:               * PreCondition:    None
1255:               *
1256:               * Input:           None
1257:               *
1258:               * Output:          None
1259:               *
1260:               * Side Effects:    None
1261:               *
1262:               * Overview:        This routine handles an OUT transaction according to
1263:               *                  which control transfer state is currently active.
1264:               *
1265:               * Note:            Note that if the the control transfer was from
1266:               *                  host to device, the session owner should be notified
1267:               *                  at the end of each OUT transaction to service the
1268:               *                  received data.
1269:               *
1270:               *****************************************************************************/
1271:              static void USBCtrlTrfOutHandler(void)
1272:              {
1273:                  if(controlTransferState == CTRL_TRF_RX)
  1492    0E02     MOVLW 0x2
  1494    0100     MOVLB 0
  1496    5D78     SUBWF 0x78, W, BANKED
  1498    E102     BNZ 0x149e
1274:                  {
1275:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
  149A    EFA4     GOTO 0x1d48
  149C    F00E     NOP
1276:                  }
1277:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
1278:                  {
1279:                      //If the status stage is complete, this means we are done with the 
1280:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
1281:                      controlTransferState = WAIT_SETUP;
  149E    6B78     CLRF 0x78, BANKED
1282:              
1283:              	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
1284:              	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
1285:              	    //and the last control transfer was of direction: device to host, see
1286:              	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
1287:              	    //to do anything to the BDT.
1288:              		if(BothEP0OutUOWNsSet == FALSE)
  14A0    518D     MOVF 0x8d, W, BANKED
  14A2    E11A     BNZ 0x14d8
1289:              		{
1290:              	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  14A4    C065     MOVFF 0x65, 0xfe9
  14A6    FFE9     NOP
  14A8    C066     MOVFF 0x66, 0xfea
  14AA    FFEA     NOP
  14AC    52EE     MOVF 0xfee, F, ACCESS
  14AE    0E08     MOVLW 0x8
  14B0    6EEF     MOVWF 0xfef, ACCESS
1291:              	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  14B2    C065     MOVFF 0x65, 0xfe9
  14B4    FFE9     NOP
  14B6    C066     MOVFF 0x66, 0xfea
  14B8    FFEA     NOP
  14BA    0E02     MOVLW 0x2
  14BC    26E9     ADDWF 0xfe9, F, ACCESS
  14BE    0E00     MOVLW 0
  14C0    22EA     ADDWFC 0xfea, F, ACCESS
  14C2    0E40     MOVLW 0x40
  14C4    6EEE     MOVWF 0xfee, ACCESS
  14C6    0E04     MOVLW 0x4
  14C8    6EED     MOVWF 0xfed, ACCESS
1292:              	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;			
  14CA    C065     MOVFF 0x65, 0xfe9
  14CC    FFE9     NOP
  14CE    C066     MOVFF 0x66, 0xfea
  14D0    FFEA     NOP
  14D2    0E8C     MOVLW 0x8c
  14D4    6EEF     MOVWF 0xfef, ACCESS
1293:              		}
1294:              		else
  14D6    0012     RETURN 0
1295:              		{
1296:              			BothEP0OutUOWNsSet = FALSE;
  14D8    6B8D     CLRF 0x8d, BANKED
1297:              		}
1298:                  }
1299:              }
  14DA    0012     RETURN 0
1300:              
1301:              /******************************************************************************
1302:               * Function:        void USBCtrlTrfInHandler(void)
1303:               *
1304:               * PreCondition:    None
1305:               *
1306:               * Input:           None
1307:               *
1308:               * Output:          None
1309:               *
1310:               * Side Effects:    None
1311:               *
1312:               * Overview:        This routine handles an IN transaction according to
1313:               *                  which control transfer state is currently active.
1314:               *
1315:               * Note:            A Set Address Request must not change the acutal address
1316:               *                  of the device until the completion of the control
1317:               *                  transfer. The end of the control transfer for Set Address
1318:               *                  Request is an IN transaction. Therefore it is necessary
1319:               *                  to service this unique situation when the condition is
1320:               *                  right. Macro mUSBCheckAdrPendingState is defined in
1321:               *                  usb9.h and its function is to specifically service this
1322:               *                  event.
1323:               *****************************************************************************/
1324:              static void USBCtrlTrfInHandler(void)
  14DC    CFD9     MOVFF 0xfd9, 0xfe6
  14DE    FFE6     NOP
  14E0    CFE1     MOVFF 0xfe1, 0xfd9
  14E2    FFD9     NOP
  14E4    52E6     MOVF 0xfe6, F, ACCESS
1325:              {
1326:                  BYTE lastDTS;
1327:              
1328:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
  14E6    C06F     MOVFF 0x6f, 0xfe9
  14E8    FFE9     NOP
  14EA    C070     MOVFF 0x70, 0xfea
  14EC    FFEA     NOP
  14EE    50EF     MOVF 0xfef, W, ACCESS
  14F0    0B40     ANDLW 0x40
  14F2    E001     BZ 0x14f6
  14F4    0E01     MOVLW 0x1
  14F6    6EDF     MOVWF 0xfdf, ACCESS
1329:              
1330:                  //switch to the next ping pong buffer
1331:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
  14F8    0100     MOVLB 0
  14FA    756F     BTG 0x6f, 0x2, BANKED
1332:              
1333:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
1334:                  //now, since the IN status stage of the control transfer has evidently
1335:                  //completed successfully.
1336:                  if(USBDeviceState == ADR_PENDING_STATE)
  14FC    0E08     MOVLW 0x8
  14FE    5D60     SUBWF 0x60, W, BANKED
  1500    E10B     BNZ 0x1518
1337:                  {
1338:                      U1ADDR = SetupPkt.bDevADR.Val;
  1502    C442     MOVFF 0x442, 0xf38
  1504    FF38     NOP
1339:                      if(U1ADDR != 0u)
  1506    010F     MOVLB 0xf
  1508    5138     MOVF 0x38, W, BANKED
  150A    E003     BZ 0x1512
1340:                      {
1341:                          USBDeviceState=ADDRESS_STATE;
  150C    0100     MOVLB 0
  150E    0E10     MOVLW 0x10
1342:                      }
1343:                      else
  1510    D002     BRA 0x1516
1344:                      {
1345:                          USBDeviceState=DEFAULT_STATE;
  1512    0100     MOVLB 0
  1514    0E04     MOVLW 0x4
  1516    6F60     MOVWF 0x60, BANKED
1346:                      }
1347:                  }//end if
1348:              
1349:              
1350:                  if(controlTransferState == CTRL_TRF_TX)
  1518    0578     DECF 0x78, W, BANKED
  151A    E126     BNZ 0x1568
1351:                  {
1352:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
  151C    C06F     MOVFF 0x6f, 0xfe9
  151E    FFE9     NOP
  1520    C070     MOVFF 0x70, 0xfea
  1522    FFEA     NOP
  1524    0E02     MOVLW 0x2
  1526    26E9     ADDWF 0xfe9, F, ACCESS
  1528    0E00     MOVLW 0
  152A    22EA     ADDWFC 0xfea, F, ACCESS
  152C    0E48     MOVLW 0x48
  152E    6EEE     MOVWF 0xfee, ACCESS
  1530    0E04     MOVLW 0x4
  1532    6EED     MOVWF 0xfed, ACCESS
1353:                      USBCtrlTrfTxService();
  1534    DBA7     RCALL 0x1c84
1354:              
1355:                      //Check if we have already sent a short packet.  If so, configure
1356:                      //the endpoint to STALL in response to any further IN tokens (in the
1357:                      //case that the host erroneously tries to receive more data than it
1358:                      //should).
1359:                      if(shortPacketStatus == SHORT_PKT_SENT)
  1536    0E02     MOVLW 0x2
  1538    0100     MOVLB 0
  153A    5D77     SUBWF 0x77, W, BANKED
  153C    E106     BNZ 0x154a
1360:                      {
1361:                          // If a short packet has been sent, don't want to send any more,
1362:                          // stall next time if host is still trying to read.
1363:                          pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
  153E    C06F     MOVFF 0x6f, 0xfe9
  1540    FFE9     NOP
  1542    C070     MOVFF 0x70, 0xfea
  1544    FFEA     NOP
  1546    0E84     MOVLW 0x84
1364:                      }
1365:                      else
  1548    D00D     BRA 0x1564
1366:                      {
1367:                          if(lastDTS == 0)
  154A    50DF     MOVF 0xfdf, W, ACCESS
  154C    E106     BNZ 0x155a
1368:                          {
1369:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
  154E    C06F     MOVFF 0x6f, 0xfe9
  1550    FFE9     NOP
  1552    C070     MOVFF 0x70, 0xfea
  1554    FFEA     NOP
  1556    0EC8     MOVLW 0xc8
1370:                          }
1371:                          else
  1558    D005     BRA 0x1564
1372:                          {
1373:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|_DTSEN;
  155A    C06F     MOVFF 0x6f, 0xfe9
  155C    FFE9     NOP
  155E    C070     MOVFF 0x70, 0xfea
  1560    FFEA     NOP
  1562    0E88     MOVLW 0x88
  1564    6EEF     MOVWF 0xfef, ACCESS
1374:                          }
1375:                      }//end if(...)else
1376:                  }
1377:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
  1566    D012     BRA 0x158c
1378:              	{
1379:                      //if someone is still expecting data from the control transfer
1380:                      //  then make sure to terminate that request and let them know that
1381:                      //  they are done
1382:                      if(outPipes[0].info.bits.busy == 1)
  1568    AF81     BTFSS 0x81, 0x7, BANKED
  156A    D00F     BRA 0x158a
1383:                      {
1384:                          if(outPipes[0].pFunc != NULL)
  156C    5184     MOVF 0x84, W, BANKED
  156E    1185     IORWF 0x85, W, BANKED
  1570    1186     IORWF 0x86, W, BANKED
  1572    E009     BZ 0x1586
1385:                          {
1386:                              outPipes[0].pFunc();
  1574    D007     BRA 0x1584
  1576    C086     MOVFF 0x86, 0xffb
  1578    FFFB     NOP
  157A    C085     MOVFF 0x85, 0xffa
  157C    FFFA     NOP
  157E    0100     MOVLB 0
  1580    5184     MOVF 0x84, W, BANKED
  1582    6EF9     MOVWF 0xff9, ACCESS
  1584    DFF8     RCALL 0x1576
1387:                          }
1388:                          outPipes[0].info.bits.busy = 0;
  1586    0100     MOVLB 0
  1588    9F81     BCF 0x81, 0x7, BANKED
1389:                      }
1390:                  	
1391:                      controlTransferState = WAIT_SETUP;
  158A    6B78     CLRF 0x78, BANKED
1392:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
1393:                      //got processed by the USBCtrlTrfRxService() handler.
1394:              	}	
1395:              
1396:              }
  158C    52E5     MOVF 0xfe5, F, ACCESS
  158E    52E5     MOVF 0xfe5, F, ACCESS
  1590    CFE7     MOVFF 0xfe7, 0xfd9
  1592    FFD9     NOP
  1594    0012     RETURN 0
1397:              
1398:              
1399:              /********************************************************************
1400:               * Function:        void USBCheckStdRequest(void)
1401:               *
1402:               * PreCondition:    None
1403:               *
1404:               * Input:           None
1405:               *
1406:               * Output:          None
1407:               *
1408:               * Side Effects:    None
1409:               *
1410:               * Overview:        This routine checks the setup data packet to see
1411:               *                  if it knows how to handle it
1412:               *
1413:               * Note:            None
1414:               *******************************************************************/
1415:              static void USBCheckStdRequest(void)
1416:              {
1417:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
  1596    0104     MOVLB 0x4
  1598    5140     MOVF 0x40, W, BANKED
  159A    0B60     ANDLW 0x60
  159C    42E8     RRNCF 0xfe8, F, ACCESS
  159E    42E8     RRNCF 0xfe8, F, ACCESS
  15A0    42E8     RRNCF 0xfe8, F, ACCESS
  15A2    42E8     RRNCF 0xfe8, F, ACCESS
  15A4    42E8     RRNCF 0xfe8, F, ACCESS
  15A6    0900     IORLW 0
  15A8    E001     BZ 0x15ac
  15AA    0012     RETURN 0
1418:              
1419:                  switch(SetupPkt.bRequest)
  15AC    5141     MOVF 0x41, W, BANKED
  15AE    0A0C     XORLW 0xc
  15B0    E050     BZ 0x1652
  15B2    0A0B     XORLW 0xb
  15B4    E03F     BZ 0x1634
  15B6    0A0C     XORLW 0xc
  15B8    E031     BZ 0x161c
  15BA    0A01     XORLW 0x1
  15BC    E022     BZ 0x1602
  15BE    0A0B     XORLW 0xb
  15C0    E01E     BZ 0x15fe
  15C2    0A02     XORLW 0x2
  15C4    E01C     BZ 0x15fe
  15C6    0A03     XORLW 0x3
  15C8    E018     BZ 0x15fa
  15CA    0A08     XORLW 0x8
  15CC    E010     BZ 0x15ee
  15CE    0A01     XORLW 0x1
  15D0    E00C     BZ 0x15ea
  15D2    0A0F     XORLW 0xf
  15D4    E008     BZ 0x15e6
  15D6    0A03     XORLW 0x3
  15D8    E001     BZ 0x15dc
  15DA    0012     RETURN 0
1420:                  {
1421:                      case USB_REQUEST_SET_ADDRESS:
1422:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
  15DC    0100     MOVLB 0
  15DE    8F7C     BSF 0x7c, 0x7, BANKED
1423:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
  15E0    0E08     MOVLW 0x8
  15E2    6F60     MOVWF 0x60, BANKED
1424:                          /* See USBCtrlTrfInHandler() for the next step */
1425:                          break;
  15E4    0012     RETURN 0
1426:                      case USB_REQUEST_GET_DESCRIPTOR:
1427:                          USBStdGetDscHandler();
  15E6    EFE3     GOTO 0x19c6
  15E8    F00C     NOP
1428:                          break;
1429:                      case USB_REQUEST_SET_CONFIGURATION:
1430:                          USBStdSetCfgHandler();
  15EA    EF46     GOTO 0x1e8c
  15EC    F00F     NOP
1431:                          break;
1432:                      case USB_REQUEST_GET_CONFIGURATION:
1433:                          inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
  15EE    0100     MOVLB 0
  15F0    0E61     MOVLW 0x61
  15F2    6F79     MOVWF 0x79, BANKED
  15F4    0E00     MOVLW 0
  15F6    6F7A     MOVWF 0x7a, BANKED
1434:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
1435:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
1436:                          inPipes[0].info.bits.busy = 1;
1437:                          break;
  15F8    D00C     BRA 0x1612
1438:                      case USB_REQUEST_GET_STATUS:
1439:                          USBStdGetStatusHandler();
  15FA    EF87     GOTO 0x1b0e
  15FC    F00D     NOP
1440:                          break;
1441:                      case USB_REQUEST_CLEAR_FEATURE:
1442:                      case USB_REQUEST_SET_FEATURE:
1443:                          USBStdFeatureReqHandler();
  15FE    EF2A     GOTO 0x1654
  1600    F00B     NOP
1444:                          break;
1445:                      case USB_REQUEST_GET_INTERFACE:
1446:                          inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
  1602    5144     MOVF 0x44, W, BANKED
  1604    0100     MOVLB 0
  1606    6F79     MOVWF 0x79, BANKED
  1608    6B7A     CLRF 0x7a, BANKED
  160A    0E62     MOVLW 0x62
  160C    2779     ADDWF 0x79, F, BANKED
  160E    0E00     MOVLW 0
  1610    237A     ADDWFC 0x7a, F, BANKED
1447:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
  1612    817C     BSF 0x7c, 0, BANKED
1448:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
  1614    0E01     MOVLW 0x1
  1616    6F7D     MOVWF 0x7d, BANKED
1449:                          inPipes[0].info.bits.busy = 1;
  1618    8F7C     BSF 0x7c, 0x7, BANKED
1450:                          break;
  161A    0012     RETURN 0
1451:                      case USB_REQUEST_SET_INTERFACE:
1452:                          inPipes[0].info.bits.busy = 1;
  161C    0100     MOVLB 0
  161E    8F7C     BSF 0x7c, 0x7, BANKED
1453:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
  1620    0104     MOVLB 0x4
  1622    5144     MOVF 0x44, W, BANKED
  1624    6AEA     CLRF 0xfea, ACCESS
  1626    0F62     ADDLW 0x62
  1628    6EE9     MOVWF 0xfe9, ACCESS
  162A    0E00     MOVLW 0
  162C    22EA     ADDWFC 0xfea, F, ACCESS
  162E    C442     MOVFF 0x442, 0xfef
  1630    FFEF     NOP
1454:                          break;
  1632    0012     RETURN 0
1455:                      case USB_REQUEST_SET_DESCRIPTOR:
1456:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
  1634    0E00     MOVLW 0
  1636    6EE6     MOVWF 0xfe6, ACCESS
  1638    6AE6     CLRF 0xfe6, ACCESS
  163A    6EE6     MOVWF 0xfe6, ACCESS
  163C    6AE6     CLRF 0xfe6, ACCESS
  163E    0E02     MOVLW 0x2
  1640    6EE6     MOVWF 0xfe6, ACCESS
  1642    6AE6     CLRF 0xfe6, ACCESS
  1644    ECA0     CALL 0x4340, 0
  1646    F021     NOP
  1648    6E14     MOVWF 0x14, ACCESS
  164A    0E06     MOVLW 0x6
  164C    5EE1     SUBWF 0xfe1, F, ACCESS
  164E    5014     MOVF 0x14, W, ACCESS
1457:                          break;
  1650    0012     RETURN 0
1458:                      case USB_REQUEST_SYNCH_FRAME:
1459:                      default:
1460:                          break;
1461:                  }//end switch
1462:              }//end USBCheckStdRequest
  1652    0012     RETURN 0
1463:              
1464:              /********************************************************************
1465:               * Function:        void USBStdFeatureReqHandler(void)
1466:               *
1467:               * PreCondition:    None
1468:               *
1469:               * Input:           None
1470:               *
1471:               * Output:          None
1472:               *
1473:               * Side Effects:    None
1474:               *
1475:               * Overview:        This routine handles the standard SET & CLEAR
1476:               *                  FEATURES requests
1477:               *
1478:               * Note:            None
1479:               *******************************************************************/
1480:              static void USBStdFeatureReqHandler(void)
  1654    CFD9     MOVFF 0xfd9, 0xfe6
  1656    FFE6     NOP
  1658    CFE1     MOVFF 0xfe1, 0xfd9
  165A    FFD9     NOP
  165C    0E03     MOVLW 0x3
  165E    26E1     ADDWF 0xfe1, F, ACCESS
1481:              {
1482:                  BDT_ENTRY *p;
1483:                  EP_STATUS current_ep_data;
1484:              
1485:                  #ifdef	USB_SUPPORT_OTG
1486:                  //Check for USB On-The-Go (OTG) specific requests
1487:                  if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
1488:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
1489:                  {  
1490:                      inPipes[0].info.bits.busy = 1;
1491:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
1492:                          USBOTGEnableHnp();
1493:                      else
1494:                          USBOTGDisableHnp();
1495:                  }
1496:              
1497:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
1498:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
1499:                  {
1500:                      inPipes[0].info.bits.busy = 1;
1501:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
1502:                          USBOTGEnableSupportHnp();
1503:                      else
1504:                          USBOTGDisableSupportHnp();
1505:                  }
1506:              
1507:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
1508:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
1509:                  {
1510:                      inPipes[0].info.bits.busy = 1;
1511:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
1512:                          USBOTGEnableAltHnp();
1513:                      else
1514:                          USBOTGDisableAltHnp();
1515:                  }
1516:                  #endif   //#ifdef USB_SUPPORT_OTG 
1517:              
1518:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
1519:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
  1660    0104     MOVLB 0x4
  1662    0542     DECF 0x42, W, BANKED
1520:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
  1664    E110     BNZ 0x1686
  1666    5140     MOVF 0x40, W, BANKED
  1668    0B1F     ANDLW 0x1f
  166A    0900     IORLW 0
  166C    E10C     BNZ 0x1686
1521:                  {
1522:                      inPipes[0].info.bits.busy = 1;
  166E    0100     MOVLB 0
  1670    8F7C     BSF 0x7c, 0x7, BANKED
1523:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
  1672    0E03     MOVLW 0x3
  1674    0104     MOVLB 0x4
  1676    5D41     SUBWF 0x41, W, BANKED
  1678    E104     BNZ 0x1682
1524:                          RemoteWakeup = TRUE;
  167A    0100     MOVLB 0
  167C    0E01     MOVLW 0x1
  167E    6F89     MOVWF 0x89, BANKED
1525:                      else
  1680    D002     BRA 0x1686
1526:                          RemoteWakeup = FALSE;
  1682    0100     MOVLB 0
  1684    6B89     CLRF 0x89, BANKED
1527:                  }//end if
1528:              
1529:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
1530:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
  1686    0104     MOVLB 0x4
  1688    5142     MOVF 0x42, W, BANKED
1531:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
  168A    E001     BZ 0x168e
  168C    D103     BRA 0x1894
  168E    5140     MOVF 0x40, W, BANKED
  1690    0B1F     ANDLW 0x1f
  1692    0802     SUBLW 0x2
  1694    E001     BZ 0x1698
  1696    D0FE     BRA 0x1894
1532:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
  1698    5144     MOVF 0x44, W, BANKED
  169A    0B0F     ANDLW 0xf
  169C    0900     IORLW 0
  169E    E101     BNZ 0x16a2
  16A0    D0F9     BRA 0x1894
  16A2    5144     MOVF 0x44, W, BANKED
  16A4    0B0F     ANDLW 0xf
  16A6    0803     SUBLW 0x3
  16A8    E201     BC 0x16ac
  16AA    D0F4     BRA 0x1894
1533:                     (USBDeviceState == CONFIGURED_STATE))
  16AC    0E20     MOVLW 0x20
  16AE    0100     MOVLB 0
  16B0    5D60     SUBWF 0x60, W, BANKED
  16B2    E001     BZ 0x16b6
  16B4    D0EF     BRA 0x1894
1534:                  {
1535:              		//The request was valid.  Take control of the control transfer and
1536:              		//perform the host requested action.
1537:              		inPipes[0].info.bits.busy = 1;
  16B6    8F7C     BSF 0x7c, 0x7, BANKED
1538:              
1539:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
1540:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
  16B8    0104     MOVLB 0x4
  16BA    BF44     BTFSC 0x44, 0x7, BANKED
  16BC    D016     BRA 0x16ea
1541:                      {
1542:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
  16BE    5144     MOVF 0x44, W, BANKED
  16C0    0B0F     ANDLW 0xf
  16C2    6EE9     MOVWF 0xfe9, ACCESS
  16C4    6AEA     CLRF 0xfea, ACCESS
  16C6    90D8     BCF 0xfd8, 0, ACCESS
  16C8    36E9     RLCF 0xfe9, F, ACCESS
  16CA    36EA     RLCF 0xfea, F, ACCESS
  16CC    0E67     MOVLW 0x67
  16CE    26E9     ADDWF 0xfe9, F, ACCESS
  16D0    0E00     MOVLW 0
  16D2    22EA     ADDWFC 0xfea, F, ACCESS
  16D4    CFEE     MOVFF 0xfee, 0xfde
  16D6    FFDE     NOP
  16D8    CFED     MOVFF 0xfed, 0xfdd
  16DA    FFDD     NOP
1543:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
  16DC    5144     MOVF 0x44, W, BANKED
  16DE    0B0F     ANDLW 0xf
  16E0    6AEA     CLRF 0xfea, ACCESS
  16E2    0F92     ADDLW 0x92
  16E4    6EE9     MOVWF 0xfe9, ACCESS
  16E6    0E00     MOVLW 0
1544:                      }
1545:                      else
  16E8    D015     BRA 0x1714
1546:                      {
1547:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
  16EA    5144     MOVF 0x44, W, BANKED
  16EC    0B0F     ANDLW 0xf
  16EE    6EE9     MOVWF 0xfe9, ACCESS
  16F0    6AEA     CLRF 0xfea, ACCESS
  16F2    90D8     BCF 0xfd8, 0, ACCESS
  16F4    36E9     RLCF 0xfe9, F, ACCESS
  16F6    36EA     RLCF 0xfea, F, ACCESS
  16F8    0E6F     MOVLW 0x6f
  16FA    26E9     ADDWF 0xfe9, F, ACCESS
  16FC    0E00     MOVLW 0
  16FE    22EA     ADDWFC 0xfea, F, ACCESS
  1700    CFEE     MOVFF 0xfee, 0xfde
  1702    FFDE     NOP
  1704    CFED     MOVFF 0xfed, 0xfdd
  1706    FFDD     NOP
1548:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
  1708    5144     MOVF 0x44, W, BANKED
  170A    0B0F     ANDLW 0xf
  170C    6AEA     CLRF 0xfea, ACCESS
  170E    0F8E     ADDLW 0x8e
  1710    6EE9     MOVWF 0xfe9, ACCESS
  1712    0E00     MOVLW 0
  1714    22EA     ADDWFC 0xfea, F, ACCESS
  1716    0E02     MOVLW 0x2
  1718    CFEF     MOVFF 0xfef, 0xfdb
  171A    FFDB     NOP
1549:                      }
1550:              
1551:                      //If ping pong buffering is enabled on the requested endpoint, need 
1552:                      //to point to the one that is the active BDT entry which the SIE will 
1553:                      //use for the next attempted transaction on that EP number.
1554:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
1555:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
  171C    50D9     MOVF 0xfd9, W, ACCESS
  171E    0F02     ADDLW 0x2
  1720    6EE9     MOVWF 0xfe9, ACCESS
  1722    CFDA     MOVFF 0xfda, 0xfea
  1724    FFEA     NOP
  1726    50EF     MOVF 0xfef, W, ACCESS
  1728    0B01     ANDLW 0x1
  172A    E103     BNZ 0x1732
1556:                          {
1557:                              USBHALPingPongSetToEven(&p);
  172C    0E00     MOVLW 0
  172E    94DF     BCF 0xfdf, 0x2, ACCESS
1558:                          }
1559:                          else //else must have been odd
  1730    D001     BRA 0x1734
1560:                          {
1561:                              USBHALPingPongSetToOdd(&p);
  1732    84DF     BSF 0xfdf, 0x2, ACCESS
1562:                          }
1563:                      #endif
1564:                      
1565:                      //Update the BDT pointers with the new, next entry based on the feature
1566:                      //  request
1567:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
  1734    BF44     BTFSC 0x44, 0x7, BANKED
  1736    D00B     BRA 0x174e
1568:                      {
1569:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
  1738    5144     MOVF 0x44, W, BANKED
  173A    0B0F     ANDLW 0xf
  173C    6EE9     MOVWF 0xfe9, ACCESS
  173E    6AEA     CLRF 0xfea, ACCESS
  1740    90D8     BCF 0xfd8, 0, ACCESS
  1742    36E9     RLCF 0xfe9, F, ACCESS
  1744    36EA     RLCF 0xfea, F, ACCESS
  1746    0E67     MOVLW 0x67
  1748    26E9     ADDWF 0xfe9, F, ACCESS
  174A    0E00     MOVLW 0
1570:                      }
1571:                      else
  174C    D00A     BRA 0x1762
1572:                      {
1573:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
  174E    5144     MOVF 0x44, W, BANKED
  1750    0B0F     ANDLW 0xf
  1752    6EE9     MOVWF 0xfe9, ACCESS
  1754    6AEA     CLRF 0xfea, ACCESS
  1756    90D8     BCF 0xfd8, 0, ACCESS
  1758    36E9     RLCF 0xfe9, F, ACCESS
  175A    36EA     RLCF 0xfea, F, ACCESS
  175C    0E6F     MOVLW 0x6f
  175E    26E9     ADDWF 0xfe9, F, ACCESS
  1760    0E00     MOVLW 0
  1762    22EA     ADDWFC 0xfea, F, ACCESS
  1764    CFDE     MOVFF 0xfde, 0xfee
  1766    FFEE     NOP
  1768    CFDD     MOVFF 0xfdd, 0xfed
  176A    FFED     NOP
1574:                      }
1575:              
1576:              		//Check if it was a SET_FEATURE endpoint halt request
1577:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
  176C    0E03     MOVLW 0x3
  176E    5D41     SUBWF 0x41, W, BANKED
  1770    E120     BNZ 0x17b2
1578:                      {
1579:                          if(p->STAT.UOWN == 1)
  1772    CFDE     MOVFF 0xfde, 0xfe9
  1774    FFE9     NOP
  1776    CFDD     MOVFF 0xfdd, 0xfea
  1778    FFEA     NOP
  177A    50EF     MOVF 0xfef, W, ACCESS
  177C    0B80     ANDLW 0x80
  177E    E011     BZ 0x17a2
1580:                          {
1581:                              //Mark that we are terminating this transfer and that the user
1582:                              //  needs to be notified later
1583:                              if(SetupPkt.EPDir == 0)
  1780    BF44     BTFSC 0x44, 0x7, BANKED
  1782    D007     BRA 0x1792
1584:                              {
1585:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
  1784    5144     MOVF 0x44, W, BANKED
  1786    0B0F     ANDLW 0xf
  1788    6AEA     CLRF 0xfea, ACCESS
  178A    0F92     ADDLW 0x92
  178C    6EE9     MOVWF 0xfe9, ACCESS
  178E    0E00     MOVLW 0
1586:                              }
1587:                              else
  1790    D006     BRA 0x179e
1588:                              {
1589:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
  1792    5144     MOVF 0x44, W, BANKED
  1794    0B0F     ANDLW 0xf
  1796    6AEA     CLRF 0xfea, ACCESS
  1798    0F8E     ADDLW 0x8e
  179A    6EE9     MOVWF 0xfe9, ACCESS
  179C    0E00     MOVLW 0
  179E    22EA     ADDWFC 0xfea, F, ACCESS
  17A0    82EF     BSF 0xfef, 0x1, ACCESS
1590:                              }
1591:                          }
1592:              
1593:              			//Then STALL the endpoint
1594:                          p->STAT.Val |= _USIE|_BSTALL;
  17A2    0E84     MOVLW 0x84
  17A4    CFDE     MOVFF 0xfde, 0xfe9
  17A6    FFE9     NOP
  17A8    CFDD     MOVFF 0xfdd, 0xfea
  17AA    FFEA     NOP
  17AC    50E8     MOVF 0xfe8, W, ACCESS
  17AE    12EF     IORWF 0xfef, F, ACCESS
1595:                      }
1596:                      else
  17B0    D071     BRA 0x1894
1597:                      {
1598:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
1599:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
1600:                              //toggle over the to the non-active BDT
1601:                              USBAdvancePingPongBuffer(&p);  
  17B2    74DF     BTG 0xfdf, 0x2, ACCESS
1602:              
1603:                              if(p->STAT.UOWN == 1)
  17B4    CFDE     MOVFF 0xfde, 0xfe9
  17B6    FFE9     NOP
  17B8    CFDD     MOVFF 0xfdd, 0xfea
  17BA    FFEA     NOP
  17BC    50EF     MOVF 0xfef, W, ACCESS
  17BE    0B80     ANDLW 0x80
  17C0    E01B     BZ 0x17f8
1604:                              {
1605:                                  //Clear UOWN and set DTS state so it will be correct the next time
1606:                                  //the application firmware uses USBTransferOnePacket() on the EP.
1607:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
  17C2    CFDE     MOVFF 0xfde, 0xfe9
  17C4    FFE9     NOP
  17C6    CFDD     MOVFF 0xfdd, 0xfea
  17C8    FFEA     NOP
  17CA    9EEF     BCF 0xfef, 0x7, ACCESS
1608:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
  17CC    CFDE     MOVFF 0xfde, 0xfe9
  17CE    FFE9     NOP
  17D0    CFDD     MOVFF 0xfdd, 0xfea
  17D2    FFEA     NOP
  17D4    8CEF     BSF 0xfef, 0x6, ACCESS
1609:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
  17D6    0E02     MOVLW 0x2
  17D8    6EE6     MOVWF 0xfe6, ACCESS
  17DA    6AE6     CLRF 0xfe6, ACCESS
  17DC    CFDE     MOVFF 0xfde, 0xfe6
  17DE    FFE6     NOP
  17E0    CFDD     MOVFF 0xfdd, 0xfe6
  17E2    FFE6     NOP
  17E4    0E05     MOVLW 0x5
  17E6    6EE6     MOVWF 0xfe6, ACCESS
  17E8    6AE6     CLRF 0xfe6, ACCESS
  17EA    ECA0     CALL 0x4340, 0
  17EC    F021     NOP
  17EE    6E14     MOVWF 0x14, ACCESS
  17F0    0E06     MOVLW 0x6
  17F2    5EE1     SUBWF 0xfe1, F, ACCESS
  17F4    5014     MOVF 0x14, W, ACCESS
1610:                              }
1611:                              else
  17F6    D005     BRA 0x1802
1612:                              {
1613:                                  //UOWN already clear, but still need to set DTS to DATA1     
1614:              					p->STAT.Val |= _DAT1;
  17F8    CFDE     MOVFF 0xfde, 0xfe9
  17FA    FFE9     NOP
  17FC    CFDD     MOVFF 0xfdd, 0xfea
  17FE    FFEA     NOP
  1800    8CEF     BSF 0xfef, 0x6, ACCESS
1615:                              }
1616:              
1617:                              //toggle back to the active BDT (the one the SIE is currently looking at
1618:                              //and will use for the next successful transaction to take place on the EP
1619:                              USBAdvancePingPongBuffer(&p);    
  1802    74DF     BTG 0xfdf, 0x2, ACCESS
1620:                              
1621:                              //Check if we are currently terminating, or have previously terminated
1622:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
1623:                              //set DTS to the proper state, and call the application callback
1624:                              //function.
1625:                              if((current_ep_data.bits.transfer_terminated != 0) || ((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 0)))
  1804    50D9     MOVF 0xfd9, W, ACCESS
  1806    0F02     ADDLW 0x2
  1808    6EE9     MOVWF 0xfe9, ACCESS
  180A    CFDA     MOVFF 0xfda, 0xfea
  180C    FFEA     NOP
  180E    50EF     MOVF 0xfef, W, ACCESS
  1810    0B02     ANDLW 0x2
  1812    E10E     BNZ 0x1830
  1814    CFDE     MOVFF 0xfde, 0xfe9
  1816    FFE9     NOP
  1818    CFDD     MOVFF 0xfdd, 0xfea
  181A    FFEA     NOP
  181C    50EF     MOVF 0xfef, W, ACCESS
  181E    0B80     ANDLW 0x80
  1820    E032     BZ 0x1886
  1822    CFDE     MOVFF 0xfde, 0xfe9
  1824    FFE9     NOP
  1826    CFDD     MOVFF 0xfdd, 0xfea
  1828    FFEA     NOP
  182A    50EF     MOVF 0xfef, W, ACCESS
  182C    0B04     ANDLW 0x4
  182E    E12B     BNZ 0x1886
1626:                              {
1627:                                  if(SetupPkt.EPDir == 0)
  1830    0104     MOVLB 0x4
  1832    BF44     BTFSC 0x44, 0x7, BANKED
  1834    D007     BRA 0x1844
1628:                                  {
1629:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
  1836    5144     MOVF 0x44, W, BANKED
  1838    0B0F     ANDLW 0xf
  183A    6AEA     CLRF 0xfea, ACCESS
  183C    0F92     ADDLW 0x92
  183E    6EE9     MOVWF 0xfe9, ACCESS
  1840    0E00     MOVLW 0
1630:                                  }
1631:                                  else
  1842    D006     BRA 0x1850
1632:                                  {
1633:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
  1844    5144     MOVF 0x44, W, BANKED
  1846    0B0F     ANDLW 0xf
  1848    6AEA     CLRF 0xfea, ACCESS
  184A    0F8E     ADDLW 0x8e
  184C    6EE9     MOVWF 0xfe9, ACCESS
  184E    0E00     MOVLW 0
  1850    22EA     ADDWFC 0xfea, F, ACCESS
  1852    92EF     BCF 0xfef, 0x1, ACCESS
1634:                                  }
1635:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
1636:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
  1854    0E3B     MOVLW 0x3b
  1856    6E14     MOVWF 0x14, ACCESS
  1858    CFDE     MOVFF 0xfde, 0xfe9
  185A    FFE9     NOP
  185C    CFDD     MOVFF 0xfdd, 0xfea
  185E    FFEA     NOP
  1860    50E8     MOVF 0xfe8, W, ACCESS
  1862    16EF     ANDWF 0xfef, F, ACCESS
1637:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
  1864    0E02     MOVLW 0x2
  1866    6EE6     MOVWF 0xfe6, ACCESS
  1868    6AE6     CLRF 0xfe6, ACCESS
  186A    CFDE     MOVFF 0xfde, 0xfe6
  186C    FFE6     NOP
  186E    CFDD     MOVFF 0xfdd, 0xfe6
  1870    FFE6     NOP
  1872    0E05     MOVLW 0x5
  1874    6EE6     MOVWF 0xfe6, ACCESS
  1876    6AE6     CLRF 0xfe6, ACCESS
  1878    ECA0     CALL 0x4340, 0
  187A    F021     NOP
  187C    6E14     MOVWF 0x14, ACCESS
  187E    0E06     MOVLW 0x6
  1880    5EE1     SUBWF 0xfe1, F, ACCESS
  1882    5014     MOVF 0x14, W, ACCESS
1638:                              }
1639:                              else
  1884    D007     BRA 0x1894
1640:                              {
1641:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
1642:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
  1886    0E3B     MOVLW 0x3b
  1888    CFDE     MOVFF 0xfde, 0xfe9
  188A    FFE9     NOP
  188C    CFDD     MOVFF 0xfdd, 0xfea
  188E    FFEA     NOP
  1890    50E8     MOVF 0xfe8, W, ACCESS
  1892    16EF     ANDWF 0xfef, F, ACCESS
1643:                              } 
1644:                          #else //else we must not be using ping-pong buffering on the requested endpoint
1645:                              if((current_ep_data.bits.transfer_terminated != 0) || ((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 0)))
1646:                              {
1647:                                  if(SetupPkt.EPDir == 0)
1648:                                  {
1649:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
1650:                                  }
1651:                                  else
1652:                                  {
1653:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
1654:                                  }
1655:               
1656:                                  //Clear UOWN and remove the STALL condition.   
1657:                                  //  In this case we also need to set the DTS bit to 1 so that
1658:                                  //  it toggles to DATA0 the next time the application firmware
1659:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
1660:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
1661:                                  p->STAT.Val |= _DAT1;
1662:                                  //Let the application firmware know a transaction just
1663:                                  //got terminated by the host, and that it is now free to
1664:                                  //re-arm the endpoint or do other tasks if desired.                                        
1665:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
1666:                              }
1667:                              else
1668:                              {
1669:                                  //Clear UOWN and remove the STALL condition.   
1670:                                  //  In this case we also need to set the DTS bit to 1 so that
1671:                                  //  it toggles to DATA0 the next time the application firmware
1672:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
1673:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
1674:                                  p->STAT.Val |= _DAT1;
1675:                              } 
1676:                          #endif
1677:                      }//end if
1678:                  }//end if
1679:              }//end USBStdFeatureReqHandler
  1894    0E03     MOVLW 0x3
  1896    5CE1     SUBWF 0xfe1, W, ACCESS
  1898    E202     BC 0x189e
  189A    6AE1     CLRF 0xfe1, ACCESS
  189C    52E5     MOVF 0xfe5, F, ACCESS
  189E    6EE1     MOVWF 0xfe1, ACCESS
  18A0    52E5     MOVF 0xfe5, F, ACCESS
  18A2    CFE7     MOVFF 0xfe7, 0xfd9
  18A4    FFD9     NOP
  18A6    0012     RETURN 0
1680:              
1681:              
1682:              /********************************************************************
1683:               * Function:        void USBCtrlEPAllowStatusStage(void)
1684:               *
1685:               * PreCondition:    Before USBCtrlEPAllowStatusStage() is called, the USBDeviceInit()
1686:               *                  function must have been called at least once, since the last 
1687:               *                  microcontroller reset or power up cycle.
1688:               *
1689:               * Input:           None
1690:               *
1691:               * Output:          None
1692:               *
1693:               * Side Effects:    None
1694:               *
1695:               * Overview:        This function can be called to prepare the appropriate
1696:               *					EP0 endpoint (IN or OUT) to be ready to allow the status
1697:               *					stage of the currently pending control transfer to complete.
1698:               *					This function will be called automatically by the
1699:               *					USB stack, while processing a control transfer, unless an
1700:               *					application specific/device class specific handler sets
1701:               *					the USBDeferStatusStagePacket boolean to TRUE, while processing
1702:               *					the SETUP packet that initiated the control transfer.  If
1703:               *					application specific code sets USBDeferStatusStagePacket to TRUE,
1704:               *					it is then responsible for calling USBCtrlEPAllowStatusStage(),
1705:               *					once the control transfer data has been satisfactorily processed.
1706:               *
1707:               * Note:            This function is re-entrant, and is safe to call from multiple
1708:               *                  contexts in the application (either higher, same, or lower
1709:               *                  priority than the context that the USBDeviceTasks() function
1710:               *                  executes at.
1711:               *******************************************************************/
1712:              void USBCtrlEPAllowStatusStage(void)
1713:              {
1714:                  //Check and set two flags, prior to actually modifying any BDT entries.
1715:                  //This double checking is necessary to make certain that 
1716:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1717:                  //in main loop context, while simultaneously getting an interrupt which 
1718:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1719:                  if(USBStatusStageEnabledFlag1 == FALSE)
  18A8    0100     MOVLB 0
  18AA    5198     MOVF 0x98, W, BANKED
  18AC    E14D     BNZ 0x1948
1720:                  {
1721:                      USBStatusStageEnabledFlag1 = TRUE;  
  18AE    0E01     MOVLW 0x1
  18B0    6F98     MOVWF 0x98, BANKED
1722:                      if(USBStatusStageEnabledFlag2 == FALSE)
  18B2    5199     MOVF 0x99, W, BANKED
  18B4    E149     BNZ 0x1948
1723:                      {
1724:                          USBStatusStageEnabledFlag2 = TRUE;
  18B6    0E01     MOVLW 0x1
  18B8    6F99     MOVWF 0x99, BANKED
1725:                      
1726:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1727:                          //stage), based on the type of control transfer currently pending.
1728:                          if(controlTransferState == CTRL_TRF_RX)
  18BA    0E02     MOVLW 0x2
  18BC    5D78     SUBWF 0x78, W, BANKED
  18BE    E10D     BNZ 0x18da
1729:                          {
1730:                              pBDTEntryIn[0]->CNT = 0;
  18C0    C06F     MOVFF 0x6f, 0xfe9
  18C2    FFE9     NOP
  18C4    C070     MOVFF 0x70, 0xfea
  18C6    FFEA     NOP
  18C8    52EE     MOVF 0xfee, F, ACCESS
  18CA    6AEF     CLRF 0xfef, ACCESS
1731:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;        
  18CC    C06F     MOVFF 0x6f, 0xfe9
  18CE    FFE9     NOP
  18D0    C070     MOVFF 0x70, 0xfea
  18D2    FFEA     NOP
  18D4    0EC8     MOVLW 0xc8
  18D6    6EEF     MOVWF 0xfef, ACCESS
1732:                          }
1733:                          else if(controlTransferState == CTRL_TRF_TX)
  18D8    0012     RETURN 0
  18DA    0578     DECF 0x78, W, BANKED
  18DC    E135     BNZ 0x1948
1734:                          {
1735:                      		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
  18DE    6B8D     CLRF 0x8d, BANKED
1736:                      
1737:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1738:                              //next SETUP packet.
1739:                      		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1740:                      		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
  18E0    C063     MOVFF 0x63, 0xfe9
  18E2    FFE9     NOP
  18E4    C064     MOVFF 0x64, 0xfea
  18E6    FFEA     NOP
  18E8    52EE     MOVF 0xfee, F, ACCESS
  18EA    0E08     MOVLW 0x8
  18EC    6EEF     MOVWF 0xfef, ACCESS
1741:                      		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
  18EE    C063     MOVFF 0x63, 0xfe9
  18F0    FFE9     NOP
  18F2    C064     MOVFF 0x64, 0xfea
  18F4    FFEA     NOP
  18F6    0E02     MOVLW 0x2
  18F8    26E9     ADDWF 0xfe9, F, ACCESS
  18FA    0E00     MOVLW 0
  18FC    22EA     ADDWFC 0xfea, F, ACCESS
  18FE    0E40     MOVLW 0x40
  1900    6EEE     MOVWF 0xfee, ACCESS
  1902    0E04     MOVLW 0x4
  1904    6EED     MOVWF 0xfed, ACCESS
1742:                      		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
  1906    C063     MOVFF 0x63, 0xfe9
  1908    FFE9     NOP
  190A    C064     MOVFF 0x64, 0xfea
  190C    FFEA     NOP
  190E    0E84     MOVLW 0x84
  1910    6EEF     MOVWF 0xfef, ACCESS
1743:                      		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
  1912    0E01     MOVLW 0x1
  1914    6F8D     MOVWF 0x8d, BANKED
1744:                      		#endif
1745:                      
1746:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1747:                      		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  1916    C065     MOVFF 0x65, 0xfe9
  1918    FFE9     NOP
  191A    C066     MOVFF 0x66, 0xfea
  191C    FFEA     NOP
  191E    52EE     MOVF 0xfee, F, ACCESS
  1920    0E08     MOVLW 0x8
  1922    6EEF     MOVWF 0xfef, ACCESS
1748:                      		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  1924    C065     MOVFF 0x65, 0xfe9
  1926    FFE9     NOP
  1928    C066     MOVFF 0x66, 0xfea
  192A    FFEA     NOP
  192C    0E02     MOVLW 0x2
  192E    26E9     ADDWF 0xfe9, F, ACCESS
  1930    0E00     MOVLW 0
  1932    22EA     ADDWFC 0xfea, F, ACCESS
  1934    0E40     MOVLW 0x40
  1936    6EEE     MOVWF 0xfee, ACCESS
  1938    0E04     MOVLW 0x4
  193A    6EED     MOVWF 0xfed, ACCESS
1749:                      		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
  193C    C065     MOVFF 0x65, 0xfe9
  193E    FFE9     NOP
  1940    C066     MOVFF 0x66, 0xfea
  1942    FFEA     NOP
  1944    0E80     MOVLW 0x80
  1946    6EEF     MOVWF 0xfef, ACCESS
1750:                          }
1751:                      }    
1752:                  }
1753:              }   
  1948    0012     RETURN 0
1754:              
1755:              
1756:              /*******************************************************************************
1757:                Function: void USBCtrlEPAllowDataStage(void);
1758:                  
1759:                Summary: This function allows the data stage of either a host-to-device or
1760:                          device-to-host control transfer (with data stage) to complete.
1761:                          This function is meant to be used in conjunction with either the
1762:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1763:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1764:                          then the firmware does not need to manually call 
1765:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1766:                          instead.
1767:                   
1768:                Description:
1769:                  
1770:                Conditions: A control transfer (with data stage) should already be pending, 
1771:                              if the firmware calls this function.  Additionally, the firmware
1772:                              should have called either USBDeferOUTDataStage() or 
1773:                              USBDeferINDataStage() at the start of the control transfer, if
1774:                              the firmware will be calling this function manually.
1775:              
1776:                Input:
1777:              
1778:                Return:
1779:              
1780:                Remarks: 
1781:                *****************************************************************************/
1782:              void USBCtrlEPAllowDataStage(void)
1783:              {
1784:                  USBDeferINDataStagePackets = FALSE;
  194A    0100     MOVLB 0
  194C    6B9A     CLRF 0x9a, BANKED
1785:                  USBDeferOUTDataStagePackets = FALSE;
  194E    6B9B     CLRF 0x9b, BANKED
1786:              
1787:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
  1950    0E02     MOVLW 0x2
  1952    5D78     SUBWF 0x78, W, BANKED
  1954    E118     BNZ 0x1986
1788:                  {
1789:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1790:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  1956    C065     MOVFF 0x65, 0xfe9
  1958    FFE9     NOP
  195A    C066     MOVFF 0x66, 0xfea
  195C    FFEA     NOP
  195E    52EE     MOVF 0xfee, F, ACCESS
  1960    0E08     MOVLW 0x8
  1962    6EEF     MOVWF 0xfef, ACCESS
1791:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
  1964    C065     MOVFF 0x65, 0xfe9
  1966    FFE9     NOP
  1968    C066     MOVFF 0x66, 0xfea
  196A    FFEA     NOP
  196C    0E02     MOVLW 0x2
  196E    26E9     ADDWF 0xfe9, F, ACCESS
  1970    0E00     MOVLW 0
  1972    22EA     ADDWFC 0xfea, F, ACCESS
  1974    0E48     MOVLW 0x48
  1976    6EEE     MOVWF 0xfee, ACCESS
  1978    0E04     MOVLW 0x4
  197A    6EED     MOVWF 0xfed, ACCESS
1792:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
  197C    C065     MOVFF 0x65, 0xfe9
  197E    FFE9     NOP
  1980    C066     MOVFF 0x66, 0xfea
  1982    FFEA     NOP
1793:                  }   
1794:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
  1984    D01D     BRA 0x19c0
1795:                  {
1796:                      //Error check the data stage byte count.  Make sure the user specified
1797:                      //value was no greater than the number of bytes the host requested.
1798:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
  1986    517D     MOVF 0x7d, W, BANKED
  1988    0104     MOVLB 0x4
  198A    5D46     SUBWF 0x46, W, BANKED
  198C    0100     MOVLB 0
  198E    517E     MOVF 0x7e, W, BANKED
  1990    0104     MOVLB 0x4
  1992    5947     SUBWFB 0x47, W, BANKED
  1994    E204     BC 0x199e
1799:              		{
1800:              			inPipes[0].wCount.Val = SetupPkt.wLength;
  1996    C446     MOVFF 0x446, 0x7d
  1998    F07D     NOP
  199A    C447     MOVFF 0x447, 0x7e
  199C    F07E     NOP
1801:              		}
1802:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
  199E    D972     RCALL 0x1c84
1803:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1804:              
1805:              	    //Cnt should have been initialized by responsible request owner (ex: by
1806:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1807:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
  19A0    C06F     MOVFF 0x6f, 0xfe9
  19A2    FFE9     NOP
  19A4    C070     MOVFF 0x70, 0xfea
  19A6    FFEA     NOP
  19A8    0E02     MOVLW 0x2
  19AA    26E9     ADDWF 0xfe9, F, ACCESS
  19AC    0E00     MOVLW 0
  19AE    22EA     ADDWFC 0xfea, F, ACCESS
  19B0    0E48     MOVLW 0x48
  19B2    6EEE     MOVWF 0xfee, ACCESS
  19B4    0E04     MOVLW 0x4
  19B6    6EED     MOVWF 0xfed, ACCESS
1808:              		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
  19B8    C06F     MOVFF 0x6f, 0xfe9
  19BA    FFE9     NOP
  19BC    C070     MOVFF 0x70, 0xfea
  19BE    FFEA     NOP
  19C0    0EC8     MOVLW 0xc8
  19C2    6EEF     MOVWF 0xfef, ACCESS
1809:                  }     
1810:              }    
  19C4    0012     RETURN 0
1811:              
1812:              /********************************************************************
1813:               * Function:        void USBStdGetDscHandler(void)
1814:               *
1815:               * PreCondition:    None
1816:               *
1817:               * Input:           None
1818:               *
1819:               * Output:          None
1820:               *
1821:               * Side Effects:    None
1822:               *
1823:               * Overview:        This routine handles the standard GET_DESCRIPTOR
1824:               *                  request.
1825:               *
1826:               * Note:            None
1827:               *******************************************************************/
1828:              static void USBStdGetDscHandler(void)
1829:              {
1830:                  if(SetupPkt.bmRequestType == 0x80)
  19C6    0E80     MOVLW 0x80
  19C8    0104     MOVLB 0x4
  19CA    5D40     SUBWF 0x40, W, BANKED
  19CC    E001     BZ 0x19d0
  19CE    D09E     BRA 0x1b0c
1831:                  {
1832:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
  19D0    0100     MOVLB 0
  19D2    0EC0     MOVLW 0xc0
  19D4    6F7C     MOVWF 0x7c, BANKED
1833:              
1834:                      switch(SetupPkt.bDescriptorType)
  19D6    0104     MOVLB 0x4
  19D8    5143     MOVF 0x43, W, BANKED
  19DA    0A03     XORLW 0x3
  19DC    E057     BZ 0x1a8c
  19DE    0A01     XORLW 0x1
  19E0    E00C     BZ 0x19fa
  19E2    0A03     XORLW 0x3
  19E4    E001     BZ 0x19e8
  19E6    D090     BRA 0x1b08
1835:                      {
1836:                          case USB_DESCRIPTOR_DEVICE:
1837:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
1838:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
1839:                              #else
1840:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
  19E8    0100     MOVLB 0
  19EA    0EC2     MOVLW 0xc2
  19EC    6F79     MOVWF 0x79, BANKED
  19EE    0E4E     MOVLW 0x4e
  19F0    6F7A     MOVWF 0x7a, BANKED
  19F2    0E00     MOVLW 0
  19F4    6F7B     MOVWF 0x7b, BANKED
1841:                              #endif
1842:                              inPipes[0].wCount.Val = sizeof(device_dsc);
  19F6    0E12     MOVLW 0x12
1843:                              break;
  19F8    D081     BRA 0x1afc
1844:                          case USB_DESCRIPTOR_CONFIGURATION:
1845:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
1846:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
1847:                              #else
1848:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
  19FA    0E9F     MOVLW 0x9f
  19FC    6E14     MOVWF 0x14, ACCESS
  19FE    0E4F     MOVLW 0x4f
  1A00    6E15     MOVWF 0x15, ACCESS
  1A02    0E00     MOVLW 0
  1A04    6E16     MOVWF 0x16, ACCESS
  1A06    C442     MOVFF 0x442, 0x17
  1A08    F017     NOP
  1A0A    6A18     CLRF 0x18, ACCESS
  1A0C    6A19     CLRF 0x19, ACCESS
  1A0E    0E03     MOVLW 0x3
  1A10    6E0C     MOVWF 0xc, ACCESS
  1A12    6A0D     CLRF 0xd, ACCESS
  1A14    6A0E     CLRF 0xe, ACCESS
  1A16    C017     MOVFF 0x17, 0x7
  1A18    F007     NOP
  1A1A    C018     MOVFF 0x18, 0x8
  1A1C    F008     NOP
  1A1E    C019     MOVFF 0x19, 0x9
  1A20    F009     NOP
  1A22    ECEB     CALL 0x4dd6, 0
  1A24    F026     NOP
  1A26    5014     MOVF 0x14, W, ACCESS
  1A28    2404     ADDWF 0x4, W, ACCESS
  1A2A    6EF3     MOVWF 0xff3, ACCESS
  1A2C    5015     MOVF 0x15, W, ACCESS
  1A2E    2005     ADDWFC 0x5, W, ACCESS
  1A30    6EF4     MOVWF 0xff4, ACCESS
  1A32    5016     MOVF 0x16, W, ACCESS
  1A34    2006     ADDWFC 0x6, W, ACCESS
  1A36    6EF8     MOVWF 0xff8, ACCESS
  1A38    CFF4     MOVFF 0xff4, 0xff7
  1A3A    FFF7     NOP
  1A3C    CFF3     MOVFF 0xff3, 0xff6
  1A3E    FFF6     NOP
  1A40    0009     TBLRD*+
  1A42    CFF5     MOVFF 0xff5, 0x79
  1A44    F079     NOP
  1A46    0009     TBLRD*+
  1A48    CFF5     MOVFF 0xff5, 0x7a
  1A4A    F07A     NOP
  1A4C    0008     TBLRD*
  1A4E    CFF5     MOVFF 0xff5, 0x7b
  1A50    F07B     NOP
1849:                              #endif
1850:              
1851:                              //This must be loaded using byte addressing.  The source pointer
1852:                              //  may not be word aligned for the 16 or 32 bit machines resulting
1853:                              //  in an address error on the dereference.
1854:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
  1A52    C079     MOVFF 0x79, 0xff6
  1A54    FFF6     NOP
  1A56    C07A     MOVFF 0x7a, 0xff7
  1A58    FFF7     NOP
  1A5A    C07B     MOVFF 0x7b, 0xff8
  1A5C    FFF8     NOP
  1A5E    0E02     MOVLW 0x2
  1A60    26F6     ADDWF 0xff6, F, ACCESS
  1A62    0E00     MOVLW 0
  1A64    22F7     ADDWFC 0xff7, F, ACCESS
  1A66    22F8     ADDWFC 0xff8, F, ACCESS
  1A68    0008     TBLRD*
  1A6A    CFF5     MOVFF 0xff5, 0x7d
  1A6C    F07D     NOP
1855:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
  1A6E    C079     MOVFF 0x79, 0xff6
  1A70    FFF6     NOP
  1A72    C07A     MOVFF 0x7a, 0xff7
  1A74    FFF7     NOP
  1A76    C07B     MOVFF 0x7b, 0xff8
  1A78    FFF8     NOP
  1A7A    0E03     MOVLW 0x3
  1A7C    26F6     ADDWF 0xff6, F, ACCESS
  1A7E    0E00     MOVLW 0
  1A80    22F7     ADDWFC 0xff7, F, ACCESS
  1A82    22F8     ADDWFC 0xff8, F, ACCESS
  1A84    0008     TBLRD*
  1A86    CFF5     MOVFF 0xff5, 0x7e
  1A88    F07E     NOP
1856:                              break;
  1A8A    0012     RETURN 0
1857:                          case USB_DESCRIPTOR_STRING:
1858:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
1859:                              //  later it is now manditory.  This should be defined in usb_config.h and should
1860:                              //  indicate the number of string descriptors.
1861:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
  1A8C    0E03     MOVLW 0x3
  1A8E    5D42     SUBWF 0x42, W, BANKED
  1A90    E238     BC 0x1b02
1862:                              {
1863:                                  //Get a pointer to the String descriptor requested
1864:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
  1A92    0EA2     MOVLW 0xa2
  1A94    6E14     MOVWF 0x14, ACCESS
  1A96    0E4F     MOVLW 0x4f
  1A98    6E15     MOVWF 0x15, ACCESS
  1A9A    0E00     MOVLW 0
  1A9C    6E16     MOVWF 0x16, ACCESS
  1A9E    C442     MOVFF 0x442, 0x17
  1AA0    F017     NOP
  1AA2    6A18     CLRF 0x18, ACCESS
  1AA4    6A19     CLRF 0x19, ACCESS
  1AA6    0E03     MOVLW 0x3
  1AA8    6E0C     MOVWF 0xc, ACCESS
  1AAA    6A0D     CLRF 0xd, ACCESS
  1AAC    6A0E     CLRF 0xe, ACCESS
  1AAE    C017     MOVFF 0x17, 0x7
  1AB0    F007     NOP
  1AB2    C018     MOVFF 0x18, 0x8
  1AB4    F008     NOP
  1AB6    C019     MOVFF 0x19, 0x9
  1AB8    F009     NOP
  1ABA    ECEB     CALL 0x4dd6, 0
  1ABC    F026     NOP
  1ABE    5014     MOVF 0x14, W, ACCESS
  1AC0    2404     ADDWF 0x4, W, ACCESS
  1AC2    6EF3     MOVWF 0xff3, ACCESS
  1AC4    5015     MOVF 0x15, W, ACCESS
  1AC6    2005     ADDWFC 0x5, W, ACCESS
  1AC8    6EF4     MOVWF 0xff4, ACCESS
  1ACA    5016     MOVF 0x16, W, ACCESS
  1ACC    2006     ADDWFC 0x6, W, ACCESS
  1ACE    6EF8     MOVWF 0xff8, ACCESS
  1AD0    CFF4     MOVFF 0xff4, 0xff7
  1AD2    FFF7     NOP
  1AD4    CFF3     MOVFF 0xff3, 0xff6
  1AD6    FFF6     NOP
  1AD8    0009     TBLRD*+
  1ADA    CFF5     MOVFF 0xff5, 0x79
  1ADC    F079     NOP
  1ADE    0009     TBLRD*+
  1AE0    CFF5     MOVFF 0xff5, 0x7a
  1AE2    F07A     NOP
  1AE4    0008     TBLRD*
  1AE6    CFF5     MOVFF 0xff5, 0x7b
  1AE8    F07B     NOP
1865:                                  // Set data count
1866:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
  1AEA    C079     MOVFF 0x79, 0xff6
  1AEC    FFF6     NOP
  1AEE    C07A     MOVFF 0x7a, 0xff7
  1AF0    FFF7     NOP
  1AF2    C07B     MOVFF 0x7b, 0xff8
  1AF4    FFF8     NOP
  1AF6    0008     TBLRD*
  1AF8    50F5     MOVF 0xff5, W, ACCESS
  1AFA    0100     MOVLB 0
  1AFC    6F7D     MOVWF 0x7d, BANKED
  1AFE    6B7E     CLRF 0x7e, BANKED
1867:                              }
1868:                              else
  1B00    0012     RETURN 0
1869:                              {
1870:                                  inPipes[0].info.Val = 0;
  1B02    0100     MOVLB 0
  1B04    6B7C     CLRF 0x7c, BANKED
1871:                              }
1872:                              break;
  1B06    0012     RETURN 0
1873:                          default:
1874:                              inPipes[0].info.Val = 0;
  1B08    0100     MOVLB 0
  1B0A    6B7C     CLRF 0x7c, BANKED
1875:                              break;
1876:                      }//end switch
1877:                  }//end if
1878:              }//end USBStdGetDscHandler
  1B0C    0012     RETURN 0
1879:              
1880:              /********************************************************************
1881:               * Function:        void USBStdGetStatusHandler(void)
1882:               *
1883:               * PreCondition:    None
1884:               *
1885:               * Input:           None
1886:               *
1887:               * Output:          None
1888:               *
1889:               * Side Effects:    None
1890:               *
1891:               * Overview:        This routine handles the standard GET_STATUS request
1892:               *
1893:               * Note:            None
1894:               *******************************************************************/
1895:              void USBStdGetStatusHandler(void)
  1B0E    CFD9     MOVFF 0xfd9, 0xfe6
  1B10    FFE6     NOP
  1B12    CFE1     MOVFF 0xfe1, 0xfd9
  1B14    FFD9     NOP
  1B16    0E02     MOVLW 0x2
  1B18    26E1     ADDWF 0xfe1, F, ACCESS
1896:              {
1897:                  CtrlTrfData[0] = 0;                 // Initialize content
  1B1A    0104     MOVLB 0x4
  1B1C    6B48     CLRF 0x48, BANKED
1898:                  CtrlTrfData[1] = 0;
  1B1E    6B49     CLRF 0x49, BANKED
1899:              
1900:                  switch(SetupPkt.Recipient)
  1B20    5140     MOVF 0x40, W, BANKED
  1B22    0B1F     ANDLW 0x1f
  1B24    0A02     XORLW 0x2
  1B26    E011     BZ 0x1b4a
  1B28    0A03     XORLW 0x3
  1B2A    E00C     BZ 0x1b44
  1B2C    0A01     XORLW 0x1
  1B2E    E135     BNZ 0x1b9a
1901:                  {
1902:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
1903:                          inPipes[0].info.bits.busy = 1;
  1B30    0100     MOVLB 0
  1B32    8F7C     BSF 0x7c, 0x7, BANKED
1904:                          /*
1905:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
1906:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
1907:                           */
1908:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
1909:                          {
1910:                              CtrlTrfData[0]|=0x01;
  1B34    0104     MOVLB 0x4
  1B36    8148     BSF 0x48, 0, BANKED
1911:                          }
1912:              
1913:                          if(RemoteWakeup == TRUE)
  1B38    0100     MOVLB 0
  1B3A    0589     DECF 0x89, W, BANKED
  1B3C    E12E     BNZ 0x1b9a
1914:                          {
1915:                              CtrlTrfData[0]|=0x02;
  1B3E    0104     MOVLB 0x4
  1B40    8348     BSF 0x48, 0x1, BANKED
1916:                          }
1917:                          break;
  1B42    D02B     BRA 0x1b9a
1918:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
1919:                          inPipes[0].info.bits.busy = 1;     // No data to update
  1B44    0100     MOVLB 0
  1B46    8F7C     BSF 0x7c, 0x7, BANKED
1920:                          break;
  1B48    D028     BRA 0x1b9a
1921:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
1922:                          inPipes[0].info.bits.busy = 1;
  1B4A    0100     MOVLB 0
  1B4C    8F7C     BSF 0x7c, 0x7, BANKED
1923:                          /*
1924:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
1925:                           */
1926:                          {
1927:                              BDT_ENTRY *p;
1928:              
1929:                              if(SetupPkt.EPDir == 0)
  1B4E    0104     MOVLB 0x4
  1B50    BF44     BTFSC 0x44, 0x7, BANKED
  1B52    D00B     BRA 0x1b6a
1930:                              {
1931:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
  1B54    5144     MOVF 0x44, W, BANKED
  1B56    0B0F     ANDLW 0xf
  1B58    6EE9     MOVWF 0xfe9, ACCESS
  1B5A    6AEA     CLRF 0xfea, ACCESS
  1B5C    90D8     BCF 0xfd8, 0, ACCESS
  1B5E    36E9     RLCF 0xfe9, F, ACCESS
  1B60    36EA     RLCF 0xfea, F, ACCESS
  1B62    0E67     MOVLW 0x67
  1B64    26E9     ADDWF 0xfe9, F, ACCESS
  1B66    0E00     MOVLW 0
1932:                              }
1933:                              else
  1B68    D00A     BRA 0x1b7e
1934:                              {
1935:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
  1B6A    5144     MOVF 0x44, W, BANKED
  1B6C    0B0F     ANDLW 0xf
  1B6E    6EE9     MOVWF 0xfe9, ACCESS
  1B70    6AEA     CLRF 0xfea, ACCESS
  1B72    90D8     BCF 0xfd8, 0, ACCESS
  1B74    36E9     RLCF 0xfe9, F, ACCESS
  1B76    36EA     RLCF 0xfea, F, ACCESS
  1B78    0E6F     MOVLW 0x6f
  1B7A    26E9     ADDWF 0xfe9, F, ACCESS
  1B7C    0E00     MOVLW 0
  1B7E    22EA     ADDWFC 0xfea, F, ACCESS
  1B80    CFEE     MOVFF 0xfee, 0xfde
  1B82    FFDE     NOP
  1B84    CFED     MOVFF 0xfed, 0xfdd
  1B86    FFDD     NOP
1936:                              }
1937:              
1938:                              if(p->STAT.Val & _BSTALL)    // Use _BSTALL as a bit mask
  1B88    CFDE     MOVFF 0xfde, 0xfe9
  1B8A    FFE9     NOP
  1B8C    CFDD     MOVFF 0xfdd, 0xfea
  1B8E    FFEA     NOP
  1B90    50EF     MOVF 0xfef, W, ACCESS
  1B92    0B04     ANDLW 0x4
  1B94    E002     BZ 0x1b9a
1939:                                  CtrlTrfData[0]=0x01;    // Set bit0
  1B96    0E01     MOVLW 0x1
  1B98    6F48     MOVWF 0x48, BANKED
1940:                              break;
1941:                          }
1942:                  }//end switch
1943:              
1944:                  if(inPipes[0].info.bits.busy == 1)
  1B9A    0100     MOVLB 0
  1B9C    AF7C     BTFSS 0x7c, 0x7, BANKED
  1B9E    D007     BRA 0x1bae
1945:                  {
1946:                      inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
  1BA0    0E48     MOVLW 0x48
  1BA2    6F79     MOVWF 0x79, BANKED
  1BA4    0E04     MOVLW 0x4
  1BA6    6F7A     MOVWF 0x7a, BANKED
1947:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
  1BA8    817C     BSF 0x7c, 0, BANKED
1948:                      inPipes[0].wCount.v[0] = 2;                         // Set data count
  1BAA    0E02     MOVLW 0x2
  1BAC    6F7D     MOVWF 0x7d, BANKED
1949:                  }//end if(...)
1950:              }//end USBStdGetStatusHandler
  1BAE    0E02     MOVLW 0x2
  1BB0    5CE1     SUBWF 0xfe1, W, ACCESS
  1BB2    E202     BC 0x1bb8
  1BB4    6AE1     CLRF 0xfe1, ACCESS
  1BB6    52E5     MOVF 0xfe5, F, ACCESS
  1BB8    6EE1     MOVWF 0xfe1, ACCESS
  1BBA    52E5     MOVF 0xfe5, F, ACCESS
  1BBC    CFE7     MOVFF 0xfe7, 0xfd9
  1BBE    FFD9     NOP
  1BC0    0012     RETURN 0
1951:              
1952:              /******************************************************************************
1953:               * Function:        void USBCtrlEPServiceComplete(void)
1954:               *
1955:               * PreCondition:    None
1956:               *
1957:               * Input:           None
1958:               *
1959:               * Output:          None
1960:               *
1961:               * Side Effects:    None
1962:               *
1963:               * Overview:        This routine wrap up the remaining tasks in servicing
1964:               *                  a Setup Request. Its main task is to set the endpoint
1965:               *                  controls appropriately for a given situation. See code
1966:               *                  below.
1967:               *                  There are three main scenarios:
1968:               *                  a) There was no handler for the Request, in this case
1969:               *                     a STALL should be sent out.
1970:               *                  b) The host has requested a read control transfer,
1971:               *                     endpoints are required to be setup in a specific way.
1972:               *                  c) The host has requested a write control transfer, or
1973:               *                     a control data stage is not required, endpoints are
1974:               *                     required to be setup in a specific way.
1975:               *
1976:               *                  Packet processing is resumed by clearing PKTDIS bit.
1977:               *
1978:               * Note:            None
1979:               *****************************************************************************/
1980:              static void USBCtrlEPServiceComplete(void)
1981:              {
1982:                  /*
1983:                   * PKTDIS bit is set when a Setup Transaction is received.
1984:                   * Clear to resume packet processing.
1985:                   */
1986:                  USBPacketDisable = 0;
  1BC2    9865     BCF 0xf65, 0x4, ACCESS
1987:              
1988:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1989:              	//control transfer is currently in progress.  We need to know the type of control
1990:              	//transfer that is currently pending, in order to know how to properly arm the 
1991:              	//EP0 IN and EP0 OUT endpoints.
1992:                  if(inPipes[0].info.bits.busy == 0)
  1BC4    0100     MOVLB 0
  1BC6    BF7C     BTFSC 0x7c, 0x7, BANKED
  1BC8    D02B     BRA 0x1c20
1993:                  {
1994:                      if(outPipes[0].info.bits.busy == 1)
  1BCA    AF81     BTFSS 0x81, 0x7, BANKED
  1BCC    D009     BRA 0x1be0
1995:                      {
1996:                          controlTransferState = CTRL_TRF_RX;
  1BCE    0E02     MOVLW 0x2
  1BD0    6F78     MOVWF 0x78, BANKED
1997:                          /*
1998:                           * Control Write:
1999:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
2000:                           */
2001:              
2002:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
2003:                          //   function decided to defer the data stage (ex: because the intended
2004:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
2005:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
2006:                          //   once it is ready to begin receiving the data.
2007:                          if(USBDeferOUTDataStagePackets == FALSE)
  1BD2    519B     MOVF 0x9b, W, BANKED
  1BD4    E101     BNZ 0x1bd8
2008:                          {
2009:                              USBCtrlEPAllowDataStage();
  1BD6    DEB9     RCALL 0x194a
2010:                          }
2011:                          
2012:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
2013:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
2014:                          USBStatusStageEnabledFlag2 = FALSE;
  1BD8    0100     MOVLB 0
  1BDA    6B99     CLRF 0x99, BANKED
2015:                          USBStatusStageEnabledFlag1 = FALSE;
  1BDC    6B98     CLRF 0x98, BANKED
2016:                      }
2017:                      else
  1BDE    0012     RETURN 0
2018:                      {
2019:                          /*
2020:                           * If no one knows how to service this request then stall.
2021:                           * Must also prepare EP0 to receive the next SETUP transaction.
2022:                           */
2023:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  1BE0    C065     MOVFF 0x65, 0xfe9
  1BE2    FFE9     NOP
  1BE4    C066     MOVFF 0x66, 0xfea
  1BE6    FFEA     NOP
  1BE8    52EE     MOVF 0xfee, F, ACCESS
  1BEA    0E08     MOVLW 0x8
  1BEC    6EEF     MOVWF 0xfef, ACCESS
2024:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  1BEE    C065     MOVFF 0x65, 0xfe9
  1BF0    FFE9     NOP
  1BF2    C066     MOVFF 0x66, 0xfea
  1BF4    FFEA     NOP
  1BF6    0E02     MOVLW 0x2
  1BF8    26E9     ADDWF 0xfe9, F, ACCESS
  1BFA    0E00     MOVLW 0
  1BFC    22EA     ADDWFC 0xfea, F, ACCESS
  1BFE    0E40     MOVLW 0x40
  1C00    6EEE     MOVWF 0xfee, ACCESS
  1C02    0E04     MOVLW 0x4
  1C04    6EED     MOVWF 0xfed, ACCESS
2025:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
  1C06    C065     MOVFF 0x65, 0xfe9
  1C08    FFE9     NOP
  1C0A    C066     MOVFF 0x66, 0xfea
  1C0C    FFEA     NOP
  1C0E    0E8C     MOVLW 0x8c
  1C10    6EEF     MOVWF 0xfef, ACCESS
2026:                          pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
  1C12    C06F     MOVFF 0x6f, 0xfe9
  1C14    FFE9     NOP
  1C16    C070     MOVFF 0x70, 0xfea
  1C18    FFEA     NOP
  1C1A    0E84     MOVLW 0x84
  1C1C    6EEF     MOVWF 0xfef, ACCESS
2027:                      }
2028:                  }
2029:                  else    // A module has claimed ownership of the control transfer session.
  1C1E    0012     RETURN 0
2030:                  {
2031:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
  1C20    0104     MOVLB 0x4
  1C22    AF40     BTFSS 0x40, 0x7, BANKED
  1C24    D00D     BRA 0x1c40
2032:              		{
2033:              			controlTransferState = CTRL_TRF_TX;
  1C26    0100     MOVLB 0
  1C28    0E01     MOVLW 0x1
  1C2A    6F78     MOVWF 0x78, BANKED
2034:              			/*
2035:              			 * Control Read:
2036:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
2037:              			 *
2038:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
2039:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
2040:              			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
2041:              			 *    Then the class request handler reponsible should call the USBDeferDataStage()
2042:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
2043:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
2044:              			 *    is ready to begin sending the data, it should then call the 
2045:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
2046:              			 */
2047:              			if(USBDeferINDataStagePackets == FALSE)
  1C2C    519A     MOVF 0x9a, W, BANKED
  1C2E    E101     BNZ 0x1c32
2048:                          {
2049:                              USBCtrlEPAllowDataStage();
  1C30    DE8C     RCALL 0x194a
2050:              			}
2051:              
2052:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
2053:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
2054:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
2055:                          //    is ready.  If the class request handler does this, it needs to be careful to
2056:                          //    be written so that it can handle the early termination scenario.
2057:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
2058:                          //    1.  The desired total number of bytes were sent to the host.
2059:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
2060:                          //        started the control transfer) has been reached.
2061:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
2062:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
2063:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
2064:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
2065:                          //        option can take care of this for you.
2066:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
2067:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
2068:                          //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
2069:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
2070:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
2071:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
2072:                          USBStatusStageEnabledFlag2 = FALSE;
  1C32    0100     MOVLB 0
  1C34    6B99     CLRF 0x99, BANKED
2073:                          USBStatusStageEnabledFlag1 = FALSE;
  1C36    6B98     CLRF 0x98, BANKED
2074:                          if(USBDeferStatusStagePacket == FALSE)
  1C38    5197     MOVF 0x97, W, BANKED
  1C3A    E123     BNZ 0x1c82
2075:                          {
2076:                              USBCtrlEPAllowStatusStage();
  1C3C    EF54     GOTO 0x18a8
  1C3E    F00C     NOP
2077:                          } 
2078:              		}
2079:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
2080:              		{
2081:              			//This situation occurs for special types of control transfers,
2082:              			//such as that which occurs when the host sends a SET_ADDRESS
2083:              			//control transfer.  Ex:
2084:              			//
2085:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
2086:              				
2087:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
2088:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
2089:              			//an IN status stage.
2090:              
2091:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
  1C40    0100     MOVLB 0
  1C42    0E02     MOVLW 0x2
  1C44    6F78     MOVWF 0x78, BANKED
2092:              			
2093:              			//1. Prepare OUT EP to receive the next SETUP packet.
2094:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  1C46    C065     MOVFF 0x65, 0xfe9
  1C48    FFE9     NOP
  1C4A    C066     MOVFF 0x66, 0xfea
  1C4C    FFEA     NOP
  1C4E    52EE     MOVF 0xfee, F, ACCESS
  1C50    0E08     MOVLW 0x8
  1C52    6EEF     MOVWF 0xfef, ACCESS
2095:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  1C54    C065     MOVFF 0x65, 0xfe9
  1C56    FFE9     NOP
  1C58    C066     MOVFF 0x66, 0xfea
  1C5A    FFEA     NOP
  1C5C    0E02     MOVLW 0x2
  1C5E    26E9     ADDWF 0xfe9, F, ACCESS
  1C60    0E00     MOVLW 0
  1C62    22EA     ADDWFC 0xfea, F, ACCESS
  1C64    0E40     MOVLW 0x40
  1C66    6EEE     MOVWF 0xfee, ACCESS
  1C68    0E04     MOVLW 0x4
  1C6A    6EED     MOVWF 0xfed, ACCESS
2096:              			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
  1C6C    C065     MOVFF 0x65, 0xfe9
  1C6E    FFE9     NOP
  1C70    C066     MOVFF 0x66, 0xfea
  1C72    FFEA     NOP
  1C74    0E84     MOVLW 0x84
  1C76    6EEF     MOVWF 0xfef, ACCESS
2097:              				
2098:              			//2. Prepare for IN status stage of the control transfer
2099:                          USBStatusStageEnabledFlag2 = FALSE;
  1C78    6B99     CLRF 0x99, BANKED
2100:                          USBStatusStageEnabledFlag1 = FALSE;
  1C7A    6B98     CLRF 0x98, BANKED
2101:              			if(USBDeferStatusStagePacket == FALSE)
  1C7C    5197     MOVF 0x97, W, BANKED
  1C7E    E101     BNZ 0x1c82
2102:                          {
2103:                              USBCtrlEPAllowStatusStage();
  1C80    DE13     RCALL 0x18a8
2104:                          } 
2105:              		}
2106:              
2107:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
2108:              
2109:              }//end USBCtrlEPServiceComplete
  1C82    0012     RETURN 0
2110:              
2111:              
2112:              /******************************************************************************
2113:               * Function:        void USBCtrlTrfTxService(void)
2114:               *
2115:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
2116:               *
2117:               * Input:           None
2118:               *
2119:               * Output:          None
2120:               *
2121:               * Side Effects:    None
2122:               *
2123:               * Overview:        This routine is used for device to host control transfers 
2124:               *					(IN transactions).  This function takes care of managing a
2125:               *                  transfer over multiple USB transactions.
2126:               *					This routine should be called from only two places.
2127:               *                  One from USBCtrlEPServiceComplete() and one from
2128:               *                  USBCtrlTrfInHandler().
2129:               *
2130:               * Note:            
2131:               *****************************************************************************/
2132:              static void USBCtrlTrfTxService(void)
  1C84    CFD9     MOVFF 0xfd9, 0xfe6
  1C86    FFE6     NOP
  1C88    CFE1     MOVFF 0xfe1, 0xfd9
  1C8A    FFD9     NOP
  1C8C    52E6     MOVF 0xfe6, F, ACCESS
2133:              {
2134:                  BYTE byteToSend;
2135:              
2136:                  //Figure out how many bytes of data to send in the next IN transaction.
2137:                  //Assume a full size packet, unless otherwise determined below.
2138:                  byteToSend = USB_EP0_BUFF_SIZE;         
  1C8E    0E08     MOVLW 0x8
  1C90    6EDF     MOVWF 0xfdf, ACCESS
2139:                  if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
  1C92    0100     MOVLB 0
  1C94    5D7D     SUBWF 0x7d, W, BANKED
  1C96    0E00     MOVLW 0
  1C98    597E     SUBWFB 0x7e, W, BANKED
  1C9A    E20A     BC 0x1cb0
2140:                  {
2141:                      byteToSend = inPipes[0].wCount.Val;
  1C9C    C07D     MOVFF 0x7d, 0xfdf
  1C9E    FFDF     NOP
2142:              
2143:                      //Keep track of whether or not we have sent a "short packet" yet.
2144:                      //This is useful so that later on, we can configure EP0 IN to STALL,
2145:                      //after we have sent all of the intended data.  This makes sure the
2146:                      //hardware STALLs if the host erroneously tries to send more IN token 
2147:                      //packets, requesting more data than intended in the control transfer.
2148:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
  1CA0    5177     MOVF 0x77, W, BANKED
  1CA2    E102     BNZ 0x1ca8
2149:                      {
2150:                          shortPacketStatus = SHORT_PKT_PENDING;
  1CA4    0E01     MOVLW 0x1
2151:                      }
2152:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
  1CA6    D003     BRA 0x1cae
  1CA8    0577     DECF 0x77, W, BANKED
  1CAA    E102     BNZ 0x1cb0
2153:                      {
2154:                          shortPacketStatus = SHORT_PKT_SENT;
  1CAC    0E02     MOVLW 0x2
  1CAE    6F77     MOVWF 0x77, BANKED
2155:                      }
2156:                  }
2157:              
2158:                  //Keep track of how many bytes remain to be sent in the transfer, by
2159:                  //subtracting the number of bytes about to be sent from the total.
2160:                  inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
  1CB0    50DF     MOVF 0xfdf, W, ACCESS
  1CB2    6A15     CLRF 0x15, ACCESS
  1CB4    50E8     MOVF 0xfe8, W, ACCESS
  1CB6    5D7D     SUBWF 0x7d, W, BANKED
  1CB8    6F7D     MOVWF 0x7d, BANKED
  1CBA    5015     MOVF 0x15, W, ACCESS
  1CBC    597E     SUBWFB 0x7e, W, BANKED
  1CBE    6F7E     MOVWF 0x7e, BANKED
2161:                  
2162:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
2163:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
2164:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
2165:                  pBDTEntryIn[0]->CNT = byteToSend;
  1CC0    C06F     MOVFF 0x6f, 0xfe9
  1CC2    FFE9     NOP
  1CC4    C070     MOVFF 0x70, 0xfea
  1CC6    FFEA     NOP
  1CC8    52EE     MOVF 0xfee, F, ACCESS
  1CCA    CFDF     MOVFF 0xfdf, 0xfef
  1CCC    FFEF     NOP
2166:              
2167:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
2168:                  //which we will send to the host.
2169:                  pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
  1CCE    0E48     MOVLW 0x48
  1CD0    6F87     MOVWF 0x87, BANKED
  1CD2    0E04     MOVLW 0x4
  1CD4    6F88     MOVWF 0x88, BANKED
2170:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
  1CD6    B17C     BTFSC 0x7c, 0, BANKED
  1CD8    D01B     BRA 0x1d10
2171:                  {
2172:                      while(byteToSend)
  1CDA    50DF     MOVF 0xfdf, W, ACCESS
  1CDC    E030     BZ 0x1d3e
  1D0E    D7E5     BRA 0x1cda
2173:                      {
2174:                          *pDst++ = *inPipes[0].pSrc.bRom++;
  1CDE    C079     MOVFF 0x79, 0xff6
  1CE0    FFF6     NOP
  1CE2    2B79     INCF 0x79, F, BANKED
  1CE4    C07A     MOVFF 0x7a, 0xff7
  1CE6    FFF7     NOP
  1CE8    0E00     MOVLW 0
  1CEA    237A     ADDWFC 0x7a, F, BANKED
  1CEC    C07B     MOVFF 0x7b, 0xff8
  1CEE    FFF8     NOP
  1CF0    237B     ADDWFC 0x7b, F, BANKED
  1CF2    0008     TBLRD*
  1CF4    50F5     MOVF 0xff5, W, ACCESS
  1CF6    6EE6     MOVWF 0xfe6, ACCESS
  1CF8    C087     MOVFF 0x87, 0xfe9
  1CFA    FFE9     NOP
  1CFC    C088     MOVFF 0x88, 0xfea
  1CFE    FFEA     NOP
  1D00    2B87     INCF 0x87, F, BANKED
  1D02    0E00     MOVLW 0
  1D04    2388     ADDWFC 0x88, F, BANKED
  1D06    52E5     MOVF 0xfe5, F, ACCESS
  1D08    50E7     MOVF 0xfe7, W, ACCESS
  1D0A    6EEF     MOVWF 0xfef, ACCESS
2175:                          byteToSend--;
  1D0C    06DF     DECF 0xfdf, F, ACCESS
2176:                      }//end while(byte_to_send.Val)
2177:                  }
2178:                  else  // RAM
2179:                  {
2180:                      while(byteToSend)
  1D10    50DF     MOVF 0xfdf, W, ACCESS
  1D12    E015     BZ 0x1d3e
  1D3C    D7E9     BRA 0x1d10
2181:                      {
2182:                          *pDst++ = *inPipes[0].pSrc.bRam++;
  1D14    C079     MOVFF 0x79, 0xfe9
  1D16    FFE9     NOP
  1D18    C07A     MOVFF 0x7a, 0xfea
  1D1A    FFEA     NOP
  1D1C    2B79     INCF 0x79, F, BANKED
  1D1E    0E00     MOVLW 0
  1D20    237A     ADDWFC 0x7a, F, BANKED
  1D22    50EF     MOVF 0xfef, W, ACCESS
  1D24    6EE6     MOVWF 0xfe6, ACCESS
  1D26    C087     MOVFF 0x87, 0xfe9
  1D28    FFE9     NOP
  1D2A    C088     MOVFF 0x88, 0xfea
  1D2C    FFEA     NOP
  1D2E    2B87     INCF 0x87, F, BANKED
  1D30    0E00     MOVLW 0
  1D32    2388     ADDWFC 0x88, F, BANKED
  1D34    52E5     MOVF 0xfe5, F, ACCESS
  1D36    50E7     MOVF 0xfe7, W, ACCESS
  1D38    6EEF     MOVWF 0xfef, ACCESS
2183:                          byteToSend--;
  1D3A    06DF     DECF 0xfdf, F, ACCESS
2184:                      }//end while(byte_to_send.Val)
2185:                  }//end if(usb_stat.ctrl_trf_mem == _ROM)
2186:              }//end USBCtrlTrfTxService
  1D3E    52E5     MOVF 0xfe5, F, ACCESS
  1D40    52E5     MOVF 0xfe5, F, ACCESS
  1D42    CFE7     MOVFF 0xfe7, 0xfd9
  1D44    FFD9     NOP
  1D46    0012     RETURN 0
2187:              
2188:              /******************************************************************************
2189:               * Function:        void USBCtrlTrfRxService(void)
2190:               *
2191:               * PreCondition:    pDst and wCount are setup properly.
2192:               *                  pSrc is always &CtrlTrfData
2193:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
2194:               *                  wCount should be set to 0 at the start of each control
2195:               *                  transfer.
2196:               *
2197:               * Input:           None
2198:               *
2199:               * Output:          None
2200:               *
2201:               * Side Effects:    None
2202:               *
2203:               * Overview:        This routine is used for host to device control transfers
2204:               *					(uses OUT transactions).  This function receives the data that arrives
2205:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2206:               *					buffer.  Once the host has sent all the data it was intending
2207:               *					to send, this function will call the appropriate outPipes[0].pFunc()
2208:               *					handler (unless it is NULL), so that it can be used by the
2209:               *					intended target firmware.
2210:               *
2211:               * Note:            None
2212:               *****************************************************************************/
2213:              static void USBCtrlTrfRxService(void)
  1D48    CFD9     MOVFF 0xfd9, 0xfe6
  1D4A    FFE6     NOP
  1D4C    CFE1     MOVFF 0xfe1, 0xfd9
  1D4E    FFD9     NOP
  1D50    0E02     MOVLW 0x2
  1D52    26E1     ADDWF 0xfe1, F, ACCESS
2214:              {
2215:                  BYTE byteToRead;
2216:                  BYTE i;
2217:              
2218:                  //Load byteToRead with the number of bytes the host just sent us in the 
2219:                  //last OUT transaction.
2220:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;   
  1D54    C063     MOVFF 0x63, 0xfe9
  1D56    FFE9     NOP
  1D58    C064     MOVFF 0x64, 0xfea
  1D5A    FFEA     NOP
  1D5C    52EE     MOVF 0xfee, F, ACCESS
  1D5E    CFEF     MOVFF 0xfef, 0xfdf
  1D60    FFDF     NOP
2221:              
2222:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2223:                  //of remaining bytes expected to be received from the host, in the control
2224:                  //transfer.  First check to see if the host sent us more bytes than the
2225:                  //application firmware was expecting to receive.
2226:                  if(byteToRead > outPipes[0].wCount.Val)
  1D62    CFDF     MOVFF 0xfdf, 0x14
  1D64    F014     NOP
  1D66    5014     MOVF 0x14, W, ACCESS
  1D68    0100     MOVLB 0
  1D6A    5D82     SUBWF 0x82, W, BANKED
  1D6C    0E00     MOVLW 0
  1D6E    5983     SUBWFB 0x83, W, BANKED
  1D70    E202     BC 0x1d76
2227:                  {
2228:                      byteToRead = outPipes[0].wCount.Val;
  1D72    C082     MOVFF 0x82, 0xfdf
  1D74    FFDF     NOP
2229:                  }	
2230:                  //Reduce the number of remaining bytes by the number we just received.
2231:              	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
  1D76    50DF     MOVF 0xfdf, W, ACCESS
  1D78    6E14     MOVWF 0x14, ACCESS
  1D7A    6A15     CLRF 0x15, ACCESS
  1D7C    50E8     MOVF 0xfe8, W, ACCESS
  1D7E    5D82     SUBWF 0x82, W, BANKED
  1D80    6F82     MOVWF 0x82, BANKED
  1D82    5015     MOVF 0x15, W, ACCESS
  1D84    5983     SUBWFB 0x83, W, BANKED
  1D86    6F83     MOVWF 0x83, BANKED
2232:              
2233:                  //Copy the OUT DATAx packet bytes that we just received from the host,
2234:                  //into the user application buffer space.
2235:                  for(i=0;i<byteToRead;i++)
  1D88    0E01     MOVLW 0x1
  1D8A    6ADB     CLRF 0xfdb, ACCESS
  1D8C    50DF     MOVF 0xfdf, W, ACCESS
  1D8E    6EF3     MOVWF 0xff3, ACCESS
  1D90    0E01     MOVLW 0x1
  1D92    CFDB     MOVFF 0xfdb, 0xff4
  1D94    FFF4     NOP
  1D96    50F3     MOVF 0xff3, W, ACCESS
  1D98    5CF4     SUBWF 0xff4, W, ACCESS
  1D9A    E216     BC 0x1dc8
  1DC2    0E01     MOVLW 0x1
  1DC4    2ADB     INCF 0xfdb, F, ACCESS
  1DC6    D7E2     BRA 0x1d8c
2236:                  {
2237:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
  1D9C    0E01     MOVLW 0x1
  1D9E    50DB     MOVF 0xfdb, W, ACCESS
  1DA0    6AEA     CLRF 0xfea, ACCESS
  1DA2    0F48     ADDLW 0x48
  1DA4    6EE9     MOVWF 0xfe9, ACCESS
  1DA6    0E04     MOVLW 0x4
  1DA8    22EA     ADDWFC 0xfea, F, ACCESS
  1DAA    50EF     MOVF 0xfef, W, ACCESS
  1DAC    6EE6     MOVWF 0xfe6, ACCESS
  1DAE    C07F     MOVFF 0x7f, 0xfe9
  1DB0    FFE9     NOP
  1DB2    C080     MOVFF 0x80, 0xfea
  1DB4    FFEA     NOP
  1DB6    2B7F     INCF 0x7f, F, BANKED
  1DB8    0E00     MOVLW 0
  1DBA    2380     ADDWFC 0x80, F, BANKED
  1DBC    52E5     MOVF 0xfe5, F, ACCESS
  1DBE    50E7     MOVF 0xfe7, W, ACCESS
  1DC0    6EEF     MOVWF 0xfef, ACCESS
2238:                  }//end while(byteToRead.Val)
2239:              
2240:                  //If there is more data to receive, prepare EP0 OUT so that it can receive 
2241:              	//the next packet in the sequence.
2242:                  if(outPipes[0].wCount.Val > 0)
  1DC8    0E00     MOVLW 0
  1DCA    80D8     BSF 0xfd8, 0, ACCESS
  1DCC    5582     SUBFWB 0x82, W, BANKED
  1DCE    0E00     MOVLW 0
  1DD0    5583     SUBFWB 0x83, W, BANKED
  1DD2    E227     BC 0x1e22
2243:                  {
2244:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  1DD4    C065     MOVFF 0x65, 0xfe9
  1DD6    FFE9     NOP
  1DD8    C066     MOVFF 0x66, 0xfea
  1DDA    FFEA     NOP
  1DDC    52EE     MOVF 0xfee, F, ACCESS
  1DDE    0E08     MOVLW 0x8
  1DE0    6EEF     MOVWF 0xfef, ACCESS
2245:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
  1DE2    C065     MOVFF 0x65, 0xfe9
  1DE4    FFE9     NOP
  1DE6    C066     MOVFF 0x66, 0xfea
  1DE8    FFEA     NOP
  1DEA    0E02     MOVLW 0x2
  1DEC    26E9     ADDWF 0xfe9, F, ACCESS
  1DEE    0E00     MOVLW 0
  1DF0    22EA     ADDWFC 0xfea, F, ACCESS
  1DF2    0E48     MOVLW 0x48
  1DF4    6EEE     MOVWF 0xfee, ACCESS
  1DF6    0E04     MOVLW 0x4
  1DF8    6EED     MOVWF 0xfed, ACCESS
2246:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
  1DFA    C063     MOVFF 0x63, 0xfe9
  1DFC    FFE9     NOP
  1DFE    C064     MOVFF 0x64, 0xfea
  1E00    FFEA     NOP
  1E02    50EF     MOVF 0xfef, W, ACCESS
  1E04    0B40     ANDLW 0x40
  1E06    E106     BNZ 0x1e14
2247:                      {
2248:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
  1E08    C065     MOVFF 0x65, 0xfe9
  1E0A    FFE9     NOP
  1E0C    C066     MOVFF 0x66, 0xfea
  1E0E    FFEA     NOP
  1E10    0EC8     MOVLW 0xc8
2249:                      }
2250:                      else
  1E12    D005     BRA 0x1e1e
2251:                      {
2252:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN;
  1E14    C065     MOVFF 0x65, 0xfe9
  1E16    FFE9     NOP
  1E18    C066     MOVFF 0x66, 0xfea
  1E1A    FFEA     NOP
  1E1C    0E88     MOVLW 0x88
  1E1E    6EEF     MOVWF 0xfef, ACCESS
2253:                      }
2254:                  }
2255:                  else
  1E20    D02B     BRA 0x1e78
2256:                  {
2257:              	    //We have received all OUT packets that we were expecting to
2258:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
2259:              		//the next SETUP transaction that may arrive.
2260:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  1E22    C065     MOVFF 0x65, 0xfe9
  1E24    FFE9     NOP
  1E26    C066     MOVFF 0x66, 0xfea
  1E28    FFEA     NOP
  1E2A    52EE     MOVF 0xfee, F, ACCESS
  1E2C    0E08     MOVLW 0x8
  1E2E    6EEF     MOVWF 0xfef, ACCESS
2261:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  1E30    C065     MOVFF 0x65, 0xfe9
  1E32    FFE9     NOP
  1E34    C066     MOVFF 0x66, 0xfea
  1E36    FFEA     NOP
  1E38    0E02     MOVLW 0x2
  1E3A    26E9     ADDWF 0xfe9, F, ACCESS
  1E3C    0E00     MOVLW 0
  1E3E    22EA     ADDWFC 0xfea, F, ACCESS
  1E40    0E40     MOVLW 0x40
  1E42    6EEE     MOVWF 0xfee, ACCESS
  1E44    0E04     MOVLW 0x4
  1E46    6EED     MOVWF 0xfed, ACCESS
2262:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
2263:                      //control transfers.  However, set BSTALL in case the host tries to send
2264:                      //more data than it claims it was going to send.
2265:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
  1E48    C065     MOVFF 0x65, 0xfe9
  1E4A    FFE9     NOP
  1E4C    C066     MOVFF 0x66, 0xfea
  1E4E    FFEA     NOP
  1E50    0E84     MOVLW 0x84
  1E52    6EEF     MOVWF 0xfef, ACCESS
2266:              
2267:              		//All data bytes for the host to device control write (OUT) have now been
2268:              		//received successfully.
2269:              		//Go ahead and call the user specified callback function, to use/consume
2270:              		//the control transfer data (ex: if the "void (*function)" parameter 
2271:              		//was non-NULL when USBEP0Receive() was called).
2272:                      if(outPipes[0].pFunc != NULL)
  1E54    5184     MOVF 0x84, W, BANKED
  1E56    1185     IORWF 0x85, W, BANKED
  1E58    1186     IORWF 0x86, W, BANKED
  1E5A    E009     BZ 0x1e6e
2273:                      {
2274:                          outPipes[0].pFunc();
  1E5C    D007     BRA 0x1e6c
  1E5E    C086     MOVFF 0x86, 0xffb
  1E60    FFFB     NOP
  1E62    C085     MOVFF 0x85, 0xffa
  1E64    FFFA     NOP
  1E66    0100     MOVLB 0
  1E68    5184     MOVF 0x84, W, BANKED
  1E6A    6EF9     MOVWF 0xff9, ACCESS
  1E6C    DFF8     RCALL 0x1e5e
2275:                      }
2276:                      outPipes[0].info.bits.busy = 0;    
  1E6E    0100     MOVLB 0
  1E70    9F81     BCF 0x81, 0x7, BANKED
2277:              
2278:                      //Ready to arm status stage IN transaction now, if the application
2279:                      //firmware has completed processing the request.  If it is still busy
2280:                      //and needs more time to finish handling the request, then the user
2281:                      //callback (the one called by the outPipes[0].pFunc();) should set the
2282:                      //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2283:                      //this case, it is the application's firmware responsibility to call 
2284:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2285:                      //Note: The application firmware must process the request and call
2286:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2287:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
2288:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
2289:                      //more details.
2290:                      if(USBDeferStatusStagePacket == FALSE)
  1E72    5197     MOVF 0x97, W, BANKED
  1E74    E101     BNZ 0x1e78
2291:                      {
2292:                          USBCtrlEPAllowStatusStage();
  1E76    DD18     RCALL 0x18a8
2293:                      }            
2294:                  }    
2295:              
2296:              }//end USBCtrlTrfRxService
  1E78    0E02     MOVLW 0x2
  1E7A    5CE1     SUBWF 0xfe1, W, ACCESS
  1E7C    E202     BC 0x1e82
  1E7E    6AE1     CLRF 0xfe1, ACCESS
  1E80    52E5     MOVF 0xfe5, F, ACCESS
  1E82    6EE1     MOVWF 0xfe1, ACCESS
  1E84    52E5     MOVF 0xfe5, F, ACCESS
  1E86    CFE7     MOVFF 0xfe7, 0xfd9
  1E88    FFD9     NOP
  1E8A    0012     RETURN 0
2297:              
2298:              
2299:              /********************************************************************
2300:               * Function:        void USBStdSetCfgHandler(void)
2301:               *
2302:               * PreCondition:    None
2303:               *
2304:               * Input:           None
2305:               *
2306:               * Output:          None
2307:               *
2308:               * Side Effects:    None
2309:               *
2310:               * Overview:        This routine first disables all endpoints by
2311:               *                  clearing UEP registers. It then configures
2312:               *                  (initializes) endpoints by calling the callback
2313:               *                  function USBCBInitEP().
2314:               *
2315:               * Note:            None
2316:               *******************************************************************/
2317:              void USBStdSetCfgHandler(void)
  1E8C    CFD9     MOVFF 0xfd9, 0xfe6
  1E8E    FFE6     NOP
  1E90    CFE1     MOVFF 0xfe1, 0xfd9
  1E92    FFD9     NOP
  1E94    52E6     MOVF 0xfe6, F, ACCESS
2318:              {
2319:                  BYTE i;
2320:              
2321:                  // This will generate a zero length packet
2322:                  inPipes[0].info.bits.busy = 1;            
  1E96    0100     MOVLB 0
  1E98    8F7C     BSF 0x7c, 0x7, BANKED
2323:              
2324:                  //Clear all of the endpoint control registers
2325:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
  1E9A    0E03     MOVLW 0x3
  1E9C    6EE6     MOVWF 0xfe6, ACCESS
  1E9E    6AE6     CLRF 0xfe6, ACCESS
  1EA0    6AE6     CLRF 0xfe6, ACCESS
  1EA2    0E27     MOVLW 0x27
  1EA4    6EE6     MOVWF 0xfe6, ACCESS
  1EA6    0E0F     MOVLW 0xf
  1EA8    6EE6     MOVWF 0xfe6, ACCESS
  1EAA    EC9E     CALL 0x4d3c, 0
  1EAC    F026     NOP
  1EAE    6E14     MOVWF 0x14, ACCESS
  1EB0    0E05     MOVLW 0x5
  1EB2    5EE1     SUBWF 0xfe1, F, ACCESS
  1EB4    5014     MOVF 0x14, W, ACCESS
2326:              
2327:                  //Clear all of the BDT entries
2328:                  for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
  1EB6    6ADF     CLRF 0xfdf, ACCESS
  1EB8    50DF     MOVF 0xfdf, W, ACCESS
  1EBA    6E14     MOVWF 0x14, ACCESS
  1EBC    6A15     CLRF 0x15, ACCESS
  1EBE    0E10     MOVLW 0x10
  1EC0    5C14     SUBWF 0x14, W, ACCESS
  1EC2    0E00     MOVLW 0
  1EC4    5815     SUBWFB 0x15, W, ACCESS
  1EC6    E210     BC 0x1ee8
  1EE4    2ADF     INCF 0xfdf, F, ACCESS
  1EE6    D7E8     BRA 0x1eb8
2329:                  {
2330:                      BDT[i].Val = 0x00;
  1EC8    50DF     MOVF 0xfdf, W, ACCESS
  1ECA    0D04     MULLW 0x4
  1ECC    CFF3     MOVFF 0xff3, 0xfe9
  1ECE    FFE9     NOP
  1ED0    CFF4     MOVFF 0xff4, 0xfea
  1ED2    FFEA     NOP
  1ED4    0E00     MOVLW 0
  1ED6    26E9     ADDWF 0xfe9, F, ACCESS
  1ED8    0E04     MOVLW 0x4
  1EDA    22EA     ADDWFC 0xfea, F, ACCESS
  1EDC    6AEE     CLRF 0xfee, ACCESS
  1EDE    6AEE     CLRF 0xfee, ACCESS
  1EE0    6AEE     CLRF 0xfee, ACCESS
  1EE2    6AEE     CLRF 0xfee, ACCESS
2331:                  }
2332:              
2333:                  // Assert reset request to all of the Ping Pong buffer pointers
2334:                  USBPingPongBufferReset = 1;                                   
  1EE8    8C65     BSF 0xf65, 0x6, ACCESS
2335:              
2336:                  //clear the alternate interface settings
2337:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
  1EEA    0E01     MOVLW 0x1
  1EEC    6EE6     MOVWF 0xfe6, ACCESS
  1EEE    6AE6     CLRF 0xfe6, ACCESS
  1EF0    6AE6     CLRF 0xfe6, ACCESS
  1EF2    0E62     MOVLW 0x62
  1EF4    6EE6     MOVWF 0xfe6, ACCESS
  1EF6    0E00     MOVLW 0
  1EF8    6EE6     MOVWF 0xfe6, ACCESS
  1EFA    EC9E     CALL 0x4d3c, 0
  1EFC    F026     NOP
  1EFE    6E14     MOVWF 0x14, ACCESS
  1F00    0E05     MOVLW 0x5
  1F02    5EE1     SUBWF 0xfe1, F, ACCESS
  1F04    5014     MOVF 0x14, W, ACCESS
2338:              
2339:                  //Stop trying to reset ping pong buffer pointers
2340:                  USBPingPongBufferReset = 0;
  1F06    9C65     BCF 0xf65, 0x6, ACCESS
2341:              
2342:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
  1F08    0100     MOVLB 0
  1F0A    0E08     MOVLW 0x8
  1F0C    6F6F     MOVWF 0x6f, BANKED
  1F0E    0E04     MOVLW 0x4
  1F10    6F70     MOVWF 0x70, BANKED
2343:              
2344:              	//Set the next out to the current out packet
2345:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
  1F12    0E00     MOVLW 0
  1F14    6F63     MOVWF 0x63, BANKED
  1F16    0E04     MOVLW 0x4
  1F18    6F64     MOVWF 0x64, BANKED
2346:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
  1F1A    C063     MOVFF 0x63, 0x65
  1F1C    F065     NOP
  1F1E    6F66     MOVWF 0x66, BANKED
2347:              
2348:                  //set the current configuration
2349:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
  1F20    C442     MOVFF 0x442, 0x61
  1F22    F061     NOP
2350:              
2351:                  //if the configuration value == 0
2352:                  if(USBActiveConfiguration == 0)
  1F24    5161     MOVF 0x61, W, BANKED
  1F26    E102     BNZ 0x1f2c
2353:                  {
2354:                      //Go back to the addressed state
2355:                      USBDeviceState = ADDRESS_STATE;
  1F28    0E10     MOVLW 0x10
2356:                  }
2357:                  else
  1F2A    D012     BRA 0x1f50
2358:                  {
2359:                      //initialize the required endpoints
2360:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
  1F2C    0E01     MOVLW 0x1
  1F2E    6EE6     MOVWF 0xfe6, ACCESS
  1F30    6AE6     CLRF 0xfe6, ACCESS
  1F32    0E61     MOVLW 0x61
  1F34    6EE6     MOVWF 0xfe6, ACCESS
  1F36    0E00     MOVLW 0
  1F38    6EE6     MOVWF 0xfe6, ACCESS
  1F3A    0E01     MOVLW 0x1
  1F3C    6EE6     MOVWF 0xfe6, ACCESS
  1F3E    6AE6     CLRF 0xfe6, ACCESS
  1F40    ECA0     CALL 0x4340, 0
  1F42    F021     NOP
  1F44    6E14     MOVWF 0x14, ACCESS
  1F46    0E06     MOVLW 0x6
  1F48    5EE1     SUBWF 0xfe1, F, ACCESS
  1F4A    5014     MOVF 0x14, W, ACCESS
2361:              
2362:                      //Otherwise go to the configured state.  Update the state variable last,
2363:                      //after performing all of the set configuration related initialization
2364:                      //tasks.
2365:                      USBDeviceState = CONFIGURED_STATE;		
  1F4C    0100     MOVLB 0
  1F4E    0E20     MOVLW 0x20
  1F50    6F60     MOVWF 0x60, BANKED
2366:                  }//end if(SetupPkt.bConfigurationValue == 0)
2367:              }//end USBStdSetCfgHandler
  1F52    52E5     MOVF 0xfe5, F, ACCESS
  1F54    52E5     MOVF 0xfe5, F, ACCESS
  1F56    CFE7     MOVFF 0xfe7, 0xfd9
  1F58    FFD9     NOP
  1F5A    0012     RETURN 0
2368:              
2369:              /********************************************************************
2370:               * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
2371:               *
2372:               * PreCondition:    None
2373:               *
2374:               * Input:           BYTE EPNum - the endpoint to be configured
2375:               *                  BYTE direction - the direction to be configured
2376:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
2377:               *
2378:               * Output:          None
2379:               *
2380:               * Side Effects:    None
2381:               *
2382:               * Overview:        This function will configure the specified 
2383:               *                  endpoint
2384:               *
2385:               * Note:            None
2386:               *******************************************************************/
2387:              static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
  1F5C    CFD9     MOVFF 0xfd9, 0xfe6
  1F5E    FFE6     NOP
  1F60    CFE1     MOVFF 0xfe1, 0xfd9
  1F62    FFD9     NOP
  1F64    0E02     MOVLW 0x2
  1F66    26E1     ADDWF 0xfe1, F, ACCESS
2388:              {
2389:                  volatile BDT_ENTRY* handle;
2390:              
2391:                  //Compute a pointer to the even BDT entry corresponding to the
2392:                  //EPNum and direction values passed to this function.
2393:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
  1F68    0E00     MOVLW 0
  1F6A    6EDE     MOVWF 0xfde, ACCESS
  1F6C    0E04     MOVLW 0x4
  1F6E    6EDD     MOVWF 0xfdd, ACCESS
2394:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
  1F70    0EFD     MOVLW 0xfd
  1F72    50DB     MOVF 0xfdb, W, ACCESS
  1F74    24E8     ADDWF 0xfe8, W, ACCESS
  1F76    6E16     MOVWF 0x16, ACCESS
  1F78    0EFE     MOVLW 0xfe
  1F7A    50DB     MOVF 0xfdb, W, ACCESS
  1F7C    0D04     MULLW 0x4
  1F7E    50F3     MOVF 0xff3, W, ACCESS
  1F80    2416     ADDWF 0x16, W, ACCESS
  1F82    0D04     MULLW 0x4
  1F84    CFF4     MOVFF 0xff4, 0x15
  1F86    F015     NOP
  1F88    CFD9     MOVFF 0xfd9, 0xfe9
  1F8A    FFE9     NOP
  1F8C    CFDA     MOVFF 0xfda, 0xfea
  1F8E    FFEA     NOP
  1F90    50F3     MOVF 0xff3, W, ACCESS
  1F92    26EE     ADDWF 0xfee, F, ACCESS
  1F94    5015     MOVF 0x15, W, ACCESS
  1F96    22ED     ADDWFC 0xfed, F, ACCESS
2395:                  
2396:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
  1F98    CFDE     MOVFF 0xfde, 0xfe9
  1F9A    FFE9     NOP
  1F9C    CFDD     MOVFF 0xfdd, 0xfea
  1F9E    FFEA     NOP
  1FA0    9EEF     BCF 0xfef, 0x7, ACCESS
2397:                  //already cleared the entire BDT table
2398:              
2399:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
2400:                  //for USBTransferOnePacket() API calls.
2401:                  if(direction == OUT_FROM_HOST)
  1FA2    0EFD     MOVLW 0xfd
  1FA4    50DB     MOVF 0xfdb, W, ACCESS
  1FA6    E10A     BNZ 0x1fbc
2402:                  {
2403:                      pBDTEntryOut[EPNum] = handle;
  1FA8    0EFE     MOVLW 0xfe
  1FAA    6AEA     CLRF 0xfea, ACCESS
  1FAC    34DB     RLCF 0xfdb, W, ACCESS
  1FAE    0BFE     ANDLW 0xfe
  1FB0    36EA     RLCF 0xfea, F, ACCESS
  1FB2    6EE9     MOVWF 0xfe9, ACCESS
  1FB4    0E67     MOVLW 0x67
  1FB6    26E9     ADDWF 0xfe9, F, ACCESS
  1FB8    0E00     MOVLW 0
2404:                  }
2405:                  else
  1FBA    D009     BRA 0x1fce
2406:                  {
2407:                      pBDTEntryIn[EPNum] = handle;
  1FBC    0EFE     MOVLW 0xfe
  1FBE    6AEA     CLRF 0xfea, ACCESS
  1FC0    34DB     RLCF 0xfdb, W, ACCESS
  1FC2    0BFE     ANDLW 0xfe
  1FC4    36EA     RLCF 0xfea, F, ACCESS
  1FC6    6EE9     MOVWF 0xfe9, ACCESS
  1FC8    0E6F     MOVLW 0x6f
  1FCA    26E9     ADDWF 0xfe9, F, ACCESS
  1FCC    0E00     MOVLW 0
  1FCE    22EA     ADDWFC 0xfea, F, ACCESS
  1FD0    CFDE     MOVFF 0xfde, 0xfee
  1FD2    FFEE     NOP
  1FD4    CFDD     MOVFF 0xfdd, 0xfed
  1FD6    FFED     NOP
2408:                  }
2409:              
2410:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2411:                      handle->STAT.DTS = 0;
  1FD8    CFDE     MOVFF 0xfde, 0xfe9
  1FDA    FFE9     NOP
  1FDC    CFDD     MOVFF 0xfdd, 0xfea
  1FDE    FFEA     NOP
  1FE0    9CEF     BCF 0xfef, 0x6, ACCESS
2412:                      (handle+1)->STAT.DTS = 1;
  1FE2    CFDE     MOVFF 0xfde, 0xfe9
  1FE4    FFE9     NOP
  1FE6    CFDD     MOVFF 0xfdd, 0xfea
  1FE8    FFEA     NOP
  1FEA    0E04     MOVLW 0x4
  1FEC    26E9     ADDWF 0xfe9, F, ACCESS
  1FEE    0E00     MOVLW 0
  1FF0    22EA     ADDWFC 0xfea, F, ACCESS
  1FF2    8CEF     BSF 0xfef, 0x6, ACCESS
2413:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
2414:                      //Set DTS to one because the first thing we will do
2415:                      //when transmitting is toggle the bit
2416:                      handle->STAT.DTS = 1;
2417:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
2418:                      if(EPNum != 0)
2419:                      {
2420:                          handle->STAT.DTS = 1;
2421:                      }
2422:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
2423:                      if(EPNum != 0)
2424:                      {
2425:                          handle->STAT.DTS = 0;
2426:                          (handle+1)->STAT.DTS = 1;
2427:                      }
2428:                  #endif
2429:              }
  1FF4    0E02     MOVLW 0x2
  1FF6    5CE1     SUBWF 0xfe1, W, ACCESS
  1FF8    E202     BC 0x1ffe
  1FFA    6AE1     CLRF 0xfe1, ACCESS
  1FFC    52E5     MOVF 0xfe5, F, ACCESS
  1FFE    6EE1     MOVWF 0xfe1, ACCESS
  2000    52E5     MOVF 0xfe5, F, ACCESS
  2002    CFE7     MOVFF 0xfe7, 0xfd9
  2004    FFD9     NOP
  2006    0012     RETURN 0
2430:              
2431:              /*****************************************************************************************************************
2432:                Function:
2433:                      void USBEnableEndpoint(BYTE ep, BYTE options)
2434:                  
2435:                Summary:
2436:                  This function will enable the specified endpoint with the specified
2437:                  options
2438:                Description:
2439:                  This function will enable the specified endpoint with the specified
2440:                  options.
2441:                  
2442:                  Typical Usage:
2443:                  <code>
2444:                  void USBCBInitEP(void)
2445:                  {
2446:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
2447:                      USBMSDInit();
2448:                  }
2449:                  </code>
2450:                  
2451:                  In the above example endpoint number MSD_DATA_IN_EP is being configured
2452:                  for both IN and OUT traffic with handshaking enabled. Also since
2453:                  MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
2454:                  explicitly disable SETUP packets on this endpoint.
2455:                Conditions:
2456:                  None
2457:                Input:
2458:                  BYTE ep -       the endpoint to be configured
2459:                  BYTE options -  optional settings for the endpoint. The options should
2460:                                  be ORed together to form a single options string. The
2461:                                  available optional settings for the endpoint. The
2462:                                  options should be ORed together to form a single options
2463:                                  string. The available options are the following\:
2464:                                  * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
2465:                                    NAK)
2466:                                  * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
2467:                                    NAK)
2468:                                  * USB_OUT_ENABLED enables the out direction
2469:                                  * USB_OUT_DISABLED disables the out direction
2470:                                  * USB_IN_ENABLED enables the in direction
2471:                                  * USB_IN_DISABLED disables the in direction
2472:                                  * USB_ALLOW_SETUP enables control transfers
2473:                                  * USB_DISALLOW_SETUP disables control transfers
2474:                Return:
2475:                  None
2476:                Remarks:
2477:                  None                                                                                                          
2478:                *****************************************************************************************************************/
2479:              void USBEnableEndpoint(BYTE ep, BYTE options)
  2008    CFD9     MOVFF 0xfd9, 0xfe6
  200A    FFE6     NOP
  200C    CFE1     MOVFF 0xfe1, 0xfd9
  200E    FFD9     NOP
  2010    0E02     MOVLW 0x2
  2012    26E1     ADDWF 0xfe1, F, ACCESS
2480:              {
2481:                  unsigned char* p;
2482:                      
2483:                  //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
2484:                  //starting DTS state in the BDT entry.
2485:                  if(options & USB_OUT_ENABLED)
  2014    0EFD     MOVLW 0xfd
  2016    A4DB     BTFSS 0xfdb, 0x2, ACCESS
  2018    D007     BRA 0x2028
2486:                  {
2487:                      USBConfigureEndpoint(ep, OUT_FROM_HOST);
  201A    6AE6     CLRF 0xfe6, ACCESS
  201C    0EFE     MOVLW 0xfe
  201E    CFDB     MOVFF 0xfdb, 0xfe6
  2020    FFE6     NOP
  2022    DF9C     RCALL 0x1f5c
  2024    52E5     MOVF 0xfe5, F, ACCESS
  2026    52E5     MOVF 0xfe5, F, ACCESS
2488:                  }
2489:                  if(options & USB_IN_ENABLED)
  2028    0EFD     MOVLW 0xfd
  202A    A2DB     BTFSS 0xfdb, 0x1, ACCESS
  202C    D008     BRA 0x203e
2490:                  {
2491:                      USBConfigureEndpoint(ep, IN_TO_HOST);
  202E    0E01     MOVLW 0x1
  2030    6EE6     MOVWF 0xfe6, ACCESS
  2032    0EFE     MOVLW 0xfe
  2034    CFDB     MOVFF 0xfdb, 0xfe6
  2036    FFE6     NOP
  2038    DF91     RCALL 0x1f5c
  203A    52E5     MOVF 0xfe5, F, ACCESS
  203C    52E5     MOVF 0xfe5, F, ACCESS
2492:                  }
2493:              
2494:                  //Update the relevant UEPx register to actually enable the endpoint with
2495:                  //the specified options (ex: handshaking enabled, control transfers allowed,
2496:                  //etc.)
2497:                  #if defined(__C32__)
2498:                      p = (unsigned char*)(&U1EP0+(4*ep));
2499:                  #else
2500:                      p = (unsigned char*)(&U1EP0+ep);
  203E    0EFE     MOVLW 0xfe
  2040    50DB     MOVF 0xfdb, W, ACCESS
  2042    6A15     CLRF 0x15, ACCESS
  2044    0F26     ADDLW 0x26
  2046    6E14     MOVWF 0x14, ACCESS
  2048    0E0F     MOVLW 0xf
  204A    2215     ADDWFC 0x15, F, ACCESS
  204C    C014     MOVFF 0x14, 0xfde
  204E    FFDE     NOP
  2050    C015     MOVFF 0x15, 0xfdd
  2052    FFDD     NOP
2501:                  #endif
2502:                  *p = options;
  2054    CFDE     MOVFF 0xfde, 0xfe9
  2056    FFE9     NOP
  2058    CFDD     MOVFF 0xfdd, 0xfea
  205A    FFEA     NOP
  205C    0EFD     MOVLW 0xfd
  205E    CFDB     MOVFF 0xfdb, 0xfef
  2060    FFEF     NOP
2503:              }
  2062    0E02     MOVLW 0x2
  2064    5CE1     SUBWF 0xfe1, W, ACCESS
  2066    E202     BC 0x206c
  2068    6AE1     CLRF 0xfe1, ACCESS
  206A    52E5     MOVF 0xfe5, F, ACCESS
  206C    6EE1     MOVWF 0xfe1, ACCESS
  206E    52E5     MOVF 0xfe5, F, ACCESS
  2070    CFE7     MOVFF 0xfe7, 0xfd9
  2072    FFD9     NOP
  2074    0012     RETURN 0
2504:              
2505:              /********************************************************************
2506:               * Function:        void USBStallEndpoint(BYTE ep, BYTE dir)
2507:               *
2508:               * PreCondition:    None
2509:               *
2510:               * Input:
2511:               *   BYTE ep - the endpoint the data will be transmitted on
2512:               *   BYTE dir - the direction of the transfer
2513:               *
2514:               * Output:          None
2515:               *
2516:               * Side Effects:    Endpoint is STALLed
2517:               *
2518:               * Overview:        STALLs the specified endpoint
2519:               *
2520:               * Note:            None
2521:               *******************************************************************/
2522:              void USBStallEndpoint(BYTE ep, BYTE dir)
  2076    CFD9     MOVFF 0xfd9, 0xfe6
  2078    FFE6     NOP
  207A    CFE1     MOVFF 0xfe1, 0xfd9
  207C    FFD9     NOP
  207E    0E02     MOVLW 0x2
  2080    26E1     ADDWF 0xfe1, F, ACCESS
2523:              {
2524:                  BDT_ENTRY *p;
2525:              
2526:                  if(ep == 0)
  2082    0EFE     MOVLW 0xfe
  2084    50DB     MOVF 0xfdb, W, ACCESS
  2086    E120     BNZ 0x20c8
2527:                  {
2528:                      /*
2529:                       * If no one knows how to service this request then stall.
2530:                       * Must also prepare EP0 to receive the next SETUP transaction.
2531:                       */
2532:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
  2088    C065     MOVFF 0x65, 0xfe9
  208A    FFE9     NOP
  208C    C066     MOVFF 0x66, 0xfea
  208E    FFEA     NOP
  2090    52EE     MOVF 0xfee, F, ACCESS
  2092    0E08     MOVLW 0x8
  2094    6EEF     MOVWF 0xfef, ACCESS
2533:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
  2096    C065     MOVFF 0x65, 0xfe9
  2098    FFE9     NOP
  209A    C066     MOVFF 0x66, 0xfea
  209C    FFEA     NOP
  209E    0E02     MOVLW 0x2
  20A0    26E9     ADDWF 0xfe9, F, ACCESS
  20A2    0E00     MOVLW 0
  20A4    22EA     ADDWFC 0xfea, F, ACCESS
  20A6    0E40     MOVLW 0x40
  20A8    6EEE     MOVWF 0xfee, ACCESS
  20AA    0E04     MOVLW 0x4
  20AC    6EED     MOVWF 0xfed, ACCESS
2534:              
2535:                      /* v2b fix */
2536:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
  20AE    C065     MOVFF 0x65, 0xfe9
  20B0    FFE9     NOP
  20B2    C066     MOVFF 0x66, 0xfea
  20B4    FFEA     NOP
  20B6    0E8C     MOVLW 0x8c
  20B8    6EEF     MOVWF 0xfef, ACCESS
2537:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
  20BA    C06F     MOVFF 0x6f, 0xfe9
  20BC    FFE9     NOP
  20BE    C070     MOVFF 0x70, 0xfea
  20C0    FFEA     NOP
  20C2    0E84     MOVLW 0x84
  20C4    6EEF     MOVWF 0xfef, ACCESS
2538:                  }
2539:                  else
  20C6    D03B     BRA 0x213e
2540:                  {
2541:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
  20C8    0EFD     MOVLW 0xfd
  20CA    50DB     MOVF 0xfdb, W, ACCESS
  20CC    24E8     ADDWF 0xfe8, W, ACCESS
  20CE    6E16     MOVWF 0x16, ACCESS
  20D0    0EFE     MOVLW 0xfe
  20D2    50DB     MOVF 0xfdb, W, ACCESS
  20D4    0D04     MULLW 0x4
  20D6    50F3     MOVF 0xff3, W, ACCESS
  20D8    2416     ADDWF 0x16, W, ACCESS
  20DA    0D04     MULLW 0x4
  20DC    CFF3     MOVFF 0xff3, 0x14
  20DE    F014     NOP
  20E0    CFF4     MOVFF 0xff4, 0x15
  20E2    F015     NOP
  20E4    0E00     MOVLW 0
  20E6    2614     ADDWF 0x14, F, ACCESS
  20E8    0E04     MOVLW 0x4
  20EA    2215     ADDWFC 0x15, F, ACCESS
  20EC    C014     MOVFF 0x14, 0xfde
  20EE    FFDE     NOP
  20F0    C015     MOVFF 0x15, 0xfdd
  20F2    FFDD     NOP
2542:                      p->STAT.Val |= _BSTALL | _USIE;
  20F4    0E84     MOVLW 0x84
  20F6    CFDE     MOVFF 0xfde, 0xfe9
  20F8    FFE9     NOP
  20FA    CFDD     MOVFF 0xfdd, 0xfea
  20FC    FFEA     NOP
  20FE    50E8     MOVF 0xfe8, W, ACCESS
  2100    12EF     IORWF 0xfef, F, ACCESS
2543:                  
2544:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
2545:                      //then stall that entry as well
2546:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || \
2547:                          (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
2548:                  
2549:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
  2102    0EFD     MOVLW 0xfd
  2104    50DB     MOVF 0xfdb, W, ACCESS
  2106    24E8     ADDWF 0xfe8, W, ACCESS
  2108    6E16     MOVWF 0x16, ACCESS
  210A    0EFE     MOVLW 0xfe
  210C    50DB     MOVF 0xfdb, W, ACCESS
  210E    0D04     MULLW 0x4
  2110    50F3     MOVF 0xff3, W, ACCESS
  2112    2416     ADDWF 0x16, W, ACCESS
  2114    0F01     ADDLW 0x1
  2116    0D04     MULLW 0x4
  2118    CFF3     MOVFF 0xff3, 0x14
  211A    F014     NOP
  211C    CFF4     MOVFF 0xff4, 0x15
  211E    F015     NOP
  2120    0E00     MOVLW 0
  2122    2614     ADDWF 0x14, F, ACCESS
  2124    0E04     MOVLW 0x4
  2126    2215     ADDWFC 0x15, F, ACCESS
  2128    C014     MOVFF 0x14, 0xfde
  212A    FFDE     NOP
  212C    C015     MOVFF 0x15, 0xfdd
  212E    FFDD     NOP
2550:                      p->STAT.Val |= _BSTALL | _USIE;
  2130    0E84     MOVLW 0x84
  2132    CFDE     MOVFF 0xfde, 0xfe9
  2134    FFE9     NOP
  2136    CFDD     MOVFF 0xfdd, 0xfea
  2138    FFEA     NOP
  213A    50E8     MOVF 0xfe8, W, ACCESS
  213C    12EF     IORWF 0xfef, F, ACCESS
2551:                      #endif
2552:                  }
2553:              }
  213E    0E02     MOVLW 0x2
  2140    5CE1     SUBWF 0xfe1, W, ACCESS
  2142    E202     BC 0x2148
  2144    6AE1     CLRF 0xfe1, ACCESS
  2146    52E5     MOVF 0xfe5, F, ACCESS
  2148    6EE1     MOVWF 0xfe1, ACCESS
  214A    52E5     MOVF 0xfe5, F, ACCESS
  214C    CFE7     MOVFF 0xfe7, 0xfd9
  214E    FFD9     NOP
  2150    0012     RETURN 0
2554:              
2555:              /********************************************************************
2556:               * Function:        USB_HANDLE USBTransferOnePacket(
2557:               *                      BYTE ep, 
2558:               *                      BYTE dir, 
2559:               *                      BYTE* data, 
2560:               *                      BYTE len)
2561:               *
2562:               * PreCondition:    The pBDTEntryIn[] or pBDTEntryOut[] pointer to 
2563:               *					the endpoint that will be used must have been 
2564:               *					initialized, prior to calling USBTransferOnePacket().
2565:               *					Therefore, the application firmware should not call
2566:               *					USBTransferOnePacket() until after the USB stack has been
2567:               					initialized (by USBDeviceInit()), and the host has sent a 
2568:               *					set configuration request.  This can be checked by
2569:               *					verifying that the USBGetDeviceState() == CONFIGURED_STATE,
2570:               *					prior to calling USBTransferOnePacket().
2571:               *					
2572:               *					Note: If calling the USBTransferOnePacket() 
2573:               *					function from within the USBCBInitEP() callback function, 
2574:               *					the set configuration is still being processed and the 
2575:               *					USBDeviceState may not be == CONFIGURED_STATE yet.  In this
2576:               *					special case, the USBTransferOnePacket() may still be 
2577:               *					called, but make sure that the endpoint has been enabled 
2578:               *					and initialized by the USBEnableEndpoint() function first.
2579:               *
2580:               * Input:
2581:               *   BYTE ep - the endpoint number that the data will be transmitted or 
2582:               *				received on
2583:               *   BYTE dir - the direction of the transfer
2584:               *              This value is either OUT_FROM_HOST or IN_TO_HOST
2585:               *   BYTE* data - For IN transactions: pointer to the RAM buffer containing 
2586:               *				  the data to be sent to the host.
2587:               *				  For OUT transactions: pointer to the RAM buffer that the
2588:               *				  received data should get written to.
2589:               *   BYTE len - length of the data needing to be sent (for IN transactions).
2590:               *				For OUT transactions, the len parameter should normally be set
2591:               *				to the endpoint size specified in the endpoint descriptor.
2592:               *
2593:               * Output:          
2594:               *   USB_HANDLE - handle to the transfer.  The handle is a pointer to
2595:               *					the BDT entry associated with this transaction.  The 
2596:               *					status of the transaction (ex: if it is complete or still
2597:               *					pending) can be checked using the USBHandleBusy() macro
2598:               *					and supplying the USB_HANDLE provided by 
2599:               *					USBTransferOnePacket().
2600:               *
2601:               *
2602:               * Side Effects:    None
2603:               *
2604:               * Overview:        The USBTransferOnePacket() function prepares a USB endpoint
2605:               *					so that it may send data to the host (an IN transaction),
2606:               *					or receive data from the host (an OUT transaction).  The
2607:               *					USBTransferOnePacket() function can be used both to receive
2608:               *					and send data to the host.  The USBTransferOnePacket()
2609:               *					function is the primary API function provided by the USB
2610:               *					stack firmware for sending or receiving application data
2611:               *					over the USB port.  The USBTransferOnePacket() is intended
2612:               *					for use with all application endpoints.  It is not used for
2613:               *					sending or receiving applicaiton data through endpoint 0
2614:               *					by using control transfers.  Separate API functions,
2615:               *					such as USBEP0Receive(), USBEP0SendRAMPtr(), and
2616:               *					USBEP0SendROMPtr() are provided for this purpose.
2617:               *					
2618:               *					The	USBTransferOnePacket() writes to the Buffer Descriptor
2619:               *					Table (BDT) entry associated with an endpoint buffer, and
2620:               *					sets the UOWN bit, which prepares the USB hardware to 
2621:               *					allow the transaction to complete.  The application firmware
2622:               *					can use the USBHandleBusy() macro to check the status of the
2623:               *					transaction, to see if the data has been successfully 
2624:               *					transmitted yet.
2625:               *
2626:               * Note:            None
2627:               *******************************************************************/
2628:              USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
  2152    CFD9     MOVFF 0xfd9, 0xfe6
  2154    FFE6     NOP
  2156    CFE1     MOVFF 0xfe1, 0xfd9
  2158    FFD9     NOP
  215A    0E02     MOVLW 0x2
  215C    26E1     ADDWF 0xfe1, F, ACCESS
2629:              {
2630:                  volatile BDT_ENTRY* handle;
2631:              
2632:                  //If the direction is IN
2633:                  if(dir != 0)
  215E    0EFD     MOVLW 0xfd
  2160    50DB     MOVF 0xfdb, W, ACCESS
  2162    E00A     BZ 0x2178
2634:                  {
2635:                      //point to the IN BDT of the specified endpoint
2636:                      handle = pBDTEntryIn[ep];
  2164    0EFE     MOVLW 0xfe
  2166    6AEA     CLRF 0xfea, ACCESS
  2168    34DB     RLCF 0xfdb, W, ACCESS
  216A    0BFE     ANDLW 0xfe
  216C    36EA     RLCF 0xfea, F, ACCESS
  216E    6EE9     MOVWF 0xfe9, ACCESS
  2170    0E6F     MOVLW 0x6f
  2172    26E9     ADDWF 0xfe9, F, ACCESS
  2174    0E00     MOVLW 0
2637:                  }
2638:                  else
  2176    D009     BRA 0x218a
2639:                  {
2640:                      //else point to the OUT BDT of the specified endpoint
2641:                      handle = pBDTEntryOut[ep];
  2178    0EFE     MOVLW 0xfe
  217A    6AEA     CLRF 0xfea, ACCESS
  217C    34DB     RLCF 0xfdb, W, ACCESS
  217E    0BFE     ANDLW 0xfe
  2180    36EA     RLCF 0xfea, F, ACCESS
  2182    6EE9     MOVWF 0xfe9, ACCESS
  2184    0E67     MOVLW 0x67
  2186    26E9     ADDWF 0xfe9, F, ACCESS
  2188    0E00     MOVLW 0
  218A    22EA     ADDWFC 0xfea, F, ACCESS
  218C    CFEE     MOVFF 0xfee, 0xfde
  218E    FFDE     NOP
  2190    CFED     MOVFF 0xfed, 0xfdd
  2192    FFDD     NOP
2642:                  }
2643:                  
2644:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
2645:                  //pBDTEntryOut[ep]) is initialized before using it.
2646:                  if(handle == 0)
  2194    CFD9     MOVFF 0xfd9, 0xfe9
  2196    FFE9     NOP
  2198    CFDA     MOVFF 0xfda, 0xfea
  219A    FFEA     NOP
  219C    50EE     MOVF 0xfee, W, ACCESS
  219E    10ED     IORWF 0xfed, W, ACCESS
  21A0    E103     BNZ 0x21a8
2647:                  {
2648:              	    return 0;
  21A2    6AF3     CLRF 0xff3, ACCESS
  21A4    6AF4     CLRF 0xff4, ACCESS
  21A6    D044     BRA 0x2230
2649:              	}
2650:              
2651:                  //Toggle the DTS bit if required
2652:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
2653:                      handle->STAT.Val ^= _DTSMASK;
2654:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
2655:                      if(ep != 0)
2656:                      {
2657:                          handle->STAT.Val ^= _DTSMASK;
2658:                      }
2659:                  #endif
2660:              
2661:                  //Set the data pointer, data length, and enable the endpoint
2662:                  handle->ADR = ConvertToPhysicalAddress(data);
  21A8    CFDE     MOVFF 0xfde, 0xfe9
  21AA    FFE9     NOP
  21AC    CFDD     MOVFF 0xfdd, 0xfea
  21AE    FFEA     NOP
  21B0    0E02     MOVLW 0x2
  21B2    26E9     ADDWF 0xfe9, F, ACCESS
  21B4    0E00     MOVLW 0
  21B6    22EA     ADDWFC 0xfea, F, ACCESS
  21B8    0EFB     MOVLW 0xfb
  21BA    CFDB     MOVFF 0xfdb, 0xfee
  21BC    FFEE     NOP
  21BE    0EFC     MOVLW 0xfc
  21C0    CFDB     MOVFF 0xfdb, 0xfed
  21C2    FFED     NOP
2663:                  handle->CNT = len;
  21C4    CFDE     MOVFF 0xfde, 0xfe9
  21C6    FFE9     NOP
  21C8    CFDD     MOVFF 0xfdd, 0xfea
  21CA    FFEA     NOP
  21CC    52EE     MOVF 0xfee, F, ACCESS
  21CE    0EFA     MOVLW 0xfa
  21D0    CFDB     MOVFF 0xfdb, 0xfef
  21D2    FFEF     NOP
2664:                  handle->STAT.Val &= _DTSMASK;
  21D4    0E40     MOVLW 0x40
  21D6    CFDE     MOVFF 0xfde, 0xfe9
  21D8    FFE9     NOP
  21DA    CFDD     MOVFF 0xfdd, 0xfea
  21DC    FFEA     NOP
  21DE    50E8     MOVF 0xfe8, W, ACCESS
  21E0    16EF     ANDWF 0xfef, F, ACCESS
2665:                  handle->STAT.Val |= _USIE | _DTSEN;
  21E2    0E88     MOVLW 0x88
  21E4    CFDE     MOVFF 0xfde, 0xfe9
  21E6    FFE9     NOP
  21E8    CFDD     MOVFF 0xfdd, 0xfea
  21EA    FFEA     NOP
  21EC    50E8     MOVF 0xfe8, W, ACCESS
  21EE    12EF     IORWF 0xfef, F, ACCESS
2666:              
2667:                  //Point to the next buffer for ping pong purposes.
2668:                  if(dir != 0)
  21F0    0EFD     MOVLW 0xfd
  21F2    50DB     MOVF 0xfdb, W, ACCESS
  21F4    E00A     BZ 0x220a
2669:                  {
2670:                      //toggle over the to the next buffer for an IN endpoint
2671:                      USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
  21F6    0EFE     MOVLW 0xfe
  21F8    6AEA     CLRF 0xfea, ACCESS
  21FA    34DB     RLCF 0xfdb, W, ACCESS
  21FC    0BFE     ANDLW 0xfe
  21FE    36EA     RLCF 0xfea, F, ACCESS
  2200    6EE9     MOVWF 0xfe9, ACCESS
  2202    0E6F     MOVLW 0x6f
  2204    26E9     ADDWF 0xfe9, F, ACCESS
  2206    0E00     MOVLW 0
2672:                  }
2673:                  else
  2208    D009     BRA 0x221c
2674:                  {
2675:                      //toggle over the to the next buffer for an OUT endpoint
2676:                      USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
  220A    0EFE     MOVLW 0xfe
  220C    6AEA     CLRF 0xfea, ACCESS
  220E    34DB     RLCF 0xfdb, W, ACCESS
  2210    0BFE     ANDLW 0xfe
  2212    36EA     RLCF 0xfea, F, ACCESS
  2214    6EE9     MOVWF 0xfe9, ACCESS
  2216    0E67     MOVLW 0x67
  2218    26E9     ADDWF 0xfe9, F, ACCESS
  221A    0E00     MOVLW 0
  221C    22EA     ADDWFC 0xfea, F, ACCESS
  221E    74EF     BTG 0xfef, 0x2, ACCESS
2677:                  }
2678:                  return (USB_HANDLE)handle;
  2220    CFDE     MOVFF 0xfde, 0x14
  2222    F014     NOP
  2224    CFDD     MOVFF 0xfdd, 0x15
  2226    F015     NOP
  2228    C014     MOVFF 0x14, 0xff3
  222A    FFF3     NOP
  222C    C015     MOVFF 0x15, 0xff4
  222E    FFF4     NOP
2679:              }
  2230    0E02     MOVLW 0x2
  2232    5CE1     SUBWF 0xfe1, W, ACCESS
  2234    E202     BC 0x223a
  2236    6AE1     CLRF 0xfe1, ACCESS
  2238    52E5     MOVF 0xfe5, F, ACCESS
  223A    6EE1     MOVWF 0xfe1, ACCESS
  223C    52E5     MOVF 0xfe5, F, ACCESS
  223E    CFE7     MOVFF 0xfe7, 0xfd9
  2240    FFD9     NOP
  2242    0012     RETURN 0
2680:              
2681:              /**************************************************************************
2682:                  Function:
2683:                      void USBCancelIO(BYTE endpoint)
2684:                  
2685:                  Description:
2686:                      This function cancels the transfers pending on the specified endpoint.
2687:                      This function can only be used after a SETUP packet is received and 
2688:                      before that setup packet is handled.  This is the time period in which
2689:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
2690:                      returns to the stack.
2691:              
2692:                  Precondition:
2693:                
2694:                  Parameters:
2695:                      BYTE endpoint - the endpoint number you wish to cancel the transfers for
2696:                   
2697:                  Return Values:
2698:                      None
2699:                      
2700:                  Remarks:
2701:                      None
2702:                                                                        
2703:                **************************************************************************/
2704:              void USBCancelIO(BYTE endpoint)
  2244    CFD9     MOVFF 0xfd9, 0xfe6
  2246    FFE6     NOP
  2248    CFE1     MOVFF 0xfe1, 0xfd9
  224A    FFD9     NOP
2705:              {
2706:                  if(USBPacketDisable == 1)
  224C    A865     BTFSS 0xf65, 0x4, ACCESS
  224E    D04E     BRA 0x22ec
2707:                  {
2708:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
2709:                  	//to mess with the BDT right now.
2710:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
  2250    0EFE     MOVLW 0xfe
  2252    6AEA     CLRF 0xfea, ACCESS
  2254    34DB     RLCF 0xfdb, W, ACCESS
  2256    0BFE     ANDLW 0xfe
  2258    36EA     RLCF 0xfea, F, ACCESS
  225A    6EE9     MOVWF 0xfe9, ACCESS
  225C    0E6F     MOVLW 0x6f
  225E    26E9     ADDWF 0xfe9, F, ACCESS
  2260    0E00     MOVLW 0
  2262    22EA     ADDWFC 0xfea, F, ACCESS
  2264    50EE     MOVF 0xfee, W, ACCESS
  2266    CFEF     MOVFF 0xfef, 0xfea
  2268    FFEA     NOP
  226A    6EE9     MOVWF 0xfe9, ACCESS
  226C    0E40     MOVLW 0x40
  226E    16EE     ANDWF 0xfee, F, ACCESS
  2270    6AEE     CLRF 0xfee, ACCESS
  2272    6AEE     CLRF 0xfee, ACCESS
  2274    6AEE     CLRF 0xfee, ACCESS
2711:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
  2276    0EFE     MOVLW 0xfe
  2278    6AEA     CLRF 0xfea, ACCESS
  227A    34DB     RLCF 0xfdb, W, ACCESS
  227C    0BFE     ANDLW 0xfe
  227E    36EA     RLCF 0xfea, F, ACCESS
  2280    6EE9     MOVWF 0xfe9, ACCESS
  2282    0E6F     MOVLW 0x6f
  2284    26E9     ADDWF 0xfe9, F, ACCESS
  2286    0E00     MOVLW 0
  2288    22EA     ADDWFC 0xfea, F, ACCESS
  228A    50EE     MOVF 0xfee, W, ACCESS
  228C    CFEF     MOVFF 0xfef, 0xfea
  228E    FFEA     NOP
  2290    6EE9     MOVWF 0xfe9, ACCESS
  2292    7CEE     BTG 0xfee, 0x6, ACCESS
2712:                  	
2713:                  	//Need to do additional handling if ping-pong buffering is being used
2714:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
2715:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
2716:                      //(either due to SIE clearing it after a transaction, or the firmware
2717:                      //clearing it) makes hardware ping pong pointer advance.
2718:                      USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
  2294    0EFE     MOVLW 0xfe
  2296    6AEA     CLRF 0xfea, ACCESS
  2298    34DB     RLCF 0xfdb, W, ACCESS
  229A    0BFE     ANDLW 0xfe
  229C    36EA     RLCF 0xfea, F, ACCESS
  229E    6EE9     MOVWF 0xfe9, ACCESS
  22A0    0E6F     MOVLW 0x6f
  22A2    26E9     ADDWF 0xfe9, F, ACCESS
  22A4    0E00     MOVLW 0
  22A6    22EA     ADDWFC 0xfea, F, ACCESS
  22A8    74EF     BTG 0xfef, 0x2, ACCESS
2719:                  
2720:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
  22AA    0E40     MOVLW 0x40
  22AC    6E14     MOVWF 0x14, ACCESS
  22AE    0EFE     MOVLW 0xfe
  22B0    6AEA     CLRF 0xfea, ACCESS
  22B2    34DB     RLCF 0xfdb, W, ACCESS
  22B4    0BFE     ANDLW 0xfe
  22B6    36EA     RLCF 0xfea, F, ACCESS
  22B8    6EE9     MOVWF 0xfe9, ACCESS
  22BA    0E6F     MOVLW 0x6f
  22BC    26E9     ADDWF 0xfe9, F, ACCESS
  22BE    0E00     MOVLW 0
  22C0    22EA     ADDWFC 0xfea, F, ACCESS
  22C2    50EE     MOVF 0xfee, W, ACCESS
  22C4    CFEF     MOVFF 0xfef, 0xfea
  22C6    FFEA     NOP
  22C8    6EE9     MOVWF 0xfe9, ACCESS
  22CA    5014     MOVF 0x14, W, ACCESS
  22CC    16EF     ANDWF 0xfef, F, ACCESS
2721:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
  22CE    0EFE     MOVLW 0xfe
  22D0    6AEA     CLRF 0xfea, ACCESS
  22D2    34DB     RLCF 0xfdb, W, ACCESS
  22D4    0BFE     ANDLW 0xfe
  22D6    36EA     RLCF 0xfea, F, ACCESS
  22D8    6EE9     MOVWF 0xfe9, ACCESS
  22DA    0E6F     MOVLW 0x6f
  22DC    26E9     ADDWF 0xfe9, F, ACCESS
  22DE    0E00     MOVLW 0
  22E0    22EA     ADDWFC 0xfea, F, ACCESS
  22E2    50EE     MOVF 0xfee, W, ACCESS
  22E4    CFEF     MOVFF 0xfef, 0xfea
  22E6    FFEA     NOP
  22E8    6EE9     MOVWF 0xfe9, ACCESS
  22EA    7CEF     BTG 0xfef, 0x6, ACCESS
2722:                      #endif
2723:                  }
2724:              }
  22EC    52E5     MOVF 0xfe5, F, ACCESS
  22EE    CFE7     MOVFF 0xfe7, 0xfd9
  22F0    FFD9     NOP
  22F2    0012     RETURN 0
2725:              
2726:              /**************************************************************************
2727:                  Function:
2728:                      void USBDeviceDetach(void)
2729:                  
2730:                  Description:
2731:                              
2732:                  Precondition:
2733:                      
2734:                  Parameters:
2735:                      None
2736:                   
2737:                  Return Values:
2738:                      None
2739:                      
2740:                  Remarks:
2741:                      None
2742:                                                                        
2743:                **************************************************************************/
2744:              #if defined(USB_INTERRUPT)
2745:              void USBDeviceDetach(void)
2746:              {
2747:                  //If the interrupt option is selected then the customer is required
2748:                  //  to notify the stack when the device is attached or removed from the
2749:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
2750:              #ifdef USB_SUPPORT_OTG
2751:                  if (USB_BUS_SENSE != 1)
2752:              #endif
2753:                  {
2754:                       // Disable module & detach from bus
2755:                       U1CON = 0;             
  22F4    6A65     CLRF 0xf65, ACCESS
2756:              
2757:                       // Mask all USB interrupts              
2758:                       U1IE = 0;          
  22F6    010F     MOVLB 0xf
  22F8    6B36     CLRF 0x36, BANKED
2759:              
2760:                       //Move to the detached state                  
2761:                       USBDeviceState = DETACHED_STATE;
  22FA    0100     MOVLB 0
  22FC    6B60     CLRF 0x60, BANKED
2762:              
2763:                       #ifdef  USB_SUPPORT_OTG    
2764:                           //Disable D+ Pullup
2765:                           U1OTGCONbits.DPPULUP = 0;
2766:              
2767:                           //Disable HNP
2768:                           USBOTGDisableHnp();
2769:              
2770:                           //Deactivate HNP
2771:                           USBOTGDeactivateHnp();
2772:                           
2773:                           //If ID Pin Changed State
2774:                           if (USBIDIF && USBIDIE)
2775:                           {  
2776:                               //Re-detect & Initialize
2777:                                USBOTGInitialize();
2778:              
2779:                                //Clear ID Interrupt Flag
2780:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
2781:                           }
2782:                       #endif
2783:              
2784:                       #ifdef __C30__
2785:                           //USBClearInterruptFlag(U1OTGIR, 3); 
2786:                       #endif
2787:                          //return so that we don't go through the rest of 
2788:                          //the state machine
2789:                        return;
2790:                  }
2791:              
2792:              #ifdef USB_SUPPORT_OTG
2793:                  //If Session Is Started Then
2794:                 else
2795:                 {
2796:                      //If SRP Is Ready
2797:                      if (USBOTGSRPIsReady())
2798:                      {   
2799:                          //Clear SRPReady
2800:                          USBOTGClearSRPReady();
2801:              
2802:                          //Clear SRP Timeout Flag
2803:                          USBOTGClearSRPTimeOutFlag();
2804:              
2805:                          //Indicate Session Started
2806:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
2807:                      }
2808:                  }
2809:              #endif
2810:              }
  22FE    0012     RETURN 0
2811:              #endif  //#if defined(USB_INTERRUPT)
2812:              /**************************************************************************
2813:                  Function:
2814:                      void USBDeviceAttach(void)
2815:                  
2816:                  Summary:
2817:                      Checks if VBUS is present, and that the USB module is not already 
2818:                      initalized, and if so, enables the USB module so as to signal device 
2819:                      attachment to the USB host.   
2820:              
2821:                  Description:
2822:                      This function indicates to the USB host that the USB device has been
2823:                      attached to the bus.  This function needs to be called in order for the
2824:                      device to start to enumerate on the bus.
2825:                              
2826:                  Precondition:
2827:                      Should only be called when USB_INTERRUPT is defined.  Also, should only 
2828:                      be called from the main() loop context.  Do not call USBDeviceAttach()
2829:                      from within an interrupt handler, as the USBDeviceAttach() function
2830:                      may modify global interrupt enable bits and settings.
2831:              
2832:                      For normal USB devices:
2833:                      Make sure that if the module was previously on, that it has been turned off 
2834:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
2835:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
2836:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
2837:                      reject this event, since no human could ever unplug and reattach a USB device in a 
2838:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
2839:                      of glitch and ignore the event altogether.  
2840:                  
2841:                  Parameters:
2842:                      None
2843:                      
2844:                  Remarks:
2845:                      None
2846:                                                                        
2847:                **************************************************************************/
2848:              #if defined(USB_INTERRUPT)
2849:              void USBDeviceAttach(void)
2850:              {
2851:                  //if we are in the detached state
2852:                  if(USBDeviceState == DETACHED_STATE)
  2300    0100     MOVLB 0
  2302    5160     MOVF 0x60, W, BANKED
  2304    E114     BNZ 0x232e
2853:                  {
2854:                      if(USB_BUS_SENSE == 1)
2855:                      {
2856:                  	    //Initialize registers to known states.
2857:                          U1CON = 0;          
  2306    6A65     CLRF 0xf65, ACCESS
2858:                  
2859:                          // Mask all USB interrupts
2860:                          U1IE = 0;                                
  2308    010F     MOVLB 0xf
  230A    6B36     CLRF 0x36, BANKED
2861:                  
2862:                          //Configure things like: pull ups, full/low-speed mode, 
2863:                          //set the ping pong mode, and set internal transceiver
2864:                          SetConfigurationOptions();
  230C    0E16     MOVLW 0x16
  230E    6F39     MOVWF 0x39, BANKED
  2310    0E9F     MOVLW 0x9f
  2312    6F37     MOVWF 0x37, BANKED
  2314    0E7B     MOVLW 0x7b
  2316    6F36     MOVWF 0x36, BANKED
2865:                  
2866:                          USBEnableInterrupts();  //Modifies global interrupt settings
  2318    8ED0     BSF 0xfd0, 0x7, ACCESS
  231A    88A2     BSF 0xfa2, 0x4, ACCESS
  231C    88A0     BSF 0xfa0, 0x4, ACCESS
  231E    8EF2     BSF 0xff2, 0x7, ACCESS
2867:                  
2868:                          // Enable module & attach to bus
2869:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
  2320    B665     BTFSC 0xf65, 0x3, ACCESS
  2322    D002     BRA 0x2328
  2324    8665     BSF 0xf65, 0x3, ACCESS
  2326    D7FC     BRA 0x2320
2870:                  
2871:                          //moved to the attached state
2872:                          USBDeviceState = ATTACHED_STATE;
  2328    0100     MOVLB 0
  232A    0E01     MOVLW 0x1
  232C    6F60     MOVWF 0x60, BANKED
2873:                  
2874:                          #ifdef  USB_SUPPORT_OTG
2875:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
2876:                          #endif
2877:                      }
2878:                  }
2879:              }
  232E    0012     RETURN 0
---  E:\Projects\DevPFG\Prog10\SD CDC Prog\main.c  -----------------------------------------------
1:                 /********************************************************************
2:                  FileName:		main.c
3:                  Dependencies:	See INCLUDES section
4:                  Processor:		PIC18, PIC24, and PIC32 USB Microcontrollers
5:                  Hardware:		This demo is natively intended to be used on Microchip USB demo
6:                  				boards supported by the MCHPFSUSB stack.  See release notes for
7:                  				support matrix.  This demo can be modified for use on other hardware
8:                  				platforms.
9:                  Complier:  	Microchip C18 (for PIC18), C30 (for PIC24), C32 (for PIC32)
10:                 Company:		Microchip Technology, Inc.
11:                
12:                 Software License Agreement:
13:                
14:                 The software supplied herewith by Microchip Technology Incorporated
15:                 (the "Company") for its PICr Microcontroller is intended and
16:                 supplied to you, the Company's customer, for use solely and
17:                 exclusively on Microchip PIC Microcontroller products. The
18:                 software is owned by the Company and/or its supplier, and is
19:                 protected under applicable copyright laws. All rights are reserved.
20:                 Any use in violation of the foregoing restrictions may subject the
21:                 user to criminal sanctions under applicable laws, as well as to
22:                 civil liability for the breach of the terms and conditions of this
23:                 license.
24:                
25:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
26:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:                
32:                ********************************************************************
33:                 File Description:
34:                
35:                 Change History:
36:                  Rev   Description
37:                  ----  -----------------------------------------
38:                  1.0   Initial release
39:                  2.1   Updated for simplicity and to use common
40:                                     coding style
41:                  2.8  Improvements to USBCBSendResume(), to make it easier to use.
42:                	Added runtime check to avoid buffer overflow possibility if
43:                	the USB IN data rate is somehow slower than the UART RX rate.
44:                ********************************************************************/
45:                
46:                /** INCLUDES *******************************************************/
47:                
48:                #include "./USB/USB.h"
49:                #include "HardwareProfile.h"
50:                #include "FSconfig.h"
51:                #if defined(USE_INTERNAL_FLASH)
52:                #include "MDD File System/internal flash.h"
53:                #elif defined(USE_SD_INTERFACE_WITH_SPI)
54:                #include "MDD File System/SD-SPI.h"
55:                #endif
56:                
57:                #include "./USB/usb_function_msd.h"
58:                #include "./USB/usb_function_cdc.h"
59:                
60:                /** CONFIGURATION **************************************************/
61:                #if defined(PICDEM_FS_USB)      // Configuration bits for PICDEM FS USB Demo Board (based on PIC18F4550)
62:                #elif defined(PIC18F46J50_PIM) || defined(PIC18F47J53_PIM) || defined(CUSTOM_PIM)
63:                     #pragma config WDTEN = OFF          //WDT disabled (enabled by SWDTEN bit)
64:                     #pragma config PLLDIV = 3           //Divide by 3 (12 MHz oscillator input)
65:                     #pragma config STVREN = ON          //stack overflow/underflow reset enabled
66:                     #pragma config XINST = OFF          //Extended instruction set disabled
67:                     #pragma config CPUDIV = OSC1        //No CPU system clock divide
68:                     #pragma config CP0 = OFF            //Program memory is not code-protected
69:                     #pragma config OSC = HSPLL          //HS oscillator, PLL enabled, HSPLL used by USB
70:                     #pragma config FCMEN = OFF          //Fail-Safe Clock Monitor disabled
71:                     #pragma config IESO = OFF           //Two-Speed Start-up disabled
72:                     #pragma config WDTPS = 32768        //1:32768
73:                     #pragma config DSWDTOSC = INTOSCREF //DSWDT uses INTOSC/INTRC as clock
74:                     #pragma config RTCOSC = T1OSCREF    //RTCC uses T1OSC/T1CKI as clock
75:                     #pragma config DSBOREN = OFF        //Zero-Power BOR disabled in Deep Sleep
76:                     #pragma config DSWDTEN = OFF        //Disabled
77:                     #pragma config DSWDTPS = 8192       //1:8,192 (8.5 seconds)
78:                     #pragma config IOL1WAY = OFF        //IOLOCK bit can be set and cleared
79:                     #pragma config MSSP7B_EN = MSK7     //7 Bit address masking
80:                     #pragma config WPFP = PAGE_1        //Write Protect Program Flash Page 0
81:                     #pragma config WPEND = PAGE_0       //Start protection at page 0
82:                     #pragma config WPCFG = OFF          //Write/Erase last page protect Disabled
83:                     #pragma config WPDIS = OFF          //WPFP[5:0], WPEND, and WPCFG bits ignored 
84:                     #if defined(PIC18F47J53_PIM)
85:                        #pragma config CFGPLLEN = OFF
86:                     #else
87:                        #pragma config T1DIG = ON           //Sec Osc clock source may be selected
88:                        #pragma config LPT1OSC = OFF        //high power Timer1 mode
89:                     #endif
90:                #elif defined(LOW_PIN_COUNT_USB_DEVELOPMENT_KIT)
91:                        //14K50
92:                        #pragma config CPUDIV = NOCLKDIV
93:                        #pragma config USBDIV = OFF
94:                        #pragma config FOSC   = HS
95:                        #pragma config PLLEN  = ON
96:                        #pragma config FCMEN  = OFF
97:                        #pragma config IESO   = OFF
98:                        #pragma config PWRTEN = OFF
99:                        #pragma config BOREN  = OFF
100:                       #pragma config BORV   = 30
101:               //        #pragma config VREGEN = ON
102:                       #pragma config WDTEN  = OFF
103:                       #pragma config WDTPS  = 32768
104:                       #pragma config MCLRE  = OFF
105:                       #pragma config HFOFST = OFF
106:                       #pragma config STVREN = ON
107:                       #pragma config LVP    = OFF
108:                       #pragma config XINST  = OFF
109:                       #pragma config BBSIZ  = OFF
110:                       #pragma config CP0    = OFF
111:                       #pragma config CP1    = OFF
112:                       #pragma config CPB    = OFF
113:                       #pragma config WRT0   = OFF
114:                       #pragma config WRT1   = OFF
115:                       #pragma config WRTB   = OFF
116:                       #pragma config WRTC   = OFF
117:                       #pragma config EBTR0  = OFF
118:                       #pragma config EBTR1  = OFF
119:                       #pragma config EBTRB  = OFF       
120:               
121:               #elif defined(EXPLORER_16)
122:                   #if defined(__PIC24FJ256GB110__)
123:                       _CONFIG1( JTAGEN_OFF & GCP_OFF & GWRP_OFF & FWDTEN_OFF & ICS_PGx2) 
124:                       _CONFIG2( 0xF7FF & IESO_OFF & FCKSM_CSDCMD & OSCIOFNC_ON & POSCMOD_HS & FNOSC_PRIPLL & PLLDIV_DIV2 & IOL1WAY_ON)
125:                   #elif defined(__PIC24FJ256GB210__)
126:                       _CONFIG1(FWDTEN_OFF & ICS_PGx2 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
127:                       _CONFIG2(POSCMOD_HS & IOL1WAY_ON & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRIPLL & PLL96MHZ_ON & PLLDIV_DIV2 & IESO_OFF)
128:                   #elif defined(__PIC24FJ64GB004__)
129:                       _CONFIG1(WDTPS_PS1 & FWPSA_PR32 & WINDIS_OFF & FWDTEN_OFF & ICS_PGx1 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
130:                       _CONFIG2(POSCMOD_HS & I2C1SEL_PRI & IOL1WAY_OFF & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRIPLL & PLL96MHZ_ON & PLLDIV_DIV2 & IESO_ON)
131:                       _CONFIG3(WPFP_WPFP0 & SOSCSEL_SOSC & WUTSEL_LEG & WPDIS_WPDIS & WPCFG_WPCFGDIS & WPEND_WPENDMEM)
132:                       _CONFIG4(DSWDTPS_DSWDTPS3 & DSWDTOSC_LPRC & RTCOSC_SOSC & DSBOREN_OFF & DSWDTEN_OFF)
133:                   #elif defined(__32MX460F512L__) || defined(__32MX795F512L__)
134:                       #pragma config UPLLEN   = ON        // USB PLL Enabled
135:                       #pragma config FPLLMUL  = MUL_15        // PLL Multiplier
136:                       #pragma config UPLLIDIV = DIV_2         // USB PLL Input Divider
137:                       #pragma config FPLLIDIV = DIV_2         // PLL Input Divider
138:                       #pragma config FPLLODIV = DIV_1         // PLL Output Divider
139:                       #pragma config FPBDIV   = DIV_1         // Peripheral Clock divisor
140:                       #pragma config FWDTEN   = OFF           // Watchdog Timer
141:                       #pragma config WDTPS    = PS1           // Watchdog Timer Postscale
142:                       #pragma config FCKSM    = CSDCMD        // Clock Switching & Fail Safe Clock Monitor
143:                       #pragma config OSCIOFNC = OFF           // CLKO Enable
144:                       #pragma config POSCMOD  = HS            // Primary Oscillator
145:                       #pragma config IESO     = OFF           // Internal/External Switch-over
146:                       #pragma config FSOSCEN  = OFF           // Secondary Oscillator Enable (KLO was off)
147:                       #pragma config FNOSC    = PRIPLL        // Oscillator Selection
148:                       #pragma config CP       = OFF           // Code Protect
149:                       #pragma config BWP      = OFF           // Boot Flash Write Protect
150:                       #pragma config PWP      = OFF           // Program Flash Write Protect
151:                       #pragma config ICESEL   = ICS_PGx2      // ICE/ICD Comm Channel Select
152:                       #pragma config DEBUG    = ON            // Background Debugger Enable
153:                   #else
154:                       #error No hardware board defined, see "HardwareProfile.h" and __FILE__
155:                   #endif
156:               #elif defined(PIC24F_STARTER_KIT)
157:                   _CONFIG1( JTAGEN_OFF & GCP_OFF & GWRP_OFF & COE_OFF & FWDTEN_OFF & ICS_PGx2) 
158:                   _CONFIG2( 0xF7FF & IESO_OFF & FCKSM_CSDCMD & OSCIOFNC_ON & POSCMOD_HS & FNOSC_PRIPLL & PLLDIV_DIV3 & IOL1WAY_ON)
159:               #elif defined(PIC24FJ256DA210_DEV_BOARD)
160:                   _CONFIG1(FWDTEN_OFF & ICS_PGx2 & GWRP_OFF & GCP_OFF & JTAGEN_OFF)
161:                   _CONFIG2(POSCMOD_HS & IOL1WAY_ON & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRIPLL & PLL96MHZ_ON & PLLDIV_DIV2 & IESO_OFF)
162:               #elif defined(PIC32_USB_STARTER_KIT)
163:                   #pragma config UPLLEN   = ON        // USB PLL Enabled
164:                   #pragma config FPLLMUL  = MUL_15        // PLL Multiplier
165:                   #pragma config UPLLIDIV = DIV_2         // USB PLL Input Divider
166:                   #pragma config FPLLIDIV = DIV_2         // PLL Input Divider
167:                   #pragma config FPLLODIV = DIV_1         // PLL Output Divider
168:                   #pragma config FPBDIV   = DIV_1         // Peripheral Clock divisor
169:                   #pragma config FWDTEN   = OFF           // Watchdog Timer
170:                   #pragma config WDTPS    = PS1           // Watchdog Timer Postscale
171:                   #pragma config FCKSM    = CSDCMD        // Clock Switching & Fail Safe Clock Monitor
172:                   #pragma config OSCIOFNC = OFF           // CLKO Enable
173:                   #pragma config POSCMOD  = HS            // Primary Oscillator
174:                   #pragma config IESO     = OFF           // Internal/External Switch-over
175:                   #pragma config FSOSCEN  = OFF           // Secondary Oscillator Enable (KLO was off)
176:                   #pragma config FNOSC    = PRIPLL        // Oscillator Selection
177:                   #pragma config CP       = OFF           // Code Protect
178:                   #pragma config BWP      = OFF           // Boot Flash Write Protect
179:                   #pragma config PWP      = OFF           // Program Flash Write Protect
180:                   #pragma config ICESEL   = ICS_PGx2      // ICE/ICD Comm Channel Select
181:                   #pragma config DEBUG    = ON            // Background Debugger Enable
182:               #else
183:                   #error No hardware board defined, see "HardwareProfile.h" and __FILE__
184:               #endif
185:               
186:               
187:               
188:               /** VARIABLES ******************************************************/
189:               #pragma udata
190:               // char USB_Out_Buffer[CDC_DATA_OUT_EP_SIZE+1];	// bad Microchip code
191:               char RS232_Out_Data[CDC_DATA_IN_EP_SIZE+1];		// bad Microchip code
192:               
193:               #define RS232_IntRec_Buf 16
194:               #if defined(__18CXX)
195:               	#pragma udata myCDC=CDC_BUFFER_ADDRESS
196:               #endif
197:               unsigned char RS232_In_Buffer[RS232_IntRec_Buf];
198:               unsigned char RS232_In_Head = 0, RS232_In_Tail = 0;	// interrupt driven circular buffer
199:               unsigned char ucInt;
200:               
201:               char cPrintBuf[CDC_DATA_OUT_EP_SIZE];
202:               
203:               #if defined(__18CXX)
204:               #pragma udata
205:               #endif
206:               int iPrintBufFull;
207:               
208:               unsigned char  NextUSBOut;
209:               //unsigned char  NextUSBOut; // the ways they fail is amasing
210:               
211:               unsigned char    LastRS232Out;  // Number of characters in the buffer
212:               unsigned char    RS232cp;       // current position within the buffer
213:               unsigned char RS232_Out_Data_Rdy = 0;
214:               USB_HANDLE  lastTransmission;
215:               
216:               USB_HANDLE USBOutHandle = 0;
217:               USB_HANDLE USBInHandle = 0;
218:               BOOL blinkStatusValid = TRUE;
219:               
220:               #pragma udata
221:               char USB_In_Buffer[64+1];
222:               char USB_Out_Buffer[64+1];
223:               BOOL stringPrinted;
224:               volatile BOOL buttonPressed;
225:               volatile BYTE buttonCount;
226:               
227:               
228:               #if defined(__C30__) || defined(__C32__)
229:               //The LUN variable definition is critical to the MSD function driver.  This
230:               //  array is a structure of function pointers that are the functions that 
231:               //  will take care of each of the physical media.  For each additional LUN
232:               //  that is added to the system, an entry into this array needs to be added
233:               //  so that the stack can know where to find the physical layer functions.
234:               //  In this example the media initialization function is named 
235:               //  "MediaInitialize", the read capacity function is named "ReadCapacity",
236:               //  etc.  
237:               LUN_FUNCTIONS LUN[MAX_LUN + 1] = 
238:               {
239:                   {
240:                       &MDD_IntFlash_MediaInitialize,
241:                       &MDD_IntFlash_ReadCapacity,
242:                       &MDD_IntFlash_ReadSectorSize,
243:                       &MDD_IntFlash_MediaDetect,
244:                       &MDD_IntFlash_SectorRead,
245:                       &MDD_IntFlash_WriteProtectState,
246:                       &MDD_IntFlash_SectorWrite
247:                   }
248:               };
249:               #endif
250:               
251:               /* Standard Response to INQUIRY command stored in ROM 	*/
252:               const ROM InquiryResponse inq_resp = {
253:               	0x00,		// peripheral device is connected, direct access block device
254:               	0x80,           // removable
255:               	0x04,	 	// version = 00=> does not conform to any standard, 4=> SPC-2
256:               	0x02,		// response is in format specified by SPC-2
257:               	0x20,		// n-4 = 36-4=32= 0x20
258:               	0x00,		// sccs etc.
259:               	0x00,		// bque=1 and cmdque=0,indicates simple queueing 00 is obsolete,
260:               			// but as in case of other device, we are just using 00
261:               	0x00,		// 00 obsolete, 0x80 for basic task queueing
262:               	{'M','i','c','r','o','c','h','p'
263:                   },
264:               	// this is the T10 assigned Vendor ID
265:               	{'M','a','s','s',' ','S','t','o','r','a','g','e',' ',' ',' ',' '
266:                   },
267:               	{'0','0','0','1'
268:                   }
269:               };
270:               
271:               /** PRIVATE PROTOTYPES *********************************************/
272:               static void InitializeSystem(void);
273:               void USBDeviceTasks(void);
274:               void ProcessIO(void);
275:               void YourHighPriorityISRCode(void);
276:               void YourLowPriorityISRCode(void);
277:               void USBCBSendResume(void);
278:               void BlinkUSBStatus(void);
279:               void UserInit(void);
280:               void InitializeUSART(void);
281:               void putcUSART(char c);
282:               unsigned char getcUSART ();
283:               
284:               
285:               #if defined(__18CXX)
286:                   #define mDataRdyUSART() PIR1bits.RCIF
287:               //    #define mTxRdyUSART()   TXSTAbits.TRMT
288:                   #define mTxRdyUSART()   PIR1bits.TXIF
289:               #elif defined(__C30__) || defined(__C32__)
290:                   #define mDataRdyUSART() UART2IsPressed()
291:                   #define mTxRdyUSART()   U2STAbits.TRMT
292:               #endif
293:               
294:               /** VECTOR REMAPPING ***********************************************/
295:               #if defined(__18CXX)
296:               	//On PIC18 devices, addresses 0x00, 0x08, and 0x18 are used for
297:               	//the reset, high priority interrupt, and low priority interrupt
298:               	//vectors.  However, the current Microchip USB bootloader 
299:               	//examples are intended to occupy addresses 0x00-0x7FF or
300:               	//0x00-0xFFF depending on which bootloader is used.  Therefore,
301:               	//the bootloader code remaps these vectors to new locations
302:               	//as indicated below.  This remapping is only necessary if you
303:               	//wish to program the hex file generated from this project with
304:               	//the USB bootloader.  If no bootloader is used, edit the
305:               	//usb_config.h file and comment out the following defines:
306:               	//#define PROGRAMMABLE_WITH_USB_HID_BOOTLOADER
307:               	//#define PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER
308:               	
309:               	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)
310:               		#define REMAPPED_RESET_VECTOR_ADDRESS			0x1000
311:               		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x1008
312:               		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x1018
313:               	#elif defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)	
314:               		#define REMAPPED_RESET_VECTOR_ADDRESS			0x800
315:               		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x808
316:               		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x818
317:               	#else	
318:               		#define REMAPPED_RESET_VECTOR_ADDRESS			0x00
319:               		#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x08
320:               		#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x18
321:               	#endif
322:               	
323:               	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
324:               	extern void _startup (void);        // See c018i.c in your C18 compiler dir
325:               	#pragma code REMAPPED_RESET_VECTOR = REMAPPED_RESET_VECTOR_ADDRESS
326:               	void _reset (void)
327:               	{
328:               	    _asm goto _startup _endasm
  1000    EF6B     GOTO 0x52d6
  1002    F029     NOP
329:               	}
  1004    0012     RETURN 0
330:               	#endif
331:               	#pragma code REMAPPED_HIGH_INTERRUPT_VECTOR = REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS
332:               	void Remapped_High_ISR (void)
333:               	{
334:               	     _asm goto YourHighPriorityISRCode _endasm
  1008    EF05     GOTO 0x3a0a
  100A    F01D     NOP
335:               	}
  100C    0012     RETURN 0
336:               	#pragma code REMAPPED_LOW_INTERRUPT_VECTOR = REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS
337:               	void Remapped_Low_ISR (void)
338:               	{
339:               	     _asm goto YourLowPriorityISRCode _endasm
  1018    EF58     GOTO 0x3ab0
  101A    F01D     NOP
340:               	}
  101C    0012     RETURN 0
341:               	
342:               	#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_MCHPUSB_BOOTLOADER)
343:               	//Note: If this project is built while one of the bootloaders has
344:               	//been defined, but then the output hex file is not programmed with
345:               	//the bootloader, addresses 0x08 and 0x18 would end up programmed with 0xFFFF.
346:               	//As a result, if an actual interrupt was enabled and occured, the PC would jump
347:               	//to 0x08 (or 0x18) and would begin executing "0xFFFF" (unprogrammed space).  This
348:               	//executes as nop instructions, but the PC would eventually reach the REMAPPED_RESET_VECTOR_ADDRESS
349:               	//(0x1000 or 0x800, depending upon bootloader), and would execute the "goto _startup".  This
350:               	//would effective reset the application.
351:               	
352:               	//To fix this situation, we should always deliberately place a 
353:               	//"goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS" at address 0x08, and a
354:               	//"goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS" at address 0x18.  When the output
355:               	//hex file of this project is programmed with the bootloader, these sections do not
356:               	//get bootloaded (as they overlap the bootloader space).  If the output hex file is not
357:               	//programmed using the bootloader, then the below goto instructions do get programmed,
358:               	//and the hex file still works like normal.  The below section is only required to fix this
359:               	//scenario.
360:               	#pragma code HIGH_INTERRUPT_VECTOR = 0x08
361:               	void High_ISR (void)
362:               	{
363:               	     _asm goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS _endasm
  0008    EF04     GOTO 0x1008
  000A    F008     NOP
364:               	}
  000C    0012     RETURN 0
365:               	#pragma code LOW_INTERRUPT_VECTOR = 0x18
366:               	void Low_ISR (void)
367:               	{
368:               	     _asm goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS _endasm
  0018    EF0C     GOTO 0x1018
  001A    F008     NOP
369:               	}
  001C    0012     RETURN 0
370:               	#endif	//end of "#if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)||defined(PROGRAMMABLE_WITH_USB_LEGACY_CUSTOM_CLASS_BOOTLOADER)"
371:               
372:               	#pragma code
373:               	
374:               	
375:               	//These are your actual interrupt handling routines.
376:               	#pragma interrupt YourHighPriorityISRCode
377:               	void YourHighPriorityISRCode()
  3A0A    CFDA     MOVFF 0xfda, 0xfe4
  3A0C    FFE4     NOP
  3A0E    CFE2     MOVFF 0xfe2, 0xfda
  3A10    FFDA     NOP
  3A12    CFE9     MOVFF 0xfe9, 0xfe4
  3A14    FFE4     NOP
  3A16    CFEA     MOVFF 0xfea, 0xfe4
  3A18    FFE4     NOP
  3A1A    CFF6     MOVFF 0xff6, 0xfe4
  3A1C    FFE4     NOP
  3A1E    CFF7     MOVFF 0xff7, 0xfe4
  3A20    FFE4     NOP
  3A22    CFF8     MOVFF 0xff8, 0xfe4
  3A24    FFE4     NOP
  3A26    CFF5     MOVFF 0xff5, 0xfe4
  3A28    FFE4     NOP
  3A2A    CFF3     MOVFF 0xff3, 0xfe4
  3A2C    FFE4     NOP
  3A2E    CFF4     MOVFF 0xff4, 0xfe4
  3A30    FFE4     NOP
  3A32    CFFA     MOVFF 0xffa, 0xfe4
  3A34    FFE4     NOP
  3A36    CFFB     MOVFF 0xffb, 0xfe4
  3A38    FFE4     NOP
  3A3A    EE00     LFSR 0, 0
  3A3C    F000     NOP
  3A3E    0E14     MOVLW 0x14
  3A40    04E8     DECF 0xfe8, W, ACCESS
  3A42    E303     BNC 0x3a4a
  3A44    CFEE     MOVFF 0xfee, 0xfe4
  3A46    FFE4     NOP
  3A48    D7FB     BRA 0x3a40
  3A4A    EE00     LFSR 0, 0x14
  3A4C    F014     NOP
  3A4E    0E08     MOVLW 0x8
  3A50    04E8     DECF 0xfe8, W, ACCESS
  3A52    E303     BNC 0x3a5a
  3A54    CFEE     MOVFF 0xfee, 0xfe4
  3A56    FFE4     NOP
  3A58    D7FB     BRA 0x3a50
  3A5A    52E6     MOVF 0xfe6, F, ACCESS
378:               	{
379:               		//Check which interrupt flag caused the interrupt.
380:               		//Service the interrupt
381:               		//Clear the interrupt flag
382:               		//Etc.
383:                       #if defined(USB_INTERRUPT)
384:               	        USBDeviceTasks();
  3A5C    ECB2     CALL 0x1164, 0
  3A5E    F008     NOP
385:                       #endif
386:               	
387:               	}	//This return will be a "retfie fast", since this is in a #pragma interrupt section 
  3A60    52E5     MOVF 0xfe5, F, ACCESS
  3A62    EE00     LFSR 0, 0x1b
  3A64    F01B     NOP
  3A66    0E08     MOVLW 0x8
  3A68    04E8     DECF 0xfe8, W, ACCESS
  3A6A    E303     BNC 0x3a72
  3A6C    CFE5     MOVFF 0xfe5, 0xfed
  3A6E    FFED     NOP
  3A70    D7FB     BRA 0x3a68
  3A72    EE00     LFSR 0, 0x13
  3A74    F013     NOP
  3A76    0E14     MOVLW 0x14
  3A78    04E8     DECF 0xfe8, W, ACCESS
  3A7A    E303     BNC 0x3a82
  3A7C    CFE5     MOVFF 0xfe5, 0xfed
  3A7E    FFED     NOP
  3A80    D7FB     BRA 0x3a78
  3A82    CFE5     MOVFF 0xfe5, 0xffb
  3A84    FFFB     NOP
  3A86    CFE5     MOVFF 0xfe5, 0xffa
  3A88    FFFA     NOP
  3A8A    CFE5     MOVFF 0xfe5, 0xff4
  3A8C    FFF4     NOP
  3A8E    CFE5     MOVFF 0xfe5, 0xff3
  3A90    FFF3     NOP
  3A92    CFE5     MOVFF 0xfe5, 0xff5
  3A94    FFF5     NOP
  3A96    CFE5     MOVFF 0xfe5, 0xff8
  3A98    FFF8     NOP
  3A9A    CFE5     MOVFF 0xfe5, 0xff7
  3A9C    FFF7     NOP
  3A9E    CFE5     MOVFF 0xfe5, 0xff6
  3AA0    FFF6     NOP
  3AA2    CFE5     MOVFF 0xfe5, 0xfea
  3AA4    FFEA     NOP
  3AA6    CFE5     MOVFF 0xfe5, 0xfe9
  3AA8    FFE9     NOP
  3AAA    CFE5     MOVFF 0xfe5, 0xfda
  3AAC    FFDA     NOP
  3AAE    0011     RETFIE 0x1
388:               	#pragma interruptlow YourLowPriorityISRCode
389:               	void YourLowPriorityISRCode()
  3AB0    CFD8     MOVFF 0xfd8, 0xfe4
  3AB2    FFE4     NOP
  3AB4    CFE0     MOVFF 0xfe0, 0xfe4
  3AB6    FFE4     NOP
  3AB8    6EE4     MOVWF 0xfe4, ACCESS
  3ABA    CFDA     MOVFF 0xfda, 0xfe4
  3ABC    FFE4     NOP
  3ABE    CFE9     MOVFF 0xfe9, 0xfe4
  3AC0    FFE4     NOP
  3AC2    CFEA     MOVFF 0xfea, 0xfe4
  3AC4    FFE4     NOP
  3AC6    52E6     MOVF 0xfe6, F, ACCESS
390:               	{
391:               		//Check which interrupt flag caused the interrupt.
392:               		//Service the interrupt
393:               		//Clear the interrupt flag
394:               		//Etc.
395:               
396:               		//Check if we received a character over the physical UART, and we need
397:               		//to buffer it up for eventual transmission to the USB host.
398:                   #if defined(__18CXX)
399:               		if(mDataRdyUSART())
  3AC8    AA9E     BTFSS 0xf9e, 0x5, ACCESS
  3ACA    D017     BRA 0x3afa
400:               		{
401:               			if (RCSTAbits.OERR)  // in case of overrun error
  3ACC    A2AC     BTFSS 0xfac, 0x1, ACCESS
  3ACE    D005     BRA 0x3ada
402:               			{                    // we should never see an overrun error, but if we do, 
403:               				RCSTAbits.CREN = 0;  // reset the port
  3AD0    98AC     BCF 0xfac, 0x4, ACCESS
404:               				ucInt = RCREG;
  3AD2    CFAF     MOVFF 0xfaf, 0x510
  3AD4    F510     NOP
405:               				RCSTAbits.CREN = 1;  // and keep going.
  3AD6    88AC     BSF 0xfac, 0x4, ACCESS
406:               			}
407:               			else
  3AD8    D002     BRA 0x3ade
408:               				ucInt = RCREG;
  3ADA    CFAF     MOVFF 0xfaf, 0x510
  3ADC    F510     NOP
409:               		// not necessary.  EUSART auto clears the flag when RCREG is cleared
410:               		//	PIR1bits.RCIF = 0;    // clear Flag
411:               			RS232_In_Buffer[RS232_In_Head] = ucInt;
  3ADE    0101     MOVLB 0x1
  3AE0    51D9     MOVF 0xd9, W, BANKED
  3AE2    6AEA     CLRF 0xfea, ACCESS
  3AE4    0F00     ADDLW 0
  3AE6    6EE9     MOVWF 0xfe9, ACCESS
  3AE8    0E05     MOVLW 0x5
  3AEA    22EA     ADDWFC 0xfea, F, ACCESS
  3AEC    C510     MOVFF 0x510, 0xfef
  3AEE    FFEF     NOP
412:               			RS232_In_Head++;
  3AF0    2BD9     INCF 0xd9, F, BANKED
413:               			if ( RS232_In_Head > (RS232_IntRec_Buf - 1) )
  3AF2    51D9     MOVF 0xd9, W, BANKED
  3AF4    080F     SUBLW 0xf
  3AF6    E201     BC 0x3afa
414:               				RS232_In_Head = 0;
  3AF8    6BD9     CLRF 0xd9, BANKED
415:               		}
416:               	#endif
417:               	
418:               	}	//This return will be a "retfie", since this is in a #pragma interruptlow section 
  3AFA    52E5     MOVF 0xfe5, F, ACCESS
  3AFC    CFE5     MOVFF 0xfe5, 0xfea
  3AFE    FFEA     NOP
  3B00    CFE5     MOVFF 0xfe5, 0xfe9
  3B02    FFE9     NOP
  3B04    CFE5     MOVFF 0xfe5, 0xfda
  3B06    FFDA     NOP
  3B08    50E5     MOVF 0xfe5, W, ACCESS
  3B0A    CFE5     MOVFF 0xfe5, 0xfe0
  3B0C    FFE0     NOP
  3B0E    CFE5     MOVFF 0xfe5, 0xfd8
  3B10    FFD8     NOP
  3B12    0010     RETFIE 0
419:               
420:               #elif defined(__C30__)
421:                   #if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)
422:                       /*
423:                        *	ISR JUMP TABLE
424:                        *
425:                        *	It is necessary to define jump table as a function because C30 will
426:                        *	not store 24-bit wide values in program memory as variables.
427:                        *
428:                        *	This function should be stored at an address where the goto instructions 
429:                        *	line up with the remapped vectors from the bootloader's linker script.
430:                        *  
431:                        *  For more information about how to remap the interrupt vectors,
432:                        *  please refer to AN1157.  An example is provided below for the T2
433:                        *  interrupt with a bootloader ending at address 0x1400
434:                        */
435:               //        void __attribute__ ((address(0x1404))) ISRTable(){
436:               //        
437:               //        	asm("reset"); //reset instruction to prevent runaway code
438:               //        	asm("goto %0"::"i"(&_T2Interrupt));  //T2Interrupt's address
439:               //        }
440:                   #endif
441:               #endif
442:               
443:               
444:               
445:               
446:               /** DECLARATIONS ***************************************************/
447:               #pragma code
448:               
449:               /********************************************************************
450:                * Function:        void main(void)
451:                *
452:                * PreCondition:    None
453:                *
454:                * Input:           None
455:                *
456:                * Output:          None
457:                *
458:                * Side Effects:    None
459:                *
460:                * Overview:        Main program entry point.
461:                *
462:                * Note:            None
463:                *****************************************************************************/
464:               
465:                #if defined(__18CXX)
466:               void main(void)
  3B14    CFD9     MOVFF 0xfd9, 0xfe6
  3B16    FFE6     NOP
  3B18    CFE1     MOVFF 0xfe1, 0xfd9
  3B1A    FFD9     NOP
  3B1C    0E02     MOVLW 0x2
  3B1E    26E1     ADDWF 0xfe1, F, ACCESS
467:               #else 
468:               int main(void)
469:               #endif
470:               {
471:               	MEDIA_INFORMATION * ucMediaResp = 0;
  3B20    6ADE     CLRF 0xfde, ACCESS
  3B22    6ADD     CLRF 0xfdd, ACCESS
472:               
473:                   InitializeSystem();
  3B24    D8CE     RCALL 0x3cc2
474:               //	ucMediaResp = MDD_SDSPI_MediaInitialize();
475:               
476:                   #if defined(USB_INTERRUPT)
477:                       USBDeviceAttach();
  3B26    EC80     CALL 0x2300, 0
  3B28    F011     NOP
478:                   #endif
479:               
480:                   while(1)
  3B2C    D7FE     BRA 0x3b2a
481:                   {
482:                       #if defined(USB_POLLING)
483:               		// Check bus status and service USB interrupts.
484:                       USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
485:                       				  // this function periodically.  This function will take care
486:                       				  // of processing and responding to SETUP transactions 
487:                       				  // (such as during the enumeration process when you first
488:                       				  // plug in).  USB hosts require that USB devices should accept
489:                       				  // and process SETUP packets in a timely fashion.  Therefore,
490:                       				  // when using polling, this function should be called 
491:                       				  // regularly (such as once every 1.8ms or faster** [see 
492:                       				  // inline code comments in usb_device.c for explanation when
493:                       				  // "or faster" applies])  In most cases, the USBDeviceTasks() 
494:                       				  // function does not take very long to execute (ex: <100 
495:                       				  // instruction cycles) before it returns.
496:                       #endif
497:                   				  
498:               
499:               		// Application-specific tasks.
500:               		// Application related code may be added here, or in the ProcessIO() function.
501:                       ProcessIO();        
  3B2A    D801     RCALL 0x3b2e
502:               //		if ( ucMediaResp->errorCode )
503:               //			ucMediaResp = MDD_SDSPI_MediaInitialize();
504:                   }//end while
505:               }//end main
506:               
507:               /********************************************************************
508:                * Function:        void ProcessIO(void)
509:                *
510:                * PreCondition:    None
511:                *
512:                * Input:           None
513:                *
514:                * Output:          None
515:                *
516:                * Side Effects:    None
517:                *
518:                * Overview:        This function is a place holder for other user
519:                *                  routines. It is a mixture of both USB and
520:                *                  non-USB tasks.
521:                *
522:                * Note:            None
523:                *******************************************************************/
524:               void ProcessIO(void)
  3B2E    CFD9     MOVFF 0xfd9, 0xfe6
  3B30    FFE6     NOP
  3B32    CFE1     MOVFF 0xfe1, 0xfd9
  3B34    FFD9     NOP
  3B36    0E03     MOVLW 0x3
  3B38    26E1     ADDWF 0xfe1, F, ACCESS
525:               {   
526:                   BYTE numBytesRead;
527:               	int iIdx;
528:                   //Blink the LEDs according to the USB device status
529:                   BlinkUSBStatus();
  3B3A    DBBA     RCALL 0x42b0
530:                   // User Application USB tasks
531:                   if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) return;
  3B3C    0E20     MOVLW 0x20
  3B3E    0100     MOVLB 0
  3B40    6EE7     MOVWF 0xfe7, ACCESS
  3B42    1960     XORWF 0x60, W, BANKED
  3B44    AEE8     BTFSS 0xfe8, 0x7, ACCESS
  3B46    D002     BRA 0x3b4c
  3B48    34E7     RLCF 0xfe7, W, ACCESS
  3B4A    D002     BRA 0x3b50
  3B4C    50E7     MOVF 0xfe7, W, ACCESS
  3B4E    5D60     SUBWF 0x60, W, BANKED
  3B50    E201     BC 0x3b54
  3B52    D0AD     BRA 0x3cae
  3B54    5065     MOVF 0xf65, W, ACCESS
  3B56    0B02     ANDLW 0x2
  3B58    E001     BZ 0x3b5c
  3B5A    D0A9     BRA 0x3cae
532:               
533:               #if !defined(CUSTOM_PIM)
534:                   if(buttonPressed)
535:                   {
536:                       if(stringPrinted == FALSE)
537:                       {
538:                           if(mUSBUSARTIsTxTrfReady())
539:                           {
540:                               putrsUSBUSART("Button Pressed -- \r\n");
541:                               stringPrinted = TRUE;
542:                           }
543:                       }
544:                   }
545:                   else
546:                   {
547:                       stringPrinted = FALSE;
548:                   }
549:               #endif
550:               
551:               	if (RS232_Out_Data_Rdy == 0)  // only check for new USB buffer if the old RS232 buffer is
  3B5C    0101     MOVLB 0x1
  3B5E    51DB     MOVF 0xdb, W, BANKED
  3B60    E115     BNZ 0x3b8c
552:               	{						  // empty.  This will cause additional USB packets to be NAK'd
553:               		LastRS232Out = getsUSBUSART(RS232_Out_Data,64); //until the buffer is free.
  3B62    0E40     MOVLW 0x40
  3B64    6EE6     MOVWF 0xfe6, ACCESS
  3B66    0E00     MOVLW 0
  3B68    6EE6     MOVWF 0xfe6, ACCESS
  3B6A    0E01     MOVLW 0x1
  3B6C    6EE6     MOVWF 0xfe6, ACCESS
  3B6E    EC6F     CALL 0x44de, 0
  3B70    F022     NOP
  3B72    52E5     MOVF 0xfe5, F, ACCESS
  3B74    52E5     MOVF 0xfe5, F, ACCESS
  3B76    52E5     MOVF 0xfe5, F, ACCESS
  3B78    0101     MOVLB 0x1
  3B7A    6F44     MOVWF 0x44, BANKED
554:               		if(LastRS232Out > 0)
  3B7C    50E8     MOVF 0xfe8, W, ACCESS
  3B7E    0800     SUBLW 0
  3B80    E205     BC 0x3b8c
555:               		{	
556:               			RS232_Out_Data_Rdy = 1;  // signal buffer full
  3B82    0101     MOVLB 0x1
  3B84    0E01     MOVLW 0x1
  3B86    6FDB     MOVWF 0xdb, BANKED
557:               			RS232cp = 0;  // Reset the current position
  3B88    0101     MOVLB 0x1
  3B8A    6B45     CLRF 0x45, BANKED
558:               		}
559:               	}
560:               
561:                   //Check if one or more bytes are waiting in the physical UART transmit
562:                   //queue.  If so, send it out the UART TX pin.
563:               	if(RS232_Out_Data_Rdy && mTxRdyUSART())
  3B8C    0101     MOVLB 0x1
  3B8E    51DB     MOVF 0xdb, W, BANKED
  3B90    E015     BZ 0x3bbc
  3B92    509E     MOVF 0xf9e, W, ACCESS
  3B94    0B10     ANDLW 0x10
  3B96    E012     BZ 0x3bbc
564:               	{
565:               		putcUSART(RS232_Out_Data[RS232cp]);
  3B98    0101     MOVLB 0x1
  3B9A    5145     MOVF 0x45, W, BANKED
  3B9C    6AEA     CLRF 0xfea, ACCESS
  3B9E    0F00     ADDLW 0
  3BA0    6EE9     MOVWF 0xfe9, ACCESS
  3BA2    0E01     MOVLW 0x1
  3BA4    22EA     ADDWFC 0xfea, F, ACCESS
  3BA6    50EF     MOVF 0xfef, W, ACCESS
  3BA8    6EE6     MOVWF 0xfe6, ACCESS
  3BAA    D8F9     RCALL 0x3d9e
  3BAC    52E5     MOVF 0xfe5, F, ACCESS
566:               		++RS232cp;
  3BAE    0101     MOVLB 0x1
  3BB0    2B45     INCF 0x45, F, BANKED
567:               		if (RS232cp == LastRS232Out)
  3BB2    5144     MOVF 0x44, W, BANKED
  3BB4    5D45     SUBWF 0x45, W, BANKED
  3BB6    E102     BNZ 0x3bbc
568:               			RS232_Out_Data_Rdy = 0;
  3BB8    0101     MOVLB 0x1
  3BBA    6BDB     CLRF 0xdb, BANKED
569:               	}
570:               
571:               //    //Check if we received a character over the physical UART, and we need
572:               //    //to buffer it up for eventual transmission to the USB host.
573:               //	if(mDataRdyUSART() && (NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)))
574:               //	{
575:               //		USB_Out_Buffer[NextUSBOut] = getcUSART();
576:               //		++NextUSBOut;
577:               //		USB_Out_Buffer[NextUSBOut] = 0;
578:               //	}
579:               	while ((RS232_In_Head != RS232_In_Tail) && (NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)))
  3BBC    0101     MOVLB 0x1
  3BBE    51DA     MOVF 0xda, W, BANKED
  3BC0    5DD9     SUBWF 0xd9, W, BANKED
  3BC2    E027     BZ 0x3c12
  3BC4    0E3F     MOVLW 0x3f
  3BC6    0101     MOVLB 0x1
  3BC8    5D43     SUBWF 0x43, W, BANKED
  3BCA    E223     BC 0x3c12
  3C10    D7D5     BRA 0x3bbc
580:               	{
581:               		USB_Out_Buffer[NextUSBOut] = RS232_In_Buffer[RS232_In_Tail];
  3BCC    0101     MOVLB 0x1
  3BCE    51DA     MOVF 0xda, W, BANKED
  3BD0    6AEA     CLRF 0xfea, ACCESS
  3BD2    0F00     ADDLW 0
  3BD4    6EE9     MOVWF 0xfe9, ACCESS
  3BD6    0E05     MOVLW 0x5
  3BD8    22EA     ADDWFC 0xfea, F, ACCESS
  3BDA    50EF     MOVF 0xfef, W, ACCESS
  3BDC    6EE6     MOVWF 0xfe6, ACCESS
  3BDE    0101     MOVLB 0x1
  3BE0    5143     MOVF 0x43, W, BANKED
  3BE2    6AEA     CLRF 0xfea, ACCESS
  3BE4    0F89     ADDLW 0x89
  3BE6    6EE9     MOVWF 0xfe9, ACCESS
  3BE8    0E01     MOVLW 0x1
  3BEA    22EA     ADDWFC 0xfea, F, ACCESS
  3BEC    52E5     MOVF 0xfe5, F, ACCESS
  3BEE    50E7     MOVF 0xfe7, W, ACCESS
  3BF0    6EEF     MOVWF 0xfef, ACCESS
582:               		++NextUSBOut, RS232_In_Tail++;	// interrupt driven circular buffer
  3BF2    2B43     INCF 0x43, F, BANKED
  3BF4    0101     MOVLB 0x1
  3BF6    2BDA     INCF 0xda, F, BANKED
583:               		if ( RS232_In_Tail > (RS232_IntRec_Buf - 1) )
  3BF8    51DA     MOVF 0xda, W, BANKED
  3BFA    080F     SUBLW 0xf
  3BFC    E201     BC 0x3c00
584:               			RS232_In_Tail = 0;
  3BFE    6BDA     CLRF 0xda, BANKED
585:               		USB_Out_Buffer[NextUSBOut] = 0;
  3C00    0101     MOVLB 0x1
  3C02    5143     MOVF 0x43, W, BANKED
  3C04    6AEA     CLRF 0xfea, ACCESS
  3C06    0F89     ADDLW 0x89
  3C08    6EE9     MOVWF 0xfe9, ACCESS
  3C0A    0E01     MOVLW 0x1
  3C0C    22EA     ADDWFC 0xfea, F, ACCESS
  3C0E    6AEF     CLRF 0xfef, ACCESS
586:               	};
587:               
588:                   //Check if the print buffer needs to be sent - one time only so may lose
589:                   //some buffer. Only used in debug mode.
590:               	if(iPrintBufFull)
  3C12    0101     MOVLB 0x1
  3C14    5141     MOVF 0x41, W, BANKED
  3C16    1142     IORWF 0x42, W, BANKED
  3C18    E032     BZ 0x3c7e
591:               	{	iIdx = 0;
  3C1A    0E01     MOVLW 0x1
  3C1C    6ADB     CLRF 0xfdb, ACCESS
  3C1E    0E02     MOVLW 0x2
  3C20    6ADB     CLRF 0xfdb, ACCESS
592:               		while ((NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)) && iPrintBufFull)
  3C22    0E3F     MOVLW 0x3f
  3C24    5D43     SUBWF 0x43, W, BANKED
  3C26    E229     BC 0x3c7a
  3C28    5141     MOVF 0x41, W, BANKED
  3C2A    1142     IORWF 0x42, W, BANKED
  3C2C    E026     BZ 0x3c7a
  3C78    D7D4     BRA 0x3c22
593:               		{
594:               			USB_Out_Buffer[NextUSBOut] = cPrintBuf[iIdx];
  3C2E    0E01     MOVLW 0x1
  3C30    CFDB     MOVFF 0xfdb, 0xfe9
  3C32    FFE9     NOP
  3C34    0E02     MOVLW 0x2
  3C36    CFDB     MOVFF 0xfdb, 0xfea
  3C38    FFEA     NOP
  3C3A    0E11     MOVLW 0x11
  3C3C    26E9     ADDWF 0xfe9, F, ACCESS
  3C3E    0E05     MOVLW 0x5
  3C40    22EA     ADDWFC 0xfea, F, ACCESS
  3C42    50EF     MOVF 0xfef, W, ACCESS
  3C44    6EE6     MOVWF 0xfe6, ACCESS
  3C46    5143     MOVF 0x43, W, BANKED
  3C48    6AEA     CLRF 0xfea, ACCESS
  3C4A    0F89     ADDLW 0x89
  3C4C    6EE9     MOVWF 0xfe9, ACCESS
  3C4E    0E01     MOVLW 0x1
  3C50    22EA     ADDWFC 0xfea, F, ACCESS
  3C52    52E5     MOVF 0xfe5, F, ACCESS
  3C54    50E7     MOVF 0xfe7, W, ACCESS
  3C56    6EEF     MOVWF 0xfef, ACCESS
595:               			++NextUSBOut, iIdx++, iPrintBufFull--;
  3C58    2B43     INCF 0x43, F, BANKED
  3C5A    0E01     MOVLW 0x1
  3C5C    2ADB     INCF 0xfdb, F, ACCESS
  3C5E    0E02     MOVLW 0x2
  3C60    E301     BNC 0x3c64
  3C62    2ADB     INCF 0xfdb, F, ACCESS
  3C64    0741     DECF 0x41, F, BANKED
  3C66    0E00     MOVLW 0
  3C68    5B42     SUBWFB 0x42, F, BANKED
596:               			USB_Out_Buffer[NextUSBOut] = 0;
  3C6A    5143     MOVF 0x43, W, BANKED
  3C6C    6AEA     CLRF 0xfea, ACCESS
  3C6E    0F89     ADDLW 0x89
  3C70    6EE9     MOVWF 0xfe9, ACCESS
  3C72    0E01     MOVLW 0x1
  3C74    22EA     ADDWFC 0xfea, F, ACCESS
  3C76    6AEF     CLRF 0xfef, ACCESS
597:               		};
598:               		iPrintBufFull = 0;
  3C7A    6B41     CLRF 0x41, BANKED
  3C7C    6B42     CLRF 0x42, BANKED
599:               	}
600:               
601:                   //Check if any bytes are waiting in the queue to send to the USB host.
602:                   //If any bytes are waiting, and the endpoint is available, prepare to
603:                   //send the USB packet to the host.
604:               	if((USBUSARTIsTxTrfReady()) && (NextUSBOut > 0))
  3C7E    0105     MOVLB 0x5
  3C80    51E1     MOVF 0xe1, W, BANKED
  3C82    E111     BNZ 0x3ca6
  3C84    0101     MOVLB 0x1
  3C86    5143     MOVF 0x43, W, BANKED
  3C88    0800     SUBLW 0
  3C8A    E20D     BC 0x3ca6
605:               	{
606:               		putUSBUSART(&USB_Out_Buffer[0], NextUSBOut);
  3C8C    C143     MOVFF 0x143, 0xfe6
  3C8E    FFE6     NOP
  3C90    0E89     MOVLW 0x89
  3C92    6EE6     MOVWF 0xfe6, ACCESS
  3C94    0E01     MOVLW 0x1
  3C96    6EE6     MOVWF 0xfe6, ACCESS
  3C98    ECCF     CALL 0x459e, 0
  3C9A    F022     NOP
  3C9C    52E5     MOVF 0xfe5, F, ACCESS
  3C9E    52E5     MOVF 0xfe5, F, ACCESS
  3CA0    52E5     MOVF 0xfe5, F, ACCESS
607:               		NextUSBOut = 0;
  3CA2    0101     MOVLB 0x1
  3CA4    6B43     CLRF 0x43, BANKED
608:               	}
609:               
610:                   CDCTxService();
  3CA6    EC79     CALL 0x46f2, 0
  3CA8    F023     NOP
611:                   MSDTasks();    
  3CAA    EC1B     CALL 0x3036, 0
  3CAC    F018     NOP
612:               }//end ProcessIO
  3CAE    0E03     MOVLW 0x3
  3CB0    5CE1     SUBWF 0xfe1, W, ACCESS
  3CB2    E202     BC 0x3cb8
  3CB4    6AE1     CLRF 0xfe1, ACCESS
  3CB6    52E5     MOVF 0xfe5, F, ACCESS
  3CB8    6EE1     MOVWF 0xfe1, ACCESS
  3CBA    52E5     MOVF 0xfe5, F, ACCESS
  3CBC    CFE7     MOVFF 0xfe7, 0xfd9
  3CBE    FFD9     NOP
  3CC0    0012     RETURN 0
613:               
614:               /********************************************************************
615:                * Function:        static void InitializeSystem(void)
616:                *
617:                * PreCondition:    None
618:                *
619:                * Input:           None
620:                *
621:                * Output:          None
622:                *
623:                * Side Effects:    None
624:                *
625:                * Overview:        InitializeSystem is a centralize initialization
626:                *                  routine. All required USB initialization routines
627:                *                  are called from here.
628:                *
629:                *                  User application initialization routine should
630:                *                  also be called from here.                  
631:                *
632:                * Note:            None
633:                *******************************************************************/
634:               static void InitializeSystem(void)
  3CC2    CFD9     MOVFF 0xfd9, 0xfe6
  3CC4    FFE6     NOP
  3CC6    CFE1     MOVFF 0xfe1, 0xfd9
  3CC8    FFD9     NOP
  3CCA    0E02     MOVLW 0x2
  3CCC    26E1     ADDWF 0xfe1, F, ACCESS
635:               {
636:                   #if (defined(__18CXX) & !defined(PIC18F87J50_PIM))
637:                       ADCON1 |= 0x0F;                 // Default all pins to digital
  3CCE    0E0F     MOVLW 0xf
  3CD0    12C1     IORWF 0xfc1, F, ACCESS
638:                   #elif defined(__C30__)
639:                       #if defined(PIC24FJ256GB110_PIM) || defined(PIC24F_STARTER_KIT) || defined(PIC24FJ64GB004_PIM)
640:                           AD1PCFGL = 0xFFFF;
641:                       #endif
642:                   #elif defined(__C32__)
643:                       AD1PCFG = 0xFFFF;
644:                   #endif
645:               
646:                   #if defined(PIC18F87J50_PIM) || defined(PIC18F46J50_PIM) || defined(PIC18F_STARTER_KIT_1) || defined(PIC18F47J53_PIM) || defined(CUSTOM_PIM)
647:               	//On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
648:               	//by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
649:               	//This allows the device to power up at a lower initial operating frequency, which can be
650:               	//advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
651:               	//operation.  On these devices, user firmware needs to manually set the OSCTUNE<PLLEN> bit to
652:               	//power up the PLL.
653:                   {
654:                       unsigned int pll_startup_counter = 600;
  3CD2    0E58     MOVLW 0x58
  3CD4    6EDE     MOVWF 0xfde, ACCESS
  3CD6    0E02     MOVLW 0x2
  3CD8    6EDD     MOVWF 0xfdd, ACCESS
655:                       OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
  3CDA    8C9B     BSF 0xf9b, 0x6, ACCESS
656:                       while(pll_startup_counter--);
  3CDC    CFDF     MOVFF 0xfdf, 0x14
  3CDE    F014     NOP
  3CE0    06DF     DECF 0xfdf, F, ACCESS
  3CE2    0E01     MOVLW 0x1
  3CE4    CFDB     MOVFF 0xfdb, 0x15
  3CE6    F015     NOP
  3CE8    E201     BC 0x3cec
  3CEA    06DB     DECF 0xfdb, F, ACCESS
  3CEC    5014     MOVF 0x14, W, ACCESS
  3CEE    1015     IORWF 0x15, W, ACCESS
  3CF0    E1F5     BNZ 0x3cdc
657:                   }
658:                   //Device switches over automatically to PLL output after PLL is locked and ready.
659:                   #endif
660:               
661:                   #if defined(PIC18F87J50_PIM)
662:               	//Configure all I/O pins to use digital input buffers.  The PIC18F87J50 Family devices
663:               	//use the ANCONx registers to control this, which is different from other devices which
664:               	//use the ADCON1 register for this purpose.
665:                   WDTCONbits.ADSHR = 1;			// Select alternate SFR location to access ANCONx registers
666:                   ANCON0 = 0xFF;                  // Default all pins to digital
667:                   ANCON1 = 0xFF;                  // Default all pins to digital
668:                   WDTCONbits.ADSHR = 0;			// Select normal SFR locations
669:                   #endif
670:               
671:                   #if defined(PIC18F46J50_PIM) || defined(PIC18F_STARTER_KIT_1) || defined(PIC18F47J53_PIM)
672:               	//Configure all I/O pins to use digital input buffers.  The PIC18F87J50 Family devices
673:               	//use the ANCONx registers to control this, which is different from other devices which
674:               	//use the ADCON1 register for this purpose.
675:                   ANCON0 = 0xFC;                  // Default all pins to digital, low 2 are analog on power board
676:                   ANCON1 = 0x7F;                  // Default all pins to digital
677:                   #endif
678:                   
679:                  #if defined(PIC24FJ64GB004_PIM) || defined(PIC24FJ256DA210_DEV_BOARD)
680:               	//On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
681:               	//by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
682:               	//This allows the device to power up at a lower initial operating frequency, which can be
683:               	//advantageous when powered from a source which is not gauranteed to be adequate for 32MHz
684:               	//operation.  On these devices, user firmware needs to manually set the CLKDIV<PLLEN> bit to
685:               	//power up the PLL.
686:                   {
687:                       unsigned int pll_startup_counter = 600;
688:                       CLKDIVbits.PLLEN = 1;
689:                       while(pll_startup_counter--);
690:                   }
691:               
692:                   //Device switches over automatically to PLL output after PLL is locked and ready.
693:                   #endif
694:               
695:                  #if defined(DSPIC33EP512MU810_PIM)
696:               
697:                   // Configure the device PLL to obtain 60 MIPS operation. The crystal
698:                   // frequency is 8MHz. Divide 8MHz by 2, multiply by 60 and divide by
699:                   // 2. This results in Fosc of 120MHz. The CPU clock frequency is
700:                   // Fcy = Fosc/2 = 60MHz. Wait for the Primary PLL to lock and then
701:                   // configure the auxilliary PLL to provide 48MHz needed for USB 
702:                   // Operation.
703:               
704:               	PLLFBD = 58;				/* M  = 60	*/
705:               	CLKDIVbits.PLLPOST = 0;		/* N1 = 2	*/
706:               	CLKDIVbits.PLLPRE = 0;		/* N2 = 2	*/
707:               	OSCTUN = 0;			
708:               
709:                   /*	Initiate Clock Switch to Primary
710:                    *	Oscillator with PLL (NOSC= 0x3)*/
711:               	
712:                   __builtin_write_OSCCONH(0x03);		
713:               	__builtin_write_OSCCONL(0x01);
714:               	while (OSCCONbits.COSC != 0x3);       
715:               
716:                   // Configuring the auxiliary PLL, since the primary
717:                   // oscillator provides the source clock to the auxiliary
718:                   // PLL, the auxiliary oscillator is disabled. Note that
719:                   // the AUX PLL is enabled. The input 8MHz clock is divided
720:                   // by 2, multiplied by 24 and then divided by 2. Wait till 
721:                   // the AUX PLL locks.
722:               
723:                   ACLKCON3 = 0x24C1;   
724:                   ACLKDIV3 = 0x7;
725:                   ACLKCON3bits.ENAPLL = 1;
726:                   while(ACLKCON3bits.APLLCK != 1); 
727:               
728:                   #endif
729:               
730:               
731:               //	The USB specifications require that USB peripheral devices must never source
732:               //	current onto the Vbus pin.  Additionally, USB peripherals should not source
733:               //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
734:               //	When designing a self powered (as opposed to bus powered) USB peripheral
735:               //	device, the firmware should make sure not to turn on the USB module and D+
736:               //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
737:               //	firmware needs some means to detect when Vbus is being powered by the host.
738:               //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
739:               // 	can be used to detect when Vbus is high (host actively powering), or low
740:               //	(host is shut down or otherwise not supplying power).  The USB firmware
741:               // 	can then periodically poll this I/O pin to know when it is okay to turn on
742:               //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
743:               //	peripheral device, it is not possible to source current on D+ or D- when the
744:               //	host is not actively providing power on Vbus. Therefore, implementing this
745:               //	bus sense feature is optional.  This firmware can be made to use this bus
746:               //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
747:               //	HardwareProfile.h file.    
748:                   #if defined(USE_USB_BUS_SENSE_IO)
749:                   tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
750:                   #endif
751:                   
752:               //	If the host PC sends a GetStatus (device) request, the firmware must respond
753:               //	and let the host know if the USB peripheral device is currently bus powered
754:               //	or self powered.  See chapter 9 in the official USB specifications for details
755:               //	regarding this request.  If the peripheral device is capable of being both
756:               //	self and bus powered, it should not return a hard coded value for this request.
757:               //	Instead, firmware should check if it is currently self or bus powered, and
758:               //	respond accordingly.  If the hardware has been configured like demonstrated
759:               //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
760:               //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
761:               //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
762:               //	has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped
763:               //	to it in HardwareProfile.h.
764:                   #if defined(USE_SELF_POWER_SENSE_IO)
765:                   tris_self_power = INPUT_PIN;	// See HardwareProfile.h
766:                   #endif
767:                   
768:                   UserInit();
  3CF2    D815     RCALL 0x3d1e
769:               
770:                   //********* Initialize Peripheral Pin Select (PPS) *************************
771:                   //  This section only pertains to devices that have the PPS capabilities.
772:                   //    When migrating code into an application, please verify that the PPS
773:                   //    setting is correct for the port pins that are used in the application.
774:                   #if defined(PIC24FJ256GB110_PIM)
775:                   //Initialize the SPI
776:                   RPINR20bits.SDI1R = 23;
777:                   RPOR7bits.RP15R = 7;
778:                   RPOR0bits.RP0R = 8;    
779:               
780:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
781:                   //  then lets have a pull-up to make sure we don't think it is there.
782:                   CNPU5bits.CN68PUE = 1; 
783:               
784:                   #elif defined(PIC24FJ64GB004_PIM)
785:                   //Initialize the SPI
786:                   RPINR20bits.SDI1R = 17;     //MSDI
787:                   RPOR8bits.RP16R = 7;        //MSDO
788:                   RPOR7bits.RP15R = 8;        //SCK
789:               
790:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
791:                   //  then lets have a pull-up to make sure we don't think it is there.
792:                   CNPU1bits.CN6PUE = 1; 
793:               
794:                   #elif defined(PIC18F46J50_PIM)
795:                   //Initialize the SPI
796:                   //RPINR21bits.SDI2R = 1;
797:                   //RPOR4bits.RP4R = 10;    //RP4 = SCK
798:                   //RPOR2bits.RP2R = 9;     //RP2 = SDO   
799:                   RPINR21 = 6;   //SDI = RP1
800:                   RPOR4 = 10;    //RP4 = SCK
801:                   RPOR2 = 9;     //RP2 = SDO
802:                   RPINR22 = 5;   //SCK = RP4
803:               
804:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
805:                   //  then lets have a pull-up to make sure we don't think it is there.
806:                   INTCON2bits.RBPU = 0; 
807:               
808:                   #elif defined(CUSTOM_PIM)
809:                   //Initialize the SPI
810:                   //RPINR21bits.SDI2R = 1;
811:                   //RPOR4bits.RP4R = 10;    //RP4 = SCK
812:                   //RPOR2bits.RP2R = 9;     //RP2 = SDO   
813:                   RPINR21 = 6;   //PICSDI = RP6 = SD CARD DO
  3CF4    010E     MOVLB 0xe
  3CF6    0E06     MOVLW 0x6
  3CF8    6FFB     MOVWF 0xfb, BANKED
814:                   RPOR5 = 10;    //RP5 = SCK
  3CFA    0E0A     MOVLW 0xa
  3CFC    6FCB     MOVWF 0xcb, BANKED
815:                   RPOR4 = 9;     //PICSDO = RP4 = SD CARD DI
  3CFE    0E09     MOVLW 0x9
  3D00    6FCA     MOVWF 0xca, BANKED
816:                   RPINR22 = 5;   //SCK = RP10
  3D02    0E05     MOVLW 0x5
  3D04    6FFC     MOVWF 0xfc, BANKED
817:               
818:                   //enable a pull-up for the card detect, just in case the SD-Card isn't attached
819:                   //  then lets have a pull-up to make sure we don't think it is there.
820:               //    INTCON2bits.RBPU = 0; // all signals have hardware pullups
821:               
822:                   #endif
823:               
824:               #if defined(USE_SD_INTERFACE_WITH_SPI)
825:                   MDD_SDSPI_InitIO();
826:               #endif
827:               
828:                   USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
  3D06    EC22     CALL 0x1044, 0
  3D08    F008     NOP
829:                   					//variables to known states.
830:               }//end InitializeSystem
  3D0A    0E02     MOVLW 0x2
  3D0C    5CE1     SUBWF 0xfe1, W, ACCESS
  3D0E    E202     BC 0x3d14
  3D10    6AE1     CLRF 0xfe1, ACCESS
  3D12    52E5     MOVF 0xfe5, F, ACCESS
  3D14    6EE1     MOVWF 0xfe1, ACCESS
  3D16    52E5     MOVF 0xfe5, F, ACCESS
  3D18    CFE7     MOVFF 0xfe7, 0xfd9
  3D1A    FFD9     NOP
  3D1C    0012     RETURN 0
831:               
832:               
833:               
834:               /******************************************************************************
835:                * Function:        void UserInit(void)
836:                *
837:                * PreCondition:    None
838:                *
839:                * Input:           None
840:                *
841:                * Output:          None
842:                *
843:                * Side Effects:    None
844:                *
845:                * Overview:        This routine should take care of all of the demo code
846:                *                  initialization that is required.
847:                *
848:                * Note:            
849:                *
850:                *****************************************************************************/
851:               void UserInit(void)
  3D1E    CFD9     MOVFF 0xfd9, 0xfe6
  3D20    FFE6     NOP
  3D22    CFE1     MOVFF 0xfe1, 0xfd9
  3D24    FFD9     NOP
  3D26    52E6     MOVF 0xfe6, F, ACCESS
852:               {
853:               	unsigned char i;
854:                   InitializeUSART();
  3D28    D81F     RCALL 0x3d68
855:               
856:               // 	 Initialize the arrays
857:               	for (i=0; i<sizeof(USB_Out_Buffer); i++)
  3D2A    6ADF     CLRF 0xfdf, ACCESS
  3D2C    50DF     MOVF 0xfdf, W, ACCESS
  3D2E    6E14     MOVWF 0x14, ACCESS
  3D30    6A15     CLRF 0x15, ACCESS
  3D32    0E41     MOVLW 0x41
  3D34    5C14     SUBWF 0x14, W, ACCESS
  3D36    0E00     MOVLW 0
  3D38    5815     SUBWFB 0x15, W, ACCESS
  3D3A    E209     BC 0x3d4e
  3D4A    2ADF     INCF 0xfdf, F, ACCESS
  3D4C    D7EF     BRA 0x3d2c
858:                   {
859:               		USB_Out_Buffer[i] = 0;
  3D3C    50DF     MOVF 0xfdf, W, ACCESS
  3D3E    6AEA     CLRF 0xfea, ACCESS
  3D40    0F89     ADDLW 0x89
  3D42    6EE9     MOVWF 0xfe9, ACCESS
  3D44    0E01     MOVLW 0x1
  3D46    22EA     ADDWFC 0xfea, F, ACCESS
  3D48    6AEF     CLRF 0xfef, ACCESS
860:                   }
861:               	NextUSBOut = 0;
  3D4E    0101     MOVLB 0x1
  3D50    6B43     CLRF 0x43, BANKED
862:               	LastRS232Out = 0;
  3D52    6B44     CLRF 0x44, BANKED
863:               	lastTransmission = 0;
  3D54    6B46     CLRF 0x46, BANKED
  3D56    6B47     CLRF 0x47, BANKED
864:               
865:                   //Initialize all of the debouncing variables
866:                   buttonCount = 0;
  3D58    6BCC     CLRF 0xcc, BANKED
867:                   buttonPressed = FALSE;
  3D5A    6BCB     CLRF 0xcb, BANKED
868:               	stringPrinted = FALSE;
  3D5C    6BCA     CLRF 0xca, BANKED
869:               
870:               	mInitAllLEDs();
871:                   mInitAllSwitches();
872:               }//end UserInit
  3D5E    52E5     MOVF 0xfe5, F, ACCESS
  3D60    52E5     MOVF 0xfe5, F, ACCESS
  3D62    CFE7     MOVFF 0xfe7, 0xfd9
  3D64    FFD9     NOP
  3D66    0012     RETURN 0
873:               
874:               /******************************************************************************
875:                * Function:        void InitializeUSART(void)
876:                *
877:                * PreCondition:    None
878:                *
879:                * Input:           None
880:                *
881:                * Output:          None
882:                *
883:                * Side Effects:    None
884:                *
885:                * Overview:        This routine initializes the UART to 19200
886:                *
887:                * Note:            
888:                *
889:                *****************************************************************************/
890:               void InitializeUSART(void)
  3D68    CFD9     MOVFF 0xfd9, 0xfe6
  3D6A    FFE6     NOP
  3D6C    CFE1     MOVFF 0xfe1, 0xfd9
  3D6E    FFD9     NOP
  3D70    52E6     MOVF 0xfe6, F, ACCESS
891:               {
892:                   #if defined(__18CXX)
893:               	    unsigned char c;
894:                       #if defined(__18F14K50)
895:                   	    //ANSELHbits.ANS11 = 0;	// Make RB5 digital so USART can use pin for Rx
896:                           ANSELH = 0;
897:                           #ifndef BAUDCON
898:                               #define BAUDCON BAUDCTL
899:                           #endif
900:                       #endif
901:                       UART_TRISRx=1;			// RX
  3D72    8E94     BSF 0xf94, 0x7, ACCESS
902:                       UART_TRISTx=0;			// TX
  3D74    9C94     BCF 0xf94, 0x6, ACCESS
903:                       TXSTA = 0x24;       	// TX enable BRGH=1
  3D76    0E24     MOVLW 0x24
  3D78    6EAD     MOVWF 0xfad, ACCESS
904:                       RCSTA = 0x90;       	// Single Character RX
  3D7A    0E90     MOVLW 0x90
  3D7C    6EAC     MOVWF 0xfac, ACCESS
905:                       SPBRG = 0x71;
  3D7E    0E71     MOVLW 0x71
  3D80    6EB0     MOVWF 0xfb0, ACCESS
906:                       SPBRGH = 0x02;      	// 0x0271 for 48MHz -> 19200 baud
  3D82    0E02     MOVLW 0x2
  3D84    6E7F     MOVWF 0xf7f, ACCESS
907:                  		PIE1bits.RC1IE = 1, IPR1bits.RC1IP = 0;	// RX enable low priority
  3D86    8A9D     BSF 0xf9d, 0x5, ACCESS
  3D88    9A9F     BCF 0xf9f, 0x5, ACCESS
908:               		INTCONbits.PEIE = 1;	// enable interrupt
  3D8A    8CF2     BSF 0xff2, 0x6, ACCESS
909:               // ABDOVF RCIDL RXDTP TXCKP BRG16 - WUE ABDEN
910:               //        BAUDCON = 0x08;     	// BRG16 = 1
911:                       BAUDCON = 0x38;     	// BRG16 = 1, TX and RX idle low
  3D8C    0E38     MOVLW 0x38
  3D8E    6E7E     MOVWF 0xf7e, ACCESS
912:                       c = RCREG;				// read 
  3D90    50AF     MOVF 0xfaf, W, ACCESS
  3D92    6EDF     MOVWF 0xfdf, ACCESS
913:                   #endif
914:               
915:                   #if defined(__C30__)
916:                       #if defined( __PIC24FJ256GB110__ ) || defined( PIC24FJ256GB210_PIM )
917:                           // PPS - Configure U2RX - put on pin 49 (RP10)
918:                           RPINR19bits.U2RXR = 10;
919:               
920:                           // PPS - Configure U2TX - put on pin 50 (RP17)
921:                           RPOR8bits.RP17R = 5;
922:                       #elif defined(__PIC24FJ64GB004__)
923:                           // PPS - Configure U2RX - put on RC3/pin 36 (RP19)
924:                           RPINR19bits.U2RXR = 19;
925:               
926:                           // PPS - Configure U2TX - put on RC9/pin 5 (RP25)
927:                           RPOR12bits.RP25R = 5;
928:                       #elif defined(__PIC24FJ256DA210__)
929:                           // PPS - Configure U2RX - put on RC14/pin 74 (RPI37)
930:                           RPINR19bits.U2RXR = 37;
931:                   
932:                           // PPS - Configure U2TX - put on RF3/pin 51 (RP16)
933:                           RPOR8bits.RP16R = 5;
934:               
935:                           TRISFbits.TRISF3 = 0;
936:                       #elif defined(__dsPIC33EP512MU810__)
937:                           // The dsPIC33EP512MU810 features Peripheral Pin
938:                           // select. The following statements map UART2 to 
939:                           // device pins which would connect to the the 
940:                           // RX232 transciever on the Explorer 16 board.
941:               
942:                            RPINR19 = 0;
943:                            RPINR19 = 0x64;
944:                            RPOR9bits.RP101R = 0x3;
945:               
946:                       #else
947:                           #error Verify that any required PPS is done here.
948:                       #endif
949:               
950:                       UART2Init();
951:                   #endif
952:               
953:                   #if defined(__C32__)
954:                       UART2Init();
955:                   #endif
956:               
957:               }//end InitializeUSART
  3D94    52E5     MOVF 0xfe5, F, ACCESS
  3D96    52E5     MOVF 0xfe5, F, ACCESS
  3D98    CFE7     MOVFF 0xfe7, 0xfd9
  3D9A    FFD9     NOP
  3D9C    0012     RETURN 0
958:               
959:               /******************************************************************************
960:                * Function:        void putcUSART(char c)
961:                *
962:                * PreCondition:    None
963:                *
964:                * Input:           char c - character to print to the UART
965:                *
966:                * Output:          None
967:                *
968:                * Side Effects:    None
969:                *
970:                * Overview:        Print the input character to the UART
971:                *
972:                * Note:            
973:                *
974:                *****************************************************************************/
975:               void putcUSART(char c)  
  3D9E    CFD9     MOVFF 0xfd9, 0xfe6
  3DA0    FFE6     NOP
  3DA2    CFE1     MOVFF 0xfe1, 0xfd9
  3DA4    FFD9     NOP
976:               {
977:                   #if defined(__18CXX)
978:               	    TXREG = c;
  3DA6    0EFE     MOVLW 0xfe
  3DA8    50DB     MOVF 0xfdb, W, ACCESS
  3DAA    6EAE     MOVWF 0xfae, ACCESS
979:                   #else
980:                       UART2PutChar(c);
981:                   #endif
982:               }
  3DAC    52E5     MOVF 0xfe5, F, ACCESS
  3DAE    CFE7     MOVFF 0xfe7, 0xfd9
  3DB0    FFD9     NOP
  3DB2    0012     RETURN 0
983:               
984:               
985:               /******************************************************************************
986:                * Function:        void mySetLineCodingHandler(void)
987:                *
988:                * PreCondition:    USB_CDC_SET_LINE_CODING_HANDLER is defined
989:                *
990:                * Input:           None
991:                *
992:                * Output:          None
993:                *
994:                * Side Effects:    None
995:                *
996:                * Overview:        This function gets called when a SetLineCoding command
997:                *                  is sent on the bus.  This function will evaluate the request
998:                *                  and determine if the application should update the baudrate
999:                *                  or not.
1000:               *
1001:               * Note:            
1002:               *
1003:               *****************************************************************************/
1004:              #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
1005:              void mySetLineCodingHandler(void)
  3DB4    CFD9     MOVFF 0xfd9, 0xfe6
  3DB6    FFE6     NOP
  3DB8    CFE1     MOVFF 0xfe1, 0xfd9
  3DBA    FFD9     NOP
  3DBC    0E22     MOVLW 0x22
  3DBE    26E1     ADDWF 0xfe1, F, ACCESS
1006:              {
1007:                  //If the request is not in a valid range
1008:                  if(cdc_notice.GetLineCoding.dwDTERate.Val > 2000000)
  3DC0    80D8     BSF 0xfd8, 0, ACCESS
  3DC2    0E80     MOVLW 0x80
  3DC4    0105     MOVLB 0x5
  3DC6    5551     SUBFWB 0x51, W, BANKED
  3DC8    0E84     MOVLW 0x84
  3DCA    5552     SUBFWB 0x52, W, BANKED
  3DCC    0E1E     MOVLW 0x1e
  3DCE    5553     SUBFWB 0x53, W, BANKED
  3DD0    0E00     MOVLW 0
  3DD2    5554     SUBFWB 0x54, W, BANKED
  3DD4    E201     BC 0x3dd8
  3DD6    D24E     BRA 0x4274
1009:                  {
1010:                      //NOTE: There are two ways that an unsupported baud rate could be
1011:                      //handled.  The first is just to ignore the request and don't change
1012:                      //the values.  That is what is currently implemented in this function.
1013:                      //The second possible method is to stall the STATUS stage of the request.
1014:                      //STALLing the STATUS stage will cause an exception to be thrown in the 
1015:                      //requesting application.  Some programs, like HyperTerminal, handle the
1016:                      //exception properly and give a pop-up box indicating that the request
1017:                      //settings are not valid.  Any application that does not handle the
1018:                      //exception correctly will likely crash when this requiest fails.  For
1019:                      //the sake of example the code required to STALL the status stage of the
1020:                      //request is provided below.  It has been left out so that this demo
1021:                      //does not cause applications without the required exception handling
1022:                      //to crash.
1023:                      //---------------------------------------
1024:                      //USBStallEndpoint(0,1);
1025:                  }
1026:                  else
1027:                  {
1028:                      DWORD_VAL dwBaud, dwBaud1, dwError, dwError1, dwRate, dwRate1;
1029:              		char cPercent[10];
1030:              
1031:                      //Update the baudrate info in the CDC driver
1032:                      CDCSetBaudRate(cdc_notice.GetLineCoding.dwDTERate.Val);
  3DD8    C551     MOVFF 0x551, 0x5d9
  3DDA    F5D9     NOP
  3DDC    C552     MOVFF 0x552, 0x5da
  3DDE    F5DA     NOP
  3DE0    C553     MOVFF 0x553, 0x5db
  3DE2    F5DB     NOP
  3DE4    C554     MOVFF 0x554, 0x5dc
  3DE6    F5DC     NOP
1033:                      
1034:                      //Update the baudrate of the UART
1035:                      #if defined(__18CXX)
1036:                          dwBaud.Val = (DWORD)(GetSystemClock()/4)/line_coding.dwDTERate.Val-1;
  3DE8    6A18     CLRF 0x18, ACCESS
  3DEA    0E1B     MOVLW 0x1b
  3DEC    6E19     MOVWF 0x19, ACCESS
  3DEE    0EB7     MOVLW 0xb7
  3DF0    6E1A     MOVWF 0x1a, ACCESS
  3DF2    6A1B     CLRF 0x1b, ACCESS
  3DF4    C018     MOVFF 0x18, 0x6
  3DF6    F006     NOP
  3DF8    C019     MOVFF 0x19, 0x7
  3DFA    F007     NOP
  3DFC    6E08     MOVWF 0x8, ACCESS
  3DFE    C01B     MOVFF 0x1b, 0x9
  3E00    F009     NOP
  3E02    C5D9     MOVFF 0x5d9, 0xb
  3E04    F00B     NOP
  3E06    C5DA     MOVFF 0x5da, 0xc
  3E08    F00C     NOP
  3E0A    C5DB     MOVFF 0x5db, 0xd
  3E0C    F00D     NOP
  3E0E    C5DC     MOVFF 0x5dc, 0xe
  3E10    F00E     NOP
  3E12    ECF5     CALL 0x51ea, 0
  3E14    F028     NOP
  3E16    C006     MOVFF 0x6, 0x14
  3E18    F014     NOP
  3E1A    C007     MOVFF 0x7, 0x15
  3E1C    F015     NOP
  3E1E    C008     MOVFF 0x8, 0x16
  3E20    F016     NOP
  3E22    C009     MOVFF 0x9, 0x17
  3E24    F017     NOP
  3E26    0614     DECF 0x14, F, ACCESS
  3E28    0E00     MOVLW 0
  3E2A    5A15     SUBWFB 0x15, F, ACCESS
  3E2C    5A16     SUBWFB 0x16, F, ACCESS
  3E2E    5A17     SUBWFB 0x17, F, ACCESS
  3E30    C014     MOVFF 0x14, 0xfdf
  3E32    FFDF     NOP
  3E34    0E01     MOVLW 0x1
  3E36    C015     MOVFF 0x15, 0xfdb
  3E38    FFDB     NOP
  3E3A    0E02     MOVLW 0x2
  3E3C    C016     MOVFF 0x16, 0xfdb
  3E3E    FFDB     NOP
  3E40    0E03     MOVLW 0x3
  3E42    C017     MOVFF 0x17, 0xfdb
  3E44    FFDB     NOP
1037:              			dwRate.Val = ((DWORD)(GetSystemClock()/4)/(dwBaud.Val+1));
  3E46    0E01     MOVLW 0x1
  3E48    6E18     MOVWF 0x18, ACCESS
  3E4A    6A19     CLRF 0x19, ACCESS
  3E4C    6A1A     CLRF 0x1a, ACCESS
  3E4E    6A1B     CLRF 0x1b, ACCESS
  3E50    CFD9     MOVFF 0xfd9, 0xfe9
  3E52    FFE9     NOP
  3E54    CFDA     MOVFF 0xfda, 0xfea
  3E56    FFEA     NOP
  3E58    50EE     MOVF 0xfee, W, ACCESS
  3E5A    2618     ADDWF 0x18, F, ACCESS
  3E5C    50EE     MOVF 0xfee, W, ACCESS
  3E5E    2219     ADDWFC 0x19, F, ACCESS
  3E60    50EE     MOVF 0xfee, W, ACCESS
  3E62    221A     ADDWFC 0x1a, F, ACCESS
  3E64    50EE     MOVF 0xfee, W, ACCESS
  3E66    221B     ADDWFC 0x1b, F, ACCESS
  3E68    6A14     CLRF 0x14, ACCESS
  3E6A    0E1B     MOVLW 0x1b
  3E6C    6E15     MOVWF 0x15, ACCESS
  3E6E    0EB7     MOVLW 0xb7
  3E70    6E16     MOVWF 0x16, ACCESS
  3E72    6A17     CLRF 0x17, ACCESS
  3E74    C014     MOVFF 0x14, 0x6
  3E76    F006     NOP
  3E78    C015     MOVFF 0x15, 0x7
  3E7A    F007     NOP
  3E7C    6E08     MOVWF 0x8, ACCESS
  3E7E    C017     MOVFF 0x17, 0x9
  3E80    F009     NOP
  3E82    C018     MOVFF 0x18, 0xb
  3E84    F00B     NOP
  3E86    C019     MOVFF 0x19, 0xc
  3E88    F00C     NOP
  3E8A    C01A     MOVFF 0x1a, 0xd
  3E8C    F00D     NOP
  3E8E    C01B     MOVFF 0x1b, 0xe
  3E90    F00E     NOP
  3E92    ECF5     CALL 0x51ea, 0
  3E94    F028     NOP
  3E96    0E10     MOVLW 0x10
  3E98    C006     MOVFF 0x6, 0xfdb
  3E9A    FFDB     NOP
  3E9C    0E11     MOVLW 0x11
  3E9E    C007     MOVFF 0x7, 0xfdb
  3EA0    FFDB     NOP
  3EA2    0E12     MOVLW 0x12
  3EA4    C008     MOVFF 0x8, 0xfdb
  3EA6    FFDB     NOP
  3EA8    0E13     MOVLW 0x13
  3EAA    C009     MOVFF 0x9, 0xfdb
  3EAC    FFDB     NOP
1038:              			dwError.Val = dwRate.Val - line_coding.dwDTERate.Val;
  3EAE    50D9     MOVF 0xfd9, W, ACCESS
  3EB0    0F10     ADDLW 0x10
  3EB2    6EE9     MOVWF 0xfe9, ACCESS
  3EB4    CFDA     MOVFF 0xfda, 0xfea
  3EB6    FFEA     NOP
  3EB8    0105     MOVLB 0x5
  3EBA    51D9     MOVF 0xd9, W, BANKED
  3EBC    5CEE     SUBWF 0xfee, W, ACCESS
  3EBE    6E14     MOVWF 0x14, ACCESS
  3EC0    51DA     MOVF 0xda, W, BANKED
  3EC2    58EE     SUBWFB 0xfee, W, ACCESS
  3EC4    6E15     MOVWF 0x15, ACCESS
  3EC6    51DB     MOVF 0xdb, W, BANKED
  3EC8    58EE     SUBWFB 0xfee, W, ACCESS
  3ECA    6E16     MOVWF 0x16, ACCESS
  3ECC    51DC     MOVF 0xdc, W, BANKED
  3ECE    58EE     SUBWFB 0xfee, W, ACCESS
  3ED0    6E17     MOVWF 0x17, ACCESS
  3ED2    0E08     MOVLW 0x8
  3ED4    C014     MOVFF 0x14, 0xfdb
  3ED6    FFDB     NOP
  3ED8    0E09     MOVLW 0x9
  3EDA    C015     MOVFF 0x15, 0xfdb
  3EDC    FFDB     NOP
  3EDE    0E0A     MOVLW 0xa
  3EE0    C016     MOVFF 0x16, 0xfdb
  3EE2    FFDB     NOP
  3EE4    0E0B     MOVLW 0xb
  3EE6    C017     MOVFF 0x17, 0xfdb
  3EE8    FFDB     NOP
1039:              			dwBaud1.Val = ((DWORD)(GetSystemClock()/4)/line_coding.dwDTERate.Val);	// pick next larger to slow more
  3EEA    6A14     CLRF 0x14, ACCESS
  3EEC    0E1B     MOVLW 0x1b
  3EEE    6E15     MOVWF 0x15, ACCESS
  3EF0    0EB7     MOVLW 0xb7
  3EF2    6E16     MOVWF 0x16, ACCESS
  3EF4    6A17     CLRF 0x17, ACCESS
  3EF6    C014     MOVFF 0x14, 0x6
  3EF8    F006     NOP
  3EFA    C015     MOVFF 0x15, 0x7
  3EFC    F007     NOP
  3EFE    6E08     MOVWF 0x8, ACCESS
  3F00    C017     MOVFF 0x17, 0x9
  3F02    F009     NOP
  3F04    C5D9     MOVFF 0x5d9, 0xb
  3F06    F00B     NOP
  3F08    C5DA     MOVFF 0x5da, 0xc
  3F0A    F00C     NOP
  3F0C    C5DB     MOVFF 0x5db, 0xd
  3F0E    F00D     NOP
  3F10    C5DC     MOVFF 0x5dc, 0xe
  3F12    F00E     NOP
  3F14    ECF5     CALL 0x51ea, 0
  3F16    F028     NOP
  3F18    0E04     MOVLW 0x4
  3F1A    C006     MOVFF 0x6, 0xfdb
  3F1C    FFDB     NOP
  3F1E    0E05     MOVLW 0x5
  3F20    C007     MOVFF 0x7, 0xfdb
  3F22    FFDB     NOP
  3F24    0E06     MOVLW 0x6
  3F26    C008     MOVFF 0x8, 0xfdb
  3F28    FFDB     NOP
  3F2A    0E07     MOVLW 0x7
  3F2C    C009     MOVFF 0x9, 0xfdb
  3F2E    FFDB     NOP
1040:              			dwRate1.Val = ((DWORD)(GetSystemClock()/4)/(dwBaud1.Val+1));
  3F30    0E01     MOVLW 0x1
  3F32    6E18     MOVWF 0x18, ACCESS
  3F34    6A19     CLRF 0x19, ACCESS
  3F36    6A1A     CLRF 0x1a, ACCESS
  3F38    6A1B     CLRF 0x1b, ACCESS
  3F3A    50D9     MOVF 0xfd9, W, ACCESS
  3F3C    0F04     ADDLW 0x4
  3F3E    6EE9     MOVWF 0xfe9, ACCESS
  3F40    CFDA     MOVFF 0xfda, 0xfea
  3F42    FFEA     NOP
  3F44    50EE     MOVF 0xfee, W, ACCESS
  3F46    2618     ADDWF 0x18, F, ACCESS
  3F48    50EE     MOVF 0xfee, W, ACCESS
  3F4A    2219     ADDWFC 0x19, F, ACCESS
  3F4C    50EE     MOVF 0xfee, W, ACCESS
  3F4E    221A     ADDWFC 0x1a, F, ACCESS
  3F50    50EE     MOVF 0xfee, W, ACCESS
  3F52    221B     ADDWFC 0x1b, F, ACCESS
  3F54    6A14     CLRF 0x14, ACCESS
  3F56    0E1B     MOVLW 0x1b
  3F58    6E15     MOVWF 0x15, ACCESS
  3F5A    0EB7     MOVLW 0xb7
  3F5C    6E16     MOVWF 0x16, ACCESS
  3F5E    6A17     CLRF 0x17, ACCESS
  3F60    C014     MOVFF 0x14, 0x6
  3F62    F006     NOP
  3F64    C015     MOVFF 0x15, 0x7
  3F66    F007     NOP
  3F68    6E08     MOVWF 0x8, ACCESS
  3F6A    C017     MOVFF 0x17, 0x9
  3F6C    F009     NOP
  3F6E    C018     MOVFF 0x18, 0xb
  3F70    F00B     NOP
  3F72    C019     MOVFF 0x19, 0xc
  3F74    F00C     NOP
  3F76    C01A     MOVFF 0x1a, 0xd
  3F78    F00D     NOP
  3F7A    C01B     MOVFF 0x1b, 0xe
  3F7C    F00E     NOP
  3F7E    ECF5     CALL 0x51ea, 0
  3F80    F028     NOP
  3F82    0E14     MOVLW 0x14
  3F84    C006     MOVFF 0x6, 0xfdb
  3F86    FFDB     NOP
  3F88    0E15     MOVLW 0x15
  3F8A    C007     MOVFF 0x7, 0xfdb
  3F8C    FFDB     NOP
  3F8E    0E16     MOVLW 0x16
  3F90    C008     MOVFF 0x8, 0xfdb
  3F92    FFDB     NOP
  3F94    0E17     MOVLW 0x17
  3F96    C009     MOVFF 0x9, 0xfdb
  3F98    FFDB     NOP
1041:              			dwError1.Val = line_coding.dwDTERate.Val - dwRate1.Val;		// make both positive
  3F9A    50D9     MOVF 0xfd9, W, ACCESS
  3F9C    0F14     ADDLW 0x14
  3F9E    6EE9     MOVWF 0xfe9, ACCESS
  3FA0    CFDA     MOVFF 0xfda, 0xfea
  3FA2    FFEA     NOP
  3FA4    50EE     MOVF 0xfee, W, ACCESS
  3FA6    0105     MOVLB 0x5
  3FA8    5DD9     SUBWF 0xd9, W, BANKED
  3FAA    6E14     MOVWF 0x14, ACCESS
  3FAC    50EE     MOVF 0xfee, W, ACCESS
  3FAE    59DA     SUBWFB 0xda, W, BANKED
  3FB0    6E15     MOVWF 0x15, ACCESS
  3FB2    50EE     MOVF 0xfee, W, ACCESS
  3FB4    59DB     SUBWFB 0xdb, W, BANKED
  3FB6    6E16     MOVWF 0x16, ACCESS
  3FB8    50EE     MOVF 0xfee, W, ACCESS
  3FBA    59DC     SUBWFB 0xdc, W, BANKED
  3FBC    6E17     MOVWF 0x17, ACCESS
  3FBE    0E0C     MOVLW 0xc
  3FC0    C014     MOVFF 0x14, 0xfdb
  3FC2    FFDB     NOP
  3FC4    0E0D     MOVLW 0xd
  3FC6    C015     MOVFF 0x15, 0xfdb
  3FC8    FFDB     NOP
  3FCA    0E0E     MOVLW 0xe
  3FCC    C016     MOVFF 0x16, 0xfdb
  3FCE    FFDB     NOP
  3FD0    0E0F     MOVLW 0xf
  3FD2    C017     MOVFF 0x17, 0xfdb
  3FD4    FFDB     NOP
1042:              			if ( dwError.Val > dwError1.Val )	// if error > error1 then use rate1
  3FD6    0E0C     MOVLW 0xc
  3FD8    CFDB     MOVFF 0xfdb, 0x14
  3FDA    F014     NOP
  3FDC    0E0D     MOVLW 0xd
  3FDE    CFDB     MOVFF 0xfdb, 0x15
  3FE0    F015     NOP
  3FE2    0E0E     MOVLW 0xe
  3FE4    CFDB     MOVFF 0xfdb, 0x16
  3FE6    F016     NOP
  3FE8    0E0F     MOVLW 0xf
  3FEA    CFDB     MOVFF 0xfdb, 0x17
  3FEC    F017     NOP
  3FEE    50D9     MOVF 0xfd9, W, ACCESS
  3FF0    0F08     ADDLW 0x8
  3FF2    6EE9     MOVWF 0xfe9, ACCESS
  3FF4    CFDA     MOVFF 0xfda, 0xfea
  3FF6    FFEA     NOP
  3FF8    50EE     MOVF 0xfee, W, ACCESS
  3FFA    5C14     SUBWF 0x14, W, ACCESS
  3FFC    50EE     MOVF 0xfee, W, ACCESS
  3FFE    5815     SUBWFB 0x15, W, ACCESS
  4000    50EE     MOVF 0xfee, W, ACCESS
  4002    5816     SUBWFB 0x16, W, ACCESS
  4004    50EE     MOVF 0xfee, W, ACCESS
  4006    5817     SUBWFB 0x17, W, ACCESS
  4008    E236     BC 0x4076
1043:              			{
1044:              	            dwBaud.Val = dwBaud1.Val;
  400A    CFD9     MOVFF 0xfd9, 0xfe9
  400C    FFE9     NOP
  400E    CFDA     MOVFF 0xfda, 0xfea
  4010    FFEA     NOP
  4012    0E04     MOVLW 0x4
  4014    CFDB     MOVFF 0xfdb, 0xfee
  4016    FFEE     NOP
  4018    0E05     MOVLW 0x5
  401A    CFDB     MOVFF 0xfdb, 0xfee
  401C    FFEE     NOP
  401E    0E06     MOVLW 0x6
  4020    CFDB     MOVFF 0xfdb, 0xfee
  4022    FFEE     NOP
  4024    0E07     MOVLW 0x7
  4026    CFDB     MOVFF 0xfdb, 0xfee
  4028    FFEE     NOP
1045:              				dwRate.Val = dwRate1.Val;
  402A    50D9     MOVF 0xfd9, W, ACCESS
  402C    0F14     ADDLW 0x14
  402E    6EE9     MOVWF 0xfe9, ACCESS
  4030    CFDA     MOVFF 0xfda, 0xfea
  4032    FFEA     NOP
  4034    0E10     MOVLW 0x10
  4036    CFEE     MOVFF 0xfee, 0xfdb
  4038    FFDB     NOP
  403A    0E11     MOVLW 0x11
  403C    CFEE     MOVFF 0xfee, 0xfdb
  403E    FFDB     NOP
  4040    0E12     MOVLW 0x12
  4042    CFEE     MOVFF 0xfee, 0xfdb
  4044    FFDB     NOP
  4046    0E13     MOVLW 0x13
  4048    CFEE     MOVFF 0xfee, 0xfdb
  404A    FFDB     NOP
1046:              				dwError.Val = dwError1.Val;
  404C    50D9     MOVF 0xfd9, W, ACCESS
  404E    0F0C     ADDLW 0xc
  4050    6EE9     MOVWF 0xfe9, ACCESS
  4052    CFDA     MOVFF 0xfda, 0xfea
  4054    FFEA     NOP
  4056    0E08     MOVLW 0x8
  4058    CFEE     MOVFF 0xfee, 0xfdb
  405A    FFDB     NOP
  405C    0E09     MOVLW 0x9
  405E    CFEE     MOVFF 0xfee, 0xfdb
  4060    FFDB     NOP
  4062    0E0A     MOVLW 0xa
  4064    CFEE     MOVFF 0xfee, 0xfdb
  4066    FFDB     NOP
  4068    0E0B     MOVLW 0xb
  406A    CFEE     MOVFF 0xfee, 0xfdb
  406C    FFDB     NOP
1047:              				cPercent[9] = '-';
  406E    0E2D     MOVLW 0x2d
  4070    6EF3     MOVWF 0xff3, ACCESS
  4072    0E21     MOVLW 0x21
1048:              			} else cPercent[0] = ' ';
  4074    D003     BRA 0x407c
  4076    0E20     MOVLW 0x20
  4078    6EF3     MOVWF 0xff3, ACCESS
  407A    0E18     MOVLW 0x18
  407C    CFF3     MOVFF 0xff3, 0xfdb
  407E    FFDB     NOP
1049:                          SPBRG = dwBaud.v[0];
  4080    50DF     MOVF 0xfdf, W, ACCESS
  4082    6EB0     MOVWF 0xfb0, ACCESS
1050:                          SPBRGH = dwBaud.v[1];
  4084    0E01     MOVLW 0x1
  4086    50DB     MOVF 0xfdb, W, ACCESS
  4088    6E7F     MOVWF 0xf7f, ACCESS
1051:              #if defined(__DEBUG)
1052:              			if ( !iPrintBufFull )
  408A    0101     MOVLB 0x1
  408C    5141     MOVF 0x41, W, BANKED
  408E    1142     IORWF 0x42, W, BANKED
  4090    E001     BZ 0x4094
  4092    D0F0     BRA 0x4274
1053:              			{	
1054:              				dwError.Val *= 10000; // for %
  4094    50D9     MOVF 0xfd9, W, ACCESS
  4096    0F08     ADDLW 0x8
  4098    6EE9     MOVWF 0xfe9, ACCESS
  409A    CFDA     MOVFF 0xfda, 0xfea
  409C    FFEA     NOP
  409E    0E10     MOVLW 0x10
  40A0    6E0B     MOVWF 0xb, ACCESS
  40A2    0E27     MOVLW 0x27
  40A4    6E0C     MOVWF 0xc, ACCESS
  40A6    6A0D     CLRF 0xd, ACCESS
  40A8    6A0E     CLRF 0xe, ACCESS
  40AA    CFEE     MOVFF 0xfee, 0x6
  40AC    F006     NOP
  40AE    CFEE     MOVFF 0xfee, 0x7
  40B0    F007     NOP
  40B2    CFEE     MOVFF 0xfee, 0x8
  40B4    F008     NOP
  40B6    CFEF     MOVFF 0xfef, 0x9
  40B8    F009     NOP
  40BA    ECBD     CALL 0x517a, 0
  40BC    F028     NOP
  40BE    C005     MOVFF 0x5, 0xfed
  40C0    FFED     NOP
  40C2    C004     MOVFF 0x4, 0xfed
  40C4    FFED     NOP
  40C6    C003     MOVFF 0x3, 0xfed
  40C8    FFED     NOP
  40CA    C002     MOVFF 0x2, 0xfef
  40CC    FFEF     NOP
1055:              				dwError.Val /= line_coding.dwDTERate.Val; // for %
  40CE    50D9     MOVF 0xfd9, W, ACCESS
  40D0    0F08     ADDLW 0x8
  40D2    6EE9     MOVWF 0xfe9, ACCESS
  40D4    CFDA     MOVFF 0xfda, 0xfea
  40D6    FFEA     NOP
  40D8    C5D9     MOVFF 0x5d9, 0xb
  40DA    F00B     NOP
  40DC    C5DA     MOVFF 0x5da, 0xc
  40DE    F00C     NOP
  40E0    C5DB     MOVFF 0x5db, 0xd
  40E2    F00D     NOP
  40E4    C5DC     MOVFF 0x5dc, 0xe
  40E6    F00E     NOP
  40E8    CFEE     MOVFF 0xfee, 0x6
  40EA    F006     NOP
  40EC    CFEE     MOVFF 0xfee, 0x7
  40EE    F007     NOP
  40F0    CFEE     MOVFF 0xfee, 0x8
  40F2    F008     NOP
  40F4    CFEF     MOVFF 0xfef, 0x9
  40F6    F009     NOP
  40F8    ECF5     CALL 0x51ea, 0
  40FA    F028     NOP
  40FC    C009     MOVFF 0x9, 0xfed
  40FE    FFED     NOP
  4100    C008     MOVFF 0x8, 0xfed
  4102    FFED     NOP
  4104    C007     MOVFF 0x7, 0xfed
  4106    FFED     NOP
  4108    C006     MOVFF 0x6, 0xfef
  410A    FFEF     NOP
1056:              				sprintf( &cPercent[0], "%04ld", dwError.Val );
  410C    50D9     MOVF 0xfd9, W, ACCESS
  410E    0F08     ADDLW 0x8
  4110    6EE9     MOVWF 0xfe9, ACCESS
  4112    CFDA     MOVFF 0xfda, 0xfea
  4114    FFEA     NOP
  4116    CFEE     MOVFF 0xfee, 0xfe6
  4118    FFE6     NOP
  411A    CFEE     MOVFF 0xfee, 0xfe6
  411C    FFE6     NOP
  411E    CFEE     MOVFF 0xfee, 0xfe6
  4120    FFE6     NOP
  4122    CFEF     MOVFF 0xfef, 0xfe6
  4124    FFE6     NOP
  4126    0E67     MOVLW 0x67
  4128    6EE6     MOVWF 0xfe6, ACCESS
  412A    0E52     MOVLW 0x52
  412C    6EE6     MOVWF 0xfe6, ACCESS
  412E    0E00     MOVLW 0
  4130    6EE6     MOVWF 0xfe6, ACCESS
  4132    50D9     MOVF 0xfd9, W, ACCESS
  4134    0F18     ADDLW 0x18
  4136    6EE6     MOVWF 0xfe6, ACCESS
  4138    0E00     MOVLW 0
  413A    20DA     ADDWFC 0xfda, W, ACCESS
  413C    6EE6     MOVWF 0xfe6, ACCESS
  413E    ECD6     CALL 0x4fac, 0
  4140    F027     NOP
  4142    6E14     MOVWF 0x14, ACCESS
  4144    0E09     MOVLW 0x9
  4146    5EE1     SUBWF 0xfe1, F, ACCESS
  4148    5014     MOVF 0x14, W, ACCESS
1057:              				cPercent[4] = cPercent[3], cPercent[3] = cPercent[2], cPercent[2] = '.', cPercent[5] = 0;
  414A    0E1B     MOVLW 0x1b
  414C    50DB     MOVF 0xfdb, W, ACCESS
  414E    6EE7     MOVWF 0xfe7, ACCESS
  4150    0E1C     MOVLW 0x1c
  4152    CFE7     MOVFF 0xfe7, 0xfdb
  4154    FFDB     NOP
  4156    0E1A     MOVLW 0x1a
  4158    50DB     MOVF 0xfdb, W, ACCESS
  415A    6EE7     MOVWF 0xfe7, ACCESS
  415C    0E1B     MOVLW 0x1b
  415E    CFE7     MOVFF 0xfe7, 0xfdb
  4160    FFDB     NOP
  4162    0E2E     MOVLW 0x2e
  4164    6EF3     MOVWF 0xff3, ACCESS
  4166    0E1A     MOVLW 0x1a
  4168    CFF3     MOVFF 0xff3, 0xfdb
  416A    FFDB     NOP
  416C    0E1D     MOVLW 0x1d
  416E    6ADB     CLRF 0xfdb, ACCESS
1058:              				if ( cPercent[0] == '0' )
  4170    0E18     MOVLW 0x18
  4172    50DB     MOVF 0xfdb, W, ACCESS
  4174    0830     SUBLW 0x30
  4176    E11A     BNZ 0x41ac
1059:              				{	cPercent[0] = cPercent[1], cPercent[1] = cPercent[2];
  4178    0E19     MOVLW 0x19
  417A    50DB     MOVF 0xfdb, W, ACCESS
  417C    6EE7     MOVWF 0xfe7, ACCESS
  417E    0E18     MOVLW 0x18
  4180    CFE7     MOVFF 0xfe7, 0xfdb
  4182    FFDB     NOP
  4184    0E1A     MOVLW 0x1a
  4186    50DB     MOVF 0xfdb, W, ACCESS
  4188    6EE7     MOVWF 0xfe7, ACCESS
  418A    0E19     MOVLW 0x19
  418C    CFE7     MOVFF 0xfe7, 0xfdb
  418E    FFDB     NOP
1060:              					cPercent[2] = cPercent[3], cPercent[3] = cPercent[4], cPercent[4] = 0;
  4190    0E1B     MOVLW 0x1b
  4192    50DB     MOVF 0xfdb, W, ACCESS
  4194    6EE7     MOVWF 0xfe7, ACCESS
  4196    0E1A     MOVLW 0x1a
  4198    CFE7     MOVFF 0xfe7, 0xfdb
  419A    FFDB     NOP
  419C    0E1C     MOVLW 0x1c
  419E    50DB     MOVF 0xfdb, W, ACCESS
  41A0    6EE7     MOVWF 0xfe7, ACCESS
  41A2    0E1B     MOVLW 0x1b
  41A4    CFE7     MOVFF 0xfe7, 0xfdb
  41A6    FFDB     NOP
  41A8    0E1C     MOVLW 0x1c
  41AA    6ADB     CLRF 0xfdb, ACCESS
1061:              				};
1062:              				if ( cPercent[9] == '-' )
  41AC    0E21     MOVLW 0x21
  41AE    50DB     MOVF 0xfdb, W, ACCESS
  41B0    082D     SUBLW 0x2d
  41B2    E125     BNZ 0x41fe
1063:              				{	cPercent[5] = cPercent[4], cPercent[4] = cPercent[3], cPercent[3] = cPercent[2];
  41B4    0E1C     MOVLW 0x1c
  41B6    50DB     MOVF 0xfdb, W, ACCESS
  41B8    6EE7     MOVWF 0xfe7, ACCESS
  41BA    0E1D     MOVLW 0x1d
  41BC    CFE7     MOVFF 0xfe7, 0xfdb
  41BE    FFDB     NOP
  41C0    0E1B     MOVLW 0x1b
  41C2    50DB     MOVF 0xfdb, W, ACCESS
  41C4    6EE7     MOVWF 0xfe7, ACCESS
  41C6    0E1C     MOVLW 0x1c
  41C8    CFE7     MOVFF 0xfe7, 0xfdb
  41CA    FFDB     NOP
  41CC    0E1A     MOVLW 0x1a
  41CE    50DB     MOVF 0xfdb, W, ACCESS
  41D0    6EE7     MOVWF 0xfe7, ACCESS
  41D2    0E1B     MOVLW 0x1b
  41D4    CFE7     MOVFF 0xfe7, 0xfdb
  41D6    FFDB     NOP
1064:              					cPercent[2] = cPercent[1], cPercent[1] = cPercent[0];
  41D8    0E19     MOVLW 0x19
  41DA    50DB     MOVF 0xfdb, W, ACCESS
  41DC    6EE7     MOVWF 0xfe7, ACCESS
  41DE    0E1A     MOVLW 0x1a
  41E0    CFE7     MOVFF 0xfe7, 0xfdb
  41E2    FFDB     NOP
  41E4    0E18     MOVLW 0x18
  41E6    50DB     MOVF 0xfdb, W, ACCESS
  41E8    6EE7     MOVWF 0xfe7, ACCESS
  41EA    0E19     MOVLW 0x19
  41EC    CFE7     MOVFF 0xfe7, 0xfdb
  41EE    FFDB     NOP
1065:              					cPercent[0] = '-', cPercent[6] = 0;
  41F0    0E2D     MOVLW 0x2d
  41F2    6EF3     MOVWF 0xff3, ACCESS
  41F4    0E18     MOVLW 0x18
  41F6    CFF3     MOVFF 0xff3, 0xfdb
  41F8    FFDB     NOP
  41FA    0E1E     MOVLW 0x1e
  41FC    6ADB     CLRF 0xfdb, ACCESS
1066:              				};
1067:              				iPrintBufFull = sprintf( &cPrintBuf[0], "\r\nRequest %ld, divisor %ld = %ld baud, %s%% error.\r\n", 
  424C    0E32     MOVLW 0x32
  424E    6EE6     MOVWF 0xfe6, ACCESS
  4250    0E52     MOVLW 0x52
  4252    6EE6     MOVWF 0xfe6, ACCESS
  4254    0E00     MOVLW 0
  4256    6EE6     MOVWF 0xfe6, ACCESS
  4258    0E11     MOVLW 0x11
  425A    6EE6     MOVWF 0xfe6, ACCESS
  425C    0E05     MOVLW 0x5
  425E    6EE6     MOVWF 0xfe6, ACCESS
1068:              					line_coding.dwDTERate.Val, dwBaud.Val, dwRate.Val, &cPercent[0] );
  41FE    50D9     MOVF 0xfd9, W, ACCESS
  4200    0F18     ADDLW 0x18
  4202    6EE6     MOVWF 0xfe6, ACCESS
  4204    0E00     MOVLW 0
  4206    20DA     ADDWFC 0xfda, W, ACCESS
  4208    6EE6     MOVWF 0xfe6, ACCESS
  420A    50D9     MOVF 0xfd9, W, ACCESS
  420C    0F10     ADDLW 0x10
  420E    6EE9     MOVWF 0xfe9, ACCESS
  4210    CFDA     MOVFF 0xfda, 0xfea
  4212    FFEA     NOP
  4214    CFEE     MOVFF 0xfee, 0xfe6
  4216    FFE6     NOP
  4218    CFEE     MOVFF 0xfee, 0xfe6
  421A    FFE6     NOP
  421C    CFEE     MOVFF 0xfee, 0xfe6
  421E    FFE6     NOP
  4220    CFEF     MOVFF 0xfef, 0xfe6
  4222    FFE6     NOP
  4224    CFD9     MOVFF 0xfd9, 0xfe9
  4226    FFE9     NOP
  4228    CFDA     MOVFF 0xfda, 0xfea
  422A    FFEA     NOP
  422C    CFEE     MOVFF 0xfee, 0xfe6
  422E    FFE6     NOP
  4230    CFEE     MOVFF 0xfee, 0xfe6
  4232    FFE6     NOP
  4234    CFEE     MOVFF 0xfee, 0xfe6
  4236    FFE6     NOP
  4238    CFEF     MOVFF 0xfef, 0xfe6
  423A    FFE6     NOP
  423C    C5D9     MOVFF 0x5d9, 0xfe6
  423E    FFE6     NOP
  4240    C5DA     MOVFF 0x5da, 0xfe6
  4242    FFE6     NOP
  4244    C5DB     MOVFF 0x5db, 0xfe6
  4246    FFE6     NOP
  4248    C5DC     MOVFF 0x5dc, 0xfe6
  424A    FFE6     NOP
  4260    ECD6     CALL 0x4fac, 0
  4262    F027     NOP
  4264    6E14     MOVWF 0x14, ACCESS
  4266    0E13     MOVLW 0x13
  4268    5EE1     SUBWF 0xfe1, F, ACCESS
  426A    5014     MOVF 0x14, W, ACCESS
  426C    CFF3     MOVFF 0xff3, 0x141
  426E    F141     NOP
  4270    CFF4     MOVFF 0xff4, 0x142
  4272    F142     NOP
1069:              			};
1070:              #endif
1071:                      #elif defined(__C30__)
1072:                          #if defined(__dsPIC33EP512MU810__)
1073:                          dwBaud.Val = ((GetPeripheralClock()+(BRG_DIV2/2*line_coding.dwDTERate.Val))/BRG_DIV2/line_coding.dwDTERate.Val-1);
1074:                          #else
1075:                          dwBaud.Val = (((GetPeripheralClock()/2)+(BRG_DIV2/2*line_coding.dwDTERate.Val))/BRG_DIV2/line_coding.dwDTERate.Val-1);
1076:                          #endif
1077:                          U2BRG = dwBaud.Val;
1078:                      #elif defined(__C32__)
1079:                          U2BRG = ((GetPeripheralClock()+(BRG_DIV2/2*line_coding.dwDTERate.Val))/BRG_DIV2/line_coding.dwDTERate.Val-1);
1080:                          //U2MODE = 0;
1081:                          U2MODEbits.BRGH = BRGH2;
1082:                          //U2STA = 0;
1083:                      #endif
1084:                  }
1085:              }
  4274    0E22     MOVLW 0x22
  4276    5CE1     SUBWF 0xfe1, W, ACCESS
  4278    E202     BC 0x427e
  427A    6AE1     CLRF 0xfe1, ACCESS
  427C    52E5     MOVF 0xfe5, F, ACCESS
  427E    6EE1     MOVWF 0xfe1, ACCESS
  4280    52E5     MOVF 0xfe5, F, ACCESS
  4282    CFE7     MOVFF 0xfe7, 0xfd9
  4284    FFD9     NOP
  4286    0012     RETURN 0
1086:              #endif
1087:              
1088:              /******************************************************************************
1089:               * Function:        unsigned char getcUSART ()
1090:               *
1091:               * PreCondition:    None
1092:               *
1093:               * Input:           None
1094:               *
1095:               * Output:          unsigned char c - character received on the UART
1096:               *
1097:               * Side Effects:    None
1098:               *
1099:               * Overview:        get a character from the UART
1100:               *
1101:               * Note:            
1102:               *
1103:               *****************************************************************************/
1104:              unsigned char getcUSART ()
  4288    CFD9     MOVFF 0xfd9, 0xfe6
  428A    FFE6     NOP
  428C    CFE1     MOVFF 0xfe1, 0xfd9
  428E    FFD9     NOP
  4290    52E6     MOVF 0xfe6, F, ACCESS
1105:              {
1106:              	char  c;
1107:              
1108:                  #if defined(__18CXX)
1109:              
1110:              	if (RCSTAbits.OERR)  // in case of overrun error
  4292    A2AC     BTFSS 0xfac, 0x1, ACCESS
  4294    D005     BRA 0x42a0
1111:              	{                    // we should never see an overrun error, but if we do, 
1112:              		RCSTAbits.CREN = 0;  // reset the port
  4296    98AC     BCF 0xfac, 0x4, ACCESS
1113:              		c = RCREG;
  4298    50AF     MOVF 0xfaf, W, ACCESS
  429A    6EDF     MOVWF 0xfdf, ACCESS
1114:              		RCSTAbits.CREN = 1;  // and keep going.
  429C    88AC     BSF 0xfac, 0x4, ACCESS
1115:              	}
1116:              	else
  429E    D002     BRA 0x42a4
1117:              		c = RCREG;
  42A0    50AF     MOVF 0xfaf, W, ACCESS
  42A2    6EDF     MOVWF 0xfdf, ACCESS
1118:              // not necessary.  EUSART auto clears the flag when RCREG is cleared
1119:              //	PIR1bits.RCIF = 0;    // clear Flag
1120:              
1121:                  #endif
1122:              
1123:                  #if defined(__C30__) || defined(__C32__)
1124:                      c = UART2GetChar();
1125:                  #endif
1126:              
1127:              	return c;
  42A4    50DF     MOVF 0xfdf, W, ACCESS
1128:              }
  42A6    52E5     MOVF 0xfe5, F, ACCESS
  42A8    52E5     MOVF 0xfe5, F, ACCESS
  42AA    CFE7     MOVFF 0xfe7, 0xfd9
  42AC    FFD9     NOP
  42AE    0012     RETURN 0
1129:              
1130:              /********************************************************************
1131:               * Function:        void BlinkUSBStatus(void)
1132:               *
1133:               * PreCondition:    None
1134:               *
1135:               * Input:           None
1136:               *
1137:               * Output:          None
1138:               *
1139:               * Side Effects:    None
1140:               *
1141:               * Overview:        BlinkUSBStatus turns on and off LEDs 
1142:               *                  corresponding to the USB device state.
1143:               *
1144:               * Note:            mLED macros can be found in HardwareProfile.h
1145:               *                  USBDeviceState is declared and updated in
1146:               *                  usb_device.c.
1147:               *******************************************************************/
1148:              void BlinkUSBStatus(void)
1149:              {
1150:              #if !defined(HARDWARE_PROFILE_CUSTOM_PIM_H)
1151:                  static WORD led_count=0;
1152:                  
1153:                  if(led_count == 0)led_count = 10000U;
1154:                  led_count--;
1155:              
1156:                  #define mLED_Both_Off()         {mLED_1_Off();mLED_2_Off();}
1157:                  #define mLED_Both_On()          {mLED_1_On();mLED_2_On();}
1158:                  #define mLED_Only_1_On()        {mLED_1_On();mLED_2_Off();}
1159:                  #define mLED_Only_2_On()        {mLED_1_Off();mLED_2_On();}
1160:              
1161:                  if(USBSuspendControl == 1)
1162:                  {
1163:                      if(led_count==0)
1164:                      {
1165:                          mLED_1_Toggle();
1166:                          if(mGetLED_1())
1167:                          {
1168:                              mLED_2_On();
1169:                          }
1170:                          else
1171:                          {
1172:                              mLED_2_Off();
1173:                          }
1174:                      }//end if
1175:                  }
1176:                  else
1177:                  {
1178:                      if(USBDeviceState == DETACHED_STATE)
1179:                      {
1180:                          mLED_Both_Off();
1181:                      }
1182:                      else if(USBDeviceState == ATTACHED_STATE)
1183:                      {
1184:                          mLED_Both_On();
1185:                      }
1186:                      else if(USBDeviceState == POWERED_STATE)
1187:                      {
1188:                          mLED_Only_1_On();
1189:                      }
1190:                      else if(USBDeviceState == DEFAULT_STATE)
1191:                      {
1192:                          mLED_Only_2_On();
1193:                      }
1194:                      else if(USBDeviceState == ADDRESS_STATE)
1195:                      {
1196:                          if(led_count == 0)
1197:                          {
1198:                              mLED_1_Toggle();
1199:                              mLED_2_Off();
1200:                          }//end if
1201:                      }
1202:                      else if(USBDeviceState == CONFIGURED_STATE)
1203:                      {
1204:                          if(led_count==0)
1205:                          {
1206:                              mLED_1_Toggle();
1207:                              if(mGetLED_1())
1208:                              {
1209:                                  mLED_2_Off();
1210:                              }
1211:                              else
1212:                              {
1213:                                  mLED_2_On();
1214:                              }
1215:                          }//end if
1216:                      }//end if(...)
1217:                  }//end if(UCONbits.SUSPND...)
1218:              #endif //#if !defined(HARDWARE_PROFILE_CUSTOM_PIM_H)
1219:              }//end BlinkUSBStatus
  42B0    0012     RETURN 0
1220:              
1221:              
1222:              
1223:              
1224:              // ******************************************************************************************************
1225:              // ************** USB Callback Functions ****************************************************************
1226:              // ******************************************************************************************************
1227:              // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
1228:              // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
1229:              // packets to your device.  In response to this, all USB devices are supposed to decrease their power
1230:              // consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
1231:              // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
1232:              // function.  You should modify these callback functions to take appropriate actions for each of these
1233:              // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
1234:              // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
1235:              // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
1236:              // add code that undoes the power saving things done in the USBCBSuspend() function.
1237:              
1238:              // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
1239:              // function.  This function is meant to be called from the application firmware instead.  See the
1240:              // additional comments near the function.
1241:              
1242:              /******************************************************************************
1243:               * Function:        void USBCBSuspend(void)
1244:               *
1245:               * PreCondition:    None
1246:               *
1247:               * Input:           None
1248:               *
1249:               * Output:          None
1250:               *
1251:               * Side Effects:    None
1252:               *
1253:               * Overview:        Call back that is invoked when a USB suspend is detected
1254:               *
1255:               * Note:            None
1256:               *****************************************************************************/
1257:              void USBCBSuspend(void)
1258:              {
1259:              	//Example power saving code.  Insert appropriate code here for the desired
1260:              	//application behavior.  If the microcontroller will be put to sleep, a
1261:              	//process similar to that shown below may be used:
1262:              	
1263:              	//ConfigureIOPinsForLowPower();
1264:              	//SaveStateOfAllInterruptEnableBits();
1265:              	//DisableAllInterruptEnableBits();
1266:              	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
1267:              	//Sleep();
1268:              	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
1269:              	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
1270:              
1271:              	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
1272:              	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
1273:              	//things to not work as intended.	
1274:              	
1275:              
1276:                  #if defined(__C30__)
1277:                  #if 0
1278:                      U1EIR = 0xFFFF;
1279:                      U1IR = 0xFFFF;
1280:                      U1OTGIR = 0xFFFF;
1281:                      IFS5bits.USB1IF = 0;
1282:                      IEC5bits.USB1IE = 1;
1283:                      U1OTGIEbits.ACTVIE = 1;
1284:                      U1OTGIRbits.ACTVIF = 1;
1285:                      Sleep();
1286:                  #endif
1287:                  #endif
1288:              }
  42B2    0012     RETURN 0
1289:              
1290:              
1291:              /******************************************************************************
1292:               * Function:        void _USB1Interrupt(void)
1293:               *
1294:               * PreCondition:    None
1295:               *
1296:               * Input:           None
1297:               *
1298:               * Output:          None
1299:               *
1300:               * Side Effects:    None
1301:               *
1302:               * Overview:        This function is called when the USB interrupt bit is set
1303:               *					In this example the interrupt is only used when the device
1304:               *					goes to sleep when it receives a USB suspend command
1305:               *
1306:               * Note:            None
1307:               *****************************************************************************/
1308:              #if 0
1309:              void __attribute__ ((interrupt)) _USB1Interrupt(void)
1310:              {
1311:                  #if !defined(self_powered)
1312:                      if(U1OTGIRbits.ACTVIF)
1313:                      {
1314:                          IEC5bits.USB1IE = 0;
1315:                          U1OTGIEbits.ACTVIE = 0;
1316:                          IFS5bits.USB1IF = 0;
1317:                      
1318:                          //USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
1319:                          USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1320:                          //USBSuspendControl = 0;
1321:                      }
1322:                  #endif
1323:              }
1324:              #endif
1325:              
1326:              /******************************************************************************
1327:               * Function:        void USBCBWakeFromSuspend(void)
1328:               *
1329:               * PreCondition:    None
1330:               *
1331:               * Input:           None
1332:               *
1333:               * Output:          None
1334:               *
1335:               * Side Effects:    None
1336:               *
1337:               * Overview:        The host may put USB peripheral devices in low power
1338:               *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
1339:               *					mode, the host may wake the device back up by sending non-
1340:               *					idle state signalling.
1341:               *					
1342:               *					This call back is invoked when a wakeup from USB suspend 
1343:               *					is detected.
1344:               *
1345:               * Note:            None
1346:               *****************************************************************************/
1347:              void USBCBWakeFromSuspend(void)
1348:              {
1349:              	// If clock switching or other power savings measures were taken when
1350:              	// executing the USBCBSuspend() function, now would be a good time to
1351:              	// switch back to normal full power run mode conditions.  The host allows
1352:              	// a few milliseconds of wakeup time, after which the device must be 
1353:              	// fully back to normal, and capable of receiving and processing USB
1354:              	// packets.  In order to do this, the USB module must receive proper
1355:              	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
1356:              	// operation).
1357:              }
  42B4    0012     RETURN 0
1358:              
1359:              /********************************************************************
1360:               * Function:        void USBCB_SOF_Handler(void)
1361:               *
1362:               * PreCondition:    None
1363:               *
1364:               * Input:           None
1365:               *
1366:               * Output:          None
1367:               *
1368:               * Side Effects:    None
1369:               *
1370:               * Overview:        The USB host sends out a SOF packet to full-speed
1371:               *                  devices every 1 ms. This interrupt may be useful
1372:               *                  for isochronous pipes. End designers should
1373:               *                  implement callback routine as necessary.
1374:               *
1375:               * Note:            None
1376:               *******************************************************************/
1377:              void USBCB_SOF_Handler(void)
1378:              {
1379:                  // No need to clear UIRbits.SOFIF to 0 here.
1380:                  // Callback caller is already doing that.
1381:              
1382:                  //This is reverse logic since the pushbutton is active low
1383:                  if(buttonPressed == sw2)
  42B6    0101     MOVLB 0x1
  42B8    05CB     DECF 0xcb, W, BANKED
  42BA    E108     BNZ 0x42cc
1384:                  {
1385:                      if(buttonCount != 0)
  42BC    51CC     MOVF 0xcc, W, BANKED
  42BE    E002     BZ 0x42c4
1386:                      {
1387:                          buttonCount--;
  42C0    07CC     DECF 0xcc, F, BANKED
1388:                      }
1389:                      else
  42C2    0012     RETURN 0
1390:                      {
1391:                          //This is reverse logic since the pushbutton is active low
1392:                          buttonPressed = !sw2;
  42C4    6BCB     CLRF 0xcb, BANKED
1393:              
1394:                          //Wait 100ms before the next press can be generated
1395:                          buttonCount = 100;
  42C6    0E64     MOVLW 0x64
  42C8    6FCC     MOVWF 0xcc, BANKED
1396:                      }
1397:                  }
1398:                  else
  42CA    0012     RETURN 0
1399:                  {
1400:                      if(buttonCount != 0)
  42CC    51CC     MOVF 0xcc, W, BANKED
  42CE    E001     BZ 0x42d2
1401:                      {
1402:                          buttonCount--;
  42D0    07CC     DECF 0xcc, F, BANKED
1403:                      }
1404:                  }
1405:              }
  42D2    0012     RETURN 0
1406:              
1407:              /*******************************************************************
1408:               * Function:        void USBCBErrorHandler(void)
1409:               *
1410:               * PreCondition:    None
1411:               *
1412:               * Input:           None
1413:               *
1414:               * Output:          None
1415:               *
1416:               * Side Effects:    None
1417:               *
1418:               * Overview:        The purpose of this callback is mainly for
1419:               *                  debugging during development. Check UEIR to see
1420:               *                  which error causes the interrupt.
1421:               *
1422:               * Note:            None
1423:               *******************************************************************/
1424:              void USBCBErrorHandler(void)
1425:              {
1426:                  // No need to clear UEIR to 0 here.
1427:                  // Callback caller is already doing that.
1428:              
1429:              	// Typically, user firmware does not need to do anything special
1430:              	// if a USB error occurs.  For example, if the host sends an OUT
1431:              	// packet to your device, but the packet gets corrupted (ex:
1432:              	// because of a bad connection, or the user unplugs the
1433:              	// USB cable during the transmission) this will typically set
1434:              	// one or more USB error interrupt flags.  Nothing specific
1435:              	// needs to be done however, since the SIE will automatically
1436:              	// send a "NAK" packet to the host.  In response to this, the
1437:              	// host will normally retry to send the packet again, and no
1438:              	// data loss occurs.  The system will typically recover
1439:              	// automatically, without the need for application firmware
1440:              	// intervention.
1441:              	
1442:              	// Nevertheless, this callback function is provided, such as
1443:              	// for debugging purposes.
1444:              }
  42D4    0012     RETURN 0
1445:              
1446:              
1447:              /*******************************************************************
1448:               * Function:        void USBCBCheckOtherReq(void)
1449:               *
1450:               * PreCondition:    None
1451:               *
1452:               * Input:           None
1453:               *
1454:               * Output:          None
1455:               *
1456:               * Side Effects:    None
1457:               *
1458:               * Overview:        When SETUP packets arrive from the host, some
1459:               * 					firmware must process the request and respond
1460:               *					appropriately to fulfill the request.  Some of
1461:               *					the SETUP packets will be for standard
1462:               *					USB "chapter 9" (as in, fulfilling chapter 9 of
1463:               *					the official USB specifications) requests, while
1464:               *					others may be specific to the USB device class
1465:               *					that is being implemented.  For example, a HID
1466:               *					class device needs to be able to respond to
1467:               *					"GET REPORT" type of requests.  This
1468:               *					is not a standard USB chapter 9 request, and 
1469:               *					therefore not handled by usb_device.c.  Instead
1470:               *					this request should be handled by class specific 
1471:               *					firmware, such as that contained in usb_function_hid.c.
1472:               *
1473:               * Note:            None
1474:               *******************************************************************/
1475:              void USBCBCheckOtherReq(void)
1476:              {
1477:                  USBCheckMSDRequest();
  42D6    ECF7     CALL 0x2fee, 0
  42D8    F017     NOP
1478:                  USBCheckCDCRequest();
  42DA    EFEA     GOTO 0x43d4
  42DC    F021     NOP
1479:              }//end
1480:              
1481:              
1482:              /*******************************************************************
1483:               * Function:        void USBCBStdSetDscHandler(void)
1484:               *
1485:               * PreCondition:    None
1486:               *
1487:               * Input:           None
1488:               *
1489:               * Output:          None
1490:               *
1491:               * Side Effects:    None
1492:               *
1493:               * Overview:        The USBCBStdSetDscHandler() callback function is
1494:               *					called when a SETUP, bRequest: SET_DESCRIPTOR request
1495:               *					arrives.  Typically SET_DESCRIPTOR requests are
1496:               *					not used in most applications, and it is
1497:               *					optional to support this type of request.
1498:               *
1499:               * Note:            None
1500:               *******************************************************************/
1501:              void USBCBStdSetDscHandler(void)
1502:              {
1503:                  // Must claim session ownership if supporting this request
1504:              }//end
  42DE    0012     RETURN 0
1505:              
1506:              
1507:              /*******************************************************************
1508:               * Function:        void USBCBInitEP(void)
1509:               *
1510:               * PreCondition:    None
1511:               *
1512:               * Input:           None
1513:               *
1514:               * Output:          None
1515:               *
1516:               * Side Effects:    None
1517:               *
1518:               * Overview:        This function is called when the device becomes
1519:               *                  initialized, which occurs after the host sends a
1520:               * 					SET_CONFIGURATION (wValue not = 0) request.  This 
1521:               *					callback function should initialize the endpoints 
1522:               *					for the device's usage according to the current 
1523:               *					configuration.
1524:               *
1525:               * Note:            None
1526:               *******************************************************************/
1527:              void USBCBInitEP(void)
1528:              {
1529:                  #if (MSD_DATA_IN_EP == MSD_DATA_OUT_EP)
1530:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
  42E0    0E1E     MOVLW 0x1e
  42E2    6EE6     MOVWF 0xfe6, ACCESS
  42E4    0E01     MOVLW 0x1
  42E6    6EE6     MOVWF 0xfe6, ACCESS
  42E8    EC04     CALL 0x2008, 0
  42EA    F010     NOP
  42EC    52E5     MOVF 0xfe5, F, ACCESS
  42EE    52E5     MOVF 0xfe5, F, ACCESS
1531:                  #else
1532:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1533:                      USBEnableEndpoint(MSD_DATA_OUT_EP,USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1534:                  #endif
1535:              
1536:                  USBMSDInit();
  42F0    ECA9     CALL 0x2f52, 0
  42F2    F017     NOP
1537:                  CDCInitEP();
  42F4    EF3C     GOTO 0x4478
  42F6    F022     NOP
1538:              }
1539:              
1540:              /********************************************************************
1541:               * Function:        void USBCBSendResume(void)
1542:               *
1543:               * PreCondition:    None
1544:               *
1545:               * Input:           None
1546:               *
1547:               * Output:          None
1548:               *
1549:               * Side Effects:    None
1550:               *
1551:               * Overview:        The USB specifications allow some types of USB
1552:               * 					peripheral devices to wake up a host PC (such
1553:               *					as if it is in a low power suspend to RAM state).
1554:               *					This can be a very useful feature in some
1555:               *					USB applications, such as an Infrared remote
1556:               *					control	receiver.  If a user presses the "power"
1557:               *					button on a remote control, it is nice that the
1558:               *					IR receiver can detect this signalling, and then
1559:               *					send a USB "command" to the PC to wake up.
1560:               *					
1561:               *					The USBCBSendResume() "callback" function is used
1562:               *					to send this special USB signalling which wakes 
1563:               *					up the PC.  This function may be called by
1564:               *					application firmware to wake up the PC.  This
1565:               *					function will only be able to wake up the host if
1566:               *                  all of the below are true:
1567:               *					
1568:               *					1.  The USB driver used on the host PC supports
1569:               *						the remote wakeup capability.
1570:               *					2.  The USB configuration descriptor indicates
1571:               *						the device is remote wakeup capable in the
1572:               *						bmAttributes field.
1573:               *					3.  The USB host PC is currently sleeping,
1574:               *						and has previously sent your device a SET 
1575:               *						FEATURE setup packet which "armed" the
1576:               *						remote wakeup capability.   
1577:               *
1578:               *                  If the host has not armed the device to perform remote wakeup,
1579:               *                  then this function will return without actually performing a
1580:               *                  remote wakeup sequence.  This is the required behavior, 
1581:               *                  as a USB device that has not been armed to perform remote 
1582:               *                  wakeup must not drive remote wakeup signalling onto the bus;
1583:               *                  doing so will cause USB compliance testing failure.
1584:               *                  
1585:               *					This callback should send a RESUME signal that
1586:               *                  has the period of 1-15ms.
1587:               *
1588:               * Note:            This function does nothing and returns quickly, if the USB
1589:               *                  bus and host are not in a suspended condition, or are 
1590:               *                  otherwise not in a remote wakeup ready state.  Therefore, it
1591:               *                  is safe to optionally call this function regularly, ex: 
1592:               *                  anytime application stimulus occurs, as the function will
1593:               *                  have no effect, until the bus really is in a state ready
1594:               *                  to accept remote wakeup. 
1595:               *
1596:               *                  When this function executes, it may perform clock switching,
1597:               *                  depending upon the application specific code in 
1598:               *                  USBCBWakeFromSuspend().  This is needed, since the USB
1599:               *                  bus will no longer be suspended by the time this function
1600:               *                  returns.  Therefore, the USB module will need to be ready
1601:               *                  to receive traffic from the host.
1602:               *
1603:               *                  The modifiable section in this routine may be changed
1604:               *                  to meet the application needs. Current implementation
1605:               *                  temporary blocks other functions from executing for a
1606:               *                  period of ~3-15 ms depending on the core frequency.
1607:               *
1608:               *                  According to USB 2.0 specification section 7.1.7.7,
1609:               *                  "The remote wakeup device must hold the resume signaling
1610:               *                  for at least 1 ms but for no more than 15 ms."
1611:               *                  The idea here is to use a delay counter loop, using a
1612:               *                  common value that would work over a wide range of core
1613:               *                  frequencies.
1614:               *                  That value selected is 1800. See table below:
1615:               *                  ==========================================================
1616:               *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
1617:               *                  ==========================================================
1618:               *                      48              12          1.05
1619:               *                       4              1           12.6
1620:               *                  ==========================================================
1621:               *                  * These timing could be incorrect when using code
1622:               *                    optimization or extended instruction mode,
1623:               *                    or when having other interrupts enabled.
1624:               *                    Make sure to verify using the MPLAB SIM's Stopwatch
1625:               *                    and verify the actual signal on an oscilloscope.
1626:               *******************************************************************/
1627:              void USBCBSendResume(void)
1628:              {
1629:                  static WORD delay_count;
1630:                  
1631:                  //First verify that the host has armed us to perform remote wakeup.
1632:                  //It does this by sending a SET_FEATURE request to enable remote wakeup,
1633:                  //usually just before the host goes to standby mode (note: it will only
1634:                  //send this SET_FEATURE request if the configuration descriptor declares
1635:                  //the device as remote wakeup capable, AND, if the feature is enabled
1636:                  //on the host (ex: on Windows based hosts, in the device manager 
1637:                  //properties page for the USB device, power management tab, the 
1638:                  //"Allow this device to bring the computer out of standby." checkbox 
1639:                  //should be checked).
1640:                  if(USBGetRemoteWakeupStatus() == TRUE) 
  42F8    0100     MOVLB 0
  42FA    0589     DECF 0x89, W, BANKED
  42FC    E120     BNZ 0x433e
1641:                  {
1642:                      //Verify that the USB bus is in fact suspended, before we send
1643:                      //remote wakeup signalling.
1644:                      if(USBIsBusSuspended() == TRUE)
  42FE    0100     MOVLB 0
  4300    058A     DECF 0x8a, W, BANKED
  4302    E11D     BNZ 0x433e
1645:                      {
1646:                          USBMaskInterrupts();
  4304    98A0     BCF 0xfa0, 0x4, ACCESS
1647:                          
1648:                          //Clock switch to settings consistent with normal USB operation.
1649:                          USBCBWakeFromSuspend();
  4306    DFD6     RCALL 0x42b4
1650:                          USBSuspendControl = 0; 
  4308    9265     BCF 0xf65, 0x1, ACCESS
1651:                          USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
  430A    0100     MOVLB 0
  430C    6B8A     CLRF 0x8a, BANKED
1652:                                                      //until a new suspend condition is detected.
1653:              
1654:                          //Section 7.1.7.7 of the USB 2.0 specifications indicates a USB
1655:                          //device must continuously see 5ms+ of idle on the bus, before it sends
1656:                          //remote wakeup signalling.  One way to be certain that this parameter
1657:                          //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
1658:                          //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yeilds
1659:                          //5ms+ total delay since start of idle).
1660:                          delay_count = 3600U;        
  430E    0101     MOVLB 0x1
  4310    0E10     MOVLW 0x10
  4312    6FCD     MOVWF 0xcd, BANKED
  4314    0E0E     MOVLW 0xe
  4316    6FCE     MOVWF 0xce, BANKED
1661:                          do
1662:                          {
1663:                              delay_count--;
  4318    07CD     DECF 0xcd, F, BANKED
  431A    0E00     MOVLW 0
  431C    5BCE     SUBWFB 0xce, F, BANKED
1664:                          }while(delay_count);
  431E    51CD     MOVF 0xcd, W, BANKED
  4320    11CE     IORWF 0xce, W, BANKED
  4322    E1FA     BNZ 0x4318
1665:                          
1666:                          //Now drive the resume K-state signalling onto the USB bus.
1667:                          USBResumeControl = 1;       // Start RESUME signaling
  4324    8465     BSF 0xf65, 0x2, ACCESS
1668:                          delay_count = 1800U;        // Set RESUME line for 1-13 ms
  4326    0E08     MOVLW 0x8
  4328    6FCD     MOVWF 0xcd, BANKED
  432A    0E07     MOVLW 0x7
  432C    6FCE     MOVWF 0xce, BANKED
1669:                          do
1670:                          {
1671:                              delay_count--;
  432E    07CD     DECF 0xcd, F, BANKED
  4330    0E00     MOVLW 0
  4332    5BCE     SUBWFB 0xce, F, BANKED
1672:                          }while(delay_count);
  4334    51CD     MOVF 0xcd, W, BANKED
  4336    11CE     IORWF 0xce, W, BANKED
  4338    E1FA     BNZ 0x432e
1673:                          USBResumeControl = 0;       //Finished driving resume signalling
  433A    9465     BCF 0xf65, 0x2, ACCESS
1674:              
1675:                          USBUnmaskInterrupts();
  433C    88A0     BSF 0xfa0, 0x4, ACCESS
1676:                      }
1677:                  }
1678:              }
  433E    0012     RETURN 0
1679:              
1680:              
1681:              /*******************************************************************
1682:               * Function:        void USBCBEP0DataReceived(void)
1683:               *
1684:               * PreCondition:    ENABLE_EP0_DATA_RECEIVED_CALLBACK must be
1685:               *                  defined already (in usb_config.h)
1686:               *
1687:               * Input:           None
1688:               *
1689:               * Output:          None
1690:               *
1691:               * Side Effects:    None
1692:               *
1693:               * Overview:        This function is called whenever a EP0 data
1694:               *                  packet is received.  This gives the user (and
1695:               *                  thus the various class examples a way to get
1696:               *                  data that is received via the control endpoint.
1697:               *                  This function needs to be used in conjunction
1698:               *                  with the USBCBCheckOtherReq() function since 
1699:               *                  the USBCBCheckOtherReq() function is the apps
1700:               *                  method for getting the initial control transfer
1701:               *                  before the data arrives.
1702:               *
1703:               * Note:            None
1704:               *******************************************************************/
1705:              #if defined(ENABLE_EP0_DATA_RECEIVED_CALLBACK)
1706:              void USBCBEP0DataReceived(void)
1707:              {
1708:              }
1709:              #endif
1710:              
1711:              /*******************************************************************
1712:               * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
1713:               *                        USB_EVENT event, void *pdata, WORD size)
1714:               *
1715:               * PreCondition:    None
1716:               *
1717:               * Input:           USB_EVENT event - the type of event
1718:               *                  void *pdata - pointer to the event data
1719:               *                  WORD size - size of the event data
1720:               *
1721:               * Output:          None
1722:               *
1723:               * Side Effects:    None
1724:               *
1725:               * Overview:        This function is called from the USB stack to
1726:               *                  notify a user application that a USB event
1727:               *                  occured.  This callback is in interrupt context
1728:               *                  when the USB_INTERRUPT option is selected.
1729:               *
1730:               * Note:            None
1731:               *******************************************************************/
1732:              BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size)
  4340    CFD9     MOVFF 0xfd9, 0xfe6
  4342    FFE6     NOP
  4344    CFE1     MOVFF 0xfe1, 0xfd9
  4346    FFD9     NOP
1733:              {
1734:                  switch(event)
  4348    0EFD     MOVLW 0xfd
  434A    CFDB     MOVFF 0xfdb, 0x8
  434C    F008     NOP
  434E    0EFE     MOVLW 0xfe
  4350    CFDB     MOVFF 0xfdb, 0x9
  4352    F009     NOP
  4354    0E05     MOVLW 0x5
  4356    1808     XORWF 0x8, W, ACCESS
  4358    E101     BNZ 0x435c
  435A    5009     MOVF 0x9, W, ACCESS
  435C    E036     BZ 0x43ca
  435E    68E8     SETF 0xfe8, ACCESS
  4360    1808     XORWF 0x8, W, ACCESS
  4362    E102     BNZ 0x4368
  4364    0E7F     MOVLW 0x7f
  4366    1809     XORWF 0x9, W, ACCESS
  4368    E02F     BZ 0x43c8
  436A    0E03     MOVLW 0x3
  436C    1808     XORWF 0x8, W, ACCESS
  436E    E101     BNZ 0x4372
  4370    5009     MOVF 0x9, W, ACCESS
  4372    E028     BZ 0x43c4
  4374    0E02     MOVLW 0x2
  4376    1808     XORWF 0x8, W, ACCESS
  4378    E101     BNZ 0x437c
  437A    5009     MOVF 0x9, W, ACCESS
  437C    E021     BZ 0x43c0
  437E    0E01     MOVLW 0x1
  4380    1808     XORWF 0x8, W, ACCESS
  4382    E101     BNZ 0x4386
  4384    5009     MOVF 0x9, W, ACCESS
  4386    E01A     BZ 0x43bc
  4388    0E74     MOVLW 0x74
  438A    1808     XORWF 0x8, W, ACCESS
  438C    E101     BNZ 0x4390
  438E    5009     MOVF 0x9, W, ACCESS
  4390    E013     BZ 0x43b8
  4392    0E75     MOVLW 0x75
  4394    1808     XORWF 0x8, W, ACCESS
  4396    E101     BNZ 0x439a
  4398    5009     MOVF 0x9, W, ACCESS
  439A    E00C     BZ 0x43b4
  439C    0E73     MOVLW 0x73
  439E    1808     XORWF 0x8, W, ACCESS
  43A0    E101     BNZ 0x43a4
  43A2    5009     MOVF 0x9, W, ACCESS
  43A4    E005     BZ 0x43b0
  43A6    0E72     MOVLW 0x72
  43A8    1808     XORWF 0x8, W, ACCESS
  43AA    E10F     BNZ 0x43ca
  43AC    5009     MOVF 0x9, W, ACCESS
  43AE    D00D     BRA 0x43ca
1735:                  {
1736:                      case EVENT_TRANSFER:
1737:                          //Add application specific callback task or callback function here if desired.
1738:                          break;
1739:                      case EVENT_SOF:
1740:                          USBCB_SOF_Handler();
  43B0    DF82     RCALL 0x42b6
1741:                          break;
  43B2    D00B     BRA 0x43ca
1742:                      case EVENT_SUSPEND:
1743:                          USBCBSuspend();
  43B4    DF7E     RCALL 0x42b2
1744:                          break;
  43B6    D009     BRA 0x43ca
1745:                      case EVENT_RESUME:
1746:                          USBCBWakeFromSuspend();
  43B8    DF7D     RCALL 0x42b4
1747:                          break;
  43BA    D007     BRA 0x43ca
1748:                      case EVENT_CONFIGURED: 
1749:                          USBCBInitEP();
  43BC    DF91     RCALL 0x42e0
1750:                          break;
  43BE    D005     BRA 0x43ca
1751:                      case EVENT_SET_DESCRIPTOR:
1752:                          USBCBStdSetDscHandler();
  43C0    DF8E     RCALL 0x42de
1753:                          break;
  43C2    D003     BRA 0x43ca
1754:                      case EVENT_EP0_REQUEST:
1755:                          USBCBCheckOtherReq();
  43C4    DF88     RCALL 0x42d6
1756:                          break;
  43C6    D001     BRA 0x43ca
1757:                      case EVENT_BUS_ERROR:
1758:                          USBCBErrorHandler();
  43C8    DF85     RCALL 0x42d4
1759:                          break;
1760:                      case EVENT_TRANSFER_TERMINATED:
1761:                          //Add application specific callback task or callback function here if desired.
1762:                          //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
1763:                          //FEATURE (endpoint halt) request on an application endpoint which was 
1764:                          //previously armed (UOWN was = 1).  Here would be a good place to:
1765:                          //1.  Determine which endpoint the transaction that just got terminated was 
1766:                          //      on, by checking the handle value in the *pdata.
1767:                          //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
1768:                          //      endpoints).
1769:                          break;
1770:                      default:
1771:                          break;
1772:                  }      
1773:                  return TRUE; 
  43CA    0E01     MOVLW 0x1
1774:              }
  43CC    52E5     MOVF 0xfe5, F, ACCESS
  43CE    CFE7     MOVFF 0xfe7, 0xfd9
  43D0    FFD9     NOP
  43D2    0012     RETURN 0